var c3 = Object.defineProperty;
var u3 = (e, t, n) => t in e ? c3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Jr = (e, t, n) => (u3(e, typeof t != "symbol" ? t + "" : t, n), n);
import { shallowRef as An, watchEffect as ol, readonly as Ev, getCurrentScope as d3, onScopeDispose as H2, ref as B, watch as Pe, unref as c, getCurrentInstance as Pt, onMounted as Nt, nextTick as xe, customRef as f3, computed as x, defineComponent as Q, openBlock as M, createElementBlock as G, createElementVNode as X, warn as p3, isVNode as yo, Fragment as kt, Comment as Pb, onBeforeUnmount as zn, inject as ot, isRef as fl, onBeforeMount as Sv, provide as Mt, renderSlot as Ie, normalizeClass as z, normalizeStyle as bt, mergeProps as Et, useSlots as Yn, createBlock as We, Transition as Ko, withCtx as fe, withDirectives as Bt, resolveDynamicComponent as Qt, createCommentVNode as _e, createTextVNode as Ut, toDisplayString as Qe, createVNode as oe, vShow as pn, toRef as Pn, onUnmounted as wo, reactive as en, toRefs as Xo, onUpdated as Pi, TransitionGroup as Ab, useAttrs as Ai, withModifiers as It, cloneVNode as v3, Text as Fb, Teleport as ka, onDeactivated as z2, renderList as ln, withKeys as Rn, createSlots as rl, normalizeProps as xo, guardReactiveProps as Ao, toRaw as Sd, vModelCheckbox as Wp, vModelRadio as W2, h as V, resolveComponent as Dt, onBeforeUpdate as h3, vModelText as Vb, toHandlers as m3, markRaw as ju, effectScope as K2, resolveDirective as _v, render as Es, createApp as U2, shallowReactive as g3, onActivated as j2, KeepAlive as b3 } from "vue";
const y3 = 'a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])', C3 = (e) => process.env.NODE_ENV === "test" ? !0 : getComputedStyle(e).position === "fixed" ? !1 : e.offsetParent !== null, eC = (e) => Array.from(e.querySelectorAll(y3)).filter((t) => w3(t) && C3(t)), w3 = (e) => {
  if (e.tabIndex > 0 || e.tabIndex === 0 && e.getAttribute("tabIndex") !== null)
    return !0;
  if (e.disabled)
    return !1;
  switch (e.nodeName) {
    case "A":
      return !!e.href && e.rel !== "ignore";
    case "INPUT":
      return !(e.type === "hidden" || e.type === "file");
    case "BUTTON":
    case "SELECT":
    case "TEXTAREA":
      return !0;
    default:
      return !1;
  }
}, pp = function(e, t, ...n) {
  let o;
  t.includes("mouse") || t.includes("click") ? o = "MouseEvents" : t.includes("key") ? o = "KeyboardEvent" : o = "HTMLEvents";
  const l = document.createEvent(o);
  return l.initEvent(t, ...n), e.dispatchEvent(l), e;
}, q2 = (e) => !e.getAttribute("aria-owns"), Y2 = (e, t, n) => {
  const { parentNode: o } = e;
  if (!o)
    return null;
  const l = o.querySelectorAll(n), a = Array.prototype.indexOf.call(l, e);
  return l[a + t] || null;
}, vp = (e) => {
  e && (e.focus(), !q2(e) && e.click());
}, uo = (e, t, { checkForDefaultPrevented: n = !0 } = {}) => (l) => {
  const a = e == null ? void 0 : e(l);
  if (n === !1 || !a)
    return t == null ? void 0 : t(l);
}, tC = (e) => (t) => t.pointerType === "mouse" ? e(t) : void 0;
var E3 = Object.defineProperty, S3 = Object.defineProperties, _3 = Object.getOwnPropertyDescriptors, nC = Object.getOwnPropertySymbols, x3 = Object.prototype.hasOwnProperty, k3 = Object.prototype.propertyIsEnumerable, oC = (e, t, n) => t in e ? E3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, T3 = (e, t) => {
  for (var n in t || (t = {}))
    x3.call(t, n) && oC(e, n, t[n]);
  if (nC)
    for (var n of nC(t))
      k3.call(t, n) && oC(e, n, t[n]);
  return e;
}, $3 = (e, t) => S3(e, _3(t));
function lC(e, t) {
  var n;
  const o = An();
  return ol(() => {
    o.value = e();
  }, $3(T3({}, t), {
    flush: (n = t == null ? void 0 : t.flush) != null ? n : "sync"
  })), Ev(o);
}
var aC;
const fn = typeof window < "u", O3 = (e) => typeof e < "u", Jm = (e) => typeof e == "function", N3 = (e) => typeof e == "string", Rc = () => {
}, M3 = fn && ((aC = window == null ? void 0 : window.navigator) == null ? void 0 : aC.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function Ss(e) {
  return typeof e == "function" ? e() : c(e);
}
function G2(e, t) {
  function n(...o) {
    return new Promise((l, a) => {
      Promise.resolve(e(() => t.apply(this, o), { fn: t, thisArg: this, args: o })).then(l).catch(a);
    });
  }
  return n;
}
function I3(e, t = {}) {
  let n, o, l = Rc;
  const a = (i) => {
    clearTimeout(i), l(), l = Rc;
  };
  return (i) => {
    const s = Ss(e), u = Ss(t.maxWait);
    return n && a(n), s <= 0 || u !== void 0 && u <= 0 ? (o && (a(o), o = null), Promise.resolve(i())) : new Promise((d, f) => {
      l = t.rejectOnCancel ? f : d, u && !o && (o = setTimeout(() => {
        n && a(n), o = null, d(i());
      }, u)), n = setTimeout(() => {
        o && a(o), o = null, d(i());
      }, s);
    });
  };
}
function R3(e, t = !0, n = !0, o = !1) {
  let l = 0, a, r = !0, i = Rc, s;
  const u = () => {
    a && (clearTimeout(a), a = void 0, i(), i = Rc);
  };
  return (f) => {
    const v = Ss(e), h = Date.now() - l, m = () => s = f();
    return u(), v <= 0 ? (l = Date.now(), m()) : (h > v && (n || !r) ? (l = Date.now(), m()) : t && (s = new Promise((p, C) => {
      i = o ? C : p, a = setTimeout(() => {
        l = Date.now(), r = !0, p(m()), u();
      }, Math.max(0, v - h));
    })), !n && !a && (a = setTimeout(() => r = !0, v)), r = !1, s);
  };
}
function D3(e) {
  return e;
}
function L3(e, t) {
  let n, o, l;
  const a = B(!0), r = () => {
    a.value = !0, l();
  };
  Pe(e, r, { flush: "sync" });
  const i = Jm(t) ? t : t.get, s = Jm(t) ? void 0 : t.set, u = f3((d, f) => (o = d, l = f, {
    get() {
      return a.value && (n = i(), a.value = !1), o(), n;
    },
    set(v) {
      s == null || s(v);
    }
  }));
  return Object.isExtensible(u) && (u.trigger = r), u;
}
function Qd(e) {
  return d3() ? (H2(e), !0) : !1;
}
function P3(e, t = 200, n = {}) {
  return G2(I3(t, n), e);
}
function A3(e, t = 200, n = {}) {
  const o = B(e.value), l = P3(() => {
    o.value = e.value;
  }, t, n);
  return Pe(e, () => l()), o;
}
function X2(e, t = 200, n = !1, o = !0, l = !1) {
  return G2(R3(t, n, o, l), e);
}
function Bb(e, t = !0) {
  Pt() ? Nt(e) : t ? e() : xe(e);
}
function ki(e, t, n = {}) {
  const {
    immediate: o = !0
  } = n, l = B(!1);
  let a = null;
  function r() {
    a && (clearTimeout(a), a = null);
  }
  function i() {
    l.value = !1, r();
  }
  function s(...u) {
    r(), l.value = !0, a = setTimeout(() => {
      l.value = !1, a = null, e(...u);
    }, Ss(t));
  }
  return o && (l.value = !0, fn && s()), Qd(i), {
    isPending: Ev(l),
    start: s,
    stop: i
  };
}
function Fl(e) {
  var t;
  const n = Ss(e);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
const Ds = fn ? window : void 0, F3 = fn ? window.document : void 0;
function jn(...e) {
  let t, n, o, l;
  if (N3(e[0]) || Array.isArray(e[0]) ? ([n, o, l] = e, t = Ds) : [t, n, o, l] = e, !t)
    return Rc;
  Array.isArray(n) || (n = [n]), Array.isArray(o) || (o = [o]);
  const a = [], r = () => {
    a.forEach((d) => d()), a.length = 0;
  }, i = (d, f, v, h) => (d.addEventListener(f, v, h), () => d.removeEventListener(f, v, h)), s = Pe(() => [Fl(t), Ss(l)], ([d, f]) => {
    r(), d && a.push(...n.flatMap((v) => o.map((h) => i(d, v, h, f))));
  }, { immediate: !0, flush: "post" }), u = () => {
    s(), r();
  };
  return Qd(u), u;
}
let rC = !1;
function Hb(e, t, n = {}) {
  const { window: o = Ds, ignore: l = [], capture: a = !0, detectIframe: r = !1 } = n;
  if (!o)
    return;
  M3 && !rC && (rC = !0, Array.from(o.document.body.children).forEach((v) => v.addEventListener("click", Rc)));
  let i = !0;
  const s = (v) => l.some((h) => {
    if (typeof h == "string")
      return Array.from(o.document.querySelectorAll(h)).some((m) => m === v.target || v.composedPath().includes(m));
    {
      const m = Fl(h);
      return m && (v.target === m || v.composedPath().includes(m));
    }
  }), d = [
    jn(o, "click", (v) => {
      const h = Fl(e);
      if (!(!h || h === v.target || v.composedPath().includes(h))) {
        if (v.detail === 0 && (i = !s(v)), !i) {
          i = !0;
          return;
        }
        t(v);
      }
    }, { passive: !0, capture: a }),
    jn(o, "pointerdown", (v) => {
      const h = Fl(e);
      h && (i = !v.composedPath().includes(h) && !s(v));
    }, { passive: !0 }),
    r && jn(o, "blur", (v) => {
      var h;
      const m = Fl(e);
      ((h = o.document.activeElement) == null ? void 0 : h.tagName) === "IFRAME" && !(m != null && m.contains(o.document.activeElement)) && t(v);
    })
  ].filter(Boolean);
  return () => d.forEach((v) => v());
}
function V3(e = {}) {
  var t;
  const { window: n = Ds } = e, o = (t = e.document) != null ? t : n == null ? void 0 : n.document, l = L3(() => null, () => o == null ? void 0 : o.activeElement);
  return n && (jn(n, "blur", (a) => {
    a.relatedTarget === null && l.trigger();
  }, !0), jn(n, "focus", l.trigger, !0)), l;
}
function Z2(e, t = !1) {
  const n = B(), o = () => n.value = !!e();
  return o(), Bb(o, t), n;
}
function B3(e) {
  return JSON.parse(JSON.stringify(e));
}
const sC = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, iC = "__vueuse_ssr_handlers__";
sC[iC] = sC[iC] || {};
function H3(e, t, { window: n = Ds, initialValue: o = "" } = {}) {
  const l = B(o), a = x(() => {
    var r;
    return Fl(t) || ((r = n == null ? void 0 : n.document) == null ? void 0 : r.documentElement);
  });
  return Pe([a, () => Ss(e)], ([r, i]) => {
    var s;
    if (r && n) {
      const u = (s = n.getComputedStyle(r).getPropertyValue(i)) == null ? void 0 : s.trim();
      l.value = u || o;
    }
  }, { immediate: !0 }), Pe(l, (r) => {
    var i;
    (i = a.value) != null && i.style && a.value.style.setProperty(Ss(e), r);
  }), l;
}
function z3({ document: e = F3 } = {}) {
  if (!e)
    return B("visible");
  const t = B(e.visibilityState);
  return jn(e, "visibilitychange", () => {
    t.value = e.visibilityState;
  }), t;
}
var cC = Object.getOwnPropertySymbols, W3 = Object.prototype.hasOwnProperty, K3 = Object.prototype.propertyIsEnumerable, U3 = (e, t) => {
  var n = {};
  for (var o in e)
    W3.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && cC)
    for (var o of cC(e))
      t.indexOf(o) < 0 && K3.call(e, o) && (n[o] = e[o]);
  return n;
};
function Xn(e, t, n = {}) {
  const o = n, { window: l = Ds } = o, a = U3(o, ["window"]);
  let r;
  const i = Z2(() => l && "ResizeObserver" in l), s = () => {
    r && (r.disconnect(), r = void 0);
  }, u = Pe(() => Fl(e), (f) => {
    s(), i.value && l && f && (r = new ResizeObserver(t), r.observe(f, a));
  }, { immediate: !0, flush: "post" }), d = () => {
    s(), u();
  };
  return Qd(d), {
    isSupported: i,
    stop: d
  };
}
function uC(e, t = {}) {
  const {
    reset: n = !0,
    windowResize: o = !0,
    windowScroll: l = !0,
    immediate: a = !0
  } = t, r = B(0), i = B(0), s = B(0), u = B(0), d = B(0), f = B(0), v = B(0), h = B(0);
  function m() {
    const p = Fl(e);
    if (!p) {
      n && (r.value = 0, i.value = 0, s.value = 0, u.value = 0, d.value = 0, f.value = 0, v.value = 0, h.value = 0);
      return;
    }
    const C = p.getBoundingClientRect();
    r.value = C.height, i.value = C.bottom, s.value = C.left, u.value = C.right, d.value = C.top, f.value = C.width, v.value = C.x, h.value = C.y;
  }
  return Xn(e, m), Pe(() => Fl(e), (p) => !p && m()), l && jn("scroll", m, { capture: !0, passive: !0 }), o && jn("resize", m, { passive: !0 }), Bb(() => {
    a && m();
  }), {
    height: r,
    bottom: i,
    left: s,
    right: u,
    top: d,
    width: f,
    x: v,
    y: h,
    update: m
  };
}
var dC = Object.getOwnPropertySymbols, j3 = Object.prototype.hasOwnProperty, q3 = Object.prototype.propertyIsEnumerable, Y3 = (e, t) => {
  var n = {};
  for (var o in e)
    j3.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && dC)
    for (var o of dC(e))
      t.indexOf(o) < 0 && q3.call(e, o) && (n[o] = e[o]);
  return n;
};
function J2(e, t, n = {}) {
  const o = n, { window: l = Ds } = o, a = Y3(o, ["window"]);
  let r;
  const i = Z2(() => l && "MutationObserver" in l), s = () => {
    r && (r.disconnect(), r = void 0);
  }, u = Pe(() => Fl(e), (f) => {
    s(), i.value && l && f && (r = new MutationObserver(t), r.observe(f, a));
  }, { immediate: !0 }), d = () => {
    s(), u();
  };
  return Qd(d), {
    isSupported: i,
    stop: d
  };
}
var fC;
(function(e) {
  e.UP = "UP", e.RIGHT = "RIGHT", e.DOWN = "DOWN", e.LEFT = "LEFT", e.NONE = "NONE";
})(fC || (fC = {}));
var G3 = Object.defineProperty, pC = Object.getOwnPropertySymbols, X3 = Object.prototype.hasOwnProperty, Z3 = Object.prototype.propertyIsEnumerable, vC = (e, t, n) => t in e ? G3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, J3 = (e, t) => {
  for (var n in t || (t = {}))
    X3.call(t, n) && vC(e, n, t[n]);
  if (pC)
    for (var n of pC(t))
      Z3.call(t, n) && vC(e, n, t[n]);
  return e;
};
const Q3 = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
J3({
  linear: D3
}, Q3);
function Q2(e, t, n, o = {}) {
  var l, a, r;
  const {
    clone: i = !1,
    passive: s = !1,
    eventName: u,
    deep: d = !1,
    defaultValue: f
  } = o, v = Pt(), h = n || (v == null ? void 0 : v.emit) || ((l = v == null ? void 0 : v.$emit) == null ? void 0 : l.bind(v)) || ((r = (a = v == null ? void 0 : v.proxy) == null ? void 0 : a.$emit) == null ? void 0 : r.bind(v == null ? void 0 : v.proxy));
  let m = u;
  t || (t = "modelValue"), m = u || m || `update:${t.toString()}`;
  const p = (g) => i ? Jm(i) ? i(g) : B3(g) : g, C = () => O3(e[t]) ? p(e[t]) : f;
  if (s) {
    const g = C(), w = B(g);
    return Pe(() => e[t], (b) => w.value = p(b)), Pe(w, (b) => {
      (b !== e[t] || d) && h(m, b);
    }, { deep: d }), w;
  } else
    return x({
      get() {
        return C();
      },
      set(g) {
        h(m, g);
      }
    });
}
function eD({ window: e = Ds } = {}) {
  if (!e)
    return B(!1);
  const t = B(e.document.hasFocus());
  return jn(e, "blur", () => {
    t.value = !1;
  }), jn(e, "focus", () => {
    t.value = !0;
  }), t;
}
function tD(e = {}) {
  const {
    window: t = Ds,
    initialWidth: n = 1 / 0,
    initialHeight: o = 1 / 0,
    listenOrientation: l = !0,
    includeScrollbar: a = !0
  } = e, r = B(n), i = B(o), s = () => {
    t && (a ? (r.value = t.innerWidth, i.value = t.innerHeight) : (r.value = t.document.documentElement.clientWidth, i.value = t.document.documentElement.clientHeight));
  };
  return s(), Bb(s), jn("resize", s, { passive: !0 }), l && jn("orientationchange", s, { passive: !0 }), { width: r, height: i };
}
const ex = () => fn && /firefox/i.test(window.navigator.userAgent), nD = (e, t) => {
  if (!fn || !e || !t)
    return !1;
  const n = e.getBoundingClientRect();
  let o;
  return t instanceof Element ? o = t.getBoundingClientRect() : o = {
    top: 0,
    right: window.innerWidth,
    bottom: window.innerHeight,
    left: 0
  }, n.top < o.bottom && n.bottom > o.top && n.right > o.left && n.left < o.right;
}, hC = (e) => {
  let t = 0, n = e;
  for (; n; )
    t += n.offsetTop, n = n.offsetParent;
  return t;
}, Qm = (e, t) => Math.abs(hC(e) - hC(t)), zb = (e) => {
  let t, n;
  return e.type === "touchend" ? (n = e.changedTouches[0].clientY, t = e.changedTouches[0].clientX) : e.type.startsWith("touch") ? (n = e.touches[0].clientY, t = e.touches[0].clientX) : (n = e.clientY, t = e.clientX), {
    clientX: t,
    clientY: n
  };
};
function oD(e, t, n, o) {
  const l = n - t;
  return e /= o / 2, e < 1 ? l / 2 * e * e * e + t : l / 2 * ((e -= 2) * e * e + 2) + t;
}
/**
* @vue/shared v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
process.env.NODE_ENV !== "production" && Object.freeze({});
process.env.NODE_ENV !== "production" && Object.freeze([]);
const no = () => {
}, tx = Object.assign, lD = Object.prototype.hasOwnProperty, sl = (e, t) => lD.call(e, t), Kt = Array.isArray, _d = (e) => Wb(e) === "[object Date]", vn = (e) => typeof e == "function", on = (e) => typeof e == "string", aD = (e) => typeof e == "symbol", Mn = (e) => e !== null && typeof e == "object", eg = (e) => (Mn(e) || vn(e)) && vn(e.then) && vn(e.catch), rD = Object.prototype.toString, Wb = (e) => rD.call(e), Bh = (e) => Wb(e).slice(8, -1), mC = (e) => Wb(e) === "[object Object]", Kb = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (n) => t[n] || (t[n] = e(n));
}, sD = /-(\w)/g, nx = Kb((e) => e.replace(sD, (t, n) => n ? n.toUpperCase() : "")), iD = /\B([A-Z])/g, cD = Kb(
  (e) => e.replace(iD, "-$1").toLowerCase()
), uD = Kb((e) => e.charAt(0).toUpperCase() + e.slice(1)), dD = (e, t) => !Object.is(e, t);
var ox = typeof global == "object" && global && global.Object === Object && global, fD = typeof self == "object" && self && self.Object === Object && self, Ba = ox || fD || Function("return this")(), Ca = Ba.Symbol, lx = Object.prototype, pD = lx.hasOwnProperty, vD = lx.toString, xu = Ca ? Ca.toStringTag : void 0;
function hD(e) {
  var t = pD.call(e, xu), n = e[xu];
  try {
    e[xu] = void 0;
    var o = !0;
  } catch {
  }
  var l = vD.call(e);
  return o && (t ? e[xu] = n : delete e[xu]), l;
}
var mD = Object.prototype, gD = mD.toString;
function bD(e) {
  return gD.call(e);
}
var yD = "[object Null]", CD = "[object Undefined]", gC = Ca ? Ca.toStringTag : void 0;
function Fi(e) {
  return e == null ? e === void 0 ? CD : yD : gC && gC in Object(e) ? hD(e) : bD(e);
}
function sr(e) {
  return e != null && typeof e == "object";
}
var wD = "[object Symbol]";
function xv(e) {
  return typeof e == "symbol" || sr(e) && Fi(e) == wD;
}
function Ub(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length, l = Array(o); ++n < o; )
    l[n] = t(e[n], n, e);
  return l;
}
var $l = Array.isArray, ED = 1 / 0, bC = Ca ? Ca.prototype : void 0, yC = bC ? bC.toString : void 0;
function ax(e) {
  if (typeof e == "string")
    return e;
  if ($l(e))
    return Ub(e, ax) + "";
  if (xv(e))
    return yC ? yC.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -ED ? "-0" : t;
}
var SD = /\s/;
function _D(e) {
  for (var t = e.length; t-- && SD.test(e.charAt(t)); )
    ;
  return t;
}
var xD = /^\s+/;
function kD(e) {
  return e && e.slice(0, _D(e) + 1).replace(xD, "");
}
function Ol(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var CC = NaN, TD = /^[-+]0x[0-9a-f]+$/i, $D = /^0b[01]+$/i, OD = /^0o[0-7]+$/i, ND = parseInt;
function tg(e) {
  if (typeof e == "number")
    return e;
  if (xv(e))
    return CC;
  if (Ol(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Ol(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = kD(e);
  var n = $D.test(e);
  return n || OD.test(e) ? ND(e.slice(2), n ? 2 : 8) : TD.test(e) ? CC : +e;
}
var wC = 1 / 0, MD = 17976931348623157e292;
function ID(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = tg(e), e === wC || e === -wC) {
    var t = e < 0 ? -1 : 1;
    return t * MD;
  }
  return e === e ? e : 0;
}
function RD(e) {
  var t = ID(e), n = t % 1;
  return t === t ? n ? t - n : t : 0;
}
function jb(e) {
  return e;
}
var DD = "[object AsyncFunction]", LD = "[object Function]", PD = "[object GeneratorFunction]", AD = "[object Proxy]";
function qb(e) {
  if (!Ol(e))
    return !1;
  var t = Fi(e);
  return t == LD || t == PD || t == DD || t == AD;
}
var Hh = Ba["__core-js_shared__"], EC = function() {
  var e = /[^.]+$/.exec(Hh && Hh.keys && Hh.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function FD(e) {
  return !!EC && EC in e;
}
var VD = Function.prototype, BD = VD.toString;
function Vi(e) {
  if (e != null) {
    try {
      return BD.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var HD = /[\\^$.*+?()[\]{}|]/g, zD = /^\[object .+?Constructor\]$/, WD = Function.prototype, KD = Object.prototype, UD = WD.toString, jD = KD.hasOwnProperty, qD = RegExp(
  "^" + UD.call(jD).replace(HD, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function YD(e) {
  if (!Ol(e) || FD(e))
    return !1;
  var t = qb(e) ? qD : zD;
  return t.test(Vi(e));
}
function GD(e, t) {
  return e == null ? void 0 : e[t];
}
function Bi(e, t) {
  var n = GD(e, t);
  return YD(n) ? n : void 0;
}
var ng = Bi(Ba, "WeakMap"), SC = Object.create, XD = /* @__PURE__ */ function() {
  function e() {
  }
  return function(t) {
    if (!Ol(t))
      return {};
    if (SC)
      return SC(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}();
function ZD(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
function JD() {
}
function rx(e, t) {
  var n = -1, o = e.length;
  for (t || (t = Array(o)); ++n < o; )
    t[n] = e[n];
  return t;
}
var QD = 800, eL = 16, tL = Date.now;
function nL(e) {
  var t = 0, n = 0;
  return function() {
    var o = tL(), l = eL - (o - n);
    if (n = o, l > 0) {
      if (++t >= QD)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function oL(e) {
  return function() {
    return e;
  };
}
var Kp = function() {
  try {
    var e = Bi(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}(), lL = Kp ? function(e, t) {
  return Kp(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: oL(t),
    writable: !0
  });
} : jb;
const aL = lL;
var sx = nL(aL);
function rL(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length; ++n < o && t(e[n], n, e) !== !1; )
    ;
  return e;
}
function ix(e, t, n, o) {
  for (var l = e.length, a = n + (o ? 1 : -1); o ? a-- : ++a < l; )
    if (t(e[a], a, e))
      return a;
  return -1;
}
function sL(e) {
  return e !== e;
}
function iL(e, t, n) {
  for (var o = n - 1, l = e.length; ++o < l; )
    if (e[o] === t)
      return o;
  return -1;
}
function cL(e, t, n) {
  return t === t ? iL(e, t, n) : ix(e, sL, n);
}
function uL(e, t) {
  var n = e == null ? 0 : e.length;
  return !!n && cL(e, t, 0) > -1;
}
var dL = 9007199254740991, fL = /^(?:0|[1-9]\d*)$/;
function kv(e, t) {
  var n = typeof e;
  return t = t ?? dL, !!t && (n == "number" || n != "symbol" && fL.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function Yb(e, t, n) {
  t == "__proto__" && Kp ? Kp(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
function ef(e, t) {
  return e === t || e !== e && t !== t;
}
var pL = Object.prototype, vL = pL.hasOwnProperty;
function Gb(e, t, n) {
  var o = e[t];
  (!(vL.call(e, t) && ef(o, n)) || n === void 0 && !(t in e)) && Yb(e, t, n);
}
function tu(e, t, n, o) {
  var l = !n;
  n || (n = {});
  for (var a = -1, r = t.length; ++a < r; ) {
    var i = t[a], s = o ? o(n[i], e[i], i, n, e) : void 0;
    s === void 0 && (s = e[i]), l ? Yb(n, i, s) : Gb(n, i, s);
  }
  return n;
}
var _C = Math.max;
function cx(e, t, n) {
  return t = _C(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var o = arguments, l = -1, a = _C(o.length - t, 0), r = Array(a); ++l < a; )
      r[l] = o[t + l];
    l = -1;
    for (var i = Array(t + 1); ++l < t; )
      i[l] = o[l];
    return i[t] = n(r), ZD(e, this, i);
  };
}
function ux(e, t) {
  return sx(cx(e, t, jb), e + "");
}
var hL = 9007199254740991;
function Xb(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= hL;
}
function nu(e) {
  return e != null && Xb(e.length) && !qb(e);
}
function mL(e, t, n) {
  if (!Ol(n))
    return !1;
  var o = typeof t;
  return (o == "number" ? nu(n) && kv(t, n.length) : o == "string" && t in n) ? ef(n[t], e) : !1;
}
function gL(e) {
  return ux(function(t, n) {
    var o = -1, l = n.length, a = l > 1 ? n[l - 1] : void 0, r = l > 2 ? n[2] : void 0;
    for (a = e.length > 3 && typeof a == "function" ? (l--, a) : void 0, r && mL(n[0], n[1], r) && (a = l < 3 ? void 0 : a, l = 1), t = Object(t); ++o < l; ) {
      var i = n[o];
      i && e(t, i, o, a);
    }
    return t;
  });
}
var bL = Object.prototype;
function Zb(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || bL;
  return e === n;
}
function yL(e, t) {
  for (var n = -1, o = Array(e); ++n < e; )
    o[n] = t(n);
  return o;
}
var CL = "[object Arguments]";
function xC(e) {
  return sr(e) && Fi(e) == CL;
}
var dx = Object.prototype, wL = dx.hasOwnProperty, EL = dx.propertyIsEnumerable, xd = xC(/* @__PURE__ */ function() {
  return arguments;
}()) ? xC : function(e) {
  return sr(e) && wL.call(e, "callee") && !EL.call(e, "callee");
};
function SL() {
  return !1;
}
var fx = typeof exports == "object" && exports && !exports.nodeType && exports, kC = fx && typeof module == "object" && module && !module.nodeType && module, _L = kC && kC.exports === fx, TC = _L ? Ba.Buffer : void 0, xL = TC ? TC.isBuffer : void 0, kd = xL || SL, kL = "[object Arguments]", TL = "[object Array]", $L = "[object Boolean]", OL = "[object Date]", NL = "[object Error]", ML = "[object Function]", IL = "[object Map]", RL = "[object Number]", DL = "[object Object]", LL = "[object RegExp]", PL = "[object Set]", AL = "[object String]", FL = "[object WeakMap]", VL = "[object ArrayBuffer]", BL = "[object DataView]", HL = "[object Float32Array]", zL = "[object Float64Array]", WL = "[object Int8Array]", KL = "[object Int16Array]", UL = "[object Int32Array]", jL = "[object Uint8Array]", qL = "[object Uint8ClampedArray]", YL = "[object Uint16Array]", GL = "[object Uint32Array]", go = {};
go[HL] = go[zL] = go[WL] = go[KL] = go[UL] = go[jL] = go[qL] = go[YL] = go[GL] = !0;
go[kL] = go[TL] = go[VL] = go[$L] = go[BL] = go[OL] = go[NL] = go[ML] = go[IL] = go[RL] = go[DL] = go[LL] = go[PL] = go[AL] = go[FL] = !1;
function XL(e) {
  return sr(e) && Xb(e.length) && !!go[Fi(e)];
}
function Jb(e) {
  return function(t) {
    return e(t);
  };
}
var px = typeof exports == "object" && exports && !exports.nodeType && exports, qu = px && typeof module == "object" && module && !module.nodeType && module, ZL = qu && qu.exports === px, zh = ZL && ox.process, Dc = function() {
  try {
    var e = qu && qu.require && qu.require("util").types;
    return e || zh && zh.binding && zh.binding("util");
  } catch {
  }
}(), $C = Dc && Dc.isTypedArray, Qb = $C ? Jb($C) : XL, JL = Object.prototype, QL = JL.hasOwnProperty;
function vx(e, t) {
  var n = $l(e), o = !n && xd(e), l = !n && !o && kd(e), a = !n && !o && !l && Qb(e), r = n || o || l || a, i = r ? yL(e.length, String) : [], s = i.length;
  for (var u in e)
    (t || QL.call(e, u)) && !(r && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    l && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    a && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    kv(u, s))) && i.push(u);
  return i;
}
function hx(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var eP = hx(Object.keys, Object), tP = Object.prototype, nP = tP.hasOwnProperty;
function oP(e) {
  if (!Zb(e))
    return eP(e);
  var t = [];
  for (var n in Object(e))
    nP.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
function tf(e) {
  return nu(e) ? vx(e) : oP(e);
}
function lP(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var aP = Object.prototype, rP = aP.hasOwnProperty;
function sP(e) {
  if (!Ol(e))
    return lP(e);
  var t = Zb(e), n = [];
  for (var o in e)
    o == "constructor" && (t || !rP.call(e, o)) || n.push(o);
  return n;
}
function nf(e) {
  return nu(e) ? vx(e, !0) : sP(e);
}
var iP = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, cP = /^\w*$/;
function ey(e, t) {
  if ($l(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || xv(e) ? !0 : cP.test(e) || !iP.test(e) || t != null && e in Object(t);
}
var Td = Bi(Object, "create");
function uP() {
  this.__data__ = Td ? Td(null) : {}, this.size = 0;
}
function dP(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var fP = "__lodash_hash_undefined__", pP = Object.prototype, vP = pP.hasOwnProperty;
function hP(e) {
  var t = this.__data__;
  if (Td) {
    var n = t[e];
    return n === fP ? void 0 : n;
  }
  return vP.call(t, e) ? t[e] : void 0;
}
var mP = Object.prototype, gP = mP.hasOwnProperty;
function bP(e) {
  var t = this.__data__;
  return Td ? t[e] !== void 0 : gP.call(t, e);
}
var yP = "__lodash_hash_undefined__";
function CP(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = Td && t === void 0 ? yP : t, this;
}
function Ti(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
Ti.prototype.clear = uP;
Ti.prototype.delete = dP;
Ti.prototype.get = hP;
Ti.prototype.has = bP;
Ti.prototype.set = CP;
function wP() {
  this.__data__ = [], this.size = 0;
}
function Tv(e, t) {
  for (var n = e.length; n--; )
    if (ef(e[n][0], t))
      return n;
  return -1;
}
var EP = Array.prototype, SP = EP.splice;
function _P(e) {
  var t = this.__data__, n = Tv(t, e);
  if (n < 0)
    return !1;
  var o = t.length - 1;
  return n == o ? t.pop() : SP.call(t, n, 1), --this.size, !0;
}
function xP(e) {
  var t = this.__data__, n = Tv(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function kP(e) {
  return Tv(this.__data__, e) > -1;
}
function TP(e, t) {
  var n = this.__data__, o = Tv(n, e);
  return o < 0 ? (++this.size, n.push([e, t])) : n[o][1] = t, this;
}
function Fr(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
Fr.prototype.clear = wP;
Fr.prototype.delete = _P;
Fr.prototype.get = xP;
Fr.prototype.has = kP;
Fr.prototype.set = TP;
var $d = Bi(Ba, "Map");
function $P() {
  this.size = 0, this.__data__ = {
    hash: new Ti(),
    map: new ($d || Fr)(),
    string: new Ti()
  };
}
function OP(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function $v(e, t) {
  var n = e.__data__;
  return OP(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function NP(e) {
  var t = $v(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function MP(e) {
  return $v(this, e).get(e);
}
function IP(e) {
  return $v(this, e).has(e);
}
function RP(e, t) {
  var n = $v(this, e), o = n.size;
  return n.set(e, t), this.size += n.size == o ? 0 : 1, this;
}
function Vr(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
Vr.prototype.clear = $P;
Vr.prototype.delete = NP;
Vr.prototype.get = MP;
Vr.prototype.has = IP;
Vr.prototype.set = RP;
var DP = "Expected a function";
function Ov(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(DP);
  var n = function() {
    var o = arguments, l = t ? t.apply(this, o) : o[0], a = n.cache;
    if (a.has(l))
      return a.get(l);
    var r = e.apply(this, o);
    return n.cache = a.set(l, r) || a, r;
  };
  return n.cache = new (Ov.Cache || Vr)(), n;
}
Ov.Cache = Vr;
var LP = 500;
function PP(e) {
  var t = Ov(e, function(o) {
    return n.size === LP && n.clear(), o;
  }), n = t.cache;
  return t;
}
var AP = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, FP = /\\(\\)?/g, VP = PP(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(AP, function(n, o, l, a) {
    t.push(l ? a.replace(FP, "$1") : o || n);
  }), t;
});
function BP(e) {
  return e == null ? "" : ax(e);
}
function ou(e, t) {
  return $l(e) ? e : ey(e, t) ? [e] : VP(BP(e));
}
var HP = 1 / 0;
function lu(e) {
  if (typeof e == "string" || xv(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -HP ? "-0" : t;
}
function Nv(e, t) {
  t = ou(t, e);
  for (var n = 0, o = t.length; e != null && n < o; )
    e = e[lu(t[n++])];
  return n && n == o ? e : void 0;
}
function bo(e, t, n) {
  var o = e == null ? void 0 : Nv(e, t);
  return o === void 0 ? n : o;
}
function ty(e, t) {
  for (var n = -1, o = t.length, l = e.length; ++n < o; )
    e[l + n] = t[n];
  return e;
}
var OC = Ca ? Ca.isConcatSpreadable : void 0;
function zP(e) {
  return $l(e) || xd(e) || !!(OC && e && e[OC]);
}
function of(e, t, n, o, l) {
  var a = -1, r = e.length;
  for (n || (n = zP), l || (l = []); ++a < r; ) {
    var i = e[a];
    t > 0 && n(i) ? t > 1 ? of(i, t - 1, n, o, l) : ty(l, i) : o || (l[l.length] = i);
  }
  return l;
}
function mx(e) {
  var t = e == null ? 0 : e.length;
  return t ? of(e, 1) : [];
}
function gx(e) {
  return sx(cx(e, void 0, mx), e + "");
}
var WP = hx(Object.getPrototypeOf, Object);
const ny = WP;
var KP = "[object Object]", UP = Function.prototype, jP = Object.prototype, bx = UP.toString, qP = jP.hasOwnProperty, YP = bx.call(Object);
function yx(e) {
  if (!sr(e) || Fi(e) != KP)
    return !1;
  var t = ny(e);
  if (t === null)
    return !0;
  var n = qP.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && bx.call(n) == YP;
}
function GP(e, t, n) {
  var o = -1, l = e.length;
  t < 0 && (t = -t > l ? 0 : l + t), n = n > l ? l : n, n < 0 && (n += l), l = t > n ? 0 : n - t >>> 0, t >>>= 0;
  for (var a = Array(l); ++o < l; )
    a[o] = e[o + t];
  return a;
}
function _s() {
  if (!arguments.length)
    return [];
  var e = arguments[0];
  return $l(e) ? e : [e];
}
function XP() {
  this.__data__ = new Fr(), this.size = 0;
}
function ZP(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function JP(e) {
  return this.__data__.get(e);
}
function QP(e) {
  return this.__data__.has(e);
}
var eA = 200;
function tA(e, t) {
  var n = this.__data__;
  if (n instanceof Fr) {
    var o = n.__data__;
    if (!$d || o.length < eA - 1)
      return o.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new Vr(o);
  }
  return n.set(e, t), this.size = n.size, this;
}
function Aa(e) {
  var t = this.__data__ = new Fr(e);
  this.size = t.size;
}
Aa.prototype.clear = XP;
Aa.prototype.delete = ZP;
Aa.prototype.get = JP;
Aa.prototype.has = QP;
Aa.prototype.set = tA;
function nA(e, t) {
  return e && tu(t, tf(t), e);
}
function oA(e, t) {
  return e && tu(t, nf(t), e);
}
var Cx = typeof exports == "object" && exports && !exports.nodeType && exports, NC = Cx && typeof module == "object" && module && !module.nodeType && module, lA = NC && NC.exports === Cx, MC = lA ? Ba.Buffer : void 0, IC = MC ? MC.allocUnsafe : void 0;
function wx(e, t) {
  if (t)
    return e.slice();
  var n = e.length, o = IC ? IC(n) : new e.constructor(n);
  return e.copy(o), o;
}
function aA(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length, l = 0, a = []; ++n < o; ) {
    var r = e[n];
    t(r, n, e) && (a[l++] = r);
  }
  return a;
}
function Ex() {
  return [];
}
var rA = Object.prototype, sA = rA.propertyIsEnumerable, RC = Object.getOwnPropertySymbols, oy = RC ? function(e) {
  return e == null ? [] : (e = Object(e), aA(RC(e), function(t) {
    return sA.call(e, t);
  }));
} : Ex;
function iA(e, t) {
  return tu(e, oy(e), t);
}
var cA = Object.getOwnPropertySymbols, Sx = cA ? function(e) {
  for (var t = []; e; )
    ty(t, oy(e)), e = ny(e);
  return t;
} : Ex;
function uA(e, t) {
  return tu(e, Sx(e), t);
}
function _x(e, t, n) {
  var o = t(e);
  return $l(e) ? o : ty(o, n(e));
}
function og(e) {
  return _x(e, tf, oy);
}
function xx(e) {
  return _x(e, nf, Sx);
}
var lg = Bi(Ba, "DataView"), ag = Bi(Ba, "Promise"), _c = Bi(Ba, "Set"), DC = "[object Map]", dA = "[object Object]", LC = "[object Promise]", PC = "[object Set]", AC = "[object WeakMap]", FC = "[object DataView]", fA = Vi(lg), pA = Vi($d), vA = Vi(ag), hA = Vi(_c), mA = Vi(ng), ei = Fi;
(lg && ei(new lg(new ArrayBuffer(1))) != FC || $d && ei(new $d()) != DC || ag && ei(ag.resolve()) != LC || _c && ei(new _c()) != PC || ng && ei(new ng()) != AC) && (ei = function(e) {
  var t = Fi(e), n = t == dA ? e.constructor : void 0, o = n ? Vi(n) : "";
  if (o)
    switch (o) {
      case fA:
        return FC;
      case pA:
        return DC;
      case vA:
        return LC;
      case hA:
        return PC;
      case mA:
        return AC;
    }
  return t;
});
const Od = ei;
var gA = Object.prototype, bA = gA.hasOwnProperty;
function yA(e) {
  var t = e.length, n = new e.constructor(t);
  return t && typeof e[0] == "string" && bA.call(e, "index") && (n.index = e.index, n.input = e.input), n;
}
var Up = Ba.Uint8Array;
function ly(e) {
  var t = new e.constructor(e.byteLength);
  return new Up(t).set(new Up(e)), t;
}
function CA(e, t) {
  var n = t ? ly(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.byteLength);
}
var wA = /\w*$/;
function EA(e) {
  var t = new e.constructor(e.source, wA.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var VC = Ca ? Ca.prototype : void 0, BC = VC ? VC.valueOf : void 0;
function SA(e) {
  return BC ? Object(BC.call(e)) : {};
}
function kx(e, t) {
  var n = t ? ly(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.length);
}
var _A = "[object Boolean]", xA = "[object Date]", kA = "[object Map]", TA = "[object Number]", $A = "[object RegExp]", OA = "[object Set]", NA = "[object String]", MA = "[object Symbol]", IA = "[object ArrayBuffer]", RA = "[object DataView]", DA = "[object Float32Array]", LA = "[object Float64Array]", PA = "[object Int8Array]", AA = "[object Int16Array]", FA = "[object Int32Array]", VA = "[object Uint8Array]", BA = "[object Uint8ClampedArray]", HA = "[object Uint16Array]", zA = "[object Uint32Array]";
function WA(e, t, n) {
  var o = e.constructor;
  switch (t) {
    case IA:
      return ly(e);
    case _A:
    case xA:
      return new o(+e);
    case RA:
      return CA(e, n);
    case DA:
    case LA:
    case PA:
    case AA:
    case FA:
    case VA:
    case BA:
    case HA:
    case zA:
      return kx(e, n);
    case kA:
      return new o();
    case TA:
    case NA:
      return new o(e);
    case $A:
      return EA(e);
    case OA:
      return new o();
    case MA:
      return SA(e);
  }
}
function Tx(e) {
  return typeof e.constructor == "function" && !Zb(e) ? XD(ny(e)) : {};
}
var KA = "[object Map]";
function UA(e) {
  return sr(e) && Od(e) == KA;
}
var HC = Dc && Dc.isMap, jA = HC ? Jb(HC) : UA, qA = "[object Set]";
function YA(e) {
  return sr(e) && Od(e) == qA;
}
var zC = Dc && Dc.isSet, GA = zC ? Jb(zC) : YA, XA = 1, ZA = 2, JA = 4, $x = "[object Arguments]", QA = "[object Array]", e4 = "[object Boolean]", t4 = "[object Date]", n4 = "[object Error]", Ox = "[object Function]", o4 = "[object GeneratorFunction]", l4 = "[object Map]", a4 = "[object Number]", Nx = "[object Object]", r4 = "[object RegExp]", s4 = "[object Set]", i4 = "[object String]", c4 = "[object Symbol]", u4 = "[object WeakMap]", d4 = "[object ArrayBuffer]", f4 = "[object DataView]", p4 = "[object Float32Array]", v4 = "[object Float64Array]", h4 = "[object Int8Array]", m4 = "[object Int16Array]", g4 = "[object Int32Array]", b4 = "[object Uint8Array]", y4 = "[object Uint8ClampedArray]", C4 = "[object Uint16Array]", w4 = "[object Uint32Array]", co = {};
co[$x] = co[QA] = co[d4] = co[f4] = co[e4] = co[t4] = co[p4] = co[v4] = co[h4] = co[m4] = co[g4] = co[l4] = co[a4] = co[Nx] = co[r4] = co[s4] = co[i4] = co[c4] = co[b4] = co[y4] = co[C4] = co[w4] = !0;
co[n4] = co[Ox] = co[u4] = !1;
function xc(e, t, n, o, l, a) {
  var r, i = t & XA, s = t & ZA, u = t & JA;
  if (n && (r = l ? n(e, o, l, a) : n(e)), r !== void 0)
    return r;
  if (!Ol(e))
    return e;
  var d = $l(e);
  if (d) {
    if (r = yA(e), !i)
      return rx(e, r);
  } else {
    var f = Od(e), v = f == Ox || f == o4;
    if (kd(e))
      return wx(e, i);
    if (f == Nx || f == $x || v && !l) {
      if (r = s || v ? {} : Tx(e), !i)
        return s ? uA(e, oA(r, e)) : iA(e, nA(r, e));
    } else {
      if (!co[f])
        return l ? e : {};
      r = WA(e, f, i);
    }
  }
  a || (a = new Aa());
  var h = a.get(e);
  if (h)
    return h;
  a.set(e, r), GA(e) ? e.forEach(function(C) {
    r.add(xc(C, t, n, C, e, a));
  }) : jA(e) && e.forEach(function(C, g) {
    r.set(g, xc(C, t, n, g, e, a));
  });
  var m = u ? s ? xx : og : s ? nf : tf, p = d ? void 0 : m(e);
  return rL(p || e, function(C, g) {
    p && (g = C, C = e[g]), Gb(r, g, xc(C, t, n, g, e, a));
  }), r;
}
var E4 = 4;
function WC(e) {
  return xc(e, E4);
}
var S4 = 1, _4 = 4;
function jp(e) {
  return xc(e, S4 | _4);
}
var x4 = "__lodash_hash_undefined__";
function k4(e) {
  return this.__data__.set(e, x4), this;
}
function T4(e) {
  return this.__data__.has(e);
}
function Nd(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new Vr(); ++t < n; )
    this.add(e[t]);
}
Nd.prototype.add = Nd.prototype.push = k4;
Nd.prototype.has = T4;
function $4(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length; ++n < o; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
function Mx(e, t) {
  return e.has(t);
}
var O4 = 1, N4 = 2;
function Ix(e, t, n, o, l, a) {
  var r = n & O4, i = e.length, s = t.length;
  if (i != s && !(r && s > i))
    return !1;
  var u = a.get(e), d = a.get(t);
  if (u && d)
    return u == t && d == e;
  var f = -1, v = !0, h = n & N4 ? new Nd() : void 0;
  for (a.set(e, t), a.set(t, e); ++f < i; ) {
    var m = e[f], p = t[f];
    if (o)
      var C = r ? o(p, m, f, t, e, a) : o(m, p, f, e, t, a);
    if (C !== void 0) {
      if (C)
        continue;
      v = !1;
      break;
    }
    if (h) {
      if (!$4(t, function(g, w) {
        if (!Mx(h, w) && (m === g || l(m, g, n, o, a)))
          return h.push(w);
      })) {
        v = !1;
        break;
      }
    } else if (!(m === p || l(m, p, n, o, a))) {
      v = !1;
      break;
    }
  }
  return a.delete(e), a.delete(t), v;
}
function M4(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(o, l) {
    n[++t] = [l, o];
  }), n;
}
function ay(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(o) {
    n[++t] = o;
  }), n;
}
var I4 = 1, R4 = 2, D4 = "[object Boolean]", L4 = "[object Date]", P4 = "[object Error]", A4 = "[object Map]", F4 = "[object Number]", V4 = "[object RegExp]", B4 = "[object Set]", H4 = "[object String]", z4 = "[object Symbol]", W4 = "[object ArrayBuffer]", K4 = "[object DataView]", KC = Ca ? Ca.prototype : void 0, Wh = KC ? KC.valueOf : void 0;
function U4(e, t, n, o, l, a, r) {
  switch (n) {
    case K4:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case W4:
      return !(e.byteLength != t.byteLength || !a(new Up(e), new Up(t)));
    case D4:
    case L4:
    case F4:
      return ef(+e, +t);
    case P4:
      return e.name == t.name && e.message == t.message;
    case V4:
    case H4:
      return e == t + "";
    case A4:
      var i = M4;
    case B4:
      var s = o & I4;
      if (i || (i = ay), e.size != t.size && !s)
        return !1;
      var u = r.get(e);
      if (u)
        return u == t;
      o |= R4, r.set(e, t);
      var d = Ix(i(e), i(t), o, l, a, r);
      return r.delete(e), d;
    case z4:
      if (Wh)
        return Wh.call(e) == Wh.call(t);
  }
  return !1;
}
var j4 = 1, q4 = Object.prototype, Y4 = q4.hasOwnProperty;
function G4(e, t, n, o, l, a) {
  var r = n & j4, i = og(e), s = i.length, u = og(t), d = u.length;
  if (s != d && !r)
    return !1;
  for (var f = s; f--; ) {
    var v = i[f];
    if (!(r ? v in t : Y4.call(t, v)))
      return !1;
  }
  var h = a.get(e), m = a.get(t);
  if (h && m)
    return h == t && m == e;
  var p = !0;
  a.set(e, t), a.set(t, e);
  for (var C = r; ++f < s; ) {
    v = i[f];
    var g = e[v], w = t[v];
    if (o)
      var b = r ? o(w, g, v, t, e, a) : o(g, w, v, e, t, a);
    if (!(b === void 0 ? g === w || l(g, w, n, o, a) : b)) {
      p = !1;
      break;
    }
    C || (C = v == "constructor");
  }
  if (p && !C) {
    var y = e.constructor, E = t.constructor;
    y != E && "constructor" in e && "constructor" in t && !(typeof y == "function" && y instanceof y && typeof E == "function" && E instanceof E) && (p = !1);
  }
  return a.delete(e), a.delete(t), p;
}
var X4 = 1, UC = "[object Arguments]", jC = "[object Array]", Af = "[object Object]", Z4 = Object.prototype, qC = Z4.hasOwnProperty;
function J4(e, t, n, o, l, a) {
  var r = $l(e), i = $l(t), s = r ? jC : Od(e), u = i ? jC : Od(t);
  s = s == UC ? Af : s, u = u == UC ? Af : u;
  var d = s == Af, f = u == Af, v = s == u;
  if (v && kd(e)) {
    if (!kd(t))
      return !1;
    r = !0, d = !1;
  }
  if (v && !d)
    return a || (a = new Aa()), r || Qb(e) ? Ix(e, t, n, o, l, a) : U4(e, t, s, n, o, l, a);
  if (!(n & X4)) {
    var h = d && qC.call(e, "__wrapped__"), m = f && qC.call(t, "__wrapped__");
    if (h || m) {
      var p = h ? e.value() : e, C = m ? t.value() : t;
      return a || (a = new Aa()), l(p, C, n, o, a);
    }
  }
  return v ? (a || (a = new Aa()), G4(e, t, n, o, l, a)) : !1;
}
function Mv(e, t, n, o, l) {
  return e === t ? !0 : e == null || t == null || !sr(e) && !sr(t) ? e !== e && t !== t : J4(e, t, n, o, Mv, l);
}
var Q4 = 1, eF = 2;
function tF(e, t, n, o) {
  var l = n.length, a = l, r = !o;
  if (e == null)
    return !a;
  for (e = Object(e); l--; ) {
    var i = n[l];
    if (r && i[2] ? i[1] !== e[i[0]] : !(i[0] in e))
      return !1;
  }
  for (; ++l < a; ) {
    i = n[l];
    var s = i[0], u = e[s], d = i[1];
    if (r && i[2]) {
      if (u === void 0 && !(s in e))
        return !1;
    } else {
      var f = new Aa();
      if (o)
        var v = o(u, d, s, e, t, f);
      if (!(v === void 0 ? Mv(d, u, Q4 | eF, o, f) : v))
        return !1;
    }
  }
  return !0;
}
function Rx(e) {
  return e === e && !Ol(e);
}
function nF(e) {
  for (var t = tf(e), n = t.length; n--; ) {
    var o = t[n], l = e[o];
    t[n] = [o, l, Rx(l)];
  }
  return t;
}
function Dx(e, t) {
  return function(n) {
    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
  };
}
function oF(e) {
  var t = nF(e);
  return t.length == 1 && t[0][2] ? Dx(t[0][0], t[0][1]) : function(n) {
    return n === e || tF(n, e, t);
  };
}
function lF(e, t) {
  return e != null && t in Object(e);
}
function aF(e, t, n) {
  t = ou(t, e);
  for (var o = -1, l = t.length, a = !1; ++o < l; ) {
    var r = lu(t[o]);
    if (!(a = e != null && n(e, r)))
      break;
    e = e[r];
  }
  return a || ++o != l ? a : (l = e == null ? 0 : e.length, !!l && Xb(l) && kv(r, l) && ($l(e) || xd(e)));
}
function Lx(e, t) {
  return e != null && aF(e, t, lF);
}
var rF = 1, sF = 2;
function iF(e, t) {
  return ey(e) && Rx(t) ? Dx(lu(e), t) : function(n) {
    var o = bo(n, e);
    return o === void 0 && o === t ? Lx(n, e) : Mv(t, o, rF | sF);
  };
}
function cF(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
function uF(e) {
  return function(t) {
    return Nv(t, e);
  };
}
function dF(e) {
  return ey(e) ? cF(lu(e)) : uF(e);
}
function Px(e) {
  return typeof e == "function" ? e : e == null ? jb : typeof e == "object" ? $l(e) ? iF(e[0], e[1]) : oF(e) : dF(e);
}
function fF(e) {
  return function(t, n, o) {
    for (var l = -1, a = Object(t), r = o(t), i = r.length; i--; ) {
      var s = r[e ? i : ++l];
      if (n(a[s], s, a) === !1)
        break;
    }
    return t;
  };
}
var Ax = fF();
function pF(e, t) {
  return e && Ax(e, t, tf);
}
function vF(e, t) {
  return function(n, o) {
    if (n == null)
      return n;
    if (!nu(n))
      return e(n, o);
    for (var l = n.length, a = t ? l : -1, r = Object(n); (t ? a-- : ++a < l) && o(r[a], a, r) !== !1; )
      ;
    return n;
  };
}
var hF = vF(pF), Kh = function() {
  return Ba.Date.now();
}, mF = "Expected a function", gF = Math.max, bF = Math.min;
function Hl(e, t, n) {
  var o, l, a, r, i, s, u = 0, d = !1, f = !1, v = !0;
  if (typeof e != "function")
    throw new TypeError(mF);
  t = tg(t) || 0, Ol(n) && (d = !!n.leading, f = "maxWait" in n, a = f ? gF(tg(n.maxWait) || 0, t) : a, v = "trailing" in n ? !!n.trailing : v);
  function h(S) {
    var _ = o, k = l;
    return o = l = void 0, u = S, r = e.apply(k, _), r;
  }
  function m(S) {
    return u = S, i = setTimeout(g, t), d ? h(S) : r;
  }
  function p(S) {
    var _ = S - s, k = S - u, N = t - _;
    return f ? bF(N, a - k) : N;
  }
  function C(S) {
    var _ = S - s, k = S - u;
    return s === void 0 || _ >= t || _ < 0 || f && k >= a;
  }
  function g() {
    var S = Kh();
    if (C(S))
      return w(S);
    i = setTimeout(g, p(S));
  }
  function w(S) {
    return i = void 0, v && o ? h(S) : (o = l = void 0, r);
  }
  function b() {
    i !== void 0 && clearTimeout(i), u = 0, o = s = l = i = void 0;
  }
  function y() {
    return i === void 0 ? r : w(Kh());
  }
  function E() {
    var S = Kh(), _ = C(S);
    if (o = arguments, l = this, s = S, _) {
      if (i === void 0)
        return m(s);
      if (f)
        return clearTimeout(i), i = setTimeout(g, t), h(s);
    }
    return i === void 0 && (i = setTimeout(g, t)), r;
  }
  return E.cancel = b, E.flush = y, E;
}
function rg(e, t, n) {
  (n !== void 0 && !ef(e[t], n) || n === void 0 && !(t in e)) && Yb(e, t, n);
}
function Fx(e) {
  return sr(e) && nu(e);
}
function sg(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
function yF(e) {
  return tu(e, nf(e));
}
function CF(e, t, n, o, l, a, r) {
  var i = sg(e, n), s = sg(t, n), u = r.get(s);
  if (u) {
    rg(e, n, u);
    return;
  }
  var d = a ? a(i, s, n + "", e, t, r) : void 0, f = d === void 0;
  if (f) {
    var v = $l(s), h = !v && kd(s), m = !v && !h && Qb(s);
    d = s, v || h || m ? $l(i) ? d = i : Fx(i) ? d = rx(i) : h ? (f = !1, d = wx(s, !0)) : m ? (f = !1, d = kx(s, !0)) : d = [] : yx(s) || xd(s) ? (d = i, xd(i) ? d = yF(i) : (!Ol(i) || qb(i)) && (d = Tx(s))) : f = !1;
  }
  f && (r.set(s, d), l(d, s, o, a, r), r.delete(s)), rg(e, n, d);
}
function Vx(e, t, n, o, l) {
  e !== t && Ax(t, function(a, r) {
    if (l || (l = new Aa()), Ol(a))
      CF(e, t, r, n, Vx, o, l);
    else {
      var i = o ? o(sg(e, r), a, r + "", e, t, l) : void 0;
      i === void 0 && (i = a), rg(e, r, i);
    }
  }, nf);
}
function wF(e, t, n) {
  for (var o = -1, l = e == null ? 0 : e.length; ++o < l; )
    if (n(t, e[o]))
      return !0;
  return !1;
}
function EF(e) {
  var t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
var SF = Math.max, _F = Math.min;
function Bx(e, t, n) {
  var o = e == null ? 0 : e.length;
  if (!o)
    return -1;
  var l = o - 1;
  return n !== void 0 && (l = RD(n), l = n < 0 ? SF(o + l, 0) : _F(l, o - 1)), ix(e, Px(t), l, !0);
}
function xF(e, t) {
  var n = -1, o = nu(e) ? Array(e.length) : [];
  return hF(e, function(l, a, r) {
    o[++n] = t(l, a, r);
  }), o;
}
function kF(e, t) {
  var n = $l(e) ? Ub : xF;
  return n(e, Px(t));
}
function TF(e, t) {
  return of(kF(e, t), 1);
}
var $F = 1 / 0;
function OF(e) {
  var t = e == null ? 0 : e.length;
  return t ? of(e, $F) : [];
}
function qp(e) {
  for (var t = -1, n = e == null ? 0 : e.length, o = {}; ++t < n; ) {
    var l = e[t];
    o[l[0]] = l[1];
  }
  return o;
}
function NF(e, t) {
  return t.length < 2 ? e : Nv(e, GP(t, 0, -1));
}
function pl(e, t) {
  return Mv(e, t);
}
function zo(e) {
  return e == null;
}
function Hx(e) {
  return e === void 0;
}
var MF = gL(function(e, t, n) {
  Vx(e, t, n);
});
const IF = MF;
function RF(e, t) {
  return t = ou(t, e), e = NF(e, t), e == null || delete e[lu(EF(t))];
}
function DF(e) {
  return yx(e) ? void 0 : e;
}
var LF = 1, PF = 2, AF = 4, FF = gx(function(e, t) {
  var n = {};
  if (e == null)
    return n;
  var o = !1;
  t = Ub(t, function(a) {
    return a = ou(a, e), o || (o = a.length > 1), a;
  }), tu(e, xx(e), n), o && (n = xc(n, LF | PF | AF, DF));
  for (var l = t.length; l--; )
    RF(n, t[l]);
  return n;
});
function zx(e, t, n, o) {
  if (!Ol(e))
    return e;
  t = ou(t, e);
  for (var l = -1, a = t.length, r = a - 1, i = e; i != null && ++l < a; ) {
    var s = lu(t[l]), u = n;
    if (s === "__proto__" || s === "constructor" || s === "prototype")
      return e;
    if (l != r) {
      var d = i[s];
      u = o ? o(d, s, i) : void 0, u === void 0 && (u = Ol(d) ? d : kv(t[l + 1]) ? [] : {});
    }
    Gb(i, s, u), i = i[s];
  }
  return e;
}
function VF(e, t, n) {
  for (var o = -1, l = t.length, a = {}; ++o < l; ) {
    var r = t[o], i = Nv(e, r);
    n(i, r) && zx(a, ou(r, e), i);
  }
  return a;
}
function BF(e, t) {
  return VF(e, t, function(n, o) {
    return Lx(e, o);
  });
}
var er = gx(function(e, t) {
  return e == null ? {} : BF(e, t);
});
function HF(e, t, n) {
  return e == null ? e : zx(e, t, n);
}
var zF = "Expected a function";
function mi(e, t, n) {
  var o = !0, l = !0;
  if (typeof e != "function")
    throw new TypeError(zF);
  return Ol(n) && (o = "leading" in n ? !!n.leading : o, l = "trailing" in n ? !!n.trailing : l), Hl(e, t, {
    leading: o,
    maxWait: t,
    trailing: l
  });
}
var WF = 1 / 0, KF = _c && 1 / ay(new _c([, -0]))[1] == WF ? function(e) {
  return new _c(e);
} : JD, UF = 200;
function jF(e, t, n) {
  var o = -1, l = uL, a = e.length, r = !0, i = [], s = i;
  if (n)
    r = !1, l = wF;
  else if (a >= UF) {
    var u = t ? null : KF(e);
    if (u)
      return ay(u);
    r = !1, l = Mx, s = new Nd();
  } else
    s = t ? [] : i;
  e:
    for (; ++o < a; ) {
      var d = e[o], f = t ? t(d) : d;
      if (d = n || d !== 0 ? d : 0, r && f === f) {
        for (var v = s.length; v--; )
          if (s[v] === f)
            continue e;
        t && s.push(f), i.push(d);
      } else
        l(s, f, n) || (s !== i && s.push(f), i.push(d));
    }
  return i;
}
var Uh = ux(function(e) {
  return jF(of(e, 1, Fx, !0));
});
const To = (e) => e === void 0, $o = (e) => typeof e == "boolean", Ot = (e) => typeof e == "number", ha = (e) => !e && e !== 0 || Kt(e) && e.length === 0 || Mn(e) && !Object.keys(e).length, wa = (e) => typeof Element > "u" ? !1 : e instanceof Element, $i = (e) => zo(e), qF = (e) => on(e) ? !Number.isNaN(Number(e)) : !1, Iv = (e) => e === window, xs = (e) => fn ? window.requestAnimationFrame(e) : setTimeout(e, 16), Oi = (e) => fn ? window.cancelAnimationFrame(e) : clearTimeout(e), ry = (e = "") => e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), Qa = (e) => uD(e), Lc = (e) => Object.keys(e), YF = (e) => Object.entries(e), hp = (e, t, n) => ({
  get value() {
    return bo(e, t, n);
  },
  set value(o) {
    HF(e, t, o);
  }
});
class Wx extends Error {
  constructor(t) {
    super(t), this.name = "ElementPlusError";
  }
}
function lo(e, t) {
  throw new Wx(`[${e}] ${t}`);
}
function dn(e, t) {
  if (process.env.NODE_ENV !== "production") {
    const n = on(e) ? new Wx(`[${e}] ${t}`) : e;
    console.warn(n);
  }
}
const GF = "utils/dom/style", Kx = (e = "") => e.split(" ").filter((t) => !!t.trim()), ba = (e, t) => {
  if (!e || !t)
    return !1;
  if (t.includes(" "))
    throw new Error("className should not contain space.");
  return e.classList.contains(t);
}, ma = (e, t) => {
  !e || !t.trim() || e.classList.add(...Kx(t));
}, vl = (e, t) => {
  !e || !t.trim() || e.classList.remove(...Kx(t));
}, ps = (e, t) => {
  var n;
  if (!fn || !e || !t)
    return "";
  let o = nx(t);
  o === "float" && (o = "cssFloat");
  try {
    const l = e.style[o];
    if (l)
      return l;
    const a = (n = document.defaultView) == null ? void 0 : n.getComputedStyle(e, "");
    return a ? a[o] : "";
  } catch {
    return e.style[o];
  }
};
function po(e, t = "px") {
  if (!e)
    return "";
  if (Ot(e) || qF(e))
    return `${e}${t}`;
  if (on(e))
    return e;
  dn(GF, "binding value must be a string or number");
}
const XF = (e, t) => {
  if (!fn)
    return !1;
  const n = {
    undefined: "overflow",
    true: "overflow-y",
    false: "overflow-x"
  }[String(t)], o = ps(e, n);
  return ["scroll", "auto", "overlay"].some((l) => o.includes(l));
}, sy = (e, t) => {
  if (!fn)
    return;
  let n = e;
  for (; n; ) {
    if ([window, document, document.documentElement].includes(n))
      return window;
    if (XF(n, t))
      return n;
    n = n.parentNode;
  }
  return n;
};
let Ff;
const Ux = (e) => {
  var t;
  if (!fn)
    return 0;
  if (Ff !== void 0)
    return Ff;
  const n = document.createElement("div");
  n.className = `${e}-scrollbar__wrap`, n.style.visibility = "hidden", n.style.width = "100px", n.style.position = "absolute", n.style.top = "-9999px", document.body.appendChild(n);
  const o = n.offsetWidth;
  n.style.overflow = "scroll";
  const l = document.createElement("div");
  l.style.width = "100%", n.appendChild(l);
  const a = l.offsetWidth;
  return (t = n.parentNode) == null || t.removeChild(n), Ff = o - a, Ff;
};
function jx(e, t) {
  if (!fn)
    return;
  if (!t) {
    e.scrollTop = 0;
    return;
  }
  const n = [];
  let o = t.offsetParent;
  for (; o !== null && e !== o && e.contains(o); )
    n.push(o), o = o.offsetParent;
  const l = t.offsetTop + n.reduce((s, u) => s + u.offsetTop, 0), a = l + t.offsetHeight, r = e.scrollTop, i = r + e.clientHeight;
  l < r ? e.scrollTop = l : a > i && (e.scrollTop = a - e.clientHeight);
}
function ZF(e, t, n, o, l) {
  const a = Date.now();
  let r;
  const i = () => {
    const u = Date.now() - a, d = oD(u > o ? o : u, t, n, o);
    Iv(e) ? e.scrollTo(window.pageXOffset, d) : e.scrollTop = d, u < o ? r = xs(i) : typeof l == "function" && l();
  };
  return i(), () => {
    r && Oi(r);
  };
}
const YC = (e, t) => Iv(t) ? e.ownerDocument.documentElement : t, GC = (e) => Iv(e) ? window.scrollY : e.scrollTop, Vf = (e) => {
  if (!fn || e === "")
    return null;
  if (on(e))
    try {
      return document.querySelector(e);
    } catch {
      return null;
    }
  return e;
};
/*! Element Plus Icons Vue v2.3.1 */
var JF = /* @__PURE__ */ Q({
  name: "ArrowDown",
  __name: "arrow-down",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
      })
    ]));
  }
}), Br = JF, QF = /* @__PURE__ */ Q({
  name: "ArrowLeft",
  __name: "arrow-left",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
      })
    ]));
  }
}), ks = QF, e8 = /* @__PURE__ */ Q({
  name: "ArrowRight",
  __name: "arrow-right",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
      })
    ]));
  }
}), xl = e8, t8 = /* @__PURE__ */ Q({
  name: "ArrowUp",
  __name: "arrow-up",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
      })
    ]));
  }
}), iy = t8, n8 = /* @__PURE__ */ Q({
  name: "Back",
  __name: "back",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M224 480h640a32 32 0 1 1 0 64H224a32 32 0 0 1 0-64"
      }),
      X("path", {
        fill: "currentColor",
        d: "m237.248 512 265.408 265.344a32 32 0 0 1-45.312 45.312l-288-288a32 32 0 0 1 0-45.312l288-288a32 32 0 1 1 45.312 45.312z"
      })
    ]));
  }
}), o8 = n8, l8 = /* @__PURE__ */ Q({
  name: "Calendar",
  __name: "calendar",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64"
      })
    ]));
  }
}), a8 = l8, r8 = /* @__PURE__ */ Q({
  name: "CaretRight",
  __name: "caret-right",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M384 192v640l384-320.064z"
      })
    ]));
  }
}), qx = r8, s8 = /* @__PURE__ */ Q({
  name: "CaretTop",
  __name: "caret-top",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M512 320 192 704h639.936z"
      })
    ]));
  }
}), i8 = s8, c8 = /* @__PURE__ */ Q({
  name: "Check",
  __name: "check",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
      })
    ]));
  }
}), lf = c8, u8 = /* @__PURE__ */ Q({
  name: "CircleCheckFilled",
  __name: "circle-check-filled",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
      })
    ]));
  }
}), d8 = u8, f8 = /* @__PURE__ */ Q({
  name: "CircleCheck",
  __name: "circle-check",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      }),
      X("path", {
        fill: "currentColor",
        d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
      })
    ]));
  }
}), cy = f8, p8 = /* @__PURE__ */ Q({
  name: "CircleCloseFilled",
  __name: "circle-close-filled",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
      })
    ]));
  }
}), uy = p8, v8 = /* @__PURE__ */ Q({
  name: "CircleClose",
  __name: "circle-close",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
      }),
      X("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      })
    ]));
  }
}), Ls = v8, h8 = /* @__PURE__ */ Q({
  name: "Clock",
  __name: "clock",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      }),
      X("path", {
        fill: "currentColor",
        d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32"
      }),
      X("path", {
        fill: "currentColor",
        d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32"
      })
    ]));
  }
}), Yx = h8, m8 = /* @__PURE__ */ Q({
  name: "Close",
  __name: "close",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
      })
    ]));
  }
}), Fa = m8, g8 = /* @__PURE__ */ Q({
  name: "DArrowLeft",
  __name: "d-arrow-left",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
      })
    ]));
  }
}), Pc = g8, b8 = /* @__PURE__ */ Q({
  name: "DArrowRight",
  __name: "d-arrow-right",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688m-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
      })
    ]));
  }
}), Ac = b8, y8 = /* @__PURE__ */ Q({
  name: "Delete",
  __name: "delete",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32zm448-64v-64H416v64zM224 896h576V256H224zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32m192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32"
      })
    ]));
  }
}), C8 = y8, w8 = /* @__PURE__ */ Q({
  name: "Document",
  __name: "document",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M832 384H576V128H192v768h640zm-26.496-64L640 154.496V320zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m160 448h384v64H320zm0-192h160v64H320zm0 384h384v64H320z"
      })
    ]));
  }
}), E8 = w8, S8 = /* @__PURE__ */ Q({
  name: "FullScreen",
  __name: "full-screen",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64z"
      })
    ]));
  }
}), _8 = S8, x8 = /* @__PURE__ */ Q({
  name: "Hide",
  __name: "hide",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
      }),
      X("path", {
        fill: "currentColor",
        d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
      })
    ]));
  }
}), k8 = x8, T8 = /* @__PURE__ */ Q({
  name: "InfoFilled",
  __name: "info-filled",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
      })
    ]));
  }
}), dy = T8, $8 = /* @__PURE__ */ Q({
  name: "Loading",
  __name: "loading",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
      })
    ]));
  }
}), Ps = $8, O8 = /* @__PURE__ */ Q({
  name: "Minus",
  __name: "minus",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
      })
    ]));
  }
}), N8 = O8, M8 = /* @__PURE__ */ Q({
  name: "MoreFilled",
  __name: "more-filled",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224"
      })
    ]));
  }
}), XC = M8, I8 = /* @__PURE__ */ Q({
  name: "More",
  __name: "more",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M176 416a112 112 0 1 0 0 224 112 112 0 0 0 0-224m0 64a48 48 0 1 1 0 96 48 48 0 0 1 0-96m336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224m0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96m336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224m0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96"
      })
    ]));
  }
}), R8 = I8, D8 = /* @__PURE__ */ Q({
  name: "PictureFilled",
  __name: "picture-filled",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M96 896a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h832a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32zm315.52-228.48-68.928-68.928a32 32 0 0 0-45.248 0L128 768.064h778.688l-242.112-290.56a32 32 0 0 0-49.216 0L458.752 665.408a32 32 0 0 1-47.232 2.112M256 384a96 96 0 1 0 192.064-.064A96 96 0 0 0 256 384"
      })
    ]));
  }
}), L8 = D8, P8 = /* @__PURE__ */ Q({
  name: "Plus",
  __name: "plus",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
      })
    ]));
  }
}), Gx = P8, A8 = /* @__PURE__ */ Q({
  name: "QuestionFilled",
  __name: "question-filled",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"
      })
    ]));
  }
}), F8 = A8, V8 = /* @__PURE__ */ Q({
  name: "RefreshLeft",
  __name: "refresh-left",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
      })
    ]));
  }
}), B8 = V8, H8 = /* @__PURE__ */ Q({
  name: "RefreshRight",
  __name: "refresh-right",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
      })
    ]));
  }
}), z8 = H8, W8 = /* @__PURE__ */ Q({
  name: "ScaleToOriginal",
  __name: "scale-to-original",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118M512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412M512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512"
      })
    ]));
  }
}), K8 = W8, U8 = /* @__PURE__ */ Q({
  name: "Search",
  __name: "search",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704"
      })
    ]));
  }
}), Xx = U8, j8 = /* @__PURE__ */ Q({
  name: "SortDown",
  __name: "sort-down",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M576 96v709.568L333.312 562.816A32 32 0 1 0 288 608l297.408 297.344A32 32 0 0 0 640 882.688V96a32 32 0 0 0-64 0"
      })
    ]));
  }
}), q8 = j8, Y8 = /* @__PURE__ */ Q({
  name: "SortUp",
  __name: "sort-up",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M384 141.248V928a32 32 0 1 0 64 0V218.56l242.688 242.688A32 32 0 1 0 736 416L438.592 118.656A32 32 0 0 0 384 141.248"
      })
    ]));
  }
}), G8 = Y8, X8 = /* @__PURE__ */ Q({
  name: "StarFilled",
  __name: "star-filled",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M283.84 867.84 512 747.776l228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72z"
      })
    ]));
  }
}), Bf = X8, Z8 = /* @__PURE__ */ Q({
  name: "Star",
  __name: "star",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "m512 747.84 228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72zM313.6 924.48a70.4 70.4 0 0 1-102.144-74.24l37.888-220.928L88.96 472.96A70.4 70.4 0 0 1 128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 0 1 126.208 0l99.2 200.96 221.824 32.256a70.4 70.4 0 0 1 39.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 0 1-102.144 74.24L512 820.096l-198.4 104.32z"
      })
    ]));
  }
}), J8 = Z8, Q8 = /* @__PURE__ */ Q({
  name: "SuccessFilled",
  __name: "success-filled",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
      })
    ]));
  }
}), Zx = Q8, eV = /* @__PURE__ */ Q({
  name: "View",
  __name: "view",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
      })
    ]));
  }
}), tV = eV, nV = /* @__PURE__ */ Q({
  name: "WarningFilled",
  __name: "warning-filled",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
      })
    ]));
  }
}), Rv = nV, oV = /* @__PURE__ */ Q({
  name: "ZoomIn",
  __name: "zoom-in",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704m-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64z"
      })
    ]));
  }
}), Jx = oV, lV = /* @__PURE__ */ Q({
  name: "ZoomOut",
  __name: "zoom-out",
  setup(e) {
    return (t, n) => (M(), G("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      X("path", {
        fill: "currentColor",
        d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704M352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64"
      })
    ]));
  }
}), aV = lV;
const Qx = "__epPropKey", Ae = (e) => e, rV = (e) => Mn(e) && !!e[Qx], Ha = (e, t) => {
  if (!Mn(e) || rV(e))
    return e;
  const { values: n, required: o, default: l, type: a, validator: r } = e, s = {
    type: a,
    required: !!o,
    validator: n || r ? (u) => {
      let d = !1, f = [];
      if (n && (f = Array.from(n), sl(e, "default") && f.push(l), d || (d = f.includes(u))), r && (d || (d = r(u))), !d && f.length > 0) {
        const v = [...new Set(f)].map((h) => JSON.stringify(h)).join(", ");
        p3(`Invalid prop: validation failed${t ? ` for prop "${t}"` : ""}. Expected one of [${v}], got value ${JSON.stringify(u)}.`);
      }
      return d;
    } : void 0,
    [Qx]: !0
  };
  return sl(e, "default") && (s.default = l), s;
}, it = (e) => qp(Object.entries(e).map(([t, n]) => [
  t,
  Ha(n, t)
])), Dn = Ae([
  String,
  Object,
  Function
]), fy = {
  Close: Fa
}, py = {
  Close: Fa,
  SuccessFilled: Zx,
  InfoFilled: dy,
  WarningFilled: Rv,
  CircleCloseFilled: uy
}, Ts = {
  success: Zx,
  warning: Rv,
  error: uy,
  info: dy
}, vy = {
  validating: Ps,
  success: cy,
  error: Ls
}, Yt = (e, t) => {
  if (e.install = (n) => {
    for (const o of [e, ...Object.values(t ?? {})])
      n.component(o.name, o);
  }, t)
    for (const [n, o] of Object.entries(t))
      e[n] = o;
  return e;
}, ek = (e, t) => (e.install = (n) => {
  e._context = n._context, n.config.globalProperties[t] = e;
}, e), sV = (e, t) => (e.install = (n) => {
  n.directive(t, e);
}, e), Jn = (e) => (e.install = no, e), Dv = (...e) => (t) => {
  e.forEach((n) => {
    vn(n) ? n(t) : n.value = t;
  });
}, xt = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
}, iV = [
  "year",
  "years",
  "month",
  "date",
  "dates",
  "week",
  "datetime",
  "datetimerange",
  "daterange",
  "monthrange"
], jh = [
  "sun",
  "mon",
  "tue",
  "wed",
  "thu",
  "fri",
  "sat"
], Jt = "update:modelValue", qn = "change", kl = "input", ZC = Symbol("INSTALLED_KEY"), fr = ["", "default", "small", "large"], tk = (e) => ["", ...fr].includes(e), cV = "utils/vue/vnode";
var fa = /* @__PURE__ */ ((e) => (e[e.TEXT = 1] = "TEXT", e[e.CLASS = 2] = "CLASS", e[e.STYLE = 4] = "STYLE", e[e.PROPS = 8] = "PROPS", e[e.FULL_PROPS = 16] = "FULL_PROPS", e[e.HYDRATE_EVENTS = 32] = "HYDRATE_EVENTS", e[e.STABLE_FRAGMENT = 64] = "STABLE_FRAGMENT", e[e.KEYED_FRAGMENT = 128] = "KEYED_FRAGMENT", e[e.UNKEYED_FRAGMENT = 256] = "UNKEYED_FRAGMENT", e[e.NEED_PATCH = 512] = "NEED_PATCH", e[e.DYNAMIC_SLOTS = 1024] = "DYNAMIC_SLOTS", e[e.HOISTED = -1] = "HOISTED", e[e.BAIL = -2] = "BAIL", e))(fa || {});
function ig(e) {
  return yo(e) && e.type === kt;
}
function uV(e) {
  return yo(e) && e.type === Pb;
}
function dV(e) {
  return yo(e) && !ig(e) && !uV(e);
}
const fV = (e) => {
  if (!yo(e))
    return dn(cV, "[getNormalizedProps] must be a VNode"), {};
  const t = e.props || {}, n = (yo(e.type) ? e.type.props : void 0) || {}, o = {};
  return Object.keys(n).forEach((l) => {
    sl(n[l], "default") && (o[l] = n[l].default);
  }), Object.keys(t).forEach((l) => {
    o[nx(l)] = t[l];
  }), o;
}, pV = (e) => {
  if (!Kt(e) || e.length > 1)
    throw new Error("expect to receive a single Vue element child");
  return e[0];
}, bs = (e) => {
  const t = Kt(e) ? e : [e], n = [];
  return t.forEach((o) => {
    var l;
    Kt(o) ? n.push(...bs(o)) : yo(o) && Kt(o.children) ? n.push(...bs(o.children)) : (n.push(o), yo(o) && ((l = o.component) != null && l.subTree) && n.push(...bs(o.component.subTree)));
  }), n;
}, JC = (e) => [...new Set(e)], Gl = (e) => !e && e !== 0 ? [] : Array.isArray(e) ? e : [e], hy = (e) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(e), Zn = (e) => e;
function vV(e) {
  let t = 0;
  const n = (...o) => {
    t && Oi(t), t = xs(() => {
      e(...o), t = 0;
    });
  };
  return n.cancel = () => {
    Oi(t), t = 0;
  }, n;
}
const hV = ["class", "style"], mV = /^on[A-Z]/, my = (e = {}) => {
  const { excludeListeners: t = !1, excludeKeys: n } = e, o = x(() => ((n == null ? void 0 : n.value) || []).concat(hV)), l = Pt();
  return l ? x(() => {
    var a;
    return qp(Object.entries((a = l.proxy) == null ? void 0 : a.$attrs).filter(([r]) => !o.value.includes(r) && !(t && mV.test(r))));
  }) : (dn("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function"), x(() => ({})));
}, Ho = ({ from: e, replacement: t, scope: n, version: o, ref: l, type: a = "API" }, r) => {
  Pe(() => c(r), (i) => {
    i && dn(n, `[${a}] ${e} is about to be deprecated in version ${o}, please use ${t} instead.
For more detail, please visit: ${l}
`);
  }, {
    immediate: !0
  });
}, nk = (e, t, n, o) => {
  let l = {
    offsetX: 0,
    offsetY: 0
  };
  const a = (s) => {
    const u = s.clientX, d = s.clientY, { offsetX: f, offsetY: v } = l, h = e.value.getBoundingClientRect(), m = h.left, p = h.top, C = h.width, g = h.height, w = document.documentElement.clientWidth, b = document.documentElement.clientHeight, y = -m + f, E = -p + v, S = w - m - C + f, _ = b - p - g + v, k = (L) => {
      let R = f + L.clientX - u, H = v + L.clientY - d;
      o != null && o.value || (R = Math.min(Math.max(R, y), S), H = Math.min(Math.max(H, E), _)), l = {
        offsetX: R,
        offsetY: H
      }, e.value && (e.value.style.transform = `translate(${po(R)}, ${po(H)})`);
    }, N = () => {
      document.removeEventListener("mousemove", k), document.removeEventListener("mouseup", N);
    };
    document.addEventListener("mousemove", k), document.addEventListener("mouseup", N);
  }, r = () => {
    t.value && e.value && t.value.addEventListener("mousedown", a);
  }, i = () => {
    t.value && e.value && t.value.removeEventListener("mousedown", a);
  };
  Nt(() => {
    ol(() => {
      n.value ? r() : i();
    });
  }), zn(() => {
    i();
  });
};
var ok = {
  name: "en",
  el: {
    breadcrumb: {
      label: "Breadcrumb"
    },
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color."
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      page: "Page",
      prev: "Go to previous page",
      next: "Go to next page",
      currentPage: "page {pager}",
      prevPages: "Previous {pager} pages",
      nextPages: "Next {pager} pages",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tour: {
      next: "Next",
      previous: "Previous",
      finish: "Finish"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    },
    carousel: {
      leftArrow: "Carousel arrow left",
      rightArrow: "Carousel arrow right",
      indicator: "Carousel switch to index {index}"
    }
  }
};
const gV = (e) => (t, n) => bV(t, n, c(e)), bV = (e, t, n) => bo(n, e, e).replace(/\{(\w+)\}/g, (o, l) => {
  var a;
  return `${(a = t == null ? void 0 : t[l]) != null ? a : `{${l}}`}`;
}), yV = (e) => {
  const t = x(() => c(e).name), n = fl(e) ? e : B(e);
  return {
    lang: t,
    locale: n,
    t: gV(e)
  };
}, lk = Symbol("localeContextKey"), bn = (e) => {
  const t = e || ot(lk, B());
  return yV(x(() => t.value || ok));
};
/**
* @vue/reactivity v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function ak(e, ...t) {
  console.warn(`[Vue warn] ${e}`, ...t);
}
let CV;
function wV(e, t = CV) {
  t && t.active && t.effects.push(e);
}
let Yu;
class EV {
  constructor(t, n, o, l) {
    this.fn = t, this.trigger = n, this.scheduler = o, this.active = !0, this.deps = [], this._dirtyLevel = 4, this._trackId = 0, this._runnings = 0, this._shouldSchedule = !1, this._depsLength = 0, wV(this, l);
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1, _V();
      for (let t = 0; t < this._depsLength; t++) {
        const n = this.deps[t];
        if (n.computed && (SV(n.computed), this._dirtyLevel >= 4))
          break;
      }
      this._dirtyLevel === 1 && (this._dirtyLevel = 0), xV();
    }
    return this._dirtyLevel >= 4;
  }
  set dirty(t) {
    this._dirtyLevel = t ? 4 : 0;
  }
  run() {
    if (this._dirtyLevel = 0, !this.active)
      return this.fn();
    let t = gi, n = Yu;
    try {
      return gi = !0, Yu = this, this._runnings++, QC(this), this.fn();
    } finally {
      ew(this), this._runnings--, Yu = n, gi = t;
    }
  }
  stop() {
    var t;
    this.active && (QC(this), ew(this), (t = this.onStop) == null || t.call(this), this.active = !1);
  }
}
function SV(e) {
  return e.value;
}
function QC(e) {
  e._trackId++, e._depsLength = 0;
}
function ew(e) {
  if (e.deps.length > e._depsLength) {
    for (let t = e._depsLength; t < e.deps.length; t++)
      rk(e.deps[t], e);
    e.deps.length = e._depsLength;
  }
}
function rk(e, t) {
  const n = e.get(t);
  n !== void 0 && t._trackId !== n && (e.delete(t), e.size === 0 && e.cleanup());
}
let gi = !0, cg = 0;
const sk = [];
function _V() {
  sk.push(gi), gi = !1;
}
function xV() {
  const e = sk.pop();
  gi = e === void 0 ? !0 : e;
}
function kV() {
  cg++;
}
function TV() {
  for (cg--; !cg && ug.length; )
    ug.shift()();
}
function $V(e, t, n) {
  var o;
  if (t.get(e) !== e._trackId) {
    t.set(e, e._trackId);
    const l = e.deps[e._depsLength];
    l !== t ? (l && rk(l, e), e.deps[e._depsLength++] = t) : e._depsLength++, process.env.NODE_ENV !== "production" && ((o = e.onTrack) == null || o.call(e, tx({ effect: e }, n)));
  }
}
const ug = [];
function OV(e, t, n) {
  var o;
  kV();
  for (const l of e.keys()) {
    let a;
    l._dirtyLevel < t && (a ?? (a = e.get(l) === l._trackId)) && (l._shouldSchedule || (l._shouldSchedule = l._dirtyLevel === 0), l._dirtyLevel = t), l._shouldSchedule && (a ?? (a = e.get(l) === l._trackId)) && (process.env.NODE_ENV !== "production" && ((o = l.onTrigger) == null || o.call(l, tx({ effect: l }, n))), l.trigger(), (!l._runnings || l.allowRecurse) && l._dirtyLevel !== 2 && (l._shouldSchedule = !1, l.scheduler && ug.push(l.scheduler)));
  }
  TV();
}
const NV = (e, t) => {
  const n = /* @__PURE__ */ new Map();
  return n.cleanup = e, n.computed = t, n;
};
Symbol(process.env.NODE_ENV !== "production" ? "iterate" : "");
Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(aD)
);
function Lv(e) {
  const t = e && e.__v_raw;
  return t ? Lv(t) : e;
}
const MV = "Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free";
class ik {
  constructor(t, n, o, l) {
    this.getter = t, this._setter = n, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this.effect = new EV(
      () => t(this._value),
      () => qh(
        this,
        this.effect._dirtyLevel === 2 ? 2 : 3
      )
    ), this.effect.computed = this, this.effect.active = this._cacheable = !l, this.__v_isReadonly = o;
  }
  get value() {
    const t = Lv(this);
    return (!t._cacheable || t.effect.dirty) && dD(t._value, t._value = t.effect.run()) && qh(t, 4), RV(t), t.effect._dirtyLevel >= 2 && (process.env.NODE_ENV !== "production" && this._warnRecursive && ak(MV, `

getter: `, this.getter), qh(t, 2)), t._value;
  }
  set value(t) {
    this._setter(t);
  }
  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
  get _dirty() {
    return this.effect.dirty;
  }
  set _dirty(t) {
    this.effect.dirty = t;
  }
  // #endregion
}
function IV(e, t, n = !1) {
  let o, l;
  const a = vn(e);
  a ? (o = e, l = process.env.NODE_ENV !== "production" ? () => {
    ak("Write operation failed: computed value is readonly");
  } : no) : (o = e.get, l = e.set);
  const r = new ik(o, l, a || !l, n);
  return process.env.NODE_ENV !== "production" && t && !n && (r.effect.onTrack = t.onTrack, r.effect.onTrigger = t.onTrigger), r;
}
function RV(e) {
  var t;
  gi && Yu && (e = Lv(e), $V(
    Yu,
    (t = e.dep) != null ? t : e.dep = NV(
      () => e.dep = void 0,
      e instanceof ik ? e : void 0
    ),
    process.env.NODE_ENV !== "production" ? {
      target: e,
      type: "get",
      key: "value"
    } : void 0
  ));
}
function qh(e, t = 4, n) {
  e = Lv(e);
  const o = e.dep;
  o && OV(
    o,
    t,
    process.env.NODE_ENV !== "production" ? {
      target: e,
      type: "set",
      key: "value",
      newValue: n
    } : void 0
  );
}
const Gu = "el", DV = "is-", Xs = (e, t, n, o, l) => {
  let a = `${e}-${t}`;
  return n && (a += `-${n}`), o && (a += `__${o}`), l && (a += `--${l}`), a;
}, ck = Symbol("namespaceContextKey"), gy = (e) => {
  const t = e || (Pt() ? ot(ck, B(Gu)) : B(Gu));
  return x(() => c(t) || Gu);
}, nt = (e, t) => {
  const n = gy(t);
  return {
    namespace: n,
    b: (p = "") => Xs(n.value, e, p, "", ""),
    e: (p) => p ? Xs(n.value, e, "", p, "") : "",
    m: (p) => p ? Xs(n.value, e, "", "", p) : "",
    be: (p, C) => p && C ? Xs(n.value, e, p, C, "") : "",
    em: (p, C) => p && C ? Xs(n.value, e, "", p, C) : "",
    bm: (p, C) => p && C ? Xs(n.value, e, p, "", C) : "",
    bem: (p, C, g) => p && C && g ? Xs(n.value, e, p, C, g) : "",
    is: (p, ...C) => {
      const g = C.length >= 1 ? C[0] : !0;
      return p && g ? `${DV}${p}` : "";
    },
    cssVar: (p) => {
      const C = {};
      for (const g in p)
        p[g] && (C[`--${n.value}-${g}`] = p[g]);
      return C;
    },
    cssVarName: (p) => `--${n.value}-${p}`,
    cssVarBlock: (p) => {
      const C = {};
      for (const g in p)
        p[g] && (C[`--${n.value}-${e}-${g}`] = p[g]);
      return C;
    },
    cssVarBlockName: (p) => `--${n.value}-${e}-${p}`
  };
}, by = (e, t = {}) => {
  fl(e) || lo("[useLockscreen]", "You need to pass a ref param to this function");
  const n = t.ns || nt("popup"), o = IV(() => n.bm("parent", "hidden"));
  if (!fn || ba(document.body, o.value))
    return;
  let l = 0, a = !1, r = "0";
  const i = () => {
    setTimeout(() => {
      vl(document == null ? void 0 : document.body, o.value), a && document && (document.body.style.width = r);
    }, 200);
  };
  Pe(e, (s) => {
    if (!s) {
      i();
      return;
    }
    a = !ba(document.body, o.value), a && (r = document.body.style.width), l = Ux(n.namespace.value);
    const u = document.documentElement.clientHeight < document.body.scrollHeight, d = ps(document.body, "overflowY");
    l > 0 && (u || d === "scroll") && a && (document.body.style.width = `calc(100% - ${l}px)`), ma(document.body, o.value);
  }), H2(() => i());
}, LV = Ha({
  type: Ae(Boolean),
  default: null
}), PV = Ha({
  type: Ae(Function)
}), uk = (e) => {
  const t = `update:${e}`, n = `onUpdate:${e}`, o = [t], l = {
    [e]: LV,
    [n]: PV
  };
  return {
    useModelToggle: ({
      indicator: r,
      toggleReason: i,
      shouldHideWhenRouteChanges: s,
      shouldProceed: u,
      onShow: d,
      onHide: f
    }) => {
      const v = Pt(), { emit: h } = v, m = v.props, p = x(() => vn(m[n])), C = x(() => m[e] === null), g = (_) => {
        r.value !== !0 && (r.value = !0, i && (i.value = _), vn(d) && d(_));
      }, w = (_) => {
        r.value !== !1 && (r.value = !1, i && (i.value = _), vn(f) && f(_));
      }, b = (_) => {
        if (m.disabled === !0 || vn(u) && !u())
          return;
        const k = p.value && fn;
        k && h(t, !0), (C.value || !k) && g(_);
      }, y = (_) => {
        if (m.disabled === !0 || !fn)
          return;
        const k = p.value && fn;
        k && h(t, !1), (C.value || !k) && w(_);
      }, E = (_) => {
        $o(_) && (m.disabled && _ ? p.value && h(t, !1) : r.value !== _ && (_ ? g() : w()));
      }, S = () => {
        r.value ? y() : b();
      };
      return Pe(() => m[e], E), s && v.appContext.config.globalProperties.$route !== void 0 && Pe(() => ({
        ...v.proxy.$route
      }), () => {
        s.value && r.value && y();
      }), Nt(() => {
        E(m[e]);
      }), {
        hide: y,
        show: b,
        toggle: S,
        hasUpdateHandler: p
      };
    },
    useModelToggleProps: l,
    useModelToggleEmits: o
  };
};
uk("modelValue");
const dk = (e) => {
  const t = Pt();
  return x(() => {
    var n, o;
    return (o = (n = t == null ? void 0 : t.proxy) == null ? void 0 : n.$props) == null ? void 0 : o[e];
  });
};
var Vl = "top", Ea = "bottom", Sa = "right", Bl = "left", yy = "auto", af = [Vl, Ea, Sa, Bl], Fc = "start", Md = "end", AV = "clippingParents", fk = "viewport", ku = "popper", FV = "reference", tw = af.reduce(function(e, t) {
  return e.concat([t + "-" + Fc, t + "-" + Md]);
}, []), Hi = [].concat(af, [yy]).reduce(function(e, t) {
  return e.concat([t, t + "-" + Fc, t + "-" + Md]);
}, []), VV = "beforeRead", BV = "read", HV = "afterRead", zV = "beforeMain", WV = "main", KV = "afterMain", UV = "beforeWrite", jV = "write", qV = "afterWrite", YV = [VV, BV, HV, zV, WV, KV, UV, jV, qV];
function ir(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function za(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function Vc(e) {
  var t = za(e).Element;
  return e instanceof t || e instanceof Element;
}
function ya(e) {
  var t = za(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function Cy(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = za(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function GV(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(n) {
    var o = t.styles[n] || {}, l = t.attributes[n] || {}, a = t.elements[n];
    !ya(a) || !ir(a) || (Object.assign(a.style, o), Object.keys(l).forEach(function(r) {
      var i = l[r];
      i === !1 ? a.removeAttribute(r) : a.setAttribute(r, i === !0 ? "" : i);
    }));
  });
}
function XV(e) {
  var t = e.state, n = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
  return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function() {
    Object.keys(t.elements).forEach(function(o) {
      var l = t.elements[o], a = t.attributes[o] || {}, r = Object.keys(t.styles.hasOwnProperty(o) ? t.styles[o] : n[o]), i = r.reduce(function(s, u) {
        return s[u] = "", s;
      }, {});
      !ya(l) || !ir(l) || (Object.assign(l.style, i), Object.keys(a).forEach(function(s) {
        l.removeAttribute(s);
      }));
    });
  };
}
var pk = { name: "applyStyles", enabled: !0, phase: "write", fn: GV, effect: XV, requires: ["computeStyles"] };
function or(e) {
  return e.split("-")[0];
}
var bi = Math.max, Yp = Math.min, Bc = Math.round;
function Hc(e, t) {
  t === void 0 && (t = !1);
  var n = e.getBoundingClientRect(), o = 1, l = 1;
  if (ya(e) && t) {
    var a = e.offsetHeight, r = e.offsetWidth;
    r > 0 && (o = Bc(n.width) / r || 1), a > 0 && (l = Bc(n.height) / a || 1);
  }
  return { width: n.width / o, height: n.height / l, top: n.top / l, right: n.right / o, bottom: n.bottom / l, left: n.left / o, x: n.left / o, y: n.top / l };
}
function wy(e) {
  var t = Hc(e), n = e.offsetWidth, o = e.offsetHeight;
  return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - o) <= 1 && (o = t.height), { x: e.offsetLeft, y: e.offsetTop, width: n, height: o };
}
function vk(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && Cy(n)) {
    var o = t;
    do {
      if (o && e.isSameNode(o))
        return !0;
      o = o.parentNode || o.host;
    } while (o);
  }
  return !1;
}
function Dr(e) {
  return za(e).getComputedStyle(e);
}
function ZV(e) {
  return ["table", "td", "th"].indexOf(ir(e)) >= 0;
}
function As(e) {
  return ((Vc(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function Pv(e) {
  return ir(e) === "html" ? e : e.assignedSlot || e.parentNode || (Cy(e) ? e.host : null) || As(e);
}
function nw(e) {
  return !ya(e) || Dr(e).position === "fixed" ? null : e.offsetParent;
}
function JV(e) {
  var t = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
  if (n && ya(e)) {
    var o = Dr(e);
    if (o.position === "fixed")
      return null;
  }
  var l = Pv(e);
  for (Cy(l) && (l = l.host); ya(l) && ["html", "body"].indexOf(ir(l)) < 0; ) {
    var a = Dr(l);
    if (a.transform !== "none" || a.perspective !== "none" || a.contain === "paint" || ["transform", "perspective"].indexOf(a.willChange) !== -1 || t && a.willChange === "filter" || t && a.filter && a.filter !== "none")
      return l;
    l = l.parentNode;
  }
  return null;
}
function rf(e) {
  for (var t = za(e), n = nw(e); n && ZV(n) && Dr(n).position === "static"; )
    n = nw(n);
  return n && (ir(n) === "html" || ir(n) === "body" && Dr(n).position === "static") ? t : n || JV(e) || t;
}
function Ey(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function Xu(e, t, n) {
  return bi(e, Yp(t, n));
}
function QV(e, t, n) {
  var o = Xu(e, t, n);
  return o > n ? n : o;
}
function hk() {
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function mk(e) {
  return Object.assign({}, hk(), e);
}
function gk(e, t) {
  return t.reduce(function(n, o) {
    return n[o] = e, n;
  }, {});
}
var e6 = function(e, t) {
  return e = typeof e == "function" ? e(Object.assign({}, t.rects, { placement: t.placement })) : e, mk(typeof e != "number" ? e : gk(e, af));
};
function t6(e) {
  var t, n = e.state, o = e.name, l = e.options, a = n.elements.arrow, r = n.modifiersData.popperOffsets, i = or(n.placement), s = Ey(i), u = [Bl, Sa].indexOf(i) >= 0, d = u ? "height" : "width";
  if (!(!a || !r)) {
    var f = e6(l.padding, n), v = wy(a), h = s === "y" ? Vl : Bl, m = s === "y" ? Ea : Sa, p = n.rects.reference[d] + n.rects.reference[s] - r[s] - n.rects.popper[d], C = r[s] - n.rects.reference[s], g = rf(a), w = g ? s === "y" ? g.clientHeight || 0 : g.clientWidth || 0 : 0, b = p / 2 - C / 2, y = f[h], E = w - v[d] - f[m], S = w / 2 - v[d] / 2 + b, _ = Xu(y, S, E), k = s;
    n.modifiersData[o] = (t = {}, t[k] = _, t.centerOffset = _ - S, t);
  }
}
function n6(e) {
  var t = e.state, n = e.options, o = n.element, l = o === void 0 ? "[data-popper-arrow]" : o;
  l != null && (typeof l == "string" && (l = t.elements.popper.querySelector(l), !l) || !vk(t.elements.popper, l) || (t.elements.arrow = l));
}
var o6 = { name: "arrow", enabled: !0, phase: "main", fn: t6, effect: n6, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
function zc(e) {
  return e.split("-")[1];
}
var l6 = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function a6(e) {
  var t = e.x, n = e.y, o = window, l = o.devicePixelRatio || 1;
  return { x: Bc(t * l) / l || 0, y: Bc(n * l) / l || 0 };
}
function ow(e) {
  var t, n = e.popper, o = e.popperRect, l = e.placement, a = e.variation, r = e.offsets, i = e.position, s = e.gpuAcceleration, u = e.adaptive, d = e.roundOffsets, f = e.isFixed, v = r.x, h = v === void 0 ? 0 : v, m = r.y, p = m === void 0 ? 0 : m, C = typeof d == "function" ? d({ x: h, y: p }) : { x: h, y: p };
  h = C.x, p = C.y;
  var g = r.hasOwnProperty("x"), w = r.hasOwnProperty("y"), b = Bl, y = Vl, E = window;
  if (u) {
    var S = rf(n), _ = "clientHeight", k = "clientWidth";
    if (S === za(n) && (S = As(n), Dr(S).position !== "static" && i === "absolute" && (_ = "scrollHeight", k = "scrollWidth")), S = S, l === Vl || (l === Bl || l === Sa) && a === Md) {
      y = Ea;
      var N = f && S === E && E.visualViewport ? E.visualViewport.height : S[_];
      p -= N - o.height, p *= s ? 1 : -1;
    }
    if (l === Bl || (l === Vl || l === Ea) && a === Md) {
      b = Sa;
      var L = f && S === E && E.visualViewport ? E.visualViewport.width : S[k];
      h -= L - o.width, h *= s ? 1 : -1;
    }
  }
  var R = Object.assign({ position: i }, u && l6), H = d === !0 ? a6({ x: h, y: p }) : { x: h, y: p };
  if (h = H.x, p = H.y, s) {
    var K;
    return Object.assign({}, R, (K = {}, K[y] = w ? "0" : "", K[b] = g ? "0" : "", K.transform = (E.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + p + "px)" : "translate3d(" + h + "px, " + p + "px, 0)", K));
  }
  return Object.assign({}, R, (t = {}, t[y] = w ? p + "px" : "", t[b] = g ? h + "px" : "", t.transform = "", t));
}
function r6(e) {
  var t = e.state, n = e.options, o = n.gpuAcceleration, l = o === void 0 ? !0 : o, a = n.adaptive, r = a === void 0 ? !0 : a, i = n.roundOffsets, s = i === void 0 ? !0 : i, u = { placement: or(t.placement), variation: zc(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: l, isFixed: t.options.strategy === "fixed" };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, ow(Object.assign({}, u, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: r, roundOffsets: s })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, ow(Object.assign({}, u, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: s })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-placement": t.placement });
}
var bk = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: r6, data: {} }, Hf = { passive: !0 };
function s6(e) {
  var t = e.state, n = e.instance, o = e.options, l = o.scroll, a = l === void 0 ? !0 : l, r = o.resize, i = r === void 0 ? !0 : r, s = za(t.elements.popper), u = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return a && u.forEach(function(d) {
    d.addEventListener("scroll", n.update, Hf);
  }), i && s.addEventListener("resize", n.update, Hf), function() {
    a && u.forEach(function(d) {
      d.removeEventListener("scroll", n.update, Hf);
    }), i && s.removeEventListener("resize", n.update, Hf);
  };
}
var yk = { name: "eventListeners", enabled: !0, phase: "write", fn: function() {
}, effect: s6, data: {} }, i6 = { left: "right", right: "left", bottom: "top", top: "bottom" };
function mp(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return i6[t];
  });
}
var c6 = { start: "end", end: "start" };
function lw(e) {
  return e.replace(/start|end/g, function(t) {
    return c6[t];
  });
}
function Sy(e) {
  var t = za(e), n = t.pageXOffset, o = t.pageYOffset;
  return { scrollLeft: n, scrollTop: o };
}
function _y(e) {
  return Hc(As(e)).left + Sy(e).scrollLeft;
}
function u6(e) {
  var t = za(e), n = As(e), o = t.visualViewport, l = n.clientWidth, a = n.clientHeight, r = 0, i = 0;
  return o && (l = o.width, a = o.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (r = o.offsetLeft, i = o.offsetTop)), { width: l, height: a, x: r + _y(e), y: i };
}
function d6(e) {
  var t, n = As(e), o = Sy(e), l = (t = e.ownerDocument) == null ? void 0 : t.body, a = bi(n.scrollWidth, n.clientWidth, l ? l.scrollWidth : 0, l ? l.clientWidth : 0), r = bi(n.scrollHeight, n.clientHeight, l ? l.scrollHeight : 0, l ? l.clientHeight : 0), i = -o.scrollLeft + _y(e), s = -o.scrollTop;
  return Dr(l || n).direction === "rtl" && (i += bi(n.clientWidth, l ? l.clientWidth : 0) - a), { width: a, height: r, x: i, y: s };
}
function xy(e) {
  var t = Dr(e), n = t.overflow, o = t.overflowX, l = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + l + o);
}
function Ck(e) {
  return ["html", "body", "#document"].indexOf(ir(e)) >= 0 ? e.ownerDocument.body : ya(e) && xy(e) ? e : Ck(Pv(e));
}
function Zu(e, t) {
  var n;
  t === void 0 && (t = []);
  var o = Ck(e), l = o === ((n = e.ownerDocument) == null ? void 0 : n.body), a = za(o), r = l ? [a].concat(a.visualViewport || [], xy(o) ? o : []) : o, i = t.concat(r);
  return l ? i : i.concat(Zu(Pv(r)));
}
function dg(e) {
  return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height });
}
function f6(e) {
  var t = Hc(e);
  return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t;
}
function aw(e, t) {
  return t === fk ? dg(u6(e)) : Vc(t) ? f6(t) : dg(d6(As(e)));
}
function p6(e) {
  var t = Zu(Pv(e)), n = ["absolute", "fixed"].indexOf(Dr(e).position) >= 0, o = n && ya(e) ? rf(e) : e;
  return Vc(o) ? t.filter(function(l) {
    return Vc(l) && vk(l, o) && ir(l) !== "body";
  }) : [];
}
function v6(e, t, n) {
  var o = t === "clippingParents" ? p6(e) : [].concat(t), l = [].concat(o, [n]), a = l[0], r = l.reduce(function(i, s) {
    var u = aw(e, s);
    return i.top = bi(u.top, i.top), i.right = Yp(u.right, i.right), i.bottom = Yp(u.bottom, i.bottom), i.left = bi(u.left, i.left), i;
  }, aw(e, a));
  return r.width = r.right - r.left, r.height = r.bottom - r.top, r.x = r.left, r.y = r.top, r;
}
function wk(e) {
  var t = e.reference, n = e.element, o = e.placement, l = o ? or(o) : null, a = o ? zc(o) : null, r = t.x + t.width / 2 - n.width / 2, i = t.y + t.height / 2 - n.height / 2, s;
  switch (l) {
    case Vl:
      s = { x: r, y: t.y - n.height };
      break;
    case Ea:
      s = { x: r, y: t.y + t.height };
      break;
    case Sa:
      s = { x: t.x + t.width, y: i };
      break;
    case Bl:
      s = { x: t.x - n.width, y: i };
      break;
    default:
      s = { x: t.x, y: t.y };
  }
  var u = l ? Ey(l) : null;
  if (u != null) {
    var d = u === "y" ? "height" : "width";
    switch (a) {
      case Fc:
        s[u] = s[u] - (t[d] / 2 - n[d] / 2);
        break;
      case Md:
        s[u] = s[u] + (t[d] / 2 - n[d] / 2);
        break;
    }
  }
  return s;
}
function Id(e, t) {
  t === void 0 && (t = {});
  var n = t, o = n.placement, l = o === void 0 ? e.placement : o, a = n.boundary, r = a === void 0 ? AV : a, i = n.rootBoundary, s = i === void 0 ? fk : i, u = n.elementContext, d = u === void 0 ? ku : u, f = n.altBoundary, v = f === void 0 ? !1 : f, h = n.padding, m = h === void 0 ? 0 : h, p = mk(typeof m != "number" ? m : gk(m, af)), C = d === ku ? FV : ku, g = e.rects.popper, w = e.elements[v ? C : d], b = v6(Vc(w) ? w : w.contextElement || As(e.elements.popper), r, s), y = Hc(e.elements.reference), E = wk({ reference: y, element: g, strategy: "absolute", placement: l }), S = dg(Object.assign({}, g, E)), _ = d === ku ? S : y, k = { top: b.top - _.top + p.top, bottom: _.bottom - b.bottom + p.bottom, left: b.left - _.left + p.left, right: _.right - b.right + p.right }, N = e.modifiersData.offset;
  if (d === ku && N) {
    var L = N[l];
    Object.keys(k).forEach(function(R) {
      var H = [Sa, Ea].indexOf(R) >= 0 ? 1 : -1, K = [Vl, Ea].indexOf(R) >= 0 ? "y" : "x";
      k[R] += L[K] * H;
    });
  }
  return k;
}
function h6(e, t) {
  t === void 0 && (t = {});
  var n = t, o = n.placement, l = n.boundary, a = n.rootBoundary, r = n.padding, i = n.flipVariations, s = n.allowedAutoPlacements, u = s === void 0 ? Hi : s, d = zc(o), f = d ? i ? tw : tw.filter(function(m) {
    return zc(m) === d;
  }) : af, v = f.filter(function(m) {
    return u.indexOf(m) >= 0;
  });
  v.length === 0 && (v = f);
  var h = v.reduce(function(m, p) {
    return m[p] = Id(e, { placement: p, boundary: l, rootBoundary: a, padding: r })[or(p)], m;
  }, {});
  return Object.keys(h).sort(function(m, p) {
    return h[m] - h[p];
  });
}
function m6(e) {
  if (or(e) === yy)
    return [];
  var t = mp(e);
  return [lw(e), t, lw(t)];
}
function g6(e) {
  var t = e.state, n = e.options, o = e.name;
  if (!t.modifiersData[o]._skip) {
    for (var l = n.mainAxis, a = l === void 0 ? !0 : l, r = n.altAxis, i = r === void 0 ? !0 : r, s = n.fallbackPlacements, u = n.padding, d = n.boundary, f = n.rootBoundary, v = n.altBoundary, h = n.flipVariations, m = h === void 0 ? !0 : h, p = n.allowedAutoPlacements, C = t.options.placement, g = or(C), w = g === C, b = s || (w || !m ? [mp(C)] : m6(C)), y = [C].concat(b).reduce(function(de, Oe) {
      return de.concat(or(Oe) === yy ? h6(t, { placement: Oe, boundary: d, rootBoundary: f, padding: u, flipVariations: m, allowedAutoPlacements: p }) : Oe);
    }, []), E = t.rects.reference, S = t.rects.popper, _ = /* @__PURE__ */ new Map(), k = !0, N = y[0], L = 0; L < y.length; L++) {
      var R = y[L], H = or(R), K = zc(R) === Fc, U = [Vl, Ea].indexOf(H) >= 0, W = U ? "width" : "height", A = Id(t, { placement: R, boundary: d, rootBoundary: f, altBoundary: v, padding: u }), $ = U ? K ? Sa : Bl : K ? Ea : Vl;
      E[W] > S[W] && ($ = mp($));
      var D = mp($), O = [];
      if (a && O.push(A[H] <= 0), i && O.push(A[$] <= 0, A[D] <= 0), O.every(function(de) {
        return de;
      })) {
        N = R, k = !1;
        break;
      }
      _.set(R, O);
    }
    if (k)
      for (var F = m ? 3 : 1, j = function(de) {
        var Oe = y.find(function(ce) {
          var ne = _.get(ce);
          if (ne)
            return ne.slice(0, de).every(function(Y) {
              return Y;
            });
        });
        if (Oe)
          return N = Oe, "break";
      }, Z = F; Z > 0; Z--) {
        var te = j(Z);
        if (te === "break")
          break;
      }
    t.placement !== N && (t.modifiersData[o]._skip = !0, t.placement = N, t.reset = !0);
  }
}
var b6 = { name: "flip", enabled: !0, phase: "main", fn: g6, requiresIfExists: ["offset"], data: { _skip: !1 } };
function rw(e, t, n) {
  return n === void 0 && (n = { x: 0, y: 0 }), { top: e.top - t.height - n.y, right: e.right - t.width + n.x, bottom: e.bottom - t.height + n.y, left: e.left - t.width - n.x };
}
function sw(e) {
  return [Vl, Sa, Ea, Bl].some(function(t) {
    return e[t] >= 0;
  });
}
function y6(e) {
  var t = e.state, n = e.name, o = t.rects.reference, l = t.rects.popper, a = t.modifiersData.preventOverflow, r = Id(t, { elementContext: "reference" }), i = Id(t, { altBoundary: !0 }), s = rw(r, o), u = rw(i, l, a), d = sw(s), f = sw(u);
  t.modifiersData[n] = { referenceClippingOffsets: s, popperEscapeOffsets: u, isReferenceHidden: d, hasPopperEscaped: f }, t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-reference-hidden": d, "data-popper-escaped": f });
}
var C6 = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: y6 };
function w6(e, t, n) {
  var o = or(e), l = [Bl, Vl].indexOf(o) >= 0 ? -1 : 1, a = typeof n == "function" ? n(Object.assign({}, t, { placement: e })) : n, r = a[0], i = a[1];
  return r = r || 0, i = (i || 0) * l, [Bl, Sa].indexOf(o) >= 0 ? { x: i, y: r } : { x: r, y: i };
}
function E6(e) {
  var t = e.state, n = e.options, o = e.name, l = n.offset, a = l === void 0 ? [0, 0] : l, r = Hi.reduce(function(d, f) {
    return d[f] = w6(f, t.rects, a), d;
  }, {}), i = r[t.placement], s = i.x, u = i.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += s, t.modifiersData.popperOffsets.y += u), t.modifiersData[o] = r;
}
var S6 = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: E6 };
function _6(e) {
  var t = e.state, n = e.name;
  t.modifiersData[n] = wk({ reference: t.rects.reference, element: t.rects.popper, strategy: "absolute", placement: t.placement });
}
var Ek = { name: "popperOffsets", enabled: !0, phase: "read", fn: _6, data: {} };
function x6(e) {
  return e === "x" ? "y" : "x";
}
function k6(e) {
  var t = e.state, n = e.options, o = e.name, l = n.mainAxis, a = l === void 0 ? !0 : l, r = n.altAxis, i = r === void 0 ? !1 : r, s = n.boundary, u = n.rootBoundary, d = n.altBoundary, f = n.padding, v = n.tether, h = v === void 0 ? !0 : v, m = n.tetherOffset, p = m === void 0 ? 0 : m, C = Id(t, { boundary: s, rootBoundary: u, padding: f, altBoundary: d }), g = or(t.placement), w = zc(t.placement), b = !w, y = Ey(g), E = x6(y), S = t.modifiersData.popperOffsets, _ = t.rects.reference, k = t.rects.popper, N = typeof p == "function" ? p(Object.assign({}, t.rects, { placement: t.placement })) : p, L = typeof N == "number" ? { mainAxis: N, altAxis: N } : Object.assign({ mainAxis: 0, altAxis: 0 }, N), R = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, H = { x: 0, y: 0 };
  if (S) {
    if (a) {
      var K, U = y === "y" ? Vl : Bl, W = y === "y" ? Ea : Sa, A = y === "y" ? "height" : "width", $ = S[y], D = $ + C[U], O = $ - C[W], F = h ? -k[A] / 2 : 0, j = w === Fc ? _[A] : k[A], Z = w === Fc ? -k[A] : -_[A], te = t.elements.arrow, de = h && te ? wy(te) : { width: 0, height: 0 }, Oe = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : hk(), ce = Oe[U], ne = Oe[W], Y = Xu(0, _[A], de[A]), ve = b ? _[A] / 2 - F - Y - ce - L.mainAxis : j - Y - ce - L.mainAxis, ie = b ? -_[A] / 2 + F + Y + ne + L.mainAxis : Z + Y + ne + L.mainAxis, he = t.elements.arrow && rf(t.elements.arrow), De = he ? y === "y" ? he.clientTop || 0 : he.clientLeft || 0 : 0, $e = (K = R == null ? void 0 : R[y]) != null ? K : 0, ue = $ + ve - $e - De, Ne = $ + ie - $e, je = Xu(h ? Yp(D, ue) : D, $, h ? bi(O, Ne) : O);
      S[y] = je, H[y] = je - $;
    }
    if (i) {
      var Fe, Ve = y === "x" ? Vl : Bl, Ze = y === "x" ? Ea : Sa, ae = S[E], pe = E === "y" ? "height" : "width", ke = ae + C[Ve], Ue = ae - C[Ze], Xe = [Vl, Bl].indexOf(g) !== -1, re = (Fe = R == null ? void 0 : R[E]) != null ? Fe : 0, Te = Xe ? ke : ae - _[pe] - k[pe] - re + L.altAxis, Ce = Xe ? ae + _[pe] + k[pe] - re - L.altAxis : Ue, Le = h && Xe ? QV(Te, ae, Ce) : Xu(h ? Te : ke, ae, h ? Ce : Ue);
      S[E] = Le, H[E] = Le - ae;
    }
    t.modifiersData[o] = H;
  }
}
var T6 = { name: "preventOverflow", enabled: !0, phase: "main", fn: k6, requiresIfExists: ["offset"] };
function $6(e) {
  return { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop };
}
function O6(e) {
  return e === za(e) || !ya(e) ? Sy(e) : $6(e);
}
function N6(e) {
  var t = e.getBoundingClientRect(), n = Bc(t.width) / e.offsetWidth || 1, o = Bc(t.height) / e.offsetHeight || 1;
  return n !== 1 || o !== 1;
}
function M6(e, t, n) {
  n === void 0 && (n = !1);
  var o = ya(t), l = ya(t) && N6(t), a = As(t), r = Hc(e, l), i = { scrollLeft: 0, scrollTop: 0 }, s = { x: 0, y: 0 };
  return (o || !o && !n) && ((ir(t) !== "body" || xy(a)) && (i = O6(t)), ya(t) ? (s = Hc(t, !0), s.x += t.clientLeft, s.y += t.clientTop) : a && (s.x = _y(a))), { x: r.left + i.scrollLeft - s.x, y: r.top + i.scrollTop - s.y, width: r.width, height: r.height };
}
function I6(e) {
  var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), o = [];
  e.forEach(function(a) {
    t.set(a.name, a);
  });
  function l(a) {
    n.add(a.name);
    var r = [].concat(a.requires || [], a.requiresIfExists || []);
    r.forEach(function(i) {
      if (!n.has(i)) {
        var s = t.get(i);
        s && l(s);
      }
    }), o.push(a);
  }
  return e.forEach(function(a) {
    n.has(a.name) || l(a);
  }), o;
}
function R6(e) {
  var t = I6(e);
  return YV.reduce(function(n, o) {
    return n.concat(t.filter(function(l) {
      return l.phase === o;
    }));
  }, []);
}
function D6(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(n) {
      Promise.resolve().then(function() {
        t = void 0, n(e());
      });
    })), t;
  };
}
function L6(e) {
  var t = e.reduce(function(n, o) {
    var l = n[o.name];
    return n[o.name] = l ? Object.assign({}, l, o, { options: Object.assign({}, l.options, o.options), data: Object.assign({}, l.data, o.data) }) : o, n;
  }, {});
  return Object.keys(t).map(function(n) {
    return t[n];
  });
}
var iw = { placement: "bottom", modifiers: [], strategy: "absolute" };
function cw() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return !t.some(function(o) {
    return !(o && typeof o.getBoundingClientRect == "function");
  });
}
function ky(e) {
  e === void 0 && (e = {});
  var t = e, n = t.defaultModifiers, o = n === void 0 ? [] : n, l = t.defaultOptions, a = l === void 0 ? iw : l;
  return function(r, i, s) {
    s === void 0 && (s = a);
    var u = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, iw, a), modifiersData: {}, elements: { reference: r, popper: i }, attributes: {}, styles: {} }, d = [], f = !1, v = { state: u, setOptions: function(p) {
      var C = typeof p == "function" ? p(u.options) : p;
      m(), u.options = Object.assign({}, a, u.options, C), u.scrollParents = { reference: Vc(r) ? Zu(r) : r.contextElement ? Zu(r.contextElement) : [], popper: Zu(i) };
      var g = R6(L6([].concat(o, u.options.modifiers)));
      return u.orderedModifiers = g.filter(function(w) {
        return w.enabled;
      }), h(), v.update();
    }, forceUpdate: function() {
      if (!f) {
        var p = u.elements, C = p.reference, g = p.popper;
        if (cw(C, g)) {
          u.rects = { reference: M6(C, rf(g), u.options.strategy === "fixed"), popper: wy(g) }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(k) {
            return u.modifiersData[k.name] = Object.assign({}, k.data);
          });
          for (var w = 0; w < u.orderedModifiers.length; w++) {
            if (u.reset === !0) {
              u.reset = !1, w = -1;
              continue;
            }
            var b = u.orderedModifiers[w], y = b.fn, E = b.options, S = E === void 0 ? {} : E, _ = b.name;
            typeof y == "function" && (u = y({ state: u, options: S, name: _, instance: v }) || u);
          }
        }
      }
    }, update: D6(function() {
      return new Promise(function(p) {
        v.forceUpdate(), p(u);
      });
    }), destroy: function() {
      m(), f = !0;
    } };
    if (!cw(r, i))
      return v;
    v.setOptions(s).then(function(p) {
      !f && s.onFirstUpdate && s.onFirstUpdate(p);
    });
    function h() {
      u.orderedModifiers.forEach(function(p) {
        var C = p.name, g = p.options, w = g === void 0 ? {} : g, b = p.effect;
        if (typeof b == "function") {
          var y = b({ state: u, name: C, instance: v, options: w }), E = function() {
          };
          d.push(y || E);
        }
      });
    }
    function m() {
      d.forEach(function(p) {
        return p();
      }), d = [];
    }
    return v;
  };
}
ky();
var P6 = [yk, Ek, bk, pk];
ky({ defaultModifiers: P6 });
var A6 = [yk, Ek, bk, pk, S6, b6, T6, o6, C6], F6 = ky({ defaultModifiers: A6 });
const V6 = (e, t, n = {}) => {
  const o = {
    name: "updateState",
    enabled: !0,
    phase: "write",
    fn: ({ state: s }) => {
      const u = B6(s);
      Object.assign(r.value, u);
    },
    requires: ["computeStyles"]
  }, l = x(() => {
    const { onFirstUpdate: s, placement: u, strategy: d, modifiers: f } = c(n);
    return {
      onFirstUpdate: s,
      placement: u || "bottom",
      strategy: d || "absolute",
      modifiers: [
        ...f || [],
        o,
        { name: "applyStyles", enabled: !1 }
      ]
    };
  }), a = An(), r = B({
    styles: {
      popper: {
        position: c(l).strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), i = () => {
    a.value && (a.value.destroy(), a.value = void 0);
  };
  return Pe(l, (s) => {
    const u = c(a);
    u && u.setOptions(s);
  }, {
    deep: !0
  }), Pe([e, t], ([s, u]) => {
    i(), !(!s || !u) && (a.value = F6(s, u, c(l)));
  }), zn(() => {
    i();
  }), {
    state: x(() => {
      var s;
      return { ...((s = c(a)) == null ? void 0 : s.state) || {} };
    }),
    styles: x(() => c(r).styles),
    attributes: x(() => c(r).attributes),
    update: () => {
      var s;
      return (s = c(a)) == null ? void 0 : s.update();
    },
    forceUpdate: () => {
      var s;
      return (s = c(a)) == null ? void 0 : s.forceUpdate();
    },
    instanceRef: x(() => c(a))
  };
};
function B6(e) {
  const t = Object.keys(e.elements), n = qp(t.map((l) => [l, e.styles[l] || {}])), o = qp(t.map((l) => [l, e.attributes[l]]));
  return {
    styles: n,
    attributes: o
  };
}
const Ty = (e) => {
  if (!e)
    return { onClick: no, onMousedown: no, onMouseup: no };
  let t = !1, n = !1;
  return { onClick: (r) => {
    t && n && e(r), t = n = !1;
  }, onMousedown: (r) => {
    t = r.target === r.currentTarget;
  }, onMouseup: (r) => {
    n = r.target === r.currentTarget;
  } };
}, H6 = (e, t = 0) => {
  if (t === 0)
    return e;
  const n = B(!1);
  let o = 0;
  const l = () => {
    o && clearTimeout(o), o = window.setTimeout(() => {
      n.value = e.value;
    }, t);
  };
  return Nt(l), Pe(() => e.value, (a) => {
    a ? l() : n.value = a;
  }), n;
};
function uw() {
  let e;
  const t = (o, l) => {
    n(), e = window.setTimeout(o, l);
  }, n = () => window.clearTimeout(e);
  return Qd(() => n()), {
    registerTimeout: t,
    cancelTimeout: n
  };
}
const fg = {
  prefix: Math.floor(Math.random() * 1e4),
  current: 0
}, z6 = Symbol("elIdInjection"), $y = () => Pt() ? ot(z6, fg) : fg, il = (e) => {
  const t = $y();
  !fn && t === fg && dn("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
  const n = gy();
  return x(() => c(e) || `${n.value}-id-${t.prefix}-${t.current++}`);
};
let dc = [];
const dw = (e) => {
  const t = e;
  t.key === xt.esc && dc.forEach((n) => n(t));
}, W6 = (e) => {
  Nt(() => {
    dc.length === 0 && document.addEventListener("keydown", dw), fn && dc.push(e);
  }), zn(() => {
    dc = dc.filter((t) => t !== e), dc.length === 0 && fn && document.removeEventListener("keydown", dw);
  });
};
let fw;
const Sk = () => {
  const e = gy(), t = $y(), n = x(() => `${e.value}-popper-container-${t.prefix}`), o = x(() => `#${n.value}`);
  return {
    id: n,
    selector: o
  };
}, K6 = (e) => {
  const t = document.createElement("div");
  return t.id = e, document.body.appendChild(t), t;
}, U6 = () => {
  const { id: e, selector: t } = Sk();
  return Sv(() => {
    fn && (process.env.NODE_ENV === "test" || !fw && !document.body.querySelector(t.value)) && (fw = K6(e.value));
  }), {
    id: e,
    selector: t
  };
}, j6 = it({
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  }
}), q6 = ({
  showAfter: e,
  hideAfter: t,
  autoClose: n,
  open: o,
  close: l
}) => {
  const { registerTimeout: a } = uw(), {
    registerTimeout: r,
    cancelTimeout: i
  } = uw();
  return {
    onOpen: (d) => {
      a(() => {
        o(d);
        const f = c(n);
        Ot(f) && f > 0 && r(() => {
          l(d);
        }, f);
      }, c(e));
    },
    onClose: (d) => {
      i(), a(() => {
        l(d);
      }, c(t));
    }
  };
}, _k = Symbol("elForwardRef"), Y6 = (e) => {
  Mt(_k, {
    setForwardRef: (n) => {
      e.value = n;
    }
  });
}, G6 = (e) => ({
  mounted(t) {
    e(t);
  },
  updated(t) {
    e(t);
  },
  unmounted() {
    e(null);
  }
}), pw = {
  current: 0
}, vw = B(0), xk = 2e3, hw = Symbol("elZIndexContextKey"), kk = Symbol("zIndexContextKey"), au = (e) => {
  const t = Pt() ? ot(hw, pw) : pw, n = e || (Pt() ? ot(kk, void 0) : void 0), o = x(() => {
    const r = c(n);
    return Ot(r) ? r : xk;
  }), l = x(() => o.value + vw.value), a = () => (t.current++, vw.value = t.current, l.value);
  return !fn && !ot(hw) && dn("ZIndexInjection", `Looks like you are using server rendering, you must provide a z-index provider to ensure the hydration process to be succeed
usage: app.provide(ZINDEX_INJECTION_KEY, { current: 0 })`), {
    initialZIndex: o,
    currentZIndex: l,
    nextZIndex: a
  };
}, Wc = Math.min, yi = Math.max, Gp = Math.round, zf = Math.floor, $s = (e) => ({
  x: e,
  y: e
}), X6 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Z6 = {
  start: "end",
  end: "start"
};
function pg(e, t, n) {
  return yi(e, Wc(t, n));
}
function sf(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Ni(e) {
  return e.split("-")[0];
}
function cf(e) {
  return e.split("-")[1];
}
function Tk(e) {
  return e === "x" ? "y" : "x";
}
function Oy(e) {
  return e === "y" ? "height" : "width";
}
function Av(e) {
  return ["top", "bottom"].includes(Ni(e)) ? "y" : "x";
}
function Ny(e) {
  return Tk(Av(e));
}
function J6(e, t, n) {
  n === void 0 && (n = !1);
  const o = cf(e), l = Ny(e), a = Oy(l);
  let r = l === "x" ? o === (n ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top";
  return t.reference[a] > t.floating[a] && (r = Xp(r)), [r, Xp(r)];
}
function Q6(e) {
  const t = Xp(e);
  return [vg(e), t, vg(t)];
}
function vg(e) {
  return e.replace(/start|end/g, (t) => Z6[t]);
}
function e5(e, t, n) {
  const o = ["left", "right"], l = ["right", "left"], a = ["top", "bottom"], r = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? l : o : t ? o : l;
    case "left":
    case "right":
      return t ? a : r;
    default:
      return [];
  }
}
function t5(e, t, n, o) {
  const l = cf(e);
  let a = e5(Ni(e), n === "start", o);
  return l && (a = a.map((r) => r + "-" + l), t && (a = a.concat(a.map(vg)))), a;
}
function Xp(e) {
  return e.replace(/left|right|bottom|top/g, (t) => X6[t]);
}
function n5(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function $k(e) {
  return typeof e != "number" ? n5(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Zp(e) {
  return {
    ...e,
    top: e.y,
    left: e.x,
    right: e.x + e.width,
    bottom: e.y + e.height
  };
}
function mw(e, t, n) {
  let {
    reference: o,
    floating: l
  } = e;
  const a = Av(t), r = Ny(t), i = Oy(r), s = Ni(t), u = a === "y", d = o.x + o.width / 2 - l.width / 2, f = o.y + o.height / 2 - l.height / 2, v = o[i] / 2 - l[i] / 2;
  let h;
  switch (s) {
    case "top":
      h = {
        x: d,
        y: o.y - l.height
      };
      break;
    case "bottom":
      h = {
        x: d,
        y: o.y + o.height
      };
      break;
    case "right":
      h = {
        x: o.x + o.width,
        y: f
      };
      break;
    case "left":
      h = {
        x: o.x - l.width,
        y: f
      };
      break;
    default:
      h = {
        x: o.x,
        y: o.y
      };
  }
  switch (cf(t)) {
    case "start":
      h[r] -= v * (n && u ? -1 : 1);
      break;
    case "end":
      h[r] += v * (n && u ? -1 : 1);
      break;
  }
  return h;
}
const o5 = async (e, t, n) => {
  const {
    placement: o = "bottom",
    strategy: l = "absolute",
    middleware: a = [],
    platform: r
  } = n, i = a.filter(Boolean), s = await (r.isRTL == null ? void 0 : r.isRTL(t));
  let u = await r.getElementRects({
    reference: e,
    floating: t,
    strategy: l
  }), {
    x: d,
    y: f
  } = mw(u, o, s), v = o, h = {}, m = 0;
  for (let p = 0; p < i.length; p++) {
    const {
      name: C,
      fn: g
    } = i[p], {
      x: w,
      y: b,
      data: y,
      reset: E
    } = await g({
      x: d,
      y: f,
      initialPlacement: o,
      placement: v,
      strategy: l,
      middlewareData: h,
      rects: u,
      platform: r,
      elements: {
        reference: e,
        floating: t
      }
    });
    d = w ?? d, f = b ?? f, h = {
      ...h,
      [C]: {
        ...h[C],
        ...y
      }
    }, E && m <= 50 && (m++, typeof E == "object" && (E.placement && (v = E.placement), E.rects && (u = E.rects === !0 ? await r.getElementRects({
      reference: e,
      floating: t,
      strategy: l
    }) : E.rects), {
      x: d,
      y: f
    } = mw(u, v, s)), p = -1);
  }
  return {
    x: d,
    y: f,
    placement: v,
    strategy: l,
    middlewareData: h
  };
};
async function My(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: o,
    y: l,
    platform: a,
    rects: r,
    elements: i,
    strategy: s
  } = e, {
    boundary: u = "clippingAncestors",
    rootBoundary: d = "viewport",
    elementContext: f = "floating",
    altBoundary: v = !1,
    padding: h = 0
  } = sf(t, e), m = $k(h), C = i[v ? f === "floating" ? "reference" : "floating" : f], g = Zp(await a.getClippingRect({
    element: (n = await (a.isElement == null ? void 0 : a.isElement(C))) == null || n ? C : C.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(i.floating)),
    boundary: u,
    rootBoundary: d,
    strategy: s
  })), w = f === "floating" ? {
    ...r.floating,
    x: o,
    y: l
  } : r.reference, b = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(i.floating)), y = await (a.isElement == null ? void 0 : a.isElement(b)) ? await (a.getScale == null ? void 0 : a.getScale(b)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, E = Zp(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: i,
    rect: w,
    offsetParent: b,
    strategy: s
  }) : w);
  return {
    top: (g.top - E.top + m.top) / y.y,
    bottom: (E.bottom - g.bottom + m.bottom) / y.y,
    left: (g.left - E.left + m.left) / y.x,
    right: (E.right - g.right + m.right) / y.x
  };
}
const l5 = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: o,
      placement: l,
      rects: a,
      platform: r,
      elements: i,
      middlewareData: s
    } = t, {
      element: u,
      padding: d = 0
    } = sf(e, t) || {};
    if (u == null)
      return {};
    const f = $k(d), v = {
      x: n,
      y: o
    }, h = Ny(l), m = Oy(h), p = await r.getDimensions(u), C = h === "y", g = C ? "top" : "left", w = C ? "bottom" : "right", b = C ? "clientHeight" : "clientWidth", y = a.reference[m] + a.reference[h] - v[h] - a.floating[m], E = v[h] - a.reference[h], S = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(u));
    let _ = S ? S[b] : 0;
    (!_ || !await (r.isElement == null ? void 0 : r.isElement(S))) && (_ = i.floating[b] || a.floating[m]);
    const k = y / 2 - E / 2, N = _ / 2 - p[m] / 2 - 1, L = Wc(f[g], N), R = Wc(f[w], N), H = L, K = _ - p[m] - R, U = _ / 2 - p[m] / 2 + k, W = pg(H, U, K), A = !s.arrow && cf(l) != null && U !== W && a.reference[m] / 2 - (U < H ? L : R) - p[m] / 2 < 0, $ = A ? U < H ? U - H : U - K : 0;
    return {
      [h]: v[h] + $,
      data: {
        [h]: W,
        centerOffset: U - W - $,
        ...A && {
          alignmentOffset: $
        }
      },
      reset: A
    };
  }
}), a5 = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, o;
      const {
        placement: l,
        middlewareData: a,
        rects: r,
        initialPlacement: i,
        platform: s,
        elements: u
      } = t, {
        mainAxis: d = !0,
        crossAxis: f = !0,
        fallbackPlacements: v,
        fallbackStrategy: h = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: p = !0,
        ...C
      } = sf(e, t);
      if ((n = a.arrow) != null && n.alignmentOffset)
        return {};
      const g = Ni(l), w = Ni(i) === i, b = await (s.isRTL == null ? void 0 : s.isRTL(u.floating)), y = v || (w || !p ? [Xp(i)] : Q6(i));
      !v && m !== "none" && y.push(...t5(i, p, m, b));
      const E = [i, ...y], S = await My(t, C), _ = [];
      let k = ((o = a.flip) == null ? void 0 : o.overflows) || [];
      if (d && _.push(S[g]), f) {
        const H = J6(l, r, b);
        _.push(S[H[0]], S[H[1]]);
      }
      if (k = [...k, {
        placement: l,
        overflows: _
      }], !_.every((H) => H <= 0)) {
        var N, L;
        const H = (((N = a.flip) == null ? void 0 : N.index) || 0) + 1, K = E[H];
        if (K)
          return {
            data: {
              index: H,
              overflows: k
            },
            reset: {
              placement: K
            }
          };
        let U = (L = k.filter((W) => W.overflows[0] <= 0).sort((W, A) => W.overflows[1] - A.overflows[1])[0]) == null ? void 0 : L.placement;
        if (!U)
          switch (h) {
            case "bestFit": {
              var R;
              const W = (R = k.map((A) => [A.placement, A.overflows.filter(($) => $ > 0).reduce(($, D) => $ + D, 0)]).sort((A, $) => A[1] - $[1])[0]) == null ? void 0 : R[0];
              W && (U = W);
              break;
            }
            case "initialPlacement":
              U = i;
              break;
          }
        if (l !== U)
          return {
            reset: {
              placement: U
            }
          };
      }
      return {};
    }
  };
};
async function r5(e, t) {
  const {
    placement: n,
    platform: o,
    elements: l
  } = e, a = await (o.isRTL == null ? void 0 : o.isRTL(l.floating)), r = Ni(n), i = cf(n), s = Av(n) === "y", u = ["left", "top"].includes(r) ? -1 : 1, d = a && s ? -1 : 1, f = sf(t, e);
  let {
    mainAxis: v,
    crossAxis: h,
    alignmentAxis: m
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...f
  };
  return i && typeof m == "number" && (h = i === "end" ? m * -1 : m), s ? {
    x: h * d,
    y: v * u
  } : {
    x: v * u,
    y: h * d
  };
}
const Ok = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, o;
      const {
        x: l,
        y: a,
        placement: r,
        middlewareData: i
      } = t, s = await r5(t, e);
      return r === ((n = i.offset) == null ? void 0 : n.placement) && (o = i.arrow) != null && o.alignmentOffset ? {} : {
        x: l + s.x,
        y: a + s.y,
        data: {
          ...s,
          placement: r
        }
      };
    }
  };
}, s5 = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: o,
        placement: l
      } = t, {
        mainAxis: a = !0,
        crossAxis: r = !1,
        limiter: i = {
          fn: (C) => {
            let {
              x: g,
              y: w
            } = C;
            return {
              x: g,
              y: w
            };
          }
        },
        ...s
      } = sf(e, t), u = {
        x: n,
        y: o
      }, d = await My(t, s), f = Av(Ni(l)), v = Tk(f);
      let h = u[v], m = u[f];
      if (a) {
        const C = v === "y" ? "top" : "left", g = v === "y" ? "bottom" : "right", w = h + d[C], b = h - d[g];
        h = pg(w, h, b);
      }
      if (r) {
        const C = f === "y" ? "top" : "left", g = f === "y" ? "bottom" : "right", w = m + d[C], b = m - d[g];
        m = pg(w, m, b);
      }
      const p = i.fn({
        ...t,
        [v]: h,
        [f]: m
      });
      return {
        ...p,
        data: {
          x: p.x - n,
          y: p.y - o
        }
      };
    }
  };
};
function Os(e) {
  return Nk(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function ea(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Hr(e) {
  var t;
  return (t = (Nk(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Nk(e) {
  return e instanceof Node || e instanceof ea(e).Node;
}
function Lr(e) {
  return e instanceof Element || e instanceof ea(e).Element;
}
function cr(e) {
  return e instanceof HTMLElement || e instanceof ea(e).HTMLElement;
}
function gw(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof ea(e).ShadowRoot;
}
function uf(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: o,
    display: l
  } = _a(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + o + n) && !["inline", "contents"].includes(l);
}
function i5(e) {
  return ["table", "td", "th"].includes(Os(e));
}
function Iy(e) {
  const t = Ry(), n = _a(e);
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((o) => (n.willChange || "").includes(o)) || ["paint", "layout", "strict", "content"].some((o) => (n.contain || "").includes(o));
}
function c5(e) {
  let t = Kc(e);
  for (; cr(t) && !Fv(t); ) {
    if (Iy(t))
      return t;
    t = Kc(t);
  }
  return null;
}
function Ry() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function Fv(e) {
  return ["html", "body", "#document"].includes(Os(e));
}
function _a(e) {
  return ea(e).getComputedStyle(e);
}
function Vv(e) {
  return Lr(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.pageXOffset,
    scrollTop: e.pageYOffset
  };
}
function Kc(e) {
  if (Os(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    gw(e) && e.host || // Fallback.
    Hr(e)
  );
  return gw(t) ? t.host : t;
}
function Mk(e) {
  const t = Kc(e);
  return Fv(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : cr(t) && uf(t) ? t : Mk(t);
}
function Rd(e, t, n) {
  var o;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const l = Mk(e), a = l === ((o = e.ownerDocument) == null ? void 0 : o.body), r = ea(l);
  return a ? t.concat(r, r.visualViewport || [], uf(l) ? l : [], r.frameElement && n ? Rd(r.frameElement) : []) : t.concat(l, Rd(l, [], n));
}
function Ik(e) {
  const t = _a(e);
  let n = parseFloat(t.width) || 0, o = parseFloat(t.height) || 0;
  const l = cr(e), a = l ? e.offsetWidth : n, r = l ? e.offsetHeight : o, i = Gp(n) !== a || Gp(o) !== r;
  return i && (n = a, o = r), {
    width: n,
    height: o,
    $: i
  };
}
function Dy(e) {
  return Lr(e) ? e : e.contextElement;
}
function kc(e) {
  const t = Dy(e);
  if (!cr(t))
    return $s(1);
  const n = t.getBoundingClientRect(), {
    width: o,
    height: l,
    $: a
  } = Ik(t);
  let r = (a ? Gp(n.width) : n.width) / o, i = (a ? Gp(n.height) : n.height) / l;
  return (!r || !Number.isFinite(r)) && (r = 1), (!i || !Number.isFinite(i)) && (i = 1), {
    x: r,
    y: i
  };
}
const u5 = /* @__PURE__ */ $s(0);
function Rk(e) {
  const t = ea(e);
  return !Ry() || !t.visualViewport ? u5 : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function d5(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== ea(e) ? !1 : t;
}
function Mi(e, t, n, o) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const l = e.getBoundingClientRect(), a = Dy(e);
  let r = $s(1);
  t && (o ? Lr(o) && (r = kc(o)) : r = kc(e));
  const i = d5(a, n, o) ? Rk(a) : $s(0);
  let s = (l.left + i.x) / r.x, u = (l.top + i.y) / r.y, d = l.width / r.x, f = l.height / r.y;
  if (a) {
    const v = ea(a), h = o && Lr(o) ? ea(o) : o;
    let m = v, p = m.frameElement;
    for (; p && o && h !== m; ) {
      const C = kc(p), g = p.getBoundingClientRect(), w = _a(p), b = g.left + (p.clientLeft + parseFloat(w.paddingLeft)) * C.x, y = g.top + (p.clientTop + parseFloat(w.paddingTop)) * C.y;
      s *= C.x, u *= C.y, d *= C.x, f *= C.y, s += b, u += y, m = ea(p), p = m.frameElement;
    }
  }
  return Zp({
    width: d,
    height: f,
    x: s,
    y: u
  });
}
const f5 = [":popover-open", ":modal"];
function Dk(e) {
  return f5.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function p5(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: o,
    strategy: l
  } = e;
  const a = l === "fixed", r = Hr(o), i = t ? Dk(t.floating) : !1;
  if (o === r || i && a)
    return n;
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = $s(1);
  const d = $s(0), f = cr(o);
  if ((f || !f && !a) && ((Os(o) !== "body" || uf(r)) && (s = Vv(o)), cr(o))) {
    const v = Mi(o);
    u = kc(o), d.x = v.x + o.clientLeft, d.y = v.y + o.clientTop;
  }
  return {
    width: n.width * u.x,
    height: n.height * u.y,
    x: n.x * u.x - s.scrollLeft * u.x + d.x,
    y: n.y * u.y - s.scrollTop * u.y + d.y
  };
}
function v5(e) {
  return Array.from(e.getClientRects());
}
function Lk(e) {
  return Mi(Hr(e)).left + Vv(e).scrollLeft;
}
function h5(e) {
  const t = Hr(e), n = Vv(e), o = e.ownerDocument.body, l = yi(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth), a = yi(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight);
  let r = -n.scrollLeft + Lk(e);
  const i = -n.scrollTop;
  return _a(o).direction === "rtl" && (r += yi(t.clientWidth, o.clientWidth) - l), {
    width: l,
    height: a,
    x: r,
    y: i
  };
}
function m5(e, t) {
  const n = ea(e), o = Hr(e), l = n.visualViewport;
  let a = o.clientWidth, r = o.clientHeight, i = 0, s = 0;
  if (l) {
    a = l.width, r = l.height;
    const u = Ry();
    (!u || u && t === "fixed") && (i = l.offsetLeft, s = l.offsetTop);
  }
  return {
    width: a,
    height: r,
    x: i,
    y: s
  };
}
function g5(e, t) {
  const n = Mi(e, !0, t === "fixed"), o = n.top + e.clientTop, l = n.left + e.clientLeft, a = cr(e) ? kc(e) : $s(1), r = e.clientWidth * a.x, i = e.clientHeight * a.y, s = l * a.x, u = o * a.y;
  return {
    width: r,
    height: i,
    x: s,
    y: u
  };
}
function bw(e, t, n) {
  let o;
  if (t === "viewport")
    o = m5(e, n);
  else if (t === "document")
    o = h5(Hr(e));
  else if (Lr(t))
    o = g5(t, n);
  else {
    const l = Rk(e);
    o = {
      ...t,
      x: t.x - l.x,
      y: t.y - l.y
    };
  }
  return Zp(o);
}
function Pk(e, t) {
  const n = Kc(e);
  return n === t || !Lr(n) || Fv(n) ? !1 : _a(n).position === "fixed" || Pk(n, t);
}
function b5(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let o = Rd(e, [], !1).filter((i) => Lr(i) && Os(i) !== "body"), l = null;
  const a = _a(e).position === "fixed";
  let r = a ? Kc(e) : e;
  for (; Lr(r) && !Fv(r); ) {
    const i = _a(r), s = Iy(r);
    !s && i.position === "fixed" && (l = null), (a ? !s && !l : !s && i.position === "static" && !!l && ["absolute", "fixed"].includes(l.position) || uf(r) && !s && Pk(e, r)) ? o = o.filter((d) => d !== r) : l = i, r = Kc(r);
  }
  return t.set(e, o), o;
}
function y5(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: o,
    strategy: l
  } = e;
  const r = [...n === "clippingAncestors" ? b5(t, this._c) : [].concat(n), o], i = r[0], s = r.reduce((u, d) => {
    const f = bw(t, d, l);
    return u.top = yi(f.top, u.top), u.right = Wc(f.right, u.right), u.bottom = Wc(f.bottom, u.bottom), u.left = yi(f.left, u.left), u;
  }, bw(t, i, l));
  return {
    width: s.right - s.left,
    height: s.bottom - s.top,
    x: s.left,
    y: s.top
  };
}
function C5(e) {
  const {
    width: t,
    height: n
  } = Ik(e);
  return {
    width: t,
    height: n
  };
}
function w5(e, t, n) {
  const o = cr(t), l = Hr(t), a = n === "fixed", r = Mi(e, !0, a, t);
  let i = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const s = $s(0);
  if (o || !o && !a)
    if ((Os(t) !== "body" || uf(l)) && (i = Vv(t)), o) {
      const f = Mi(t, !0, a, t);
      s.x = f.x + t.clientLeft, s.y = f.y + t.clientTop;
    } else
      l && (s.x = Lk(l));
  const u = r.left + i.scrollLeft - s.x, d = r.top + i.scrollTop - s.y;
  return {
    x: u,
    y: d,
    width: r.width,
    height: r.height
  };
}
function yw(e, t) {
  return !cr(e) || _a(e).position === "fixed" ? null : t ? t(e) : e.offsetParent;
}
function Ak(e, t) {
  const n = ea(e);
  if (!cr(e) || Dk(e))
    return n;
  let o = yw(e, t);
  for (; o && i5(o) && _a(o).position === "static"; )
    o = yw(o, t);
  return o && (Os(o) === "html" || Os(o) === "body" && _a(o).position === "static" && !Iy(o)) ? n : o || c5(e) || n;
}
const E5 = async function(e) {
  const t = this.getOffsetParent || Ak, n = this.getDimensions;
  return {
    reference: w5(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      ...await n(e.floating)
    }
  };
};
function S5(e) {
  return _a(e).direction === "rtl";
}
const _5 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: p5,
  getDocumentElement: Hr,
  getClippingRect: y5,
  getOffsetParent: Ak,
  getElementRects: E5,
  getClientRects: v5,
  getDimensions: C5,
  getScale: kc,
  isElement: Lr,
  isRTL: S5
};
function x5(e, t) {
  let n = null, o;
  const l = Hr(e);
  function a() {
    var i;
    clearTimeout(o), (i = n) == null || i.disconnect(), n = null;
  }
  function r(i, s) {
    i === void 0 && (i = !1), s === void 0 && (s = 1), a();
    const {
      left: u,
      top: d,
      width: f,
      height: v
    } = e.getBoundingClientRect();
    if (i || t(), !f || !v)
      return;
    const h = zf(d), m = zf(l.clientWidth - (u + f)), p = zf(l.clientHeight - (d + v)), C = zf(u), w = {
      rootMargin: -h + "px " + -m + "px " + -p + "px " + -C + "px",
      threshold: yi(0, Wc(1, s)) || 1
    };
    let b = !0;
    function y(E) {
      const S = E[0].intersectionRatio;
      if (S !== s) {
        if (!b)
          return r();
        S ? r(!1, S) : o = setTimeout(() => {
          r(!1, 1e-7);
        }, 100);
      }
      b = !1;
    }
    try {
      n = new IntersectionObserver(y, {
        ...w,
        // Handle <iframe>s
        root: l.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(y, w);
    }
    n.observe(e);
  }
  return r(!0), a;
}
function k5(e, t, n, o) {
  o === void 0 && (o = {});
  const {
    ancestorScroll: l = !0,
    ancestorResize: a = !0,
    elementResize: r = typeof ResizeObserver == "function",
    layoutShift: i = typeof IntersectionObserver == "function",
    animationFrame: s = !1
  } = o, u = Dy(e), d = l || a ? [...u ? Rd(u) : [], ...Rd(t)] : [];
  d.forEach((g) => {
    l && g.addEventListener("scroll", n, {
      passive: !0
    }), a && g.addEventListener("resize", n);
  });
  const f = u && i ? x5(u, n) : null;
  let v = -1, h = null;
  r && (h = new ResizeObserver((g) => {
    let [w] = g;
    w && w.target === u && h && (h.unobserve(t), cancelAnimationFrame(v), v = requestAnimationFrame(() => {
      var b;
      (b = h) == null || b.observe(t);
    })), n();
  }), u && !s && h.observe(u), h.observe(t));
  let m, p = s ? Mi(e) : null;
  s && C();
  function C() {
    const g = Mi(e);
    p && (g.x !== p.x || g.y !== p.y || g.width !== p.width || g.height !== p.height) && n(), p = g, m = requestAnimationFrame(C);
  }
  return n(), () => {
    var g;
    d.forEach((w) => {
      l && w.removeEventListener("scroll", n), a && w.removeEventListener("resize", n);
    }), f == null || f(), (g = h) == null || g.disconnect(), h = null, s && cancelAnimationFrame(m);
  };
}
const T5 = s5, $5 = a5, Fk = l5, Vk = (e, t, n) => {
  const o = /* @__PURE__ */ new Map(), l = {
    platform: _5,
    ...n
  }, a = {
    ...l.platform,
    _c: o
  };
  return o5(e, t, {
    ...l,
    platform: a
  });
};
it({});
const O5 = (e) => {
  if (!fn)
    return;
  if (!e)
    return e;
  const t = Fl(e);
  return t || (fl(e) ? t : e);
}, N5 = ({
  middleware: e,
  placement: t,
  strategy: n
}) => {
  const o = B(), l = B(), a = B(), r = B(), i = B({}), s = {
    x: a,
    y: r,
    placement: t,
    strategy: n,
    middlewareData: i
  }, u = async () => {
    if (!fn)
      return;
    const d = O5(o), f = Fl(l);
    if (!d || !f)
      return;
    const v = await Vk(d, f, {
      placement: c(t),
      strategy: c(n),
      middleware: c(e)
    });
    Lc(s).forEach((h) => {
      s[h].value = v[h];
    });
  };
  return Nt(() => {
    ol(() => {
      u();
    });
  }), {
    ...s,
    update: u,
    referenceRef: o,
    contentRef: l
  };
}, M5 = ({
  arrowRef: e,
  padding: t
}) => ({
  name: "arrow",
  options: {
    element: e,
    padding: t
  },
  fn(n) {
    const o = c(e);
    return o ? Fk({
      element: o,
      padding: t
    }).fn(n) : {};
  }
});
function I5(e) {
  const t = B();
  function n() {
    if (e.value == null)
      return;
    const { selectionStart: l, selectionEnd: a, value: r } = e.value;
    if (l == null || a == null)
      return;
    const i = r.slice(0, Math.max(0, l)), s = r.slice(Math.max(0, a));
    t.value = {
      selectionStart: l,
      selectionEnd: a,
      value: r,
      beforeTxt: i,
      afterTxt: s
    };
  }
  function o() {
    if (e.value == null || t.value == null)
      return;
    const { value: l } = e.value, { beforeTxt: a, afterTxt: r, selectionStart: i } = t.value;
    if (a == null || r == null || i == null)
      return;
    let s = l.length;
    if (l.endsWith(r))
      s = l.length - r.length;
    else if (l.startsWith(a))
      s = a.length;
    else {
      const u = a[i - 1], d = l.indexOf(u, i - 1);
      d !== -1 && (s = d + 1);
    }
    e.value.setSelectionRange(s, s);
  }
  return [n, o];
}
const R5 = (e, t, n) => bs(e.subTree).filter((a) => {
  var r;
  return yo(a) && ((r = a.type) == null ? void 0 : r.name) === t && !!a.component;
}).map((a) => a.component.uid).map((a) => n[a]).filter((a) => !!a), Ly = (e, t) => {
  const n = {}, o = An([]);
  return {
    children: o,
    addChild: (r) => {
      n[r.uid] = r, o.value = R5(e, t, n);
    },
    removeChild: (r) => {
      delete n[r], o.value = o.value.filter((i) => i.uid !== r);
    }
  };
}, Lo = Ha({
  type: String,
  values: fr,
  required: !1
}), Bk = Symbol("size"), D5 = () => {
  const e = ot(Bk, {});
  return x(() => c(e.size) || "");
};
function Bv(e, { afterFocus: t, beforeBlur: n, afterBlur: o } = {}) {
  const l = Pt(), { emit: a } = l, r = An(), i = B(!1), s = (f) => {
    i.value || (i.value = !0, a("focus", f), t == null || t());
  }, u = (f) => {
    var v;
    vn(n) && n(f) || f.relatedTarget && ((v = r.value) != null && v.contains(f.relatedTarget)) || (i.value = !1, a("blur", f), o == null || o());
  }, d = () => {
    var f;
    (f = e.value) == null || f.focus();
  };
  return Pe(r, (f) => {
    f && f.setAttribute("tabindex", "-1");
  }), jn(r, "click", d), {
    wrapperRef: r,
    isFocused: i,
    handleFocus: s,
    handleBlur: u
  };
}
const L5 = "use-empty-values", P5 = ["", void 0, null], A5 = void 0, ru = it({
  emptyValues: Array,
  valueOnClear: {
    type: [String, Number, Boolean, Function],
    default: void 0,
    validator: (e) => vn(e) ? !e() : !e
  }
}), Hv = (e, t) => {
  let n = df();
  n.value || (n = B({}));
  const o = x(() => e.emptyValues || n.value.emptyValues || P5), l = x(() => vn(e.valueOnClear) ? e.valueOnClear() : e.valueOnClear !== void 0 ? e.valueOnClear : vn(n.value.valueOnClear) ? n.value.valueOnClear() : n.value.valueOnClear !== void 0 ? n.value.valueOnClear : t !== void 0 ? t : A5), a = (r) => o.value.includes(r);
  return o.value.includes(l.value) || dn(L5, "value-on-clear should be a value of empty-values"), {
    emptyValues: o,
    valueOnClear: l,
    isEmptyValue: a
  };
}, F5 = it({
  ariaLabel: String,
  ariaOrientation: {
    type: String,
    values: ["horizontal", "vertical", "undefined"]
  },
  ariaControls: String
}), Zo = (e) => er(F5, e), Hk = Symbol(), Jp = B();
function df(e, t = void 0) {
  const n = Pt() ? ot(Hk, Jp) : Jp;
  return e ? x(() => {
    var o, l;
    return (l = (o = n.value) == null ? void 0 : o[e]) != null ? l : t;
  }) : n;
}
function zv(e, t) {
  const n = df(), o = nt(e, x(() => {
    var i;
    return ((i = n.value) == null ? void 0 : i.namespace) || Gu;
  })), l = bn(x(() => {
    var i;
    return (i = n.value) == null ? void 0 : i.locale;
  })), a = au(x(() => {
    var i;
    return ((i = n.value) == null ? void 0 : i.zIndex) || xk;
  })), r = x(() => {
    var i;
    return c(t) || ((i = n.value) == null ? void 0 : i.size) || "";
  });
  return Py(x(() => c(n) || {})), {
    ns: o,
    locale: l,
    zIndex: a,
    size: r
  };
}
const Py = (e, t, n = !1) => {
  var o;
  const l = !!Pt(), a = l ? df() : void 0, r = (o = t == null ? void 0 : t.provide) != null ? o : l ? Mt : void 0;
  if (!r) {
    dn("provideGlobalConfig", "provideGlobalConfig() can only be used inside setup().");
    return;
  }
  const i = x(() => {
    const s = c(e);
    return a != null && a.value ? V5(a.value, s) : s;
  });
  return r(Hk, i), r(lk, x(() => i.value.locale)), r(ck, x(() => i.value.namespace)), r(kk, x(() => i.value.zIndex)), r(Bk, {
    size: x(() => i.value.size || "")
  }), (n || !Jp.value) && (Jp.value = i.value), i;
}, V5 = (e, t) => {
  const n = [.../* @__PURE__ */ new Set([...Lc(e), ...Lc(t)])], o = {};
  for (const l of n)
    o[l] = t[l] !== void 0 ? t[l] : e[l];
  return o;
}, B5 = it({
  a11y: {
    type: Boolean,
    default: !0
  },
  locale: {
    type: Ae(Object)
  },
  size: Lo,
  button: {
    type: Ae(Object)
  },
  experimentalFeatures: {
    type: Ae(Object)
  },
  keyboardNavigation: {
    type: Boolean,
    default: !0
  },
  message: {
    type: Ae(Object)
  },
  zIndex: Number,
  namespace: {
    type: String,
    default: "el"
  },
  ...ru
}), hg = {}, H5 = Q({
  name: "ElConfigProvider",
  props: B5,
  setup(e, { slots: t }) {
    Pe(() => e.message, (o) => {
      Object.assign(hg, o ?? {});
    }, { immediate: !0, deep: !0 });
    const n = Py(e);
    return () => Ie(t, "default", { config: n == null ? void 0 : n.value });
  }
}), z5 = Yt(H5), W5 = "2.7.3", K5 = (e = []) => ({
  version: W5,
  install: (n, o) => {
    n[ZC] || (n[ZC] = !0, e.forEach((l) => n.use(l)), o && Py(o, n, !0));
  }
}), U5 = it({
  zIndex: {
    type: Ae([Number, String]),
    default: 100
  },
  target: {
    type: String,
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  position: {
    type: String,
    values: ["top", "bottom"],
    default: "top"
  }
}), j5 = {
  scroll: ({ scrollTop: e, fixed: t }) => Ot(e) && $o(t),
  [qn]: (e) => $o(e)
};
var ut = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [o, l] of t)
    n[o] = l;
  return n;
};
const zk = "ElAffix", q5 = Q({
  name: zk
}), Y5 = /* @__PURE__ */ Q({
  ...q5,
  props: U5,
  emits: j5,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = nt("affix"), a = An(), r = An(), i = An(), { height: s } = tD(), {
      height: u,
      width: d,
      top: f,
      bottom: v,
      update: h
    } = uC(r, { windowScroll: !1 }), m = uC(a), p = B(!1), C = B(0), g = B(0), w = x(() => ({
      height: p.value ? `${u.value}px` : "",
      width: p.value ? `${d.value}px` : ""
    })), b = x(() => {
      if (!p.value)
        return {};
      const S = o.offset ? po(o.offset) : 0;
      return {
        height: `${u.value}px`,
        width: `${d.value}px`,
        top: o.position === "top" ? S : "",
        bottom: o.position === "bottom" ? S : "",
        transform: g.value ? `translateY(${g.value}px)` : "",
        zIndex: o.zIndex
      };
    }), y = () => {
      if (i.value)
        if (C.value = i.value instanceof Window ? document.documentElement.scrollTop : i.value.scrollTop || 0, o.position === "top")
          if (o.target) {
            const S = m.bottom.value - o.offset - u.value;
            p.value = o.offset > f.value && m.bottom.value > 0, g.value = S < 0 ? S : 0;
          } else
            p.value = o.offset > f.value;
        else if (o.target) {
          const S = s.value - m.top.value - o.offset - u.value;
          p.value = s.value - o.offset < v.value && s.value > m.top.value, g.value = S < 0 ? -S : 0;
        } else
          p.value = s.value - o.offset < v.value;
    }, E = () => {
      h(), n("scroll", {
        scrollTop: C.value,
        fixed: p.value
      });
    };
    return Pe(p, (S) => n("change", S)), Nt(() => {
      var S;
      o.target ? (a.value = (S = document.querySelector(o.target)) != null ? S : void 0, a.value || lo(zk, `Target does not exist: ${o.target}`)) : a.value = document.documentElement, i.value = sy(r.value, !0), h();
    }), jn(i, "scroll", E), ol(y), t({
      update: y,
      updateRoot: h
    }), (S, _) => (M(), G("div", {
      ref_key: "root",
      ref: r,
      class: z(c(l).b()),
      style: bt(c(w))
    }, [
      X("div", {
        class: z({ [c(l).m("fixed")]: p.value }),
        style: bt(c(b))
      }, [
        Ie(S.$slots, "default")
      ], 6)
    ], 6));
  }
});
var G5 = /* @__PURE__ */ ut(Y5, [["__file", "affix.vue"]]);
const X5 = Yt(G5), Z5 = it({
  size: {
    type: Ae([Number, String])
  },
  color: {
    type: String
  }
}), J5 = Q({
  name: "ElIcon",
  inheritAttrs: !1
}), Q5 = /* @__PURE__ */ Q({
  ...J5,
  props: Z5,
  setup(e) {
    const t = e, n = nt("icon"), o = x(() => {
      const { size: l, color: a } = t;
      return !l && !a ? {} : {
        fontSize: To(l) ? void 0 : po(l),
        "--color": a
      };
    });
    return (l, a) => (M(), G("i", Et({
      class: c(n).b(),
      style: c(o)
    }, l.$attrs), [
      Ie(l.$slots, "default")
    ], 16));
  }
});
var eB = /* @__PURE__ */ ut(Q5, [["__file", "icon.vue"]]);
const Ct = Yt(eB), tB = ["light", "dark"], nB = it({
  title: {
    type: String,
    default: ""
  },
  description: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: Lc(Ts),
    default: "info"
  },
  closable: {
    type: Boolean,
    default: !0
  },
  closeText: {
    type: String,
    default: ""
  },
  showIcon: Boolean,
  center: Boolean,
  effect: {
    type: String,
    values: tB,
    default: "light"
  }
}), oB = {
  close: (e) => e instanceof MouseEvent
}, lB = Q({
  name: "ElAlert"
}), aB = /* @__PURE__ */ Q({
  ...lB,
  props: nB,
  emits: oB,
  setup(e, { emit: t }) {
    const n = e, { Close: o } = py, l = Yn(), a = nt("alert"), r = B(!0), i = x(() => Ts[n.type]), s = x(() => [
      a.e("icon"),
      { [a.is("big")]: !!n.description || !!l.default }
    ]), u = x(() => ({ "with-description": n.description || l.default })), d = (f) => {
      r.value = !1, t("close", f);
    };
    return (f, v) => (M(), We(Ko, {
      name: c(a).b("fade"),
      persisted: ""
    }, {
      default: fe(() => [
        Bt(X("div", {
          class: z([c(a).b(), c(a).m(f.type), c(a).is("center", f.center), c(a).is(f.effect)]),
          role: "alert"
        }, [
          f.showIcon && c(i) ? (M(), We(c(Ct), {
            key: 0,
            class: z(c(s))
          }, {
            default: fe(() => [
              (M(), We(Qt(c(i))))
            ]),
            _: 1
          }, 8, ["class"])) : _e("v-if", !0),
          X("div", {
            class: z(c(a).e("content"))
          }, [
            f.title || f.$slots.title ? (M(), G("span", {
              key: 0,
              class: z([c(a).e("title"), c(u)])
            }, [
              Ie(f.$slots, "title", {}, () => [
                Ut(Qe(f.title), 1)
              ])
            ], 2)) : _e("v-if", !0),
            f.$slots.default || f.description ? (M(), G("p", {
              key: 1,
              class: z(c(a).e("description"))
            }, [
              Ie(f.$slots, "default", {}, () => [
                Ut(Qe(f.description), 1)
              ])
            ], 2)) : _e("v-if", !0),
            f.closable ? (M(), G(kt, { key: 2 }, [
              f.closeText ? (M(), G("div", {
                key: 0,
                class: z([c(a).e("close-btn"), c(a).is("customed")]),
                onClick: d
              }, Qe(f.closeText), 3)) : (M(), We(c(Ct), {
                key: 1,
                class: z(c(a).e("close-btn")),
                onClick: d
              }, {
                default: fe(() => [
                  oe(c(o))
                ]),
                _: 1
              }, 8, ["class"]))
            ], 64)) : _e("v-if", !0)
          ], 2)
        ], 2), [
          [pn, r.value]
        ])
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
var rB = /* @__PURE__ */ ut(aB, [["__file", "alert.vue"]]);
const sB = Yt(rB), zi = Symbol("formContextKey"), ur = Symbol("formItemContextKey"), Mo = (e, t = {}) => {
  const n = B(void 0), o = t.prop ? n : dk("size"), l = t.global ? n : D5(), a = t.form ? { size: void 0 } : ot(zi, void 0), r = t.formItem ? { size: void 0 } : ot(ur, void 0);
  return x(() => o.value || c(e) || (r == null ? void 0 : r.size) || (a == null ? void 0 : a.size) || l.value || "");
}, Nl = (e) => {
  const t = dk("disabled"), n = ot(zi, void 0);
  return x(() => t.value || c(e) || (n == null ? void 0 : n.disabled) || !1);
}, ml = () => {
  const e = ot(zi, void 0), t = ot(ur, void 0);
  return {
    form: e,
    formItem: t
  };
}, Wa = (e, {
  formItemContext: t,
  disableIdGeneration: n,
  disableIdManagement: o
}) => {
  n || (n = B(!1)), o || (o = B(!1));
  const l = B();
  let a;
  const r = x(() => {
    var i;
    return !!(!(e.label || e.ariaLabel) && t && t.inputIds && ((i = t.inputIds) == null ? void 0 : i.length) <= 1);
  });
  return Nt(() => {
    a = Pe([Pn(e, "id"), n], ([i, s]) => {
      const u = i ?? (s ? void 0 : il().value);
      u !== l.value && (t != null && t.removeInputId && (l.value && t.removeInputId(l.value), !(o != null && o.value) && !s && u && t.addInputId(u)), l.value = u);
    }, { immediate: !0 });
  }), wo(() => {
    a && a(), t != null && t.removeInputId && l.value && t.removeInputId(l.value);
  }), {
    isLabeledByFormItem: r,
    inputId: l
  };
}, iB = it({
  size: {
    type: String,
    values: fr
  },
  disabled: Boolean
}), cB = it({
  ...iB,
  model: Object,
  rules: {
    type: Ae(Object)
  },
  labelPosition: {
    type: String,
    values: ["left", "right", "top"],
    default: "right"
  },
  requireAsteriskPosition: {
    type: String,
    values: ["left", "right"],
    default: "left"
  },
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  labelSuffix: {
    type: String,
    default: ""
  },
  inline: Boolean,
  inlineMessage: Boolean,
  statusIcon: Boolean,
  showMessage: {
    type: Boolean,
    default: !0
  },
  validateOnRuleChange: {
    type: Boolean,
    default: !0
  },
  hideRequiredAsterisk: Boolean,
  scrollToError: Boolean,
  scrollIntoViewOptions: {
    type: [Object, Boolean]
  }
}), uB = {
  validate: (e, t, n) => (Kt(e) || on(e)) && $o(t) && on(n)
}, dB = "ElForm";
function fB() {
  const e = B([]), t = x(() => {
    if (!e.value.length)
      return "0";
    const a = Math.max(...e.value);
    return a ? `${a}px` : "";
  });
  function n(a) {
    const r = e.value.indexOf(a);
    return r === -1 && t.value === "0" && dn(dB, `unexpected width ${a}`), r;
  }
  function o(a, r) {
    if (a && r) {
      const i = n(r);
      e.value.splice(i, 1, a);
    } else
      a && e.value.push(a);
  }
  function l(a) {
    const r = n(a);
    r > -1 && e.value.splice(r, 1);
  }
  return {
    autoLabelWidth: t,
    registerLabelWidth: o,
    deregisterLabelWidth: l
  };
}
const Wf = (e, t) => {
  const n = _s(t);
  return n.length > 0 ? e.filter((o) => o.prop && n.includes(o.prop)) : e;
}, gp = "ElForm", pB = Q({
  name: gp
}), vB = /* @__PURE__ */ Q({
  ...pB,
  props: cB,
  emits: uB,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = [], a = Mo(), r = nt("form"), i = x(() => {
      const { labelPosition: b, inline: y } = o;
      return [
        r.b(),
        r.m(a.value || "default"),
        {
          [r.m(`label-${b}`)]: b,
          [r.m("inline")]: y
        }
      ];
    }), s = (b) => l.find((y) => y.prop === b), u = (b) => {
      l.push(b);
    }, d = (b) => {
      b.prop && l.splice(l.indexOf(b), 1);
    }, f = (b = []) => {
      if (!o.model) {
        dn(gp, "model is required for resetFields to work.");
        return;
      }
      Wf(l, b).forEach((y) => y.resetField());
    }, v = (b = []) => {
      Wf(l, b).forEach((y) => y.clearValidate());
    }, h = x(() => {
      const b = !!o.model;
      return b || dn(gp, "model is required for validate to work."), b;
    }), m = (b) => {
      if (l.length === 0)
        return [];
      const y = Wf(l, b);
      return y.length ? y : (dn(gp, "please pass correct props!"), []);
    }, p = async (b) => g(void 0, b), C = async (b = []) => {
      if (!h.value)
        return !1;
      const y = m(b);
      if (y.length === 0)
        return !0;
      let E = {};
      for (const S of y)
        try {
          await S.validate("");
        } catch (_) {
          E = {
            ...E,
            ..._
          };
        }
      return Object.keys(E).length === 0 ? !0 : Promise.reject(E);
    }, g = async (b = [], y) => {
      const E = !vn(y);
      try {
        const S = await C(b);
        return S === !0 && await (y == null ? void 0 : y(S)), S;
      } catch (S) {
        if (S instanceof Error)
          throw S;
        const _ = S;
        return o.scrollToError && w(Object.keys(_)[0]), await (y == null ? void 0 : y(!1, _)), E && Promise.reject(_);
      }
    }, w = (b) => {
      var y;
      const E = Wf(l, b)[0];
      E && ((y = E.$el) == null || y.scrollIntoView(o.scrollIntoViewOptions));
    };
    return Pe(() => o.rules, () => {
      o.validateOnRuleChange && p().catch((b) => dn(b));
    }, { deep: !0 }), Mt(zi, en({
      ...Xo(o),
      emit: n,
      resetFields: f,
      clearValidate: v,
      validateField: g,
      getField: s,
      addField: u,
      removeField: d,
      ...fB()
    })), t({
      validate: p,
      validateField: g,
      resetFields: f,
      clearValidate: v,
      scrollToField: w,
      fields: l
    }), (b, y) => (M(), G("form", {
      class: z(c(i))
    }, [
      Ie(b.$slots, "default")
    ], 2));
  }
});
var hB = /* @__PURE__ */ ut(vB, [["__file", "form.vue"]]);
function ri() {
  return ri = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, ri.apply(this, arguments);
}
function mB(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Dd(e, t);
}
function mg(e) {
  return mg = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, mg(e);
}
function Dd(e, t) {
  return Dd = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, l) {
    return o.__proto__ = l, o;
  }, Dd(e, t);
}
function gB() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function bp(e, t, n) {
  return gB() ? bp = Reflect.construct.bind() : bp = function(l, a, r) {
    var i = [null];
    i.push.apply(i, a);
    var s = Function.bind.apply(l, i), u = new s();
    return r && Dd(u, r.prototype), u;
  }, bp.apply(null, arguments);
}
function bB(e) {
  return Function.toString.call(e).indexOf("[native code]") !== -1;
}
function gg(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return gg = function(o) {
    if (o === null || !bB(o))
      return o;
    if (typeof o != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof t < "u") {
      if (t.has(o))
        return t.get(o);
      t.set(o, l);
    }
    function l() {
      return bp(o, arguments, mg(this).constructor);
    }
    return l.prototype = Object.create(o.prototype, {
      constructor: {
        value: l,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), Dd(l, o);
  }, gg(e);
}
var yB = /%[sdj%]/g, Wk = function() {
};
typeof process < "u" && process.env && process.env.NODE_ENV !== "production" && typeof window < "u" && typeof document < "u" && (Wk = function(t, n) {
  typeof console < "u" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING > "u" && n.every(function(o) {
    return typeof o == "string";
  }) && console.warn(t, n);
});
function bg(e) {
  if (!e || !e.length)
    return null;
  var t = {};
  return e.forEach(function(n) {
    var o = n.field;
    t[o] = t[o] || [], t[o].push(n);
  }), t;
}
function Zl(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)
    n[o - 1] = arguments[o];
  var l = 0, a = n.length;
  if (typeof e == "function")
    return e.apply(null, n);
  if (typeof e == "string") {
    var r = e.replace(yB, function(i) {
      if (i === "%%")
        return "%";
      if (l >= a)
        return i;
      switch (i) {
        case "%s":
          return String(n[l++]);
        case "%d":
          return Number(n[l++]);
        case "%j":
          try {
            return JSON.stringify(n[l++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return i;
      }
    });
    return r;
  }
  return e;
}
function CB(e) {
  return e === "string" || e === "url" || e === "hex" || e === "email" || e === "date" || e === "pattern";
}
function Uo(e, t) {
  return !!(e == null || t === "array" && Array.isArray(e) && !e.length || CB(t) && typeof e == "string" && !e);
}
function wB(e, t, n) {
  var o = [], l = 0, a = e.length;
  function r(i) {
    o.push.apply(o, i || []), l++, l === a && n(o);
  }
  e.forEach(function(i) {
    t(i, r);
  });
}
function Cw(e, t, n) {
  var o = 0, l = e.length;
  function a(r) {
    if (r && r.length) {
      n(r);
      return;
    }
    var i = o;
    o = o + 1, i < l ? t(e[i], a) : n([]);
  }
  a([]);
}
function EB(e) {
  var t = [];
  return Object.keys(e).forEach(function(n) {
    t.push.apply(t, e[n] || []);
  }), t;
}
var ww = /* @__PURE__ */ function(e) {
  mB(t, e);
  function t(n, o) {
    var l;
    return l = e.call(this, "Async Validation Error") || this, l.errors = n, l.fields = o, l;
  }
  return t;
}(/* @__PURE__ */ gg(Error));
function SB(e, t, n, o, l) {
  if (t.first) {
    var a = new Promise(function(v, h) {
      var m = function(g) {
        return o(g), g.length ? h(new ww(g, bg(g))) : v(l);
      }, p = EB(e);
      Cw(p, n, m);
    });
    return a.catch(function(v) {
      return v;
    }), a;
  }
  var r = t.firstFields === !0 ? Object.keys(e) : t.firstFields || [], i = Object.keys(e), s = i.length, u = 0, d = [], f = new Promise(function(v, h) {
    var m = function(C) {
      if (d.push.apply(d, C), u++, u === s)
        return o(d), d.length ? h(new ww(d, bg(d))) : v(l);
    };
    i.length || (o(d), v(l)), i.forEach(function(p) {
      var C = e[p];
      r.indexOf(p) !== -1 ? Cw(C, n, m) : wB(C, n, m);
    });
  });
  return f.catch(function(v) {
    return v;
  }), f;
}
function _B(e) {
  return !!(e && e.message !== void 0);
}
function xB(e, t) {
  for (var n = e, o = 0; o < t.length; o++) {
    if (n == null)
      return n;
    n = n[t[o]];
  }
  return n;
}
function Ew(e, t) {
  return function(n) {
    var o;
    return e.fullFields ? o = xB(t, e.fullFields) : o = t[n.field || e.fullField], _B(n) ? (n.field = n.field || e.fullField, n.fieldValue = o, n) : {
      message: typeof n == "function" ? n() : n,
      fieldValue: o,
      field: n.field || e.fullField
    };
  };
}
function Sw(e, t) {
  if (t) {
    for (var n in t)
      if (t.hasOwnProperty(n)) {
        var o = t[n];
        typeof o == "object" && typeof e[n] == "object" ? e[n] = ri({}, e[n], o) : e[n] = o;
      }
  }
  return e;
}
var Kk = function(t, n, o, l, a, r) {
  t.required && (!o.hasOwnProperty(t.field) || Uo(n, r || t.type)) && l.push(Zl(a.messages.required, t.fullField));
}, kB = function(t, n, o, l, a) {
  (/^\s+$/.test(n) || n === "") && l.push(Zl(a.messages.whitespace, t.fullField));
}, Kf, TB = function() {
  if (Kf)
    return Kf;
  var e = "[a-fA-F\\d:]", t = function(y) {
    return y && y.includeBoundaries ? "(?:(?<=\\s|^)(?=" + e + ")|(?<=" + e + ")(?=\\s|$))" : "";
  }, n = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", o = "[a-fA-F\\d]{1,4}", l = (`
(?:
(?:` + o + ":){7}(?:" + o + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + o + ":){6}(?:" + n + "|:" + o + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + o + ":){5}(?::" + n + "|(?::" + o + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + o + ":){4}(?:(?::" + o + "){0,1}:" + n + "|(?::" + o + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + o + ":){3}(?:(?::" + o + "){0,2}:" + n + "|(?::" + o + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + o + ":){2}(?:(?::" + o + "){0,3}:" + n + "|(?::" + o + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + o + ":){1}(?:(?::" + o + "){0,4}:" + n + "|(?::" + o + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + o + "){0,5}:" + n + "|(?::" + o + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), a = new RegExp("(?:^" + n + "$)|(?:^" + l + "$)"), r = new RegExp("^" + n + "$"), i = new RegExp("^" + l + "$"), s = function(y) {
    return y && y.exact ? a : new RegExp("(?:" + t(y) + n + t(y) + ")|(?:" + t(y) + l + t(y) + ")", "g");
  };
  s.v4 = function(b) {
    return b && b.exact ? r : new RegExp("" + t(b) + n + t(b), "g");
  }, s.v6 = function(b) {
    return b && b.exact ? i : new RegExp("" + t(b) + l + t(b), "g");
  };
  var u = "(?:(?:[a-z]+:)?//)", d = "(?:\\S+(?::\\S*)?@)?", f = s.v4().source, v = s.v6().source, h = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", m = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", p = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", C = "(?::\\d{2,5})?", g = '(?:[/?#][^\\s"]*)?', w = "(?:" + u + "|www\\.)" + d + "(?:localhost|" + f + "|" + v + "|" + h + m + p + ")" + C + g;
  return Kf = new RegExp("(?:^" + w + "$)", "i"), Kf;
}, _w = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
}, zu = {
  integer: function(t) {
    return zu.number(t) && parseInt(t, 10) === t;
  },
  float: function(t) {
    return zu.number(t) && !zu.integer(t);
  },
  array: function(t) {
    return Array.isArray(t);
  },
  regexp: function(t) {
    if (t instanceof RegExp)
      return !0;
    try {
      return !!new RegExp(t);
    } catch {
      return !1;
    }
  },
  date: function(t) {
    return typeof t.getTime == "function" && typeof t.getMonth == "function" && typeof t.getYear == "function" && !isNaN(t.getTime());
  },
  number: function(t) {
    return isNaN(t) ? !1 : typeof t == "number";
  },
  object: function(t) {
    return typeof t == "object" && !zu.array(t);
  },
  method: function(t) {
    return typeof t == "function";
  },
  email: function(t) {
    return typeof t == "string" && t.length <= 320 && !!t.match(_w.email);
  },
  url: function(t) {
    return typeof t == "string" && t.length <= 2048 && !!t.match(TB());
  },
  hex: function(t) {
    return typeof t == "string" && !!t.match(_w.hex);
  }
}, $B = function(t, n, o, l, a) {
  if (t.required && n === void 0) {
    Kk(t, n, o, l, a);
    return;
  }
  var r = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], i = t.type;
  r.indexOf(i) > -1 ? zu[i](n) || l.push(Zl(a.messages.types[i], t.fullField, t.type)) : i && typeof n !== t.type && l.push(Zl(a.messages.types[i], t.fullField, t.type));
}, OB = function(t, n, o, l, a) {
  var r = typeof t.len == "number", i = typeof t.min == "number", s = typeof t.max == "number", u = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, d = n, f = null, v = typeof n == "number", h = typeof n == "string", m = Array.isArray(n);
  if (v ? f = "number" : h ? f = "string" : m && (f = "array"), !f)
    return !1;
  m && (d = n.length), h && (d = n.replace(u, "_").length), r ? d !== t.len && l.push(Zl(a.messages[f].len, t.fullField, t.len)) : i && !s && d < t.min ? l.push(Zl(a.messages[f].min, t.fullField, t.min)) : s && !i && d > t.max ? l.push(Zl(a.messages[f].max, t.fullField, t.max)) : i && s && (d < t.min || d > t.max) && l.push(Zl(a.messages[f].range, t.fullField, t.min, t.max));
}, Gi = "enum", NB = function(t, n, o, l, a) {
  t[Gi] = Array.isArray(t[Gi]) ? t[Gi] : [], t[Gi].indexOf(n) === -1 && l.push(Zl(a.messages[Gi], t.fullField, t[Gi].join(", ")));
}, MB = function(t, n, o, l, a) {
  if (t.pattern) {
    if (t.pattern instanceof RegExp)
      t.pattern.lastIndex = 0, t.pattern.test(n) || l.push(Zl(a.messages.pattern.mismatch, t.fullField, n, t.pattern));
    else if (typeof t.pattern == "string") {
      var r = new RegExp(t.pattern);
      r.test(n) || l.push(Zl(a.messages.pattern.mismatch, t.fullField, n, t.pattern));
    }
  }
}, Ln = {
  required: Kk,
  whitespace: kB,
  type: $B,
  range: OB,
  enum: NB,
  pattern: MB
}, IB = function(t, n, o, l, a) {
  var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (Uo(n, "string") && !t.required)
      return o();
    Ln.required(t, n, l, r, a, "string"), Uo(n, "string") || (Ln.type(t, n, l, r, a), Ln.range(t, n, l, r, a), Ln.pattern(t, n, l, r, a), t.whitespace === !0 && Ln.whitespace(t, n, l, r, a));
  }
  o(r);
}, RB = function(t, n, o, l, a) {
  var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (Uo(n) && !t.required)
      return o();
    Ln.required(t, n, l, r, a), n !== void 0 && Ln.type(t, n, l, r, a);
  }
  o(r);
}, DB = function(t, n, o, l, a) {
  var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (n === "" && (n = void 0), Uo(n) && !t.required)
      return o();
    Ln.required(t, n, l, r, a), n !== void 0 && (Ln.type(t, n, l, r, a), Ln.range(t, n, l, r, a));
  }
  o(r);
}, LB = function(t, n, o, l, a) {
  var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (Uo(n) && !t.required)
      return o();
    Ln.required(t, n, l, r, a), n !== void 0 && Ln.type(t, n, l, r, a);
  }
  o(r);
}, PB = function(t, n, o, l, a) {
  var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (Uo(n) && !t.required)
      return o();
    Ln.required(t, n, l, r, a), Uo(n) || Ln.type(t, n, l, r, a);
  }
  o(r);
}, AB = function(t, n, o, l, a) {
  var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (Uo(n) && !t.required)
      return o();
    Ln.required(t, n, l, r, a), n !== void 0 && (Ln.type(t, n, l, r, a), Ln.range(t, n, l, r, a));
  }
  o(r);
}, FB = function(t, n, o, l, a) {
  var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (Uo(n) && !t.required)
      return o();
    Ln.required(t, n, l, r, a), n !== void 0 && (Ln.type(t, n, l, r, a), Ln.range(t, n, l, r, a));
  }
  o(r);
}, VB = function(t, n, o, l, a) {
  var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (n == null && !t.required)
      return o();
    Ln.required(t, n, l, r, a, "array"), n != null && (Ln.type(t, n, l, r, a), Ln.range(t, n, l, r, a));
  }
  o(r);
}, BB = function(t, n, o, l, a) {
  var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (Uo(n) && !t.required)
      return o();
    Ln.required(t, n, l, r, a), n !== void 0 && Ln.type(t, n, l, r, a);
  }
  o(r);
}, HB = "enum", zB = function(t, n, o, l, a) {
  var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (Uo(n) && !t.required)
      return o();
    Ln.required(t, n, l, r, a), n !== void 0 && Ln[HB](t, n, l, r, a);
  }
  o(r);
}, WB = function(t, n, o, l, a) {
  var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (Uo(n, "string") && !t.required)
      return o();
    Ln.required(t, n, l, r, a), Uo(n, "string") || Ln.pattern(t, n, l, r, a);
  }
  o(r);
}, KB = function(t, n, o, l, a) {
  var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (Uo(n, "date") && !t.required)
      return o();
    if (Ln.required(t, n, l, r, a), !Uo(n, "date")) {
      var s;
      n instanceof Date ? s = n : s = new Date(n), Ln.type(t, s, l, r, a), s && Ln.range(t, s.getTime(), l, r, a);
    }
  }
  o(r);
}, UB = function(t, n, o, l, a) {
  var r = [], i = Array.isArray(n) ? "array" : typeof n;
  Ln.required(t, n, l, r, a, i), o(r);
}, Yh = function(t, n, o, l, a) {
  var r = t.type, i = [], s = t.required || !t.required && l.hasOwnProperty(t.field);
  if (s) {
    if (Uo(n, r) && !t.required)
      return o();
    Ln.required(t, n, l, i, a, r), Uo(n, r) || Ln.type(t, n, l, i, a);
  }
  o(i);
}, jB = function(t, n, o, l, a) {
  var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (Uo(n) && !t.required)
      return o();
    Ln.required(t, n, l, r, a);
  }
  o(r);
}, Ju = {
  string: IB,
  method: RB,
  number: DB,
  boolean: LB,
  regexp: PB,
  integer: AB,
  float: FB,
  array: VB,
  object: BB,
  enum: zB,
  pattern: WB,
  date: KB,
  url: Yh,
  hex: Yh,
  email: Yh,
  required: UB,
  any: jB
};
function yg() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function() {
      var t = JSON.parse(JSON.stringify(this));
      return t.clone = this.clone, t;
    }
  };
}
var Cg = yg(), ff = /* @__PURE__ */ function() {
  function e(n) {
    this.rules = null, this._messages = Cg, this.define(n);
  }
  var t = e.prototype;
  return t.define = function(o) {
    var l = this;
    if (!o)
      throw new Error("Cannot configure a schema with no rules");
    if (typeof o != "object" || Array.isArray(o))
      throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(o).forEach(function(a) {
      var r = o[a];
      l.rules[a] = Array.isArray(r) ? r : [r];
    });
  }, t.messages = function(o) {
    return o && (this._messages = Sw(yg(), o)), this._messages;
  }, t.validate = function(o, l, a) {
    var r = this;
    l === void 0 && (l = {}), a === void 0 && (a = function() {
    });
    var i = o, s = l, u = a;
    if (typeof s == "function" && (u = s, s = {}), !this.rules || Object.keys(this.rules).length === 0)
      return u && u(null, i), Promise.resolve(i);
    function d(p) {
      var C = [], g = {};
      function w(y) {
        if (Array.isArray(y)) {
          var E;
          C = (E = C).concat.apply(E, y);
        } else
          C.push(y);
      }
      for (var b = 0; b < p.length; b++)
        w(p[b]);
      C.length ? (g = bg(C), u(C, g)) : u(null, i);
    }
    if (s.messages) {
      var f = this.messages();
      f === Cg && (f = yg()), Sw(f, s.messages), s.messages = f;
    } else
      s.messages = this.messages();
    var v = {}, h = s.keys || Object.keys(this.rules);
    h.forEach(function(p) {
      var C = r.rules[p], g = i[p];
      C.forEach(function(w) {
        var b = w;
        typeof b.transform == "function" && (i === o && (i = ri({}, i)), g = i[p] = b.transform(g)), typeof b == "function" ? b = {
          validator: b
        } : b = ri({}, b), b.validator = r.getValidationMethod(b), b.validator && (b.field = p, b.fullField = b.fullField || p, b.type = r.getType(b), v[p] = v[p] || [], v[p].push({
          rule: b,
          value: g,
          source: i,
          field: p
        }));
      });
    });
    var m = {};
    return SB(v, s, function(p, C) {
      var g = p.rule, w = (g.type === "object" || g.type === "array") && (typeof g.fields == "object" || typeof g.defaultField == "object");
      w = w && (g.required || !g.required && p.value), g.field = p.field;
      function b(S, _) {
        return ri({}, _, {
          fullField: g.fullField + "." + S,
          fullFields: g.fullFields ? [].concat(g.fullFields, [S]) : [S]
        });
      }
      function y(S) {
        S === void 0 && (S = []);
        var _ = Array.isArray(S) ? S : [S];
        !s.suppressWarning && _.length && e.warning("async-validator:", _), _.length && g.message !== void 0 && (_ = [].concat(g.message));
        var k = _.map(Ew(g, i));
        if (s.first && k.length)
          return m[g.field] = 1, C(k);
        if (!w)
          C(k);
        else {
          if (g.required && !p.value)
            return g.message !== void 0 ? k = [].concat(g.message).map(Ew(g, i)) : s.error && (k = [s.error(g, Zl(s.messages.required, g.field))]), C(k);
          var N = {};
          g.defaultField && Object.keys(p.value).map(function(H) {
            N[H] = g.defaultField;
          }), N = ri({}, N, p.rule.fields);
          var L = {};
          Object.keys(N).forEach(function(H) {
            var K = N[H], U = Array.isArray(K) ? K : [K];
            L[H] = U.map(b.bind(null, H));
          });
          var R = new e(L);
          R.messages(s.messages), p.rule.options && (p.rule.options.messages = s.messages, p.rule.options.error = s.error), R.validate(p.value, p.rule.options || s, function(H) {
            var K = [];
            k && k.length && K.push.apply(K, k), H && H.length && K.push.apply(K, H), C(K.length ? K : null);
          });
        }
      }
      var E;
      if (g.asyncValidator)
        E = g.asyncValidator(g, p.value, y, p.source, s);
      else if (g.validator) {
        try {
          E = g.validator(g, p.value, y, p.source, s);
        } catch (S) {
          console.error == null || console.error(S), s.suppressValidatorError || setTimeout(function() {
            throw S;
          }, 0), y(S.message);
        }
        E === !0 ? y() : E === !1 ? y(typeof g.message == "function" ? g.message(g.fullField || g.field) : g.message || (g.fullField || g.field) + " fails") : E instanceof Array ? y(E) : E instanceof Error && y(E.message);
      }
      E && E.then && E.then(function() {
        return y();
      }, function(S) {
        return y(S);
      });
    }, function(p) {
      d(p);
    }, i);
  }, t.getType = function(o) {
    if (o.type === void 0 && o.pattern instanceof RegExp && (o.type = "pattern"), typeof o.validator != "function" && o.type && !Ju.hasOwnProperty(o.type))
      throw new Error(Zl("Unknown rule type %s", o.type));
    return o.type || "string";
  }, t.getValidationMethod = function(o) {
    if (typeof o.validator == "function")
      return o.validator;
    var l = Object.keys(o), a = l.indexOf("message");
    return a !== -1 && l.splice(a, 1), l.length === 1 && l[0] === "required" ? Ju.required : Ju[this.getType(o)] || void 0;
  }, e;
}();
ff.register = function(t, n) {
  if (typeof n != "function")
    throw new Error("Cannot register a validator by type, validator is not a function");
  Ju[t] = n;
};
ff.warning = Wk;
ff.messages = Cg;
ff.validators = Ju;
const qB = [
  "",
  "error",
  "validating",
  "success"
], YB = it({
  label: String,
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  prop: {
    type: Ae([String, Array])
  },
  required: {
    type: Boolean,
    default: void 0
  },
  rules: {
    type: Ae([Object, Array])
  },
  error: String,
  validateStatus: {
    type: String,
    values: qB
  },
  for: String,
  inlineMessage: {
    type: [String, Boolean],
    default: ""
  },
  showMessage: {
    type: Boolean,
    default: !0
  },
  size: {
    type: String,
    values: fr
  }
}), xw = "ElLabelWrap";
var GB = Q({
  name: xw,
  props: {
    isAutoWidth: Boolean,
    updateAll: Boolean
  },
  setup(e, {
    slots: t
  }) {
    const n = ot(zi, void 0), o = ot(ur);
    o || lo(xw, "usage: <el-form-item><label-wrap /></el-form-item>");
    const l = nt("form"), a = B(), r = B(0), i = () => {
      var d;
      if ((d = a.value) != null && d.firstElementChild) {
        const f = window.getComputedStyle(a.value.firstElementChild).width;
        return Math.ceil(Number.parseFloat(f));
      } else
        return 0;
    }, s = (d = "update") => {
      xe(() => {
        t.default && e.isAutoWidth && (d === "update" ? r.value = i() : d === "remove" && (n == null || n.deregisterLabelWidth(r.value)));
      });
    }, u = () => s("update");
    return Nt(() => {
      u();
    }), zn(() => {
      s("remove");
    }), Pi(() => u()), Pe(r, (d, f) => {
      e.updateAll && (n == null || n.registerLabelWidth(d, f));
    }), Xn(x(() => {
      var d, f;
      return (f = (d = a.value) == null ? void 0 : d.firstElementChild) != null ? f : null;
    }), u), () => {
      var d, f;
      if (!t)
        return null;
      const {
        isAutoWidth: v
      } = e;
      if (v) {
        const h = n == null ? void 0 : n.autoLabelWidth, m = o == null ? void 0 : o.hasLabel, p = {};
        if (m && h && h !== "auto") {
          const C = Math.max(0, Number.parseInt(h, 10) - r.value), g = n.labelPosition === "left" ? "marginRight" : "marginLeft";
          C && (p[g] = `${C}px`);
        }
        return oe("div", {
          ref: a,
          class: [l.be("item", "label-wrap")],
          style: p
        }, [(d = t.default) == null ? void 0 : d.call(t)]);
      } else
        return oe(kt, {
          ref: a
        }, [(f = t.default) == null ? void 0 : f.call(t)]);
    };
  }
});
const XB = ["role", "aria-labelledby"], ZB = Q({
  name: "ElFormItem"
}), JB = /* @__PURE__ */ Q({
  ...ZB,
  props: YB,
  setup(e, { expose: t }) {
    const n = e, o = Yn(), l = ot(zi, void 0), a = ot(ur, void 0), r = Mo(void 0, { formItem: !1 }), i = nt("form-item"), s = il().value, u = B([]), d = B(""), f = A3(d, 100), v = B(""), h = B();
    let m, p = !1;
    const C = x(() => {
      if ((l == null ? void 0 : l.labelPosition) === "top")
        return {};
      const ne = po(n.labelWidth || (l == null ? void 0 : l.labelWidth) || "");
      return ne ? { width: ne } : {};
    }), g = x(() => {
      if ((l == null ? void 0 : l.labelPosition) === "top" || l != null && l.inline)
        return {};
      if (!n.label && !n.labelWidth && N)
        return {};
      const ne = po(n.labelWidth || (l == null ? void 0 : l.labelWidth) || "");
      return !n.label && !o.label ? { marginLeft: ne } : {};
    }), w = x(() => [
      i.b(),
      i.m(r.value),
      i.is("error", d.value === "error"),
      i.is("validating", d.value === "validating"),
      i.is("success", d.value === "success"),
      i.is("required", U.value || n.required),
      i.is("no-asterisk", l == null ? void 0 : l.hideRequiredAsterisk),
      (l == null ? void 0 : l.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
      { [i.m("feedback")]: l == null ? void 0 : l.statusIcon }
    ]), b = x(() => $o(n.inlineMessage) ? n.inlineMessage : (l == null ? void 0 : l.inlineMessage) || !1), y = x(() => [
      i.e("error"),
      { [i.em("error", "inline")]: b.value }
    ]), E = x(() => n.prop ? on(n.prop) ? n.prop : n.prop.join(".") : ""), S = x(() => !!(n.label || o.label)), _ = x(() => n.for || (u.value.length === 1 ? u.value[0] : void 0)), k = x(() => !_.value && S.value), N = !!a, L = x(() => {
      const ne = l == null ? void 0 : l.model;
      if (!(!ne || !n.prop))
        return hp(ne, n.prop).value;
    }), R = x(() => {
      const { required: ne } = n, Y = [];
      n.rules && Y.push(..._s(n.rules));
      const ve = l == null ? void 0 : l.rules;
      if (ve && n.prop) {
        const ie = hp(ve, n.prop).value;
        ie && Y.push(..._s(ie));
      }
      if (ne !== void 0) {
        const ie = Y.map((he, De) => [he, De]).filter(([he]) => Object.keys(he).includes("required"));
        if (ie.length > 0)
          for (const [he, De] of ie)
            he.required !== ne && (Y[De] = { ...he, required: ne });
        else
          Y.push({ required: ne });
      }
      return Y;
    }), H = x(() => R.value.length > 0), K = (ne) => R.value.filter((ve) => !ve.trigger || !ne ? !0 : Array.isArray(ve.trigger) ? ve.trigger.includes(ne) : ve.trigger === ne).map(({ trigger: ve, ...ie }) => ie), U = x(() => R.value.some((ne) => ne.required)), W = x(() => {
      var ne;
      return f.value === "error" && n.showMessage && ((ne = l == null ? void 0 : l.showMessage) != null ? ne : !0);
    }), A = x(() => `${n.label || ""}${(l == null ? void 0 : l.labelSuffix) || ""}`), $ = (ne) => {
      d.value = ne;
    }, D = (ne) => {
      var Y, ve;
      const { errors: ie, fields: he } = ne;
      (!ie || !he) && console.error(ne), $("error"), v.value = ie ? (ve = (Y = ie == null ? void 0 : ie[0]) == null ? void 0 : Y.message) != null ? ve : `${n.prop} is required` : "", l == null || l.emit("validate", n.prop, !1, v.value);
    }, O = () => {
      $("success"), l == null || l.emit("validate", n.prop, !0, "");
    }, F = async (ne) => {
      const Y = E.value;
      return new ff({
        [Y]: ne
      }).validate({ [Y]: L.value }, { firstFields: !0 }).then(() => (O(), !0)).catch((ie) => (D(ie), Promise.reject(ie)));
    }, j = async (ne, Y) => {
      if (p || !n.prop)
        return !1;
      const ve = vn(Y);
      if (!H.value)
        return Y == null || Y(!1), !1;
      const ie = K(ne);
      return ie.length === 0 ? (Y == null || Y(!0), !0) : ($("validating"), F(ie).then(() => (Y == null || Y(!0), !0)).catch((he) => {
        const { fields: De } = he;
        return Y == null || Y(!1, De), ve ? !1 : Promise.reject(De);
      }));
    }, Z = () => {
      $(""), v.value = "", p = !1;
    }, te = async () => {
      const ne = l == null ? void 0 : l.model;
      if (!ne || !n.prop)
        return;
      const Y = hp(ne, n.prop);
      p = !0, Y.value = WC(m), await xe(), Z(), p = !1;
    }, de = (ne) => {
      u.value.includes(ne) || u.value.push(ne);
    }, Oe = (ne) => {
      u.value = u.value.filter((Y) => Y !== ne);
    };
    Pe(() => n.error, (ne) => {
      v.value = ne || "", $(ne ? "error" : "");
    }, { immediate: !0 }), Pe(() => n.validateStatus, (ne) => $(ne || ""));
    const ce = en({
      ...Xo(n),
      $el: h,
      size: r,
      validateState: d,
      labelId: s,
      inputIds: u,
      isGroup: k,
      hasLabel: S,
      fieldValue: L,
      addInputId: de,
      removeInputId: Oe,
      resetField: te,
      clearValidate: Z,
      validate: j
    });
    return Mt(ur, ce), Nt(() => {
      n.prop && (l == null || l.addField(ce), m = WC(L.value));
    }), zn(() => {
      l == null || l.removeField(ce);
    }), t({
      size: r,
      validateMessage: v,
      validateState: d,
      validate: j,
      clearValidate: Z,
      resetField: te
    }), (ne, Y) => {
      var ve;
      return M(), G("div", {
        ref_key: "formItemRef",
        ref: h,
        class: z(c(w)),
        role: c(k) ? "group" : void 0,
        "aria-labelledby": c(k) ? c(s) : void 0
      }, [
        oe(c(GB), {
          "is-auto-width": c(C).width === "auto",
          "update-all": ((ve = c(l)) == null ? void 0 : ve.labelWidth) === "auto"
        }, {
          default: fe(() => [
            c(S) ? (M(), We(Qt(c(_) ? "label" : "div"), {
              key: 0,
              id: c(s),
              for: c(_),
              class: z(c(i).e("label")),
              style: bt(c(C))
            }, {
              default: fe(() => [
                Ie(ne.$slots, "label", { label: c(A) }, () => [
                  Ut(Qe(c(A)), 1)
                ])
              ]),
              _: 3
            }, 8, ["id", "for", "class", "style"])) : _e("v-if", !0)
          ]),
          _: 3
        }, 8, ["is-auto-width", "update-all"]),
        X("div", {
          class: z(c(i).e("content")),
          style: bt(c(g))
        }, [
          Ie(ne.$slots, "default"),
          oe(Ab, {
            name: `${c(i).namespace.value}-zoom-in-top`
          }, {
            default: fe(() => [
              c(W) ? Ie(ne.$slots, "error", {
                key: 0,
                error: v.value
              }, () => [
                X("div", {
                  class: z(c(y))
                }, Qe(v.value), 3)
              ]) : _e("v-if", !0)
            ]),
            _: 3
          }, 8, ["name"])
        ], 6)
      ], 10, XB);
    };
  }
});
var Uk = /* @__PURE__ */ ut(JB, [["__file", "form-item.vue"]]);
const jk = Yt(hB, {
  FormItem: Uk
}), qk = Jn(Uk);
let Ia;
const QB = `
  height:0 !important;
  visibility:hidden !important;
  ${ex() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`, e7 = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function t7(e) {
  const t = window.getComputedStyle(e), n = t.getPropertyValue("box-sizing"), o = Number.parseFloat(t.getPropertyValue("padding-bottom")) + Number.parseFloat(t.getPropertyValue("padding-top")), l = Number.parseFloat(t.getPropertyValue("border-bottom-width")) + Number.parseFloat(t.getPropertyValue("border-top-width"));
  return { contextStyle: e7.map((r) => `${r}:${t.getPropertyValue(r)}`).join(";"), paddingSize: o, borderSize: l, boxSizing: n };
}
function kw(e, t = 1, n) {
  var o;
  Ia || (Ia = document.createElement("textarea"), document.body.appendChild(Ia));
  const { paddingSize: l, borderSize: a, boxSizing: r, contextStyle: i } = t7(e);
  Ia.setAttribute("style", `${i};${QB}`), Ia.value = e.value || e.placeholder || "";
  let s = Ia.scrollHeight;
  const u = {};
  r === "border-box" ? s = s + a : r === "content-box" && (s = s - l), Ia.value = "";
  const d = Ia.scrollHeight - l;
  if (Ot(t)) {
    let f = d * t;
    r === "border-box" && (f = f + l + a), s = Math.max(f, s), u.minHeight = `${f}px`;
  }
  if (Ot(n)) {
    let f = d * n;
    r === "border-box" && (f = f + l + a), s = Math.min(f, s);
  }
  return u.height = `${s}px`, (o = Ia.parentNode) == null || o.removeChild(Ia), Ia = void 0, u;
}
const n7 = it({
  id: {
    type: String,
    default: void 0
  },
  size: Lo,
  disabled: Boolean,
  modelValue: {
    type: Ae([
      String,
      Number,
      Object
    ]),
    default: ""
  },
  maxlength: {
    type: [String, Number]
  },
  minlength: {
    type: [String, Number]
  },
  type: {
    type: String,
    default: "text"
  },
  resize: {
    type: String,
    values: ["none", "both", "horizontal", "vertical"]
  },
  autosize: {
    type: Ae([Boolean, Object]),
    default: !1
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  formatter: {
    type: Function
  },
  parser: {
    type: Function
  },
  placeholder: {
    type: String
  },
  form: {
    type: String
  },
  readonly: {
    type: Boolean,
    default: !1
  },
  clearable: {
    type: Boolean,
    default: !1
  },
  showPassword: {
    type: Boolean,
    default: !1
  },
  showWordLimit: {
    type: Boolean,
    default: !1
  },
  suffixIcon: {
    type: Dn
  },
  prefixIcon: {
    type: Dn
  },
  containerRole: {
    type: String,
    default: void 0
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  inputStyle: {
    type: Ae([Object, Array, String]),
    default: () => Zn({})
  },
  autofocus: {
    type: Boolean,
    default: !1
  },
  ...Zo(["ariaLabel"])
}), o7 = {
  [Jt]: (e) => on(e),
  input: (e) => on(e),
  change: (e) => on(e),
  focus: (e) => e instanceof FocusEvent,
  blur: (e) => e instanceof FocusEvent,
  clear: () => !0,
  mouseleave: (e) => e instanceof MouseEvent,
  mouseenter: (e) => e instanceof MouseEvent,
  keydown: (e) => e instanceof Event,
  compositionstart: (e) => e instanceof CompositionEvent,
  compositionupdate: (e) => e instanceof CompositionEvent,
  compositionend: (e) => e instanceof CompositionEvent
}, l7 = ["role"], a7 = ["id", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus"], r7 = ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus"], s7 = Q({
  name: "ElInput",
  inheritAttrs: !1
}), i7 = /* @__PURE__ */ Q({
  ...s7,
  props: n7,
  emits: o7,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = Ai(), a = Yn(), r = x(() => {
      const re = {};
      return o.containerRole === "combobox" && (re["aria-haspopup"] = l["aria-haspopup"], re["aria-owns"] = l["aria-owns"], re["aria-expanded"] = l["aria-expanded"]), re;
    }), i = x(() => [
      o.type === "textarea" ? C.b() : p.b(),
      p.m(h.value),
      p.is("disabled", m.value),
      p.is("exceed", de.value),
      {
        [p.b("group")]: a.prepend || a.append,
        [p.bm("group", "append")]: a.append,
        [p.bm("group", "prepend")]: a.prepend,
        [p.m("prefix")]: a.prefix || o.prefixIcon,
        [p.m("suffix")]: a.suffix || o.suffixIcon || o.clearable || o.showPassword,
        [p.bm("suffix", "password-clear")]: F.value && j.value,
        [p.b("hidden")]: o.type === "hidden"
      },
      l.class
    ]), s = x(() => [
      p.e("wrapper"),
      p.is("focus", L.value)
    ]), u = my({
      excludeKeys: x(() => Object.keys(r.value))
    }), { form: d, formItem: f } = ml(), { inputId: v } = Wa(o, {
      formItemContext: f
    }), h = Mo(), m = Nl(), p = nt("input"), C = nt("textarea"), g = An(), w = An(), b = B(!1), y = B(!1), E = B(!1), S = B(), _ = An(o.inputStyle), k = x(() => g.value || w.value), { wrapperRef: N, isFocused: L, handleFocus: R, handleBlur: H } = Bv(k, {
      afterBlur() {
        var re;
        o.validateEvent && ((re = f == null ? void 0 : f.validate) == null || re.call(f, "blur").catch((Te) => dn(Te)));
      }
    }), K = x(() => {
      var re;
      return (re = d == null ? void 0 : d.statusIcon) != null ? re : !1;
    }), U = x(() => (f == null ? void 0 : f.validateState) || ""), W = x(() => U.value && vy[U.value]), A = x(() => E.value ? tV : k8), $ = x(() => [
      l.style
    ]), D = x(() => [
      o.inputStyle,
      _.value,
      { resize: o.resize }
    ]), O = x(() => zo(o.modelValue) ? "" : String(o.modelValue)), F = x(() => o.clearable && !m.value && !o.readonly && !!O.value && (L.value || b.value)), j = x(() => o.showPassword && !m.value && !o.readonly && !!O.value && (!!O.value || L.value)), Z = x(() => o.showWordLimit && !!o.maxlength && (o.type === "text" || o.type === "textarea") && !m.value && !o.readonly && !o.showPassword), te = x(() => O.value.length), de = x(() => !!Z.value && te.value > Number(o.maxlength)), Oe = x(() => !!a.suffix || !!o.suffixIcon || F.value || o.showPassword || Z.value || !!U.value && K.value), [ce, ne] = I5(g);
    Xn(w, (re) => {
      if (ie(), !Z.value || o.resize !== "both")
        return;
      const Te = re[0], { width: Ce } = Te.contentRect;
      S.value = {
        right: `calc(100% - ${Ce + 15 + 6}px)`
      };
    });
    const Y = () => {
      const { type: re, autosize: Te } = o;
      if (!(!fn || re !== "textarea" || !w.value))
        if (Te) {
          const Ce = Mn(Te) ? Te.minRows : void 0, Le = Mn(Te) ? Te.maxRows : void 0, ge = kw(w.value, Ce, Le);
          _.value = {
            overflowY: "hidden",
            ...ge
          }, xe(() => {
            w.value.offsetHeight, _.value = ge;
          });
        } else
          _.value = {
            minHeight: kw(w.value).minHeight
          };
    }, ie = ((re) => {
      let Te = !1;
      return () => {
        var Ce;
        if (Te || !o.autosize)
          return;
        ((Ce = w.value) == null ? void 0 : Ce.offsetParent) === null || (re(), Te = !0);
      };
    })(Y), he = () => {
      const re = k.value, Te = o.formatter ? o.formatter(O.value) : O.value;
      !re || re.value === Te || (re.value = Te);
    }, De = async (re) => {
      ce();
      let { value: Te } = re.target;
      if (o.formatter && (Te = o.parser ? o.parser(Te) : Te), !y.value) {
        if (Te === O.value) {
          he();
          return;
        }
        n(Jt, Te), n("input", Te), await xe(), he(), ne();
      }
    }, $e = (re) => {
      n("change", re.target.value);
    }, ue = (re) => {
      n("compositionstart", re), y.value = !0;
    }, Ne = (re) => {
      var Te;
      n("compositionupdate", re);
      const Ce = (Te = re.target) == null ? void 0 : Te.value, Le = Ce[Ce.length - 1] || "";
      y.value = !hy(Le);
    }, je = (re) => {
      n("compositionend", re), y.value && (y.value = !1, De(re));
    }, Fe = () => {
      E.value = !E.value, Ve();
    }, Ve = async () => {
      var re;
      await xe(), (re = k.value) == null || re.focus();
    }, Ze = () => {
      var re;
      return (re = k.value) == null ? void 0 : re.blur();
    }, ae = (re) => {
      b.value = !1, n("mouseleave", re);
    }, pe = (re) => {
      b.value = !0, n("mouseenter", re);
    }, ke = (re) => {
      n("keydown", re);
    }, Ue = () => {
      var re;
      (re = k.value) == null || re.select();
    }, Xe = () => {
      n(Jt, ""), n("change", ""), n("clear"), n("input", "");
    };
    return Pe(() => o.modelValue, () => {
      var re;
      xe(() => Y()), o.validateEvent && ((re = f == null ? void 0 : f.validate) == null || re.call(f, "change").catch((Te) => dn(Te)));
    }), Pe(O, () => he()), Pe(() => o.type, async () => {
      await xe(), he(), Y();
    }), Nt(() => {
      !o.formatter && o.parser && dn("ElInput", "If you set the parser, you also need to set the formatter."), he(), xe(Y);
    }), Ho({
      from: "label",
      replacement: "aria-label",
      version: "2.8.0",
      scope: "el-input",
      ref: "https://element-plus.org/en-US/component/input.html"
    }, x(() => !!o.label)), t({
      input: g,
      textarea: w,
      ref: k,
      textareaStyle: D,
      autosize: Pn(o, "autosize"),
      focus: Ve,
      blur: Ze,
      select: Ue,
      clear: Xe,
      resizeTextarea: Y
    }), (re, Te) => (M(), G("div", Et(c(r), {
      class: c(i),
      style: c($),
      role: re.containerRole,
      onMouseenter: pe,
      onMouseleave: ae
    }), [
      _e(" input "),
      re.type !== "textarea" ? (M(), G(kt, { key: 0 }, [
        _e(" prepend slot "),
        re.$slots.prepend ? (M(), G("div", {
          key: 0,
          class: z(c(p).be("group", "prepend"))
        }, [
          Ie(re.$slots, "prepend")
        ], 2)) : _e("v-if", !0),
        X("div", {
          ref_key: "wrapperRef",
          ref: N,
          class: z(c(s))
        }, [
          _e(" prefix slot "),
          re.$slots.prefix || re.prefixIcon ? (M(), G("span", {
            key: 0,
            class: z(c(p).e("prefix"))
          }, [
            X("span", {
              class: z(c(p).e("prefix-inner"))
            }, [
              Ie(re.$slots, "prefix"),
              re.prefixIcon ? (M(), We(c(Ct), {
                key: 0,
                class: z(c(p).e("icon"))
              }, {
                default: fe(() => [
                  (M(), We(Qt(re.prefixIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : _e("v-if", !0)
            ], 2)
          ], 2)) : _e("v-if", !0),
          X("input", Et({
            id: c(v),
            ref_key: "input",
            ref: g,
            class: c(p).e("inner")
          }, c(u), {
            minlength: re.minlength,
            maxlength: re.maxlength,
            type: re.showPassword ? E.value ? "text" : "password" : re.type,
            disabled: c(m),
            readonly: re.readonly,
            autocomplete: re.autocomplete,
            tabindex: re.tabindex,
            "aria-label": re.label || re.ariaLabel,
            placeholder: re.placeholder,
            style: re.inputStyle,
            form: re.form,
            autofocus: re.autofocus,
            onCompositionstart: ue,
            onCompositionupdate: Ne,
            onCompositionend: je,
            onInput: De,
            onFocus: Te[0] || (Te[0] = (...Ce) => c(R) && c(R)(...Ce)),
            onBlur: Te[1] || (Te[1] = (...Ce) => c(H) && c(H)(...Ce)),
            onChange: $e,
            onKeydown: ke
          }), null, 16, a7),
          _e(" suffix slot "),
          c(Oe) ? (M(), G("span", {
            key: 1,
            class: z(c(p).e("suffix"))
          }, [
            X("span", {
              class: z(c(p).e("suffix-inner"))
            }, [
              !c(F) || !c(j) || !c(Z) ? (M(), G(kt, { key: 0 }, [
                Ie(re.$slots, "suffix"),
                re.suffixIcon ? (M(), We(c(Ct), {
                  key: 0,
                  class: z(c(p).e("icon"))
                }, {
                  default: fe(() => [
                    (M(), We(Qt(re.suffixIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : _e("v-if", !0)
              ], 64)) : _e("v-if", !0),
              c(F) ? (M(), We(c(Ct), {
                key: 1,
                class: z([c(p).e("icon"), c(p).e("clear")]),
                onMousedown: It(c(no), ["prevent"]),
                onClick: Xe
              }, {
                default: fe(() => [
                  oe(c(Ls))
                ]),
                _: 1
              }, 8, ["class", "onMousedown"])) : _e("v-if", !0),
              c(j) ? (M(), We(c(Ct), {
                key: 2,
                class: z([c(p).e("icon"), c(p).e("password")]),
                onClick: Fe
              }, {
                default: fe(() => [
                  (M(), We(Qt(c(A))))
                ]),
                _: 1
              }, 8, ["class"])) : _e("v-if", !0),
              c(Z) ? (M(), G("span", {
                key: 3,
                class: z(c(p).e("count"))
              }, [
                X("span", {
                  class: z(c(p).e("count-inner"))
                }, Qe(c(te)) + " / " + Qe(re.maxlength), 3)
              ], 2)) : _e("v-if", !0),
              c(U) && c(W) && c(K) ? (M(), We(c(Ct), {
                key: 4,
                class: z([
                  c(p).e("icon"),
                  c(p).e("validateIcon"),
                  c(p).is("loading", c(U) === "validating")
                ])
              }, {
                default: fe(() => [
                  (M(), We(Qt(c(W))))
                ]),
                _: 1
              }, 8, ["class"])) : _e("v-if", !0)
            ], 2)
          ], 2)) : _e("v-if", !0)
        ], 2),
        _e(" append slot "),
        re.$slots.append ? (M(), G("div", {
          key: 1,
          class: z(c(p).be("group", "append"))
        }, [
          Ie(re.$slots, "append")
        ], 2)) : _e("v-if", !0)
      ], 64)) : (M(), G(kt, { key: 1 }, [
        _e(" textarea "),
        X("textarea", Et({
          id: c(v),
          ref_key: "textarea",
          ref: w,
          class: c(C).e("inner")
        }, c(u), {
          minlength: re.minlength,
          maxlength: re.maxlength,
          tabindex: re.tabindex,
          disabled: c(m),
          readonly: re.readonly,
          autocomplete: re.autocomplete,
          style: c(D),
          "aria-label": re.label || re.ariaLabel,
          placeholder: re.placeholder,
          form: re.form,
          autofocus: re.autofocus,
          onCompositionstart: ue,
          onCompositionupdate: Ne,
          onCompositionend: je,
          onInput: De,
          onFocus: Te[2] || (Te[2] = (...Ce) => c(R) && c(R)(...Ce)),
          onBlur: Te[3] || (Te[3] = (...Ce) => c(H) && c(H)(...Ce)),
          onChange: $e,
          onKeydown: ke
        }), null, 16, r7),
        c(Z) ? (M(), G("span", {
          key: 0,
          style: bt(S.value),
          class: z(c(p).e("count"))
        }, Qe(c(te)) + " / " + Qe(re.maxlength), 7)) : _e("v-if", !0)
      ], 64))
    ], 16, l7));
  }
});
var c7 = /* @__PURE__ */ ut(i7, [["__file", "input.vue"]]);
const nl = Yt(c7), Xi = 4, Yk = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
}, u7 = ({
  move: e,
  size: t,
  bar: n
}) => ({
  [n.size]: t,
  transform: `translate${n.axis}(${e}%)`
}), Ay = Symbol("scrollbarContextKey"), d7 = it({
  vertical: Boolean,
  size: String,
  move: Number,
  ratio: {
    type: Number,
    required: !0
  },
  always: Boolean
}), f7 = "Thumb", p7 = /* @__PURE__ */ Q({
  __name: "thumb",
  props: d7,
  setup(e) {
    const t = e, n = ot(Ay), o = nt("scrollbar");
    n || lo(f7, "can not inject scrollbar context");
    const l = B(), a = B(), r = B({}), i = B(!1);
    let s = !1, u = !1, d = fn ? document.onselectstart : null;
    const f = x(() => Yk[t.vertical ? "vertical" : "horizontal"]), v = x(() => u7({
      size: t.size,
      move: t.move,
      bar: f.value
    })), h = x(() => l.value[f.value.offset] ** 2 / n.wrapElement[f.value.scrollSize] / t.ratio / a.value[f.value.offset]), m = (S) => {
      var _;
      if (S.stopPropagation(), S.ctrlKey || [1, 2].includes(S.button))
        return;
      (_ = window.getSelection()) == null || _.removeAllRanges(), C(S);
      const k = S.currentTarget;
      k && (r.value[f.value.axis] = k[f.value.offset] - (S[f.value.client] - k.getBoundingClientRect()[f.value.direction]));
    }, p = (S) => {
      if (!a.value || !l.value || !n.wrapElement)
        return;
      const _ = Math.abs(S.target.getBoundingClientRect()[f.value.direction] - S[f.value.client]), k = a.value[f.value.offset] / 2, N = (_ - k) * 100 * h.value / l.value[f.value.offset];
      n.wrapElement[f.value.scroll] = N * n.wrapElement[f.value.scrollSize] / 100;
    }, C = (S) => {
      S.stopImmediatePropagation(), s = !0, document.addEventListener("mousemove", g), document.addEventListener("mouseup", w), d = document.onselectstart, document.onselectstart = () => !1;
    }, g = (S) => {
      if (!l.value || !a.value || s === !1)
        return;
      const _ = r.value[f.value.axis];
      if (!_)
        return;
      const k = (l.value.getBoundingClientRect()[f.value.direction] - S[f.value.client]) * -1, N = a.value[f.value.offset] - _, L = (k - N) * 100 * h.value / l.value[f.value.offset];
      n.wrapElement[f.value.scroll] = L * n.wrapElement[f.value.scrollSize] / 100;
    }, w = () => {
      s = !1, r.value[f.value.axis] = 0, document.removeEventListener("mousemove", g), document.removeEventListener("mouseup", w), E(), u && (i.value = !1);
    }, b = () => {
      u = !1, i.value = !!t.size;
    }, y = () => {
      u = !0, i.value = s;
    };
    zn(() => {
      E(), document.removeEventListener("mouseup", w);
    });
    const E = () => {
      document.onselectstart !== d && (document.onselectstart = d);
    };
    return jn(Pn(n, "scrollbarElement"), "mousemove", b), jn(Pn(n, "scrollbarElement"), "mouseleave", y), (S, _) => (M(), We(Ko, {
      name: c(o).b("fade"),
      persisted: ""
    }, {
      default: fe(() => [
        Bt(X("div", {
          ref_key: "instance",
          ref: l,
          class: z([c(o).e("bar"), c(o).is(c(f).key)]),
          onMousedown: p
        }, [
          X("div", {
            ref_key: "thumb",
            ref: a,
            class: z(c(o).e("thumb")),
            style: bt(c(v)),
            onMousedown: m
          }, null, 38)
        ], 34), [
          [pn, S.always || i.value]
        ])
      ]),
      _: 1
    }, 8, ["name"]));
  }
});
var Tw = /* @__PURE__ */ ut(p7, [["__file", "thumb.vue"]]);
const v7 = it({
  always: {
    type: Boolean,
    default: !0
  },
  minSize: {
    type: Number,
    required: !0
  }
}), h7 = /* @__PURE__ */ Q({
  __name: "bar",
  props: v7,
  setup(e, { expose: t }) {
    const n = e, o = ot(Ay), l = B(0), a = B(0), r = B(""), i = B(""), s = B(1), u = B(1);
    return t({
      handleScroll: (v) => {
        if (v) {
          const h = v.offsetHeight - Xi, m = v.offsetWidth - Xi;
          a.value = v.scrollTop * 100 / h * s.value, l.value = v.scrollLeft * 100 / m * u.value;
        }
      },
      update: () => {
        const v = o == null ? void 0 : o.wrapElement;
        if (!v)
          return;
        const h = v.offsetHeight - Xi, m = v.offsetWidth - Xi, p = h ** 2 / v.scrollHeight, C = m ** 2 / v.scrollWidth, g = Math.max(p, n.minSize), w = Math.max(C, n.minSize);
        s.value = p / (h - p) / (g / (h - g)), u.value = C / (m - C) / (w / (m - w)), i.value = g + Xi < h ? `${g}px` : "", r.value = w + Xi < m ? `${w}px` : "";
      }
    }), (v, h) => (M(), G(kt, null, [
      oe(Tw, {
        move: l.value,
        ratio: u.value,
        size: r.value,
        always: v.always
      }, null, 8, ["move", "ratio", "size", "always"]),
      oe(Tw, {
        move: a.value,
        ratio: s.value,
        size: i.value,
        vertical: "",
        always: v.always
      }, null, 8, ["move", "ratio", "size", "always"])
    ], 64));
  }
});
var m7 = /* @__PURE__ */ ut(h7, [["__file", "bar.vue"]]);
const g7 = it({
  height: {
    type: [String, Number],
    default: ""
  },
  maxHeight: {
    type: [String, Number],
    default: ""
  },
  native: {
    type: Boolean,
    default: !1
  },
  wrapStyle: {
    type: Ae([String, Object, Array]),
    default: ""
  },
  wrapClass: {
    type: [String, Array],
    default: ""
  },
  viewClass: {
    type: [String, Array],
    default: ""
  },
  viewStyle: {
    type: [String, Array, Object],
    default: ""
  },
  noresize: Boolean,
  tag: {
    type: String,
    default: "div"
  },
  always: Boolean,
  minSize: {
    type: Number,
    default: 20
  },
  id: String,
  role: String,
  ...Zo(["ariaLabel", "ariaOrientation"])
}), b7 = {
  scroll: ({
    scrollTop: e,
    scrollLeft: t
  }) => [e, t].every(Ot)
}, wg = "ElScrollbar", y7 = Q({
  name: wg
}), C7 = /* @__PURE__ */ Q({
  ...y7,
  props: g7,
  emits: b7,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = nt("scrollbar");
    let a, r;
    const i = B(), s = B(), u = B(), d = B(), f = x(() => {
      const b = {};
      return o.height && (b.height = po(o.height)), o.maxHeight && (b.maxHeight = po(o.maxHeight)), [o.wrapStyle, b];
    }), v = x(() => [
      o.wrapClass,
      l.e("wrap"),
      { [l.em("wrap", "hidden-default")]: !o.native }
    ]), h = x(() => [l.e("view"), o.viewClass]), m = () => {
      var b;
      s.value && ((b = d.value) == null || b.handleScroll(s.value), n("scroll", {
        scrollTop: s.value.scrollTop,
        scrollLeft: s.value.scrollLeft
      }));
    };
    function p(b, y) {
      Mn(b) ? s.value.scrollTo(b) : Ot(b) && Ot(y) && s.value.scrollTo(b, y);
    }
    const C = (b) => {
      if (!Ot(b)) {
        dn(wg, "value must be a number");
        return;
      }
      s.value.scrollTop = b;
    }, g = (b) => {
      if (!Ot(b)) {
        dn(wg, "value must be a number");
        return;
      }
      s.value.scrollLeft = b;
    }, w = () => {
      var b;
      (b = d.value) == null || b.update();
    };
    return Pe(() => o.noresize, (b) => {
      b ? (a == null || a(), r == null || r()) : ({ stop: a } = Xn(u, w), r = jn("resize", w));
    }, { immediate: !0 }), Pe(() => [o.maxHeight, o.height], () => {
      o.native || xe(() => {
        var b;
        w(), s.value && ((b = d.value) == null || b.handleScroll(s.value));
      });
    }), Mt(Ay, en({
      scrollbarElement: i,
      wrapElement: s
    })), Nt(() => {
      o.native || xe(() => {
        w();
      });
    }), Pi(() => w()), t({
      wrapRef: s,
      update: w,
      scrollTo: p,
      setScrollTop: C,
      setScrollLeft: g,
      handleScroll: m
    }), (b, y) => (M(), G("div", {
      ref_key: "scrollbarRef",
      ref: i,
      class: z(c(l).b())
    }, [
      X("div", {
        ref_key: "wrapRef",
        ref: s,
        class: z(c(v)),
        style: bt(c(f)),
        onScroll: m
      }, [
        (M(), We(Qt(b.tag), {
          id: b.id,
          ref_key: "resizeRef",
          ref: u,
          class: z(c(h)),
          style: bt(b.viewStyle),
          role: b.role,
          "aria-label": b.ariaLabel,
          "aria-orientation": b.ariaOrientation
        }, {
          default: fe(() => [
            Ie(b.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
      ], 38),
      b.native ? _e("v-if", !0) : (M(), We(m7, {
        key: 0,
        ref_key: "barRef",
        ref: d,
        always: b.always,
        "min-size": b.minSize
      }, null, 8, ["always", "min-size"]))
    ], 2));
  }
});
var w7 = /* @__PURE__ */ ut(C7, [["__file", "scrollbar.vue"]]);
const zr = Yt(w7), Fy = Symbol("popper"), Gk = Symbol("popperContent"), E7 = [
  "dialog",
  "grid",
  "group",
  "listbox",
  "menu",
  "navigation",
  "tooltip",
  "tree"
], Xk = it({
  role: {
    type: String,
    values: E7,
    default: "tooltip"
  }
}), S7 = Q({
  name: "ElPopper",
  inheritAttrs: !1
}), _7 = /* @__PURE__ */ Q({
  ...S7,
  props: Xk,
  setup(e, { expose: t }) {
    const n = e, o = B(), l = B(), a = B(), r = B(), i = x(() => n.role), s = {
      triggerRef: o,
      popperInstanceRef: l,
      contentRef: a,
      referenceRef: r,
      role: i
    };
    return t(s), Mt(Fy, s), (u, d) => Ie(u.$slots, "default");
  }
});
var x7 = /* @__PURE__ */ ut(_7, [["__file", "popper.vue"]]);
const Zk = it({
  arrowOffset: {
    type: Number,
    default: 5
  }
}), k7 = Q({
  name: "ElPopperArrow",
  inheritAttrs: !1
}), T7 = /* @__PURE__ */ Q({
  ...k7,
  props: Zk,
  setup(e, { expose: t }) {
    const n = e, o = nt("popper"), { arrowOffset: l, arrowRef: a, arrowStyle: r } = ot(Gk, void 0);
    return Pe(() => n.arrowOffset, (i) => {
      l.value = i;
    }), zn(() => {
      a.value = void 0;
    }), t({
      arrowRef: a
    }), (i, s) => (M(), G("span", {
      ref_key: "arrowRef",
      ref: a,
      class: z(c(o).e("arrow")),
      style: bt(c(r)),
      "data-popper-arrow": ""
    }, null, 6));
  }
});
var $7 = /* @__PURE__ */ ut(T7, [["__file", "arrow.vue"]]);
const Gh = "ElOnlyChild", Jk = Q({
  name: Gh,
  setup(e, {
    slots: t,
    attrs: n
  }) {
    var o;
    const l = ot(_k), a = G6((o = l == null ? void 0 : l.setForwardRef) != null ? o : no);
    return () => {
      var r;
      const i = (r = t.default) == null ? void 0 : r.call(t, n);
      if (!i)
        return null;
      if (i.length > 1)
        return dn(Gh, "requires exact only one valid child."), null;
      const s = Qk(i);
      return s ? Bt(v3(s, n), [[a]]) : (dn(Gh, "no valid child node found"), null);
    };
  }
});
function Qk(e) {
  if (!e)
    return null;
  const t = e;
  for (const n of t) {
    if (Mn(n))
      switch (n.type) {
        case Pb:
          continue;
        case Fb:
        case "svg":
          return $w(n);
        case kt:
          return Qk(n.children);
        default:
          return n;
      }
    return $w(n);
  }
  return null;
}
function $w(e) {
  const t = nt("only-child");
  return oe("span", {
    class: t.e("content")
  }, [e]);
}
const eT = it({
  virtualRef: {
    type: Ae(Object)
  },
  virtualTriggering: Boolean,
  onMouseenter: {
    type: Ae(Function)
  },
  onMouseleave: {
    type: Ae(Function)
  },
  onClick: {
    type: Ae(Function)
  },
  onKeydown: {
    type: Ae(Function)
  },
  onFocus: {
    type: Ae(Function)
  },
  onBlur: {
    type: Ae(Function)
  },
  onContextmenu: {
    type: Ae(Function)
  },
  id: String,
  open: Boolean
}), O7 = Q({
  name: "ElPopperTrigger",
  inheritAttrs: !1
}), N7 = /* @__PURE__ */ Q({
  ...O7,
  props: eT,
  setup(e, { expose: t }) {
    const n = e, { role: o, triggerRef: l } = ot(Fy, void 0);
    Y6(l);
    const a = x(() => i.value ? n.id : void 0), r = x(() => {
      if (o && o.value === "tooltip")
        return n.open && n.id ? n.id : void 0;
    }), i = x(() => {
      if (o && o.value !== "tooltip")
        return o.value;
    }), s = x(() => i.value ? `${n.open}` : void 0);
    let u;
    return Nt(() => {
      Pe(() => n.virtualRef, (d) => {
        d && (l.value = Fl(d));
      }, {
        immediate: !0
      }), Pe(l, (d, f) => {
        u == null || u(), u = void 0, wa(d) && ([
          "onMouseenter",
          "onMouseleave",
          "onClick",
          "onKeydown",
          "onFocus",
          "onBlur",
          "onContextmenu"
        ].forEach((v) => {
          var h;
          const m = n[v];
          m && (d.addEventListener(v.slice(2).toLowerCase(), m), (h = f == null ? void 0 : f.removeEventListener) == null || h.call(f, v.slice(2).toLowerCase(), m));
        }), u = Pe([a, r, i, s], (v) => {
          [
            "aria-controls",
            "aria-describedby",
            "aria-haspopup",
            "aria-expanded"
          ].forEach((h, m) => {
            zo(v[m]) ? d.removeAttribute(h) : d.setAttribute(h, v[m]);
          });
        }, { immediate: !0 })), wa(f) && [
          "aria-controls",
          "aria-describedby",
          "aria-haspopup",
          "aria-expanded"
        ].forEach((v) => f.removeAttribute(v));
      }, {
        immediate: !0
      });
    }), zn(() => {
      u == null || u(), u = void 0;
    }), t({
      triggerRef: l
    }), (d, f) => d.virtualTriggering ? _e("v-if", !0) : (M(), We(c(Jk), Et({ key: 0 }, d.$attrs, {
      "aria-controls": c(a),
      "aria-describedby": c(r),
      "aria-expanded": c(s),
      "aria-haspopup": c(i)
    }), {
      default: fe(() => [
        Ie(d.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"]));
  }
});
var M7 = /* @__PURE__ */ ut(N7, [["__file", "trigger.vue"]]);
const Xh = "focus-trap.focus-after-trapped", Zh = "focus-trap.focus-after-released", I7 = "focus-trap.focusout-prevented", Ow = {
  cancelable: !0,
  bubbles: !1
}, R7 = {
  cancelable: !0,
  bubbles: !1
}, Nw = "focusAfterTrapped", Mw = "focusAfterReleased", Vy = Symbol("elFocusTrap"), By = B(), Wv = B(0), Hy = B(0);
let Uf = 0;
const tT = (e) => {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (o) => {
      const l = o.tagName === "INPUT" && o.type === "hidden";
      return o.disabled || o.hidden || l ? NodeFilter.FILTER_SKIP : o.tabIndex >= 0 || o === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); )
    t.push(n.currentNode);
  return t;
}, Iw = (e, t) => {
  for (const n of e)
    if (!D7(n, t))
      return n;
}, D7 = (e, t) => {
  if (process.env.NODE_ENV === "test")
    return !1;
  if (getComputedStyle(e).visibility === "hidden")
    return !0;
  for (; e; ) {
    if (t && e === t)
      return !1;
    if (getComputedStyle(e).display === "none")
      return !0;
    e = e.parentElement;
  }
  return !1;
}, L7 = (e) => {
  const t = tT(e), n = Iw(t, e), o = Iw(t.reverse(), e);
  return [n, o];
}, P7 = (e) => e instanceof HTMLInputElement && "select" in e, cs = (e, t) => {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), Hy.value = window.performance.now(), e !== n && P7(e) && t && e.select();
  }
};
function Rw(e, t) {
  const n = [...e], o = e.indexOf(t);
  return o !== -1 && n.splice(o, 1), n;
}
const A7 = () => {
  let e = [];
  return {
    push: (o) => {
      const l = e[0];
      l && o !== l && l.pause(), e = Rw(e, o), e.unshift(o);
    },
    remove: (o) => {
      var l, a;
      e = Rw(e, o), (a = (l = e[0]) == null ? void 0 : l.resume) == null || a.call(l);
    }
  };
}, F7 = (e, t = !1) => {
  const n = document.activeElement;
  for (const o of e)
    if (cs(o, t), document.activeElement !== n)
      return;
}, Dw = A7(), V7 = () => Wv.value > Hy.value, jf = () => {
  By.value = "pointer", Wv.value = window.performance.now();
}, Lw = () => {
  By.value = "keyboard", Wv.value = window.performance.now();
}, B7 = () => (Nt(() => {
  Uf === 0 && (document.addEventListener("mousedown", jf), document.addEventListener("touchstart", jf), document.addEventListener("keydown", Lw)), Uf++;
}), zn(() => {
  Uf--, Uf <= 0 && (document.removeEventListener("mousedown", jf), document.removeEventListener("touchstart", jf), document.removeEventListener("keydown", Lw));
}), {
  focusReason: By,
  lastUserFocusTimestamp: Wv,
  lastAutomatedFocusTimestamp: Hy
}), qf = (e) => new CustomEvent(I7, {
  ...R7,
  detail: e
}), H7 = Q({
  name: "ElFocusTrap",
  inheritAttrs: !1,
  props: {
    loop: Boolean,
    trapped: Boolean,
    focusTrapEl: Object,
    focusStartEl: {
      type: [Object, String],
      default: "first"
    }
  },
  emits: [
    Nw,
    Mw,
    "focusin",
    "focusout",
    "focusout-prevented",
    "release-requested"
  ],
  setup(e, { emit: t }) {
    const n = B();
    let o, l;
    const { focusReason: a } = B7();
    W6((m) => {
      e.trapped && !r.paused && t("release-requested", m);
    });
    const r = {
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    }, i = (m) => {
      if (!e.loop && !e.trapped || r.paused)
        return;
      const { key: p, altKey: C, ctrlKey: g, metaKey: w, currentTarget: b, shiftKey: y } = m, { loop: E } = e, S = p === xt.tab && !C && !g && !w, _ = document.activeElement;
      if (S && _) {
        const k = b, [N, L] = L7(k);
        if (N && L) {
          if (!y && _ === L) {
            const H = qf({
              focusReason: a.value
            });
            t("focusout-prevented", H), H.defaultPrevented || (m.preventDefault(), E && cs(N, !0));
          } else if (y && [N, k].includes(_)) {
            const H = qf({
              focusReason: a.value
            });
            t("focusout-prevented", H), H.defaultPrevented || (m.preventDefault(), E && cs(L, !0));
          }
        } else if (_ === k) {
          const H = qf({
            focusReason: a.value
          });
          t("focusout-prevented", H), H.defaultPrevented || m.preventDefault();
        }
      }
    };
    Mt(Vy, {
      focusTrapRef: n,
      onKeydown: i
    }), Pe(() => e.focusTrapEl, (m) => {
      m && (n.value = m);
    }, { immediate: !0 }), Pe([n], ([m], [p]) => {
      m && (m.addEventListener("keydown", i), m.addEventListener("focusin", d), m.addEventListener("focusout", f)), p && (p.removeEventListener("keydown", i), p.removeEventListener("focusin", d), p.removeEventListener("focusout", f));
    });
    const s = (m) => {
      t(Nw, m);
    }, u = (m) => t(Mw, m), d = (m) => {
      const p = c(n);
      if (!p)
        return;
      const C = m.target, g = m.relatedTarget, w = C && p.contains(C);
      e.trapped || g && p.contains(g) || (o = g), w && t("focusin", m), !r.paused && e.trapped && (w ? l = C : cs(l, !0));
    }, f = (m) => {
      const p = c(n);
      if (!(r.paused || !p))
        if (e.trapped) {
          const C = m.relatedTarget;
          !zo(C) && !p.contains(C) && setTimeout(() => {
            if (!r.paused && e.trapped) {
              const g = qf({
                focusReason: a.value
              });
              t("focusout-prevented", g), g.defaultPrevented || cs(l, !0);
            }
          }, 0);
        } else {
          const C = m.target;
          C && p.contains(C) || t("focusout", m);
        }
    };
    async function v() {
      await xe();
      const m = c(n);
      if (m) {
        Dw.push(r);
        const p = m.contains(document.activeElement) ? o : document.activeElement;
        if (o = p, !m.contains(p)) {
          const g = new Event(Xh, Ow);
          m.addEventListener(Xh, s), m.dispatchEvent(g), g.defaultPrevented || xe(() => {
            let w = e.focusStartEl;
            on(w) || (cs(w), document.activeElement !== w && (w = "first")), w === "first" && F7(tT(m), !0), (document.activeElement === p || w === "container") && cs(m);
          });
        }
      }
    }
    function h() {
      const m = c(n);
      if (m) {
        m.removeEventListener(Xh, s);
        const p = new CustomEvent(Zh, {
          ...Ow,
          detail: {
            focusReason: a.value
          }
        });
        m.addEventListener(Zh, u), m.dispatchEvent(p), !p.defaultPrevented && (a.value == "keyboard" || !V7() || m.contains(document.activeElement)) && cs(o ?? document.body), m.removeEventListener(Zh, u), Dw.remove(r);
      }
    }
    return Nt(() => {
      e.trapped && v(), Pe(() => e.trapped, (m) => {
        m ? v() : h();
      });
    }), zn(() => {
      e.trapped && h();
    }), {
      onKeydown: i
    };
  }
});
function z7(e, t, n, o, l, a) {
  return Ie(e.$slots, "default", { handleKeydown: e.onKeydown });
}
var pf = /* @__PURE__ */ ut(H7, [["render", z7], ["__file", "focus-trap.vue"]]);
const W7 = ["fixed", "absolute"], K7 = it({
  boundariesPadding: {
    type: Number,
    default: 0
  },
  fallbackPlacements: {
    type: Ae(Array),
    default: void 0
  },
  gpuAcceleration: {
    type: Boolean,
    default: !0
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    values: Hi,
    default: "bottom"
  },
  popperOptions: {
    type: Ae(Object),
    default: () => ({})
  },
  strategy: {
    type: String,
    values: W7,
    default: "absolute"
  }
}), nT = it({
  ...K7,
  id: String,
  style: {
    type: Ae([String, Array, Object])
  },
  className: {
    type: Ae([String, Array, Object])
  },
  effect: {
    type: String,
    default: "dark"
  },
  visible: Boolean,
  enterable: {
    type: Boolean,
    default: !0
  },
  pure: Boolean,
  focusOnShow: {
    type: Boolean,
    default: !1
  },
  trapping: {
    type: Boolean,
    default: !1
  },
  popperClass: {
    type: Ae([String, Array, Object])
  },
  popperStyle: {
    type: Ae([String, Array, Object])
  },
  referenceEl: {
    type: Ae(Object)
  },
  triggerTargetEl: {
    type: Ae(Object)
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: !0
  },
  virtualTriggering: Boolean,
  zIndex: Number,
  ...Zo(["ariaLabel"])
}), U7 = {
  mouseenter: (e) => e instanceof MouseEvent,
  mouseleave: (e) => e instanceof MouseEvent,
  focus: () => !0,
  blur: () => !0,
  close: () => !0
}, j7 = (e, t = []) => {
  const { placement: n, strategy: o, popperOptions: l } = e, a = {
    placement: n,
    strategy: o,
    ...l,
    modifiers: [...Y7(e), ...t]
  };
  return G7(a, l == null ? void 0 : l.modifiers), a;
}, q7 = (e) => {
  if (fn)
    return Fl(e);
};
function Y7(e) {
  const { offset: t, gpuAcceleration: n, fallbackPlacements: o } = e;
  return [
    {
      name: "offset",
      options: {
        offset: [0, t ?? 12]
      }
    },
    {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    },
    {
      name: "flip",
      options: {
        padding: 5,
        fallbackPlacements: o
      }
    },
    {
      name: "computeStyles",
      options: {
        gpuAcceleration: n
      }
    }
  ];
}
function G7(e, t) {
  t && (e.modifiers = [...e.modifiers, ...t ?? []]);
}
const X7 = 0, Z7 = (e) => {
  const { popperInstanceRef: t, contentRef: n, triggerRef: o, role: l } = ot(Fy, void 0), a = B(), r = B(), i = x(() => ({
    name: "eventListeners",
    enabled: !!e.visible
  })), s = x(() => {
    var g;
    const w = c(a), b = (g = c(r)) != null ? g : X7;
    return {
      name: "arrow",
      enabled: !Hx(w),
      options: {
        element: w,
        padding: b
      }
    };
  }), u = x(() => ({
    onFirstUpdate: () => {
      m();
    },
    ...j7(e, [
      c(s),
      c(i)
    ])
  })), d = x(() => q7(e.referenceEl) || c(o)), { attributes: f, state: v, styles: h, update: m, forceUpdate: p, instanceRef: C } = V6(d, n, u);
  return Pe(C, (g) => t.value = g), Nt(() => {
    Pe(() => {
      var g;
      return (g = c(d)) == null ? void 0 : g.getBoundingClientRect();
    }, () => {
      m();
    });
  }), {
    attributes: f,
    arrowRef: a,
    contentRef: n,
    instanceRef: C,
    state: v,
    styles: h,
    role: l,
    forceUpdate: p,
    update: m
  };
}, J7 = (e, {
  attributes: t,
  styles: n,
  role: o
}) => {
  const { nextZIndex: l } = au(), a = nt("popper"), r = x(() => c(t).popper), i = B(Ot(e.zIndex) ? e.zIndex : l()), s = x(() => [
    a.b(),
    a.is("pure", e.pure),
    a.is(e.effect),
    e.popperClass
  ]), u = x(() => [
    { zIndex: c(i) },
    c(n).popper,
    e.popperStyle || {}
  ]), d = x(() => o.value === "dialog" ? "false" : void 0), f = x(() => c(n).arrow || {});
  return {
    ariaModal: d,
    arrowStyle: f,
    contentAttrs: r,
    contentClass: s,
    contentStyle: u,
    contentZIndex: i,
    updateZIndex: () => {
      i.value = Ot(e.zIndex) ? e.zIndex : l();
    }
  };
}, Q7 = (e, t) => {
  const n = B(!1), o = B();
  return {
    focusStartRef: o,
    trapped: n,
    onFocusAfterReleased: (u) => {
      var d;
      ((d = u.detail) == null ? void 0 : d.focusReason) !== "pointer" && (o.value = "first", t("blur"));
    },
    onFocusAfterTrapped: () => {
      t("focus");
    },
    onFocusInTrap: (u) => {
      e.visible && !n.value && (u.target && (o.value = u.target), n.value = !0);
    },
    onFocusoutPrevented: (u) => {
      e.trapping || (u.detail.focusReason === "pointer" && u.preventDefault(), n.value = !1);
    },
    onReleaseRequested: () => {
      n.value = !1, t("close");
    }
  };
}, eH = Q({
  name: "ElPopperContent"
}), tH = /* @__PURE__ */ Q({
  ...eH,
  props: nT,
  emits: U7,
  setup(e, { expose: t, emit: n }) {
    const o = e, {
      focusStartRef: l,
      trapped: a,
      onFocusAfterReleased: r,
      onFocusAfterTrapped: i,
      onFocusInTrap: s,
      onFocusoutPrevented: u,
      onReleaseRequested: d
    } = Q7(o, n), { attributes: f, arrowRef: v, contentRef: h, styles: m, instanceRef: p, role: C, update: g } = Z7(o), {
      ariaModal: w,
      arrowStyle: b,
      contentAttrs: y,
      contentClass: E,
      contentStyle: S,
      updateZIndex: _
    } = J7(o, {
      styles: m,
      attributes: f,
      role: C
    }), k = ot(ur, void 0), N = B();
    Mt(Gk, {
      arrowStyle: b,
      arrowRef: v,
      arrowOffset: N
    }), k && (k.addInputId || k.removeInputId) && Mt(ur, {
      ...k,
      addInputId: no,
      removeInputId: no
    });
    let L;
    const R = (K = !0) => {
      g(), K && _();
    }, H = () => {
      R(!1), o.visible && o.focusOnShow ? a.value = !0 : o.visible === !1 && (a.value = !1);
    };
    return Nt(() => {
      Pe(() => o.triggerTargetEl, (K, U) => {
        L == null || L(), L = void 0;
        const W = c(K || h.value), A = c(U || h.value);
        wa(W) && (L = Pe([C, () => o.ariaLabel, w, () => o.id], ($) => {
          ["role", "aria-label", "aria-modal", "id"].forEach((D, O) => {
            zo($[O]) ? W.removeAttribute(D) : W.setAttribute(D, $[O]);
          });
        }, { immediate: !0 })), A !== W && wa(A) && ["role", "aria-label", "aria-modal", "id"].forEach(($) => {
          A.removeAttribute($);
        });
      }, { immediate: !0 }), Pe(() => o.visible, H, { immediate: !0 });
    }), zn(() => {
      L == null || L(), L = void 0;
    }), t({
      popperContentRef: h,
      popperInstanceRef: p,
      updatePopper: R,
      contentStyle: S
    }), (K, U) => (M(), G("div", Et({
      ref_key: "contentRef",
      ref: h
    }, c(y), {
      style: c(S),
      class: c(E),
      tabindex: "-1",
      onMouseenter: U[0] || (U[0] = (W) => K.$emit("mouseenter", W)),
      onMouseleave: U[1] || (U[1] = (W) => K.$emit("mouseleave", W))
    }), [
      oe(c(pf), {
        trapped: c(a),
        "trap-on-focus-in": !0,
        "focus-trap-el": c(h),
        "focus-start-el": c(l),
        onFocusAfterTrapped: c(i),
        onFocusAfterReleased: c(r),
        onFocusin: c(s),
        onFocusoutPrevented: c(u),
        onReleaseRequested: c(d)
      }, {
        default: fe(() => [
          Ie(K.$slots, "default")
        ]),
        _: 3
      }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
    ], 16));
  }
});
var nH = /* @__PURE__ */ ut(tH, [["__file", "content.vue"]]);
const oT = Yt(x7), Kv = Symbol("elTooltip"), Fo = it({
  ...j6,
  ...nT,
  appendTo: {
    type: Ae([String, Object])
  },
  content: {
    type: String,
    default: ""
  },
  rawContent: {
    type: Boolean,
    default: !1
  },
  persistent: Boolean,
  visible: {
    type: Ae(Boolean),
    default: null
  },
  transition: String,
  teleported: {
    type: Boolean,
    default: !0
  },
  disabled: Boolean,
  ...Zo(["ariaLabel"])
}), Ld = it({
  ...eT,
  disabled: Boolean,
  trigger: {
    type: Ae([String, Array]),
    default: "hover"
  },
  triggerKeys: {
    type: Ae(Array),
    default: () => [xt.enter, xt.space]
  }
}), {
  useModelToggleProps: oH,
  useModelToggleEmits: lH,
  useModelToggle: aH
} = uk("visible"), rH = it({
  ...Xk,
  ...oH,
  ...Fo,
  ...Ld,
  ...Zk,
  showArrow: {
    type: Boolean,
    default: !0
  }
}), sH = [
  ...lH,
  "before-show",
  "before-hide",
  "show",
  "hide",
  "open",
  "close"
], iH = (e, t) => Kt(e) ? e.includes(t) : e === t, Zi = (e, t, n) => (o) => {
  iH(c(e), t) && n(o);
}, cH = Q({
  name: "ElTooltipTrigger"
}), uH = /* @__PURE__ */ Q({
  ...cH,
  props: Ld,
  setup(e, { expose: t }) {
    const n = e, o = nt("tooltip"), { controlled: l, id: a, open: r, onOpen: i, onClose: s, onToggle: u } = ot(Kv, void 0), d = B(null), f = () => {
      if (c(l) || n.disabled)
        return !0;
    }, v = Pn(n, "trigger"), h = uo(f, Zi(v, "hover", i)), m = uo(f, Zi(v, "hover", s)), p = uo(f, Zi(v, "click", (y) => {
      y.button === 0 && u(y);
    })), C = uo(f, Zi(v, "focus", i)), g = uo(f, Zi(v, "focus", s)), w = uo(f, Zi(v, "contextmenu", (y) => {
      y.preventDefault(), u(y);
    })), b = uo(f, (y) => {
      const { code: E } = y;
      n.triggerKeys.includes(E) && (y.preventDefault(), u(y));
    });
    return t({
      triggerRef: d
    }), (y, E) => (M(), We(c(M7), {
      id: c(a),
      "virtual-ref": y.virtualRef,
      open: c(r),
      "virtual-triggering": y.virtualTriggering,
      class: z(c(o).e("trigger")),
      onBlur: c(g),
      onClick: c(p),
      onContextmenu: c(w),
      onFocus: c(C),
      onMouseenter: c(h),
      onMouseleave: c(m),
      onKeydown: c(b)
    }, {
      default: fe(() => [
        Ie(y.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]));
  }
});
var dH = /* @__PURE__ */ ut(uH, [["__file", "trigger.vue"]]);
const fH = Q({
  name: "ElTooltipContent",
  inheritAttrs: !1
}), pH = /* @__PURE__ */ Q({
  ...fH,
  props: Fo,
  setup(e, { expose: t }) {
    const n = e, { selector: o } = Sk(), l = nt("tooltip"), a = B(null), r = B(!1), {
      controlled: i,
      id: s,
      open: u,
      trigger: d,
      onClose: f,
      onOpen: v,
      onShow: h,
      onHide: m,
      onBeforeShow: p,
      onBeforeHide: C
    } = ot(Kv, void 0), g = x(() => n.transition || `${l.namespace.value}-fade-in-linear`), w = x(() => process.env.NODE_ENV === "test" ? !0 : n.persistent);
    zn(() => {
      r.value = !0;
    });
    const b = x(() => c(w) ? !0 : c(u)), y = x(() => n.disabled ? !1 : c(u)), E = x(() => n.appendTo || o.value), S = x(() => {
      var $;
      return ($ = n.style) != null ? $ : {};
    }), _ = x(() => !c(u)), k = () => {
      m();
    }, N = () => {
      if (c(i))
        return !0;
    }, L = uo(N, () => {
      n.enterable && c(d) === "hover" && v();
    }), R = uo(N, () => {
      c(d) === "hover" && f();
    }), H = () => {
      var $, D;
      (D = ($ = a.value) == null ? void 0 : $.updatePopper) == null || D.call($), p == null || p();
    }, K = () => {
      C == null || C();
    }, U = () => {
      h(), A = Hb(x(() => {
        var $;
        return ($ = a.value) == null ? void 0 : $.popperContentRef;
      }), () => {
        if (c(i))
          return;
        c(d) !== "hover" && f();
      });
    }, W = () => {
      n.virtualTriggering || f();
    };
    let A;
    return Pe(() => c(u), ($) => {
      $ || A == null || A();
    }, {
      flush: "post"
    }), Pe(() => n.content, () => {
      var $, D;
      (D = ($ = a.value) == null ? void 0 : $.updatePopper) == null || D.call($);
    }), t({
      contentRef: a
    }), ($, D) => (M(), We(ka, {
      disabled: !$.teleported,
      to: c(E)
    }, [
      oe(Ko, {
        name: c(g),
        onAfterLeave: k,
        onBeforeEnter: H,
        onAfterEnter: U,
        onBeforeLeave: K
      }, {
        default: fe(() => [
          c(b) ? Bt((M(), We(c(nH), Et({
            key: 0,
            id: c(s),
            ref_key: "contentRef",
            ref: a
          }, $.$attrs, {
            "aria-label": $.ariaLabel,
            "aria-hidden": c(_),
            "boundaries-padding": $.boundariesPadding,
            "fallback-placements": $.fallbackPlacements,
            "gpu-acceleration": $.gpuAcceleration,
            offset: $.offset,
            placement: $.placement,
            "popper-options": $.popperOptions,
            strategy: $.strategy,
            effect: $.effect,
            enterable: $.enterable,
            pure: $.pure,
            "popper-class": $.popperClass,
            "popper-style": [$.popperStyle, c(S)],
            "reference-el": $.referenceEl,
            "trigger-target-el": $.triggerTargetEl,
            visible: c(y),
            "z-index": $.zIndex,
            onMouseenter: c(L),
            onMouseleave: c(R),
            onBlur: W,
            onClose: c(f)
          }), {
            default: fe(() => [
              r.value ? _e("v-if", !0) : Ie($.$slots, "default", { key: 0 })
            ]),
            _: 3
          }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
            [pn, c(y)]
          ]) : _e("v-if", !0)
        ]),
        _: 3
      }, 8, ["name"])
    ], 8, ["disabled", "to"]));
  }
});
var vH = /* @__PURE__ */ ut(pH, [["__file", "content.vue"]]);
const hH = ["innerHTML"], mH = { key: 1 }, gH = Q({
  name: "ElTooltip"
}), bH = /* @__PURE__ */ Q({
  ...gH,
  props: rH,
  emits: sH,
  setup(e, { expose: t, emit: n }) {
    const o = e;
    U6();
    const l = il(), a = B(), r = B(), i = () => {
      var g;
      const w = c(a);
      w && ((g = w.popperInstanceRef) == null || g.update());
    }, s = B(!1), u = B(), { show: d, hide: f, hasUpdateHandler: v } = aH({
      indicator: s,
      toggleReason: u
    }), { onOpen: h, onClose: m } = q6({
      showAfter: Pn(o, "showAfter"),
      hideAfter: Pn(o, "hideAfter"),
      autoClose: Pn(o, "autoClose"),
      open: d,
      close: f
    }), p = x(() => $o(o.visible) && !v.value);
    Mt(Kv, {
      controlled: p,
      id: l,
      open: Ev(s),
      trigger: Pn(o, "trigger"),
      onOpen: (g) => {
        h(g);
      },
      onClose: (g) => {
        m(g);
      },
      onToggle: (g) => {
        c(s) ? m(g) : h(g);
      },
      onShow: () => {
        n("show", u.value);
      },
      onHide: () => {
        n("hide", u.value);
      },
      onBeforeShow: () => {
        n("before-show", u.value);
      },
      onBeforeHide: () => {
        n("before-hide", u.value);
      },
      updatePopper: i
    }), Pe(() => o.disabled, (g) => {
      g && s.value && (s.value = !1);
    });
    const C = (g) => {
      var w, b;
      const y = (b = (w = r.value) == null ? void 0 : w.contentRef) == null ? void 0 : b.popperContentRef, E = (g == null ? void 0 : g.relatedTarget) || document.activeElement;
      return y && y.contains(E);
    };
    return z2(() => s.value && f()), t({
      popperRef: a,
      contentRef: r,
      isFocusInsideContent: C,
      updatePopper: i,
      onOpen: h,
      onClose: m,
      hide: f
    }), (g, w) => (M(), We(c(oT), {
      ref_key: "popperRef",
      ref: a,
      role: g.role
    }, {
      default: fe(() => [
        oe(dH, {
          disabled: g.disabled,
          trigger: g.trigger,
          "trigger-keys": g.triggerKeys,
          "virtual-ref": g.virtualRef,
          "virtual-triggering": g.virtualTriggering
        }, {
          default: fe(() => [
            g.$slots.default ? Ie(g.$slots, "default", { key: 0 }) : _e("v-if", !0)
          ]),
          _: 3
        }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
        oe(vH, {
          ref_key: "contentRef",
          ref: r,
          "aria-label": g.ariaLabel,
          "boundaries-padding": g.boundariesPadding,
          content: g.content,
          disabled: g.disabled,
          effect: g.effect,
          enterable: g.enterable,
          "fallback-placements": g.fallbackPlacements,
          "hide-after": g.hideAfter,
          "gpu-acceleration": g.gpuAcceleration,
          offset: g.offset,
          persistent: g.persistent,
          "popper-class": g.popperClass,
          "popper-style": g.popperStyle,
          placement: g.placement,
          "popper-options": g.popperOptions,
          pure: g.pure,
          "raw-content": g.rawContent,
          "reference-el": g.referenceEl,
          "trigger-target-el": g.triggerTargetEl,
          "show-after": g.showAfter,
          strategy: g.strategy,
          teleported: g.teleported,
          transition: g.transition,
          "virtual-triggering": g.virtualTriggering,
          "z-index": g.zIndex,
          "append-to": g.appendTo
        }, {
          default: fe(() => [
            Ie(g.$slots, "content", {}, () => [
              g.rawContent ? (M(), G("span", {
                key: 0,
                innerHTML: g.content
              }, null, 8, hH)) : (M(), G("span", mH, Qe(g.content), 1))
            ]),
            g.showArrow ? (M(), We(c($7), {
              key: 0,
              "arrow-offset": g.arrowOffset
            }, null, 8, ["arrow-offset"])) : _e("v-if", !0)
          ]),
          _: 3
        }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
      ]),
      _: 3
    }, 8, ["role"]));
  }
});
var yH = /* @__PURE__ */ ut(bH, [["__file", "tooltip.vue"]]);
const hl = Yt(yH), CH = it({
  valueKey: {
    type: String,
    default: "value"
  },
  modelValue: {
    type: [String, Number],
    default: ""
  },
  debounce: {
    type: Number,
    default: 300
  },
  placement: {
    type: Ae(String),
    values: [
      "top",
      "top-start",
      "top-end",
      "bottom",
      "bottom-start",
      "bottom-end"
    ],
    default: "bottom-start"
  },
  fetchSuggestions: {
    type: Ae([Function, Array]),
    default: no
  },
  popperClass: {
    type: String,
    default: ""
  },
  triggerOnFocus: {
    type: Boolean,
    default: !0
  },
  selectWhenUnmatched: {
    type: Boolean,
    default: !1
  },
  hideLoading: {
    type: Boolean,
    default: !1
  },
  teleported: Fo.teleported,
  highlightFirstItem: {
    type: Boolean,
    default: !1
  },
  fitInputWidth: {
    type: Boolean,
    default: !1
  },
  clearable: {
    type: Boolean,
    default: !1
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  name: String,
  ...Zo(["ariaLabel"])
}), wH = {
  [Jt]: (e) => on(e),
  [kl]: (e) => on(e),
  [qn]: (e) => on(e),
  focus: (e) => e instanceof FocusEvent,
  blur: (e) => e instanceof FocusEvent,
  clear: () => !0,
  select: (e) => Mn(e)
}, EH = ["aria-expanded", "aria-owns"], SH = { key: 0 }, _H = ["id", "aria-selected", "onClick"], lT = "ElAutocomplete", xH = Q({
  name: lT,
  inheritAttrs: !1
}), kH = /* @__PURE__ */ Q({
  ...xH,
  props: CH,
  emits: wH,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = my(), a = Ai(), r = Nl(), i = nt("autocomplete"), s = B(), u = B(), d = B(), f = B();
    let v = !1, h = !1;
    const m = B([]), p = B(-1), C = B(""), g = B(!1), w = B(!1), b = B(!1), y = il(), E = x(() => a.style), S = x(() => (m.value.length > 0 || b.value) && g.value), _ = x(() => !o.hideLoading && b.value), k = x(() => s.value ? Array.from(s.value.$el.querySelectorAll("input")) : []), N = () => {
      S.value && (C.value = `${s.value.$el.offsetWidth}px`);
    }, L = () => {
      p.value = -1;
    }, H = Hl(async (ce) => {
      if (w.value)
        return;
      const ne = (Y) => {
        b.value = !1, !w.value && (Kt(Y) ? (m.value = Y, p.value = o.highlightFirstItem ? 0 : -1) : lo(lT, "autocomplete suggestions must be an array"));
      };
      if (b.value = !0, Kt(o.fetchSuggestions))
        ne(o.fetchSuggestions);
      else {
        const Y = await o.fetchSuggestions(ce, ne);
        Kt(Y) && ne(Y);
      }
    }, o.debounce), K = (ce) => {
      const ne = !!ce;
      if (n(kl, ce), n(Jt, ce), w.value = !1, g.value || (g.value = ne), !o.triggerOnFocus && !ce) {
        w.value = !0, m.value = [];
        return;
      }
      H(ce);
    }, U = (ce) => {
      var ne;
      r.value || (((ne = ce.target) == null ? void 0 : ne.tagName) !== "INPUT" || k.value.includes(document.activeElement)) && (g.value = !0);
    }, W = (ce) => {
      n(qn, ce);
    }, A = (ce) => {
      h ? h = !1 : (g.value = !0, n("focus", ce), o.triggerOnFocus && !v && H(String(o.modelValue)));
    }, $ = (ce) => {
      setTimeout(() => {
        var ne;
        if ((ne = d.value) != null && ne.isFocusInsideContent()) {
          h = !0;
          return;
        }
        g.value && j(), n("blur", ce);
      });
    }, D = () => {
      g.value = !1, n(Jt, ""), n("clear");
    }, O = async () => {
      S.value && p.value >= 0 && p.value < m.value.length ? de(m.value[p.value]) : o.selectWhenUnmatched && (n("select", { value: o.modelValue }), m.value = [], p.value = -1);
    }, F = (ce) => {
      S.value && (ce.preventDefault(), ce.stopPropagation(), j());
    }, j = () => {
      g.value = !1;
    }, Z = () => {
      var ce;
      (ce = s.value) == null || ce.focus();
    }, te = () => {
      var ce;
      (ce = s.value) == null || ce.blur();
    }, de = async (ce) => {
      n(kl, ce[o.valueKey]), n(Jt, ce[o.valueKey]), n("select", ce), m.value = [], p.value = -1;
    }, Oe = (ce) => {
      if (!S.value || b.value)
        return;
      if (ce < 0) {
        p.value = -1;
        return;
      }
      ce >= m.value.length && (ce = m.value.length - 1);
      const ne = u.value.querySelector(`.${i.be("suggestion", "wrap")}`), ve = ne.querySelectorAll(`.${i.be("suggestion", "list")} li`)[ce], ie = ne.scrollTop, { offsetTop: he, scrollHeight: De } = ve;
      he + De > ie + ne.clientHeight && (ne.scrollTop += De), he < ie && (ne.scrollTop -= De), p.value = ce, s.value.ref.setAttribute("aria-activedescendant", `${y.value}-item-${p.value}`);
    };
    return Hb(f, () => {
      S.value && j();
    }), Nt(() => {
      s.value.ref.setAttribute("role", "textbox"), s.value.ref.setAttribute("aria-autocomplete", "list"), s.value.ref.setAttribute("aria-controls", "id"), s.value.ref.setAttribute("aria-activedescendant", `${y.value}-item-${p.value}`), v = s.value.ref.hasAttribute("readonly");
    }), t({
      highlightedIndex: p,
      activated: g,
      loading: b,
      inputRef: s,
      popperRef: d,
      suggestions: m,
      handleSelect: de,
      handleKeyEnter: O,
      focus: Z,
      blur: te,
      close: j,
      highlight: Oe
    }), (ce, ne) => (M(), We(c(hl), {
      ref_key: "popperRef",
      ref: d,
      visible: c(S),
      placement: ce.placement,
      "fallback-placements": ["bottom-start", "top-start"],
      "popper-class": [c(i).e("popper"), ce.popperClass],
      teleported: ce.teleported,
      "gpu-acceleration": !1,
      pure: "",
      "manual-mode": "",
      effect: "light",
      trigger: "click",
      transition: `${c(i).namespace.value}-zoom-in-top`,
      persistent: "",
      role: "listbox",
      onBeforeShow: N,
      onHide: L
    }, {
      content: fe(() => [
        X("div", {
          ref_key: "regionRef",
          ref: u,
          class: z([c(i).b("suggestion"), c(i).is("loading", c(_))]),
          style: bt({
            [ce.fitInputWidth ? "width" : "minWidth"]: C.value,
            outline: "none"
          }),
          role: "region"
        }, [
          oe(c(zr), {
            id: c(y),
            tag: "ul",
            "wrap-class": c(i).be("suggestion", "wrap"),
            "view-class": c(i).be("suggestion", "list"),
            role: "listbox"
          }, {
            default: fe(() => [
              c(_) ? (M(), G("li", SH, [
                Ie(ce.$slots, "loading", {}, () => [
                  oe(c(Ct), {
                    class: z(c(i).is("loading"))
                  }, {
                    default: fe(() => [
                      oe(c(Ps))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ])
              ])) : (M(!0), G(kt, { key: 1 }, ln(m.value, (Y, ve) => (M(), G("li", {
                id: `${c(y)}-item-${ve}`,
                key: ve,
                class: z({ highlighted: p.value === ve }),
                role: "option",
                "aria-selected": p.value === ve,
                onClick: (ie) => de(Y)
              }, [
                Ie(ce.$slots, "default", { item: Y }, () => [
                  Ut(Qe(Y[ce.valueKey]), 1)
                ])
              ], 10, _H))), 128))
            ]),
            _: 3
          }, 8, ["id", "wrap-class", "view-class"])
        ], 6)
      ]),
      default: fe(() => [
        X("div", {
          ref_key: "listboxRef",
          ref: f,
          class: z([c(i).b(), ce.$attrs.class]),
          style: bt(c(E)),
          role: "combobox",
          "aria-haspopup": "listbox",
          "aria-expanded": c(S),
          "aria-owns": c(y)
        }, [
          oe(c(nl), Et({
            ref_key: "inputRef",
            ref: s
          }, c(l), {
            clearable: ce.clearable,
            disabled: c(r),
            name: ce.name,
            "model-value": ce.modelValue,
            "aria-label": ce.ariaLabel,
            onInput: K,
            onChange: W,
            onFocus: A,
            onBlur: $,
            onClear: D,
            onKeydown: [
              ne[0] || (ne[0] = Rn(It((Y) => Oe(p.value - 1), ["prevent"]), ["up"])),
              ne[1] || (ne[1] = Rn(It((Y) => Oe(p.value + 1), ["prevent"]), ["down"])),
              Rn(O, ["enter"]),
              Rn(j, ["tab"]),
              Rn(F, ["esc"])
            ],
            onMousedown: U
          }), rl({ _: 2 }, [
            ce.$slots.prepend ? {
              name: "prepend",
              fn: fe(() => [
                Ie(ce.$slots, "prepend")
              ])
            } : void 0,
            ce.$slots.append ? {
              name: "append",
              fn: fe(() => [
                Ie(ce.$slots, "append")
              ])
            } : void 0,
            ce.$slots.prefix ? {
              name: "prefix",
              fn: fe(() => [
                Ie(ce.$slots, "prefix")
              ])
            } : void 0,
            ce.$slots.suffix ? {
              name: "suffix",
              fn: fe(() => [
                Ie(ce.$slots, "suffix")
              ])
            } : void 0
          ]), 1040, ["clearable", "disabled", "name", "model-value", "aria-label", "onKeydown"])
        ], 14, EH)
      ]),
      _: 3
    }, 8, ["visible", "placement", "popper-class", "teleported", "transition"]));
  }
});
var TH = /* @__PURE__ */ ut(kH, [["__file", "autocomplete.vue"]]);
const $H = Yt(TH), OH = it({
  size: {
    type: [Number, String],
    values: fr,
    default: "",
    validator: (e) => Ot(e)
  },
  shape: {
    type: String,
    values: ["circle", "square"],
    default: "circle"
  },
  icon: {
    type: Dn
  },
  src: {
    type: String,
    default: ""
  },
  alt: String,
  srcSet: String,
  fit: {
    type: Ae(String),
    default: "cover"
  }
}), NH = {
  error: (e) => e instanceof Event
}, MH = ["src", "alt", "srcset"], IH = Q({
  name: "ElAvatar"
}), RH = /* @__PURE__ */ Q({
  ...IH,
  props: OH,
  emits: NH,
  setup(e, { emit: t }) {
    const n = e, o = nt("avatar"), l = B(!1), a = x(() => {
      const { size: u, icon: d, shape: f } = n, v = [o.b()];
      return on(u) && v.push(o.m(u)), d && v.push(o.m("icon")), f && v.push(o.m(f)), v;
    }), r = x(() => {
      const { size: u } = n;
      return Ot(u) ? o.cssVarBlock({
        size: po(u) || ""
      }) : void 0;
    }), i = x(() => ({
      objectFit: n.fit
    }));
    Pe(() => n.src, () => l.value = !1);
    function s(u) {
      l.value = !0, t("error", u);
    }
    return (u, d) => (M(), G("span", {
      class: z(c(a)),
      style: bt(c(r))
    }, [
      (u.src || u.srcSet) && !l.value ? (M(), G("img", {
        key: 0,
        src: u.src,
        alt: u.alt,
        srcset: u.srcSet,
        style: bt(c(i)),
        onError: s
      }, null, 44, MH)) : u.icon ? (M(), We(c(Ct), { key: 1 }, {
        default: fe(() => [
          (M(), We(Qt(u.icon)))
        ]),
        _: 1
      })) : Ie(u.$slots, "default", { key: 2 })
    ], 6));
  }
});
var DH = /* @__PURE__ */ ut(RH, [["__file", "avatar.vue"]]);
const LH = Yt(DH), PH = {
  visibilityHeight: {
    type: Number,
    default: 200
  },
  target: {
    type: String,
    default: ""
  },
  right: {
    type: Number,
    default: 40
  },
  bottom: {
    type: Number,
    default: 40
  }
}, AH = {
  click: (e) => e instanceof MouseEvent
}, FH = (e, t, n) => {
  const o = An(), l = An(), a = B(!1), r = () => {
    o.value && (a.value = o.value.scrollTop >= e.visibilityHeight);
  }, i = (u) => {
    var d;
    (d = o.value) == null || d.scrollTo({ top: 0, behavior: "smooth" }), t("click", u);
  }, s = X2(r, 300, !0);
  return jn(l, "scroll", s), Nt(() => {
    var u;
    l.value = document, o.value = document.documentElement, e.target && (o.value = (u = document.querySelector(e.target)) != null ? u : void 0, o.value || lo(n, `target does not exist: ${e.target}`), l.value = o.value), r();
  }), {
    visible: a,
    handleClick: i
  };
}, aT = "ElBacktop", VH = Q({
  name: aT
}), BH = /* @__PURE__ */ Q({
  ...VH,
  props: PH,
  emits: AH,
  setup(e, { emit: t }) {
    const n = e, o = nt("backtop"), { handleClick: l, visible: a } = FH(n, t, aT), r = x(() => ({
      right: `${n.right}px`,
      bottom: `${n.bottom}px`
    }));
    return (i, s) => (M(), We(Ko, {
      name: `${c(o).namespace.value}-fade-in`
    }, {
      default: fe(() => [
        c(a) ? (M(), G("div", {
          key: 0,
          style: bt(c(r)),
          class: z(c(o).b()),
          onClick: s[0] || (s[0] = It((...u) => c(l) && c(l)(...u), ["stop"]))
        }, [
          Ie(i.$slots, "default", {}, () => [
            oe(c(Ct), {
              class: z(c(o).e("icon"))
            }, {
              default: fe(() => [
                oe(c(i8))
              ]),
              _: 1
            }, 8, ["class"])
          ])
        ], 6)) : _e("v-if", !0)
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
var HH = /* @__PURE__ */ ut(BH, [["__file", "backtop.vue"]]);
const zH = Yt(HH), WH = it({
  value: {
    type: [String, Number],
    default: ""
  },
  max: {
    type: Number,
    default: 99
  },
  isDot: Boolean,
  hidden: Boolean,
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger"],
    default: "danger"
  },
  showZero: {
    type: Boolean,
    default: !0
  },
  color: String,
  dotStyle: {
    type: Ae([String, Object, Array])
  },
  badgeStyle: {
    type: Ae([String, Object, Array])
  },
  offset: {
    type: Ae(Array),
    default: [0, 0]
  },
  dotClass: {
    type: String
  },
  badgeClass: {
    type: String
  }
}), KH = ["textContent"], UH = Q({
  name: "ElBadge"
}), jH = /* @__PURE__ */ Q({
  ...UH,
  props: WH,
  setup(e, { expose: t }) {
    const n = e, o = nt("badge"), l = x(() => n.isDot ? "" : Ot(n.value) && Ot(n.max) ? n.max < n.value ? `${n.max}+` : n.value === 0 && !n.showZero ? "" : `${n.value}` : `${n.value}`), a = x(() => {
      var r, i, s, u, d, f;
      return [
        {
          backgroundColor: n.color,
          marginRight: po(-((i = (r = n.offset) == null ? void 0 : r[0]) != null ? i : 0)),
          marginTop: po((u = (s = n.offset) == null ? void 0 : s[1]) != null ? u : 0)
        },
        (d = n.dotStyle) != null ? d : {},
        (f = n.badgeStyle) != null ? f : {}
      ];
    });
    return Ho({
      from: "dot-style",
      replacement: "badge-style",
      version: "2.8.0",
      scope: "el-badge",
      ref: "https://element-plus.org/en-US/component/badge.html"
    }, x(() => !!n.dotStyle)), Ho({
      from: "dot-class",
      replacement: "badge-class",
      version: "2.8.0",
      scope: "el-badge",
      ref: "https://element-plus.org/en-US/component/badge.html"
    }, x(() => !!n.dotClass)), t({
      content: l
    }), (r, i) => (M(), G("div", {
      class: z(c(o).b())
    }, [
      Ie(r.$slots, "default"),
      oe(Ko, {
        name: `${c(o).namespace.value}-zoom-in-center`,
        persisted: ""
      }, {
        default: fe(() => [
          Bt(X("sup", {
            class: z([
              c(o).e("content"),
              c(o).em("content", r.type),
              c(o).is("fixed", !!r.$slots.default),
              c(o).is("dot", r.isDot),
              r.dotClass,
              r.badgeClass
            ]),
            style: bt(c(a)),
            textContent: Qe(c(l))
          }, null, 14, KH), [
            [pn, !r.hidden && (c(l) || r.isDot)]
          ])
        ]),
        _: 1
      }, 8, ["name"])
    ], 2));
  }
});
var qH = /* @__PURE__ */ ut(jH, [["__file", "badge.vue"]]);
const zy = Yt(qH), rT = Symbol("breadcrumbKey"), YH = it({
  separator: {
    type: String,
    default: "/"
  },
  separatorIcon: {
    type: Dn
  }
}), GH = ["aria-label"], XH = Q({
  name: "ElBreadcrumb"
}), ZH = /* @__PURE__ */ Q({
  ...XH,
  props: YH,
  setup(e) {
    const t = e, { t: n } = bn(), o = nt("breadcrumb"), l = B();
    return Mt(rT, t), Nt(() => {
      const a = l.value.querySelectorAll(`.${o.e("item")}`);
      a.length && a[a.length - 1].setAttribute("aria-current", "page");
    }), (a, r) => (M(), G("div", {
      ref_key: "breadcrumb",
      ref: l,
      class: z(c(o).b()),
      "aria-label": c(n)("el.breadcrumb.label"),
      role: "navigation"
    }, [
      Ie(a.$slots, "default")
    ], 10, GH));
  }
});
var JH = /* @__PURE__ */ ut(ZH, [["__file", "breadcrumb.vue"]]);
const QH = it({
  to: {
    type: Ae([String, Object]),
    default: ""
  },
  replace: {
    type: Boolean,
    default: !1
  }
}), ez = Q({
  name: "ElBreadcrumbItem"
}), tz = /* @__PURE__ */ Q({
  ...ez,
  props: QH,
  setup(e) {
    const t = e, n = Pt(), o = ot(rT, void 0), l = nt("breadcrumb"), a = n.appContext.config.globalProperties.$router, r = B(), i = () => {
      !t.to || !a || (t.replace ? a.replace(t.to) : a.push(t.to));
    };
    return (s, u) => {
      var d, f;
      return M(), G("span", {
        class: z(c(l).e("item"))
      }, [
        X("span", {
          ref_key: "link",
          ref: r,
          class: z([c(l).e("inner"), c(l).is("link", !!s.to)]),
          role: "link",
          onClick: i
        }, [
          Ie(s.$slots, "default")
        ], 2),
        (d = c(o)) != null && d.separatorIcon ? (M(), We(c(Ct), {
          key: 0,
          class: z(c(l).e("separator"))
        }, {
          default: fe(() => [
            (M(), We(Qt(c(o).separatorIcon)))
          ]),
          _: 1
        }, 8, ["class"])) : (M(), G("span", {
          key: 1,
          class: z(c(l).e("separator")),
          role: "presentation"
        }, Qe((f = c(o)) == null ? void 0 : f.separator), 3))
      ], 2);
    };
  }
});
var sT = /* @__PURE__ */ ut(tz, [["__file", "breadcrumb-item.vue"]]);
const nz = Yt(JH, {
  BreadcrumbItem: sT
}), oz = Jn(sT), iT = Symbol("buttonGroupContextKey"), lz = (e, t) => {
  Ho({
    from: "type.text",
    replacement: "link",
    version: "3.0.0",
    scope: "props",
    ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
  }, x(() => e.type === "text"));
  const n = ot(iT, void 0), o = df("button"), { form: l } = ml(), a = Mo(x(() => n == null ? void 0 : n.size)), r = Nl(), i = B(), s = Yn(), u = x(() => e.type || (n == null ? void 0 : n.type) || ""), d = x(() => {
    var m, p, C;
    return (C = (p = e.autoInsertSpace) != null ? p : (m = o.value) == null ? void 0 : m.autoInsertSpace) != null ? C : !1;
  }), f = x(() => e.tag === "button" ? {
    ariaDisabled: r.value || e.loading,
    disabled: r.value || e.loading,
    autofocus: e.autofocus,
    type: e.nativeType
  } : {}), v = x(() => {
    var m;
    const p = (m = s.default) == null ? void 0 : m.call(s);
    if (d.value && (p == null ? void 0 : p.length) === 1) {
      const C = p[0];
      if ((C == null ? void 0 : C.type) === Fb) {
        const g = C.children;
        return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(g.trim());
      }
    }
    return !1;
  });
  return {
    _disabled: r,
    _size: a,
    _type: u,
    _ref: i,
    _props: f,
    shouldAddSpace: v,
    handleClick: (m) => {
      e.nativeType === "reset" && (l == null || l.resetFields()), t("click", m);
    }
  };
}, Eg = [
  "default",
  "primary",
  "success",
  "warning",
  "info",
  "danger",
  "text",
  ""
], az = ["button", "submit", "reset"], Sg = it({
  size: Lo,
  disabled: Boolean,
  type: {
    type: String,
    values: Eg,
    default: ""
  },
  icon: {
    type: Dn
  },
  nativeType: {
    type: String,
    values: az,
    default: "button"
  },
  loading: Boolean,
  loadingIcon: {
    type: Dn,
    default: () => Ps
  },
  plain: Boolean,
  text: Boolean,
  link: Boolean,
  bg: Boolean,
  autofocus: Boolean,
  round: Boolean,
  circle: Boolean,
  color: String,
  dark: Boolean,
  autoInsertSpace: {
    type: Boolean,
    default: void 0
  },
  tag: {
    type: Ae([String, Object]),
    default: "button"
  }
}), rz = {
  click: (e) => e instanceof MouseEvent
};
function ll(e, t) {
  sz(e) && (e = "100%");
  var n = iz(e);
  return e = t === 360 ? e : Math.min(t, Math.max(0, parseFloat(e))), n && (e = parseInt(String(e * t), 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : (t === 360 ? e = (e < 0 ? e % t + t : e % t) / parseFloat(String(t)) : e = e % t / parseFloat(String(t)), e);
}
function Yf(e) {
  return Math.min(1, Math.max(0, e));
}
function sz(e) {
  return typeof e == "string" && e.indexOf(".") !== -1 && parseFloat(e) === 1;
}
function iz(e) {
  return typeof e == "string" && e.indexOf("%") !== -1;
}
function cT(e) {
  return e = parseFloat(e), (isNaN(e) || e < 0 || e > 1) && (e = 1), e;
}
function Gf(e) {
  return e <= 1 ? "".concat(Number(e) * 100, "%") : e;
}
function si(e) {
  return e.length === 1 ? "0" + e : String(e);
}
function cz(e, t, n) {
  return {
    r: ll(e, 255) * 255,
    g: ll(t, 255) * 255,
    b: ll(n, 255) * 255
  };
}
function Pw(e, t, n) {
  e = ll(e, 255), t = ll(t, 255), n = ll(n, 255);
  var o = Math.max(e, t, n), l = Math.min(e, t, n), a = 0, r = 0, i = (o + l) / 2;
  if (o === l)
    r = 0, a = 0;
  else {
    var s = o - l;
    switch (r = i > 0.5 ? s / (2 - o - l) : s / (o + l), o) {
      case e:
        a = (t - n) / s + (t < n ? 6 : 0);
        break;
      case t:
        a = (n - e) / s + 2;
        break;
      case n:
        a = (e - t) / s + 4;
        break;
    }
    a /= 6;
  }
  return { h: a, s: r, l: i };
}
function Jh(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * (6 * n) : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function uz(e, t, n) {
  var o, l, a;
  if (e = ll(e, 360), t = ll(t, 100), n = ll(n, 100), t === 0)
    l = n, a = n, o = n;
  else {
    var r = n < 0.5 ? n * (1 + t) : n + t - n * t, i = 2 * n - r;
    o = Jh(i, r, e + 1 / 3), l = Jh(i, r, e), a = Jh(i, r, e - 1 / 3);
  }
  return { r: o * 255, g: l * 255, b: a * 255 };
}
function Aw(e, t, n) {
  e = ll(e, 255), t = ll(t, 255), n = ll(n, 255);
  var o = Math.max(e, t, n), l = Math.min(e, t, n), a = 0, r = o, i = o - l, s = o === 0 ? 0 : i / o;
  if (o === l)
    a = 0;
  else {
    switch (o) {
      case e:
        a = (t - n) / i + (t < n ? 6 : 0);
        break;
      case t:
        a = (n - e) / i + 2;
        break;
      case n:
        a = (e - t) / i + 4;
        break;
    }
    a /= 6;
  }
  return { h: a, s, v: r };
}
function dz(e, t, n) {
  e = ll(e, 360) * 6, t = ll(t, 100), n = ll(n, 100);
  var o = Math.floor(e), l = e - o, a = n * (1 - t), r = n * (1 - l * t), i = n * (1 - (1 - l) * t), s = o % 6, u = [n, r, a, a, i, n][s], d = [i, n, n, r, a, a][s], f = [a, a, i, n, n, r][s];
  return { r: u * 255, g: d * 255, b: f * 255 };
}
function Fw(e, t, n, o) {
  var l = [
    si(Math.round(e).toString(16)),
    si(Math.round(t).toString(16)),
    si(Math.round(n).toString(16))
  ];
  return o && l[0].startsWith(l[0].charAt(1)) && l[1].startsWith(l[1].charAt(1)) && l[2].startsWith(l[2].charAt(1)) ? l[0].charAt(0) + l[1].charAt(0) + l[2].charAt(0) : l.join("");
}
function fz(e, t, n, o, l) {
  var a = [
    si(Math.round(e).toString(16)),
    si(Math.round(t).toString(16)),
    si(Math.round(n).toString(16)),
    si(pz(o))
  ];
  return l && a[0].startsWith(a[0].charAt(1)) && a[1].startsWith(a[1].charAt(1)) && a[2].startsWith(a[2].charAt(1)) && a[3].startsWith(a[3].charAt(1)) ? a[0].charAt(0) + a[1].charAt(0) + a[2].charAt(0) + a[3].charAt(0) : a.join("");
}
function pz(e) {
  return Math.round(parseFloat(e) * 255).toString(16);
}
function Vw(e) {
  return jl(e) / 255;
}
function jl(e) {
  return parseInt(e, 16);
}
function vz(e) {
  return {
    r: e >> 16,
    g: (e & 65280) >> 8,
    b: e & 255
  };
}
var _g = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function hz(e) {
  var t = { r: 0, g: 0, b: 0 }, n = 1, o = null, l = null, a = null, r = !1, i = !1;
  return typeof e == "string" && (e = bz(e)), typeof e == "object" && (Er(e.r) && Er(e.g) && Er(e.b) ? (t = cz(e.r, e.g, e.b), r = !0, i = String(e.r).substr(-1) === "%" ? "prgb" : "rgb") : Er(e.h) && Er(e.s) && Er(e.v) ? (o = Gf(e.s), l = Gf(e.v), t = dz(e.h, o, l), r = !0, i = "hsv") : Er(e.h) && Er(e.s) && Er(e.l) && (o = Gf(e.s), a = Gf(e.l), t = uz(e.h, o, a), r = !0, i = "hsl"), Object.prototype.hasOwnProperty.call(e, "a") && (n = e.a)), n = cT(n), {
    ok: r,
    format: e.format || i,
    r: Math.min(255, Math.max(t.r, 0)),
    g: Math.min(255, Math.max(t.g, 0)),
    b: Math.min(255, Math.max(t.b, 0)),
    a: n
  };
}
var mz = "[-\\+]?\\d+%?", gz = "[-\\+]?\\d*\\.\\d+%?", hs = "(?:".concat(gz, ")|(?:").concat(mz, ")"), Qh = "[\\s|\\(]+(".concat(hs, ")[,|\\s]+(").concat(hs, ")[,|\\s]+(").concat(hs, ")\\s*\\)?"), em = "[\\s|\\(]+(".concat(hs, ")[,|\\s]+(").concat(hs, ")[,|\\s]+(").concat(hs, ")[,|\\s]+(").concat(hs, ")\\s*\\)?"), Da = {
  CSS_UNIT: new RegExp(hs),
  rgb: new RegExp("rgb" + Qh),
  rgba: new RegExp("rgba" + em),
  hsl: new RegExp("hsl" + Qh),
  hsla: new RegExp("hsla" + em),
  hsv: new RegExp("hsv" + Qh),
  hsva: new RegExp("hsva" + em),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function bz(e) {
  if (e = e.trim().toLowerCase(), e.length === 0)
    return !1;
  var t = !1;
  if (_g[e])
    e = _g[e], t = !0;
  else if (e === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var n = Da.rgb.exec(e);
  return n ? { r: n[1], g: n[2], b: n[3] } : (n = Da.rgba.exec(e), n ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = Da.hsl.exec(e), n ? { h: n[1], s: n[2], l: n[3] } : (n = Da.hsla.exec(e), n ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = Da.hsv.exec(e), n ? { h: n[1], s: n[2], v: n[3] } : (n = Da.hsva.exec(e), n ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = Da.hex8.exec(e), n ? {
    r: jl(n[1]),
    g: jl(n[2]),
    b: jl(n[3]),
    a: Vw(n[4]),
    format: t ? "name" : "hex8"
  } : (n = Da.hex6.exec(e), n ? {
    r: jl(n[1]),
    g: jl(n[2]),
    b: jl(n[3]),
    format: t ? "name" : "hex"
  } : (n = Da.hex4.exec(e), n ? {
    r: jl(n[1] + n[1]),
    g: jl(n[2] + n[2]),
    b: jl(n[3] + n[3]),
    a: Vw(n[4] + n[4]),
    format: t ? "name" : "hex8"
  } : (n = Da.hex3.exec(e), n ? {
    r: jl(n[1] + n[1]),
    g: jl(n[2] + n[2]),
    b: jl(n[3] + n[3]),
    format: t ? "name" : "hex"
  } : !1)))))))));
}
function Er(e) {
  return !!Da.CSS_UNIT.exec(String(e));
}
var uT = (
  /** @class */
  function() {
    function e(t, n) {
      t === void 0 && (t = ""), n === void 0 && (n = {});
      var o;
      if (t instanceof e)
        return t;
      typeof t == "number" && (t = vz(t)), this.originalInput = t;
      var l = hz(t);
      this.originalInput = t, this.r = l.r, this.g = l.g, this.b = l.b, this.a = l.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (o = n.format) !== null && o !== void 0 ? o : l.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = l.ok;
    }
    return e.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, e.prototype.isLight = function() {
      return !this.isDark();
    }, e.prototype.getBrightness = function() {
      var t = this.toRgb();
      return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3;
    }, e.prototype.getLuminance = function() {
      var t = this.toRgb(), n, o, l, a = t.r / 255, r = t.g / 255, i = t.b / 255;
      return a <= 0.03928 ? n = a / 12.92 : n = Math.pow((a + 0.055) / 1.055, 2.4), r <= 0.03928 ? o = r / 12.92 : o = Math.pow((r + 0.055) / 1.055, 2.4), i <= 0.03928 ? l = i / 12.92 : l = Math.pow((i + 0.055) / 1.055, 2.4), 0.2126 * n + 0.7152 * o + 0.0722 * l;
    }, e.prototype.getAlpha = function() {
      return this.a;
    }, e.prototype.setAlpha = function(t) {
      return this.a = cT(t), this.roundA = Math.round(100 * this.a) / 100, this;
    }, e.prototype.isMonochrome = function() {
      var t = this.toHsl().s;
      return t === 0;
    }, e.prototype.toHsv = function() {
      var t = Aw(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, v: t.v, a: this.a };
    }, e.prototype.toHsvString = function() {
      var t = Aw(this.r, this.g, this.b), n = Math.round(t.h * 360), o = Math.round(t.s * 100), l = Math.round(t.v * 100);
      return this.a === 1 ? "hsv(".concat(n, ", ").concat(o, "%, ").concat(l, "%)") : "hsva(".concat(n, ", ").concat(o, "%, ").concat(l, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHsl = function() {
      var t = Pw(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, l: t.l, a: this.a };
    }, e.prototype.toHslString = function() {
      var t = Pw(this.r, this.g, this.b), n = Math.round(t.h * 360), o = Math.round(t.s * 100), l = Math.round(t.l * 100);
      return this.a === 1 ? "hsl(".concat(n, ", ").concat(o, "%, ").concat(l, "%)") : "hsla(".concat(n, ", ").concat(o, "%, ").concat(l, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHex = function(t) {
      return t === void 0 && (t = !1), Fw(this.r, this.g, this.b, t);
    }, e.prototype.toHexString = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex(t);
    }, e.prototype.toHex8 = function(t) {
      return t === void 0 && (t = !1), fz(this.r, this.g, this.b, this.a, t);
    }, e.prototype.toHex8String = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex8(t);
    }, e.prototype.toHexShortString = function(t) {
      return t === void 0 && (t = !1), this.a === 1 ? this.toHexString(t) : this.toHex8String(t);
    }, e.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, e.prototype.toRgbString = function() {
      var t = Math.round(this.r), n = Math.round(this.g), o = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(t, ", ").concat(n, ", ").concat(o, ")") : "rgba(".concat(t, ", ").concat(n, ", ").concat(o, ", ").concat(this.roundA, ")");
    }, e.prototype.toPercentageRgb = function() {
      var t = function(n) {
        return "".concat(Math.round(ll(n, 255) * 100), "%");
      };
      return {
        r: t(this.r),
        g: t(this.g),
        b: t(this.b),
        a: this.a
      };
    }, e.prototype.toPercentageRgbString = function() {
      var t = function(n) {
        return Math.round(ll(n, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%)") : "rgba(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%, ").concat(this.roundA, ")");
    }, e.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var t = "#" + Fw(this.r, this.g, this.b, !1), n = 0, o = Object.entries(_g); n < o.length; n++) {
        var l = o[n], a = l[0], r = l[1];
        if (t === r)
          return a;
      }
      return !1;
    }, e.prototype.toString = function(t) {
      var n = !!t;
      t = t ?? this.format;
      var o = !1, l = this.a < 1 && this.a >= 0, a = !n && l && (t.startsWith("hex") || t === "name");
      return a ? t === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (t === "rgb" && (o = this.toRgbString()), t === "prgb" && (o = this.toPercentageRgbString()), (t === "hex" || t === "hex6") && (o = this.toHexString()), t === "hex3" && (o = this.toHexString(!0)), t === "hex4" && (o = this.toHex8String(!0)), t === "hex8" && (o = this.toHex8String()), t === "name" && (o = this.toName()), t === "hsl" && (o = this.toHslString()), t === "hsv" && (o = this.toHsvString()), o || this.toHexString());
    }, e.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, e.prototype.clone = function() {
      return new e(this.toString());
    }, e.prototype.lighten = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.l += t / 100, n.l = Yf(n.l), new e(n);
    }, e.prototype.brighten = function(t) {
      t === void 0 && (t = 10);
      var n = this.toRgb();
      return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(t / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(t / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(t / 100)))), new e(n);
    }, e.prototype.darken = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.l -= t / 100, n.l = Yf(n.l), new e(n);
    }, e.prototype.tint = function(t) {
      return t === void 0 && (t = 10), this.mix("white", t);
    }, e.prototype.shade = function(t) {
      return t === void 0 && (t = 10), this.mix("black", t);
    }, e.prototype.desaturate = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.s -= t / 100, n.s = Yf(n.s), new e(n);
    }, e.prototype.saturate = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.s += t / 100, n.s = Yf(n.s), new e(n);
    }, e.prototype.greyscale = function() {
      return this.desaturate(100);
    }, e.prototype.spin = function(t) {
      var n = this.toHsl(), o = (n.h + t) % 360;
      return n.h = o < 0 ? 360 + o : o, new e(n);
    }, e.prototype.mix = function(t, n) {
      n === void 0 && (n = 50);
      var o = this.toRgb(), l = new e(t).toRgb(), a = n / 100, r = {
        r: (l.r - o.r) * a + o.r,
        g: (l.g - o.g) * a + o.g,
        b: (l.b - o.b) * a + o.b,
        a: (l.a - o.a) * a + o.a
      };
      return new e(r);
    }, e.prototype.analogous = function(t, n) {
      t === void 0 && (t = 6), n === void 0 && (n = 30);
      var o = this.toHsl(), l = 360 / n, a = [this];
      for (o.h = (o.h - (l * t >> 1) + 720) % 360; --t; )
        o.h = (o.h + l) % 360, a.push(new e(o));
      return a;
    }, e.prototype.complement = function() {
      var t = this.toHsl();
      return t.h = (t.h + 180) % 360, new e(t);
    }, e.prototype.monochromatic = function(t) {
      t === void 0 && (t = 6);
      for (var n = this.toHsv(), o = n.h, l = n.s, a = n.v, r = [], i = 1 / t; t--; )
        r.push(new e({ h: o, s: l, v: a })), a = (a + i) % 1;
      return r;
    }, e.prototype.splitcomplement = function() {
      var t = this.toHsl(), n = t.h;
      return [
        this,
        new e({ h: (n + 72) % 360, s: t.s, l: t.l }),
        new e({ h: (n + 216) % 360, s: t.s, l: t.l })
      ];
    }, e.prototype.onBackground = function(t) {
      var n = this.toRgb(), o = new e(t).toRgb(), l = n.a + o.a * (1 - n.a);
      return new e({
        r: (n.r * n.a + o.r * o.a * (1 - n.a)) / l,
        g: (n.g * n.a + o.g * o.a * (1 - n.a)) / l,
        b: (n.b * n.a + o.b * o.a * (1 - n.a)) / l,
        a: l
      });
    }, e.prototype.triad = function() {
      return this.polyad(3);
    }, e.prototype.tetrad = function() {
      return this.polyad(4);
    }, e.prototype.polyad = function(t) {
      for (var n = this.toHsl(), o = n.h, l = [this], a = 360 / t, r = 1; r < t; r++)
        l.push(new e({ h: (o + r * a) % 360, s: n.s, l: n.l }));
      return l;
    }, e.prototype.equals = function(t) {
      return this.toRgbString() === new e(t).toRgbString();
    }, e;
  }()
);
function Qr(e, t = 20) {
  return e.mix("#141414", t).toString();
}
function yz(e) {
  const t = Nl(), n = nt("button");
  return x(() => {
    let o = {};
    const l = e.color;
    if (l) {
      const a = new uT(l), r = e.dark ? a.tint(20).toString() : Qr(a, 20);
      if (e.plain)
        o = n.cssVarBlock({
          "bg-color": e.dark ? Qr(a, 90) : a.tint(90).toString(),
          "text-color": l,
          "border-color": e.dark ? Qr(a, 50) : a.tint(50).toString(),
          "hover-text-color": `var(${n.cssVarName("color-white")})`,
          "hover-bg-color": l,
          "hover-border-color": l,
          "active-bg-color": r,
          "active-text-color": `var(${n.cssVarName("color-white")})`,
          "active-border-color": r
        }), t.value && (o[n.cssVarBlockName("disabled-bg-color")] = e.dark ? Qr(a, 90) : a.tint(90).toString(), o[n.cssVarBlockName("disabled-text-color")] = e.dark ? Qr(a, 50) : a.tint(50).toString(), o[n.cssVarBlockName("disabled-border-color")] = e.dark ? Qr(a, 80) : a.tint(80).toString());
      else {
        const i = e.dark ? Qr(a, 30) : a.tint(30).toString(), s = a.isDark() ? `var(${n.cssVarName("color-white")})` : `var(${n.cssVarName("color-black")})`;
        if (o = n.cssVarBlock({
          "bg-color": l,
          "text-color": s,
          "border-color": l,
          "hover-bg-color": i,
          "hover-text-color": s,
          "hover-border-color": i,
          "active-bg-color": r,
          "active-border-color": r
        }), t.value) {
          const u = e.dark ? Qr(a, 50) : a.tint(50).toString();
          o[n.cssVarBlockName("disabled-bg-color")] = u, o[n.cssVarBlockName("disabled-text-color")] = e.dark ? "rgba(255, 255, 255, 0.5)" : `var(${n.cssVarName("color-white")})`, o[n.cssVarBlockName("disabled-border-color")] = u;
        }
      }
    }
    return o;
  });
}
const Cz = Q({
  name: "ElButton"
}), wz = /* @__PURE__ */ Q({
  ...Cz,
  props: Sg,
  emits: rz,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = yz(o), a = nt("button"), { _ref: r, _size: i, _type: s, _disabled: u, _props: d, shouldAddSpace: f, handleClick: v } = lz(o, n), h = x(() => [
      a.b(),
      a.m(s.value),
      a.m(i.value),
      a.is("disabled", u.value),
      a.is("loading", o.loading),
      a.is("plain", o.plain),
      a.is("round", o.round),
      a.is("circle", o.circle),
      a.is("text", o.text),
      a.is("link", o.link),
      a.is("has-bg", o.bg)
    ]);
    return t({
      ref: r,
      size: i,
      type: s,
      disabled: u,
      shouldAddSpace: f
    }), (m, p) => (M(), We(Qt(m.tag), Et({
      ref_key: "_ref",
      ref: r
    }, c(d), {
      class: c(h),
      style: c(l),
      onClick: c(v)
    }), {
      default: fe(() => [
        m.loading ? (M(), G(kt, { key: 0 }, [
          m.$slots.loading ? Ie(m.$slots, "loading", { key: 0 }) : (M(), We(c(Ct), {
            key: 1,
            class: z(c(a).is("loading"))
          }, {
            default: fe(() => [
              (M(), We(Qt(m.loadingIcon)))
            ]),
            _: 1
          }, 8, ["class"]))
        ], 64)) : m.icon || m.$slots.icon ? (M(), We(c(Ct), { key: 1 }, {
          default: fe(() => [
            m.icon ? (M(), We(Qt(m.icon), { key: 0 })) : Ie(m.$slots, "icon", { key: 1 })
          ]),
          _: 3
        })) : _e("v-if", !0),
        m.$slots.default ? (M(), G("span", {
          key: 2,
          class: z({ [c(a).em("text", "expand")]: c(f) })
        }, [
          Ie(m.$slots, "default")
        ], 2)) : _e("v-if", !0)
      ]),
      _: 3
    }, 16, ["class", "style", "onClick"]));
  }
});
var Ez = /* @__PURE__ */ ut(wz, [["__file", "button.vue"]]);
const Sz = {
  size: Sg.size,
  type: Sg.type
}, _z = Q({
  name: "ElButtonGroup"
}), xz = /* @__PURE__ */ Q({
  ..._z,
  props: Sz,
  setup(e) {
    const t = e;
    Mt(iT, en({
      size: Pn(t, "size"),
      type: Pn(t, "type")
    }));
    const n = nt("button");
    return (o, l) => (M(), G("div", {
      class: z(`${c(n).b("group")}`)
    }, [
      Ie(o.$slots, "default")
    ], 2));
  }
});
var dT = /* @__PURE__ */ ut(xz, [["__file", "button-group.vue"]]);
const Do = Yt(Ez, {
  ButtonGroup: dT
}), fT = Jn(dT);
var Wr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function pr(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var pT = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Wr, function() {
    var n = 1e3, o = 6e4, l = 36e5, a = "millisecond", r = "second", i = "minute", s = "hour", u = "day", d = "week", f = "month", v = "quarter", h = "year", m = "date", p = "Invalid Date", C = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, g = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, w = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(U) {
      var W = ["th", "st", "nd", "rd"], A = U % 100;
      return "[" + U + (W[(A - 20) % 10] || W[A] || W[0]) + "]";
    } }, b = function(U, W, A) {
      var $ = String(U);
      return !$ || $.length >= W ? U : "" + Array(W + 1 - $.length).join(A) + U;
    }, y = { s: b, z: function(U) {
      var W = -U.utcOffset(), A = Math.abs(W), $ = Math.floor(A / 60), D = A % 60;
      return (W <= 0 ? "+" : "-") + b($, 2, "0") + ":" + b(D, 2, "0");
    }, m: function U(W, A) {
      if (W.date() < A.date())
        return -U(A, W);
      var $ = 12 * (A.year() - W.year()) + (A.month() - W.month()), D = W.clone().add($, f), O = A - D < 0, F = W.clone().add($ + (O ? -1 : 1), f);
      return +(-($ + (A - D) / (O ? D - F : F - D)) || 0);
    }, a: function(U) {
      return U < 0 ? Math.ceil(U) || 0 : Math.floor(U);
    }, p: function(U) {
      return { M: f, y: h, w: d, d: u, D: m, h: s, m: i, s: r, ms: a, Q: v }[U] || String(U || "").toLowerCase().replace(/s$/, "");
    }, u: function(U) {
      return U === void 0;
    } }, E = "en", S = {};
    S[E] = w;
    var _ = "$isDayjsObject", k = function(U) {
      return U instanceof H || !(!U || !U[_]);
    }, N = function U(W, A, $) {
      var D;
      if (!W)
        return E;
      if (typeof W == "string") {
        var O = W.toLowerCase();
        S[O] && (D = O), A && (S[O] = A, D = O);
        var F = W.split("-");
        if (!D && F.length > 1)
          return U(F[0]);
      } else {
        var j = W.name;
        S[j] = W, D = j;
      }
      return !$ && D && (E = D), D || !$ && E;
    }, L = function(U, W) {
      if (k(U))
        return U.clone();
      var A = typeof W == "object" ? W : {};
      return A.date = U, A.args = arguments, new H(A);
    }, R = y;
    R.l = N, R.i = k, R.w = function(U, W) {
      return L(U, { locale: W.$L, utc: W.$u, x: W.$x, $offset: W.$offset });
    };
    var H = function() {
      function U(A) {
        this.$L = N(A.locale, null, !0), this.parse(A), this.$x = this.$x || A.x || {}, this[_] = !0;
      }
      var W = U.prototype;
      return W.parse = function(A) {
        this.$d = function($) {
          var D = $.date, O = $.utc;
          if (D === null)
            return /* @__PURE__ */ new Date(NaN);
          if (R.u(D))
            return /* @__PURE__ */ new Date();
          if (D instanceof Date)
            return new Date(D);
          if (typeof D == "string" && !/Z$/i.test(D)) {
            var F = D.match(C);
            if (F) {
              var j = F[2] - 1 || 0, Z = (F[7] || "0").substring(0, 3);
              return O ? new Date(Date.UTC(F[1], j, F[3] || 1, F[4] || 0, F[5] || 0, F[6] || 0, Z)) : new Date(F[1], j, F[3] || 1, F[4] || 0, F[5] || 0, F[6] || 0, Z);
            }
          }
          return new Date(D);
        }(A), this.init();
      }, W.init = function() {
        var A = this.$d;
        this.$y = A.getFullYear(), this.$M = A.getMonth(), this.$D = A.getDate(), this.$W = A.getDay(), this.$H = A.getHours(), this.$m = A.getMinutes(), this.$s = A.getSeconds(), this.$ms = A.getMilliseconds();
      }, W.$utils = function() {
        return R;
      }, W.isValid = function() {
        return this.$d.toString() !== p;
      }, W.isSame = function(A, $) {
        var D = L(A);
        return this.startOf($) <= D && D <= this.endOf($);
      }, W.isAfter = function(A, $) {
        return L(A) < this.startOf($);
      }, W.isBefore = function(A, $) {
        return this.endOf($) < L(A);
      }, W.$g = function(A, $, D) {
        return R.u(A) ? this[$] : this.set(D, A);
      }, W.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, W.valueOf = function() {
        return this.$d.getTime();
      }, W.startOf = function(A, $) {
        var D = this, O = !!R.u($) || $, F = R.p(A), j = function(ve, ie) {
          var he = R.w(D.$u ? Date.UTC(D.$y, ie, ve) : new Date(D.$y, ie, ve), D);
          return O ? he : he.endOf(u);
        }, Z = function(ve, ie) {
          return R.w(D.toDate()[ve].apply(D.toDate("s"), (O ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(ie)), D);
        }, te = this.$W, de = this.$M, Oe = this.$D, ce = "set" + (this.$u ? "UTC" : "");
        switch (F) {
          case h:
            return O ? j(1, 0) : j(31, 11);
          case f:
            return O ? j(1, de) : j(0, de + 1);
          case d:
            var ne = this.$locale().weekStart || 0, Y = (te < ne ? te + 7 : te) - ne;
            return j(O ? Oe - Y : Oe + (6 - Y), de);
          case u:
          case m:
            return Z(ce + "Hours", 0);
          case s:
            return Z(ce + "Minutes", 1);
          case i:
            return Z(ce + "Seconds", 2);
          case r:
            return Z(ce + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, W.endOf = function(A) {
        return this.startOf(A, !1);
      }, W.$set = function(A, $) {
        var D, O = R.p(A), F = "set" + (this.$u ? "UTC" : ""), j = (D = {}, D[u] = F + "Date", D[m] = F + "Date", D[f] = F + "Month", D[h] = F + "FullYear", D[s] = F + "Hours", D[i] = F + "Minutes", D[r] = F + "Seconds", D[a] = F + "Milliseconds", D)[O], Z = O === u ? this.$D + ($ - this.$W) : $;
        if (O === f || O === h) {
          var te = this.clone().set(m, 1);
          te.$d[j](Z), te.init(), this.$d = te.set(m, Math.min(this.$D, te.daysInMonth())).$d;
        } else
          j && this.$d[j](Z);
        return this.init(), this;
      }, W.set = function(A, $) {
        return this.clone().$set(A, $);
      }, W.get = function(A) {
        return this[R.p(A)]();
      }, W.add = function(A, $) {
        var D, O = this;
        A = Number(A);
        var F = R.p($), j = function(de) {
          var Oe = L(O);
          return R.w(Oe.date(Oe.date() + Math.round(de * A)), O);
        };
        if (F === f)
          return this.set(f, this.$M + A);
        if (F === h)
          return this.set(h, this.$y + A);
        if (F === u)
          return j(1);
        if (F === d)
          return j(7);
        var Z = (D = {}, D[i] = o, D[s] = l, D[r] = n, D)[F] || 1, te = this.$d.getTime() + A * Z;
        return R.w(te, this);
      }, W.subtract = function(A, $) {
        return this.add(-1 * A, $);
      }, W.format = function(A) {
        var $ = this, D = this.$locale();
        if (!this.isValid())
          return D.invalidDate || p;
        var O = A || "YYYY-MM-DDTHH:mm:ssZ", F = R.z(this), j = this.$H, Z = this.$m, te = this.$M, de = D.weekdays, Oe = D.months, ce = D.meridiem, ne = function(ie, he, De, $e) {
          return ie && (ie[he] || ie($, O)) || De[he].slice(0, $e);
        }, Y = function(ie) {
          return R.s(j % 12 || 12, ie, "0");
        }, ve = ce || function(ie, he, De) {
          var $e = ie < 12 ? "AM" : "PM";
          return De ? $e.toLowerCase() : $e;
        };
        return O.replace(g, function(ie, he) {
          return he || function(De) {
            switch (De) {
              case "YY":
                return String($.$y).slice(-2);
              case "YYYY":
                return R.s($.$y, 4, "0");
              case "M":
                return te + 1;
              case "MM":
                return R.s(te + 1, 2, "0");
              case "MMM":
                return ne(D.monthsShort, te, Oe, 3);
              case "MMMM":
                return ne(Oe, te);
              case "D":
                return $.$D;
              case "DD":
                return R.s($.$D, 2, "0");
              case "d":
                return String($.$W);
              case "dd":
                return ne(D.weekdaysMin, $.$W, de, 2);
              case "ddd":
                return ne(D.weekdaysShort, $.$W, de, 3);
              case "dddd":
                return de[$.$W];
              case "H":
                return String(j);
              case "HH":
                return R.s(j, 2, "0");
              case "h":
                return Y(1);
              case "hh":
                return Y(2);
              case "a":
                return ve(j, Z, !0);
              case "A":
                return ve(j, Z, !1);
              case "m":
                return String(Z);
              case "mm":
                return R.s(Z, 2, "0");
              case "s":
                return String($.$s);
              case "ss":
                return R.s($.$s, 2, "0");
              case "SSS":
                return R.s($.$ms, 3, "0");
              case "Z":
                return F;
            }
            return null;
          }(ie) || F.replace(":", "");
        });
      }, W.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, W.diff = function(A, $, D) {
        var O, F = this, j = R.p($), Z = L(A), te = (Z.utcOffset() - this.utcOffset()) * o, de = this - Z, Oe = function() {
          return R.m(F, Z);
        };
        switch (j) {
          case h:
            O = Oe() / 12;
            break;
          case f:
            O = Oe();
            break;
          case v:
            O = Oe() / 3;
            break;
          case d:
            O = (de - te) / 6048e5;
            break;
          case u:
            O = (de - te) / 864e5;
            break;
          case s:
            O = de / l;
            break;
          case i:
            O = de / o;
            break;
          case r:
            O = de / n;
            break;
          default:
            O = de;
        }
        return D ? O : R.a(O);
      }, W.daysInMonth = function() {
        return this.endOf(f).$D;
      }, W.$locale = function() {
        return S[this.$L];
      }, W.locale = function(A, $) {
        if (!A)
          return this.$L;
        var D = this.clone(), O = N(A, $, !0);
        return O && (D.$L = O), D;
      }, W.clone = function() {
        return R.w(this.$d, this);
      }, W.toDate = function() {
        return new Date(this.valueOf());
      }, W.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, W.toISOString = function() {
        return this.$d.toISOString();
      }, W.toString = function() {
        return this.$d.toUTCString();
      }, U;
    }(), K = H.prototype;
    return L.prototype = K, [["$ms", a], ["$s", r], ["$m", i], ["$H", s], ["$W", u], ["$M", f], ["$y", h], ["$D", m]].forEach(function(U) {
      K[U[1]] = function(W) {
        return this.$g(W, U[0], U[1]);
      };
    }), L.extend = function(U, W) {
      return U.$i || (U(W, H, L), U.$i = !0), L;
    }, L.locale = N, L.isDayjs = k, L.unix = function(U) {
      return L(1e3 * U);
    }, L.en = S[E], L.Ls = S, L.p = {}, L;
  });
})(pT);
var kz = pT.exports;
const Gt = /* @__PURE__ */ pr(kz);
var vT = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Wr, function() {
    var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, o = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, l = /\d\d/, a = /\d\d?/, r = /\d*[^-_:/,()\s\d]+/, i = {}, s = function(p) {
      return (p = +p) + (p > 68 ? 1900 : 2e3);
    }, u = function(p) {
      return function(C) {
        this[p] = +C;
      };
    }, d = [/[+-]\d\d:?(\d\d)?|Z/, function(p) {
      (this.zone || (this.zone = {})).offset = function(C) {
        if (!C || C === "Z")
          return 0;
        var g = C.match(/([+-]|\d\d)/g), w = 60 * g[1] + (+g[2] || 0);
        return w === 0 ? 0 : g[0] === "+" ? -w : w;
      }(p);
    }], f = function(p) {
      var C = i[p];
      return C && (C.indexOf ? C : C.s.concat(C.f));
    }, v = function(p, C) {
      var g, w = i.meridiem;
      if (w) {
        for (var b = 1; b <= 24; b += 1)
          if (p.indexOf(w(b, 0, C)) > -1) {
            g = b > 12;
            break;
          }
      } else
        g = p === (C ? "pm" : "PM");
      return g;
    }, h = { A: [r, function(p) {
      this.afternoon = v(p, !1);
    }], a: [r, function(p) {
      this.afternoon = v(p, !0);
    }], S: [/\d/, function(p) {
      this.milliseconds = 100 * +p;
    }], SS: [l, function(p) {
      this.milliseconds = 10 * +p;
    }], SSS: [/\d{3}/, function(p) {
      this.milliseconds = +p;
    }], s: [a, u("seconds")], ss: [a, u("seconds")], m: [a, u("minutes")], mm: [a, u("minutes")], H: [a, u("hours")], h: [a, u("hours")], HH: [a, u("hours")], hh: [a, u("hours")], D: [a, u("day")], DD: [l, u("day")], Do: [r, function(p) {
      var C = i.ordinal, g = p.match(/\d+/);
      if (this.day = g[0], C)
        for (var w = 1; w <= 31; w += 1)
          C(w).replace(/\[|\]/g, "") === p && (this.day = w);
    }], M: [a, u("month")], MM: [l, u("month")], MMM: [r, function(p) {
      var C = f("months"), g = (f("monthsShort") || C.map(function(w) {
        return w.slice(0, 3);
      })).indexOf(p) + 1;
      if (g < 1)
        throw new Error();
      this.month = g % 12 || g;
    }], MMMM: [r, function(p) {
      var C = f("months").indexOf(p) + 1;
      if (C < 1)
        throw new Error();
      this.month = C % 12 || C;
    }], Y: [/[+-]?\d+/, u("year")], YY: [l, function(p) {
      this.year = s(p);
    }], YYYY: [/\d{4}/, u("year")], Z: d, ZZ: d };
    function m(p) {
      var C, g;
      C = p, g = i && i.formats;
      for (var w = (p = C.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(N, L, R) {
        var H = R && R.toUpperCase();
        return L || g[R] || n[R] || g[H].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(K, U, W) {
          return U || W.slice(1);
        });
      })).match(o), b = w.length, y = 0; y < b; y += 1) {
        var E = w[y], S = h[E], _ = S && S[0], k = S && S[1];
        w[y] = k ? { regex: _, parser: k } : E.replace(/^\[|\]$/g, "");
      }
      return function(N) {
        for (var L = {}, R = 0, H = 0; R < b; R += 1) {
          var K = w[R];
          if (typeof K == "string")
            H += K.length;
          else {
            var U = K.regex, W = K.parser, A = N.slice(H), $ = U.exec(A)[0];
            W.call(L, $), N = N.replace($, "");
          }
        }
        return function(D) {
          var O = D.afternoon;
          if (O !== void 0) {
            var F = D.hours;
            O ? F < 12 && (D.hours += 12) : F === 12 && (D.hours = 0), delete D.afternoon;
          }
        }(L), L;
      };
    }
    return function(p, C, g) {
      g.p.customParseFormat = !0, p && p.parseTwoDigitYear && (s = p.parseTwoDigitYear);
      var w = C.prototype, b = w.parse;
      w.parse = function(y) {
        var E = y.date, S = y.utc, _ = y.args;
        this.$u = S;
        var k = _[1];
        if (typeof k == "string") {
          var N = _[2] === !0, L = _[3] === !0, R = N || L, H = _[2];
          L && (H = _[2]), i = this.$locale(), !N && H && (i = g.Ls[H]), this.$d = function(A, $, D) {
            try {
              if (["x", "X"].indexOf($) > -1)
                return new Date(($ === "X" ? 1e3 : 1) * A);
              var O = m($)(A), F = O.year, j = O.month, Z = O.day, te = O.hours, de = O.minutes, Oe = O.seconds, ce = O.milliseconds, ne = O.zone, Y = /* @__PURE__ */ new Date(), ve = Z || (F || j ? 1 : Y.getDate()), ie = F || Y.getFullYear(), he = 0;
              F && !j || (he = j > 0 ? j - 1 : Y.getMonth());
              var De = te || 0, $e = de || 0, ue = Oe || 0, Ne = ce || 0;
              return ne ? new Date(Date.UTC(ie, he, ve, De, $e, ue, Ne + 60 * ne.offset * 1e3)) : D ? new Date(Date.UTC(ie, he, ve, De, $e, ue, Ne)) : new Date(ie, he, ve, De, $e, ue, Ne);
            } catch {
              return /* @__PURE__ */ new Date("");
            }
          }(E, k, S), this.init(), H && H !== !0 && (this.$L = this.locale(H).$L), R && E != this.format(k) && (this.$d = /* @__PURE__ */ new Date("")), i = {};
        } else if (k instanceof Array)
          for (var K = k.length, U = 1; U <= K; U += 1) {
            _[1] = k[U - 1];
            var W = g.apply(this, _);
            if (W.isValid()) {
              this.$d = W.$d, this.$L = W.$L, this.init();
              break;
            }
            U === K && (this.$d = /* @__PURE__ */ new Date(""));
          }
        else
          b.call(this, y);
      };
    };
  });
})(vT);
var Tz = vT.exports;
const Wy = /* @__PURE__ */ pr(Tz), Bw = ["hours", "minutes", "seconds"], xg = "HH:mm:ss", fc = "YYYY-MM-DD", $z = {
  date: fc,
  dates: fc,
  week: "gggg[w]ww",
  year: "YYYY",
  years: "YYYY",
  month: "YYYY-MM",
  datetime: `${fc} ${xg}`,
  monthrange: "YYYY-MM",
  daterange: fc,
  datetimerange: `${fc} ${xg}`
}, tm = (e, t) => [
  e > 0 ? e - 1 : void 0,
  e,
  e < t ? e + 1 : void 0
], ys = (e) => Array.from(Array.from({ length: e }).keys()), hT = (e) => e.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim(), mT = (e) => e.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim(), Hw = function(e, t) {
  const n = _d(e), o = _d(t);
  return n && o ? e.getTime() === t.getTime() : !n && !o ? e === t : !1;
}, zw = function(e, t) {
  const n = Kt(e), o = Kt(t);
  return n && o ? e.length !== t.length ? !1 : e.every((l, a) => Hw(l, t[a])) : !n && !o ? Hw(e, t) : !1;
}, Ww = function(e, t, n) {
  const o = ha(t) || t === "x" ? Gt(e).locale(n) : Gt(e, t).locale(n);
  return o.isValid() ? o : void 0;
}, Kw = function(e, t, n) {
  return ha(t) ? e : t === "x" ? +e : Gt(e).locale(n).format(t);
}, nm = (e, t) => {
  var n;
  const o = [], l = t == null ? void 0 : t();
  for (let a = 0; a < e; a++)
    o.push((n = l == null ? void 0 : l.includes(a)) != null ? n : !1);
  return o;
}, gT = it({
  disabledHours: {
    type: Ae(Function)
  },
  disabledMinutes: {
    type: Ae(Function)
  },
  disabledSeconds: {
    type: Ae(Function)
  }
}), bT = it({
  visible: Boolean,
  actualVisible: {
    type: Boolean,
    default: void 0
  },
  format: {
    type: String,
    default: ""
  }
}), Ky = it({
  id: {
    type: Ae([Array, String])
  },
  name: {
    type: Ae([Array, String]),
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  format: String,
  valueFormat: String,
  dateFormat: String,
  timeFormat: String,
  type: {
    type: String,
    default: ""
  },
  clearable: {
    type: Boolean,
    default: !0
  },
  clearIcon: {
    type: Ae([String, Object]),
    default: Ls
  },
  editable: {
    type: Boolean,
    default: !0
  },
  prefixIcon: {
    type: Ae([String, Object]),
    default: ""
  },
  size: Lo,
  readonly: Boolean,
  disabled: Boolean,
  placeholder: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: Ae(Object),
    default: () => ({})
  },
  modelValue: {
    type: Ae([Date, Array, String, Number]),
    default: ""
  },
  rangeSeparator: {
    type: String,
    default: "-"
  },
  startPlaceholder: String,
  endPlaceholder: String,
  defaultValue: {
    type: Ae([Date, Array])
  },
  defaultTime: {
    type: Ae([Date, Array])
  },
  isRange: Boolean,
  ...gT,
  disabledDate: {
    type: Function
  },
  cellClassName: {
    type: Function
  },
  shortcuts: {
    type: Array,
    default: () => []
  },
  arrowControl: Boolean,
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: Ae([String, Number]),
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  unlinkPanels: Boolean,
  ...ru,
  ...Zo(["ariaLabel"])
}), Oz = ["id", "name", "placeholder", "value", "disabled", "readonly"], Nz = ["id", "name", "placeholder", "value", "disabled", "readonly"], Mz = Q({
  name: "Picker"
}), Iz = /* @__PURE__ */ Q({
  ...Mz,
  props: Ky,
  emits: [
    "update:modelValue",
    "change",
    "focus",
    "blur",
    "calendar-change",
    "panel-change",
    "visible-change",
    "keydown"
  ],
  setup(e, { expose: t, emit: n }) {
    const o = e, l = Ai(), { lang: a } = bn(), r = nt("date"), i = nt("input"), s = nt("range"), { form: u, formItem: d } = ml(), f = ot("ElPopperOptions", {}), { valueOnClear: v } = Hv(o, null), h = B(), m = B(), p = B(!1), C = B(!1), g = B(null);
    let w = !1, b = !1;
    const y = x(() => [
      r.b("editor"),
      r.bm("editor", o.type),
      i.e("wrapper"),
      r.is("disabled", te.value),
      r.is("active", p.value),
      s.b("editor"),
      Ze ? s.bm("editor", Ze.value) : "",
      l.class
    ]), E = x(() => [
      i.e("icon"),
      s.e("close-icon"),
      he.value ? "" : s.e("close-icon--hidden")
    ]);
    Pe(p, (Me) => {
      Me ? xe(() => {
        Me && (g.value = o.modelValue);
      }) : (ke.value = null, xe(() => {
        S(o.modelValue);
      }));
    });
    const S = (Me, et) => {
      (et || !zw(Me, g.value)) && (n("change", Me), o.validateEvent && (d == null || d.validate("change").catch((mt) => dn(mt))));
    }, _ = (Me) => {
      if (!zw(o.modelValue, Me)) {
        let et;
        Kt(Me) ? et = Me.map((mt) => Kw(mt, o.valueFormat, a.value)) : Me && (et = Kw(Me, o.valueFormat, a.value)), n("update:modelValue", Me && et, a.value);
      }
    }, k = (Me) => {
      n("keydown", Me);
    }, N = x(() => {
      if (m.value) {
        const Me = Ve.value ? m.value : m.value.$el;
        return Array.from(Me.querySelectorAll("input"));
      }
      return [];
    }), L = (Me, et, mt) => {
      const Lt = N.value;
      Lt.length && (!mt || mt === "min" ? (Lt[0].setSelectionRange(Me, et), Lt[0].focus()) : mt === "max" && (Lt[1].setSelectionRange(Me, et), Lt[1].focus()));
    }, R = () => {
      O(!0, !0), xe(() => {
        b = !1;
      });
    }, H = (Me = "", et = !1) => {
      et || (b = !0), p.value = et;
      let mt;
      Kt(Me) ? mt = Me.map((Lt) => Lt.toDate()) : mt = Me && Me.toDate(), ke.value = null, _(mt);
    }, K = () => {
      C.value = !0;
    }, U = () => {
      n("visible-change", !0);
    }, W = (Me) => {
      (Me == null ? void 0 : Me.key) === xt.esc && O(!0, !0);
    }, A = () => {
      C.value = !1, p.value = !1, b = !1, n("visible-change", !1);
    }, $ = () => {
      p.value = !0;
    }, D = () => {
      p.value = !1;
    }, O = (Me = !0, et = !1) => {
      b = et;
      const [mt, Lt] = c(N);
      let be = mt;
      !Me && Ve.value && (be = Lt), be && be.focus();
    }, F = (Me) => {
      o.readonly || te.value || p.value || b || (p.value = !0, n("focus", Me));
    };
    let j;
    const Z = (Me) => {
      const et = async () => {
        setTimeout(() => {
          var mt;
          j === et && (!((mt = h.value) != null && mt.isFocusInsideContent() && !w) && N.value.filter((Lt) => Lt.contains(document.activeElement)).length === 0 && (Ue(), p.value = !1, n("blur", Me), o.validateEvent && (d == null || d.validate("blur").catch((Lt) => dn(Lt)))), w = !1);
        }, 0);
      };
      j = et, et();
    }, te = x(() => o.disabled || (u == null ? void 0 : u.disabled)), de = x(() => {
      let Me;
      if ($e.value ? Re.value.getDefaultValue && (Me = Re.value.getDefaultValue()) : Kt(o.modelValue) ? Me = o.modelValue.map((et) => Ww(et, o.valueFormat, a.value)) : Me = Ww(o.modelValue, o.valueFormat, a.value), Re.value.getRangeAvailableTime) {
        const et = Re.value.getRangeAvailableTime(Me);
        pl(et, Me) || (Me = et, _(Kt(Me) ? Me.map((mt) => mt.toDate()) : Me.toDate()));
      }
      return Kt(Me) && Me.some((et) => !et) && (Me = []), Me;
    }), Oe = x(() => {
      if (!Re.value.panelReady)
        return "";
      const Me = re(de.value);
      return Kt(ke.value) ? [
        ke.value[0] || Me && Me[0] || "",
        ke.value[1] || Me && Me[1] || ""
      ] : ke.value !== null ? ke.value : !ne.value && $e.value || !p.value && $e.value ? "" : Me ? Y.value || ve.value ? Me.join(", ") : Me : "";
    }), ce = x(() => o.type.includes("time")), ne = x(() => o.type.startsWith("time")), Y = x(() => o.type === "dates"), ve = x(() => o.type === "years"), ie = x(() => o.prefixIcon || (ce.value ? Yx : a8)), he = B(!1), De = (Me) => {
      o.readonly || te.value || he.value && (Me.stopPropagation(), R(), _(v.value), S(v.value, !0), he.value = !1, p.value = !1, Re.value.handleClear && Re.value.handleClear());
    }, $e = x(() => {
      const { modelValue: Me } = o;
      return !Me || Kt(Me) && !Me.filter(Boolean).length;
    }), ue = async (Me) => {
      var et;
      o.readonly || te.value || (((et = Me.target) == null ? void 0 : et.tagName) !== "INPUT" || N.value.includes(document.activeElement)) && (p.value = !0);
    }, Ne = () => {
      o.readonly || te.value || !$e.value && o.clearable && (he.value = !0);
    }, je = () => {
      he.value = !1;
    }, Fe = (Me) => {
      var et;
      o.readonly || te.value || (((et = Me.touches[0].target) == null ? void 0 : et.tagName) !== "INPUT" || N.value.includes(document.activeElement)) && (p.value = !0);
    }, Ve = x(() => o.type.includes("range")), Ze = Mo(), ae = x(() => {
      var Me, et;
      return (et = (Me = c(h)) == null ? void 0 : Me.popperRef) == null ? void 0 : et.contentRef;
    }), pe = x(() => {
      var Me;
      return c(Ve) ? c(m) : (Me = c(m)) == null ? void 0 : Me.$el;
    });
    Hb(pe, (Me) => {
      const et = c(ae), mt = c(pe);
      et && (Me.target === et || Me.composedPath().includes(et)) || Me.target === mt || Me.composedPath().includes(mt) || (p.value = !1);
    });
    const ke = B(null), Ue = () => {
      if (ke.value) {
        const Me = Xe(Oe.value);
        Me && Te(Me) && (_(Kt(Me) ? Me.map((et) => et.toDate()) : Me.toDate()), ke.value = null);
      }
      ke.value === "" && (_(v.value), S(v.value), ke.value = null);
    }, Xe = (Me) => Me ? Re.value.parseUserInput(Me) : null, re = (Me) => Me ? Re.value.formatToString(Me) : null, Te = (Me) => Re.value.isValidValue(Me), Ce = async (Me) => {
      if (o.readonly || te.value)
        return;
      const { code: et } = Me;
      if (k(Me), et === xt.esc) {
        p.value === !0 && (p.value = !1, Me.preventDefault(), Me.stopPropagation());
        return;
      }
      if (et === xt.down && (Re.value.handleFocusPicker && (Me.preventDefault(), Me.stopPropagation()), p.value === !1 && (p.value = !0, await xe()), Re.value.handleFocusPicker)) {
        Re.value.handleFocusPicker();
        return;
      }
      if (et === xt.tab) {
        w = !0;
        return;
      }
      if (et === xt.enter || et === xt.numpadEnter) {
        (ke.value === null || ke.value === "" || Te(Xe(Oe.value))) && (Ue(), p.value = !1), Me.stopPropagation();
        return;
      }
      if (ke.value) {
        Me.stopPropagation();
        return;
      }
      Re.value.handleKeydownInput && Re.value.handleKeydownInput(Me);
    }, Le = (Me) => {
      ke.value = Me, p.value || (p.value = !0);
    }, ge = (Me) => {
      const et = Me.target;
      ke.value ? ke.value = [et.value, ke.value[1]] : ke.value = [et.value, null];
    }, Ee = (Me) => {
      const et = Me.target;
      ke.value ? ke.value = [ke.value[0], et.value] : ke.value = [null, et.value];
    }, me = () => {
      var Me;
      const et = ke.value, mt = Xe(et && et[0]), Lt = c(de);
      if (mt && mt.isValid()) {
        ke.value = [
          re(mt),
          ((Me = Oe.value) == null ? void 0 : Me[1]) || null
        ];
        const be = [mt, Lt && (Lt[1] || null)];
        Te(be) && (_(be), ke.value = null);
      }
    }, Ke = () => {
      var Me;
      const et = c(ke), mt = Xe(et && et[1]), Lt = c(de);
      if (mt && mt.isValid()) {
        ke.value = [
          ((Me = c(Oe)) == null ? void 0 : Me[0]) || null,
          re(mt)
        ];
        const be = [Lt && Lt[0], mt];
        Te(be) && (_(be), ke.value = null);
      }
    }, Re = B({}), we = (Me) => {
      Re.value[Me[0]] = Me[1], Re.value.panelReady = !0;
    }, ze = (Me) => {
      n("calendar-change", Me);
    }, Je = (Me, et, mt) => {
      n("panel-change", Me, et, mt);
    };
    return Mt("EP_PICKER_BASE", {
      props: o
    }), Ho({
      from: "label",
      replacement: "aria-label",
      version: "2.8.0",
      scope: "el-time-picker",
      ref: "https://element-plus.org/en-US/component/time-picker.html"
    }, x(() => !!o.label)), t({
      focus: O,
      handleFocusInput: F,
      handleBlurInput: Z,
      handleOpen: $,
      handleClose: D,
      onPick: H
    }), (Me, et) => (M(), We(c(hl), Et({
      ref_key: "refPopper",
      ref: h,
      visible: p.value,
      effect: "light",
      pure: "",
      trigger: "click"
    }, Me.$attrs, {
      role: "dialog",
      teleported: "",
      transition: `${c(r).namespace.value}-zoom-in-top`,
      "popper-class": [`${c(r).namespace.value}-picker__popper`, Me.popperClass],
      "popper-options": c(f),
      "fallback-placements": ["bottom", "top", "right", "left"],
      "gpu-acceleration": !1,
      "stop-popper-mouse-event": !1,
      "hide-after": 0,
      persistent: "",
      onBeforeShow: K,
      onShow: U,
      onHide: A
    }), {
      default: fe(() => [
        c(Ve) ? (M(), G("div", {
          key: 1,
          ref_key: "inputRef",
          ref: m,
          class: z(c(y)),
          style: bt(Me.$attrs.style),
          onClick: F,
          onMouseenter: Ne,
          onMouseleave: je,
          onTouchstartPassive: Fe,
          onKeydown: Ce
        }, [
          c(ie) ? (M(), We(c(Ct), {
            key: 0,
            class: z([c(i).e("icon"), c(s).e("icon")]),
            onMousedown: It(ue, ["prevent"]),
            onTouchstartPassive: Fe
          }, {
            default: fe(() => [
              (M(), We(Qt(c(ie))))
            ]),
            _: 1
          }, 8, ["class", "onMousedown"])) : _e("v-if", !0),
          X("input", {
            id: Me.id && Me.id[0],
            autocomplete: "off",
            name: Me.name && Me.name[0],
            placeholder: Me.startPlaceholder,
            value: c(Oe) && c(Oe)[0],
            disabled: c(te),
            readonly: !Me.editable || Me.readonly,
            class: z(c(s).b("input")),
            onMousedown: ue,
            onInput: ge,
            onChange: me,
            onFocus: F,
            onBlur: Z
          }, null, 42, Oz),
          Ie(Me.$slots, "range-separator", {}, () => [
            X("span", {
              class: z(c(s).b("separator"))
            }, Qe(Me.rangeSeparator), 3)
          ]),
          X("input", {
            id: Me.id && Me.id[1],
            autocomplete: "off",
            name: Me.name && Me.name[1],
            placeholder: Me.endPlaceholder,
            value: c(Oe) && c(Oe)[1],
            disabled: c(te),
            readonly: !Me.editable || Me.readonly,
            class: z(c(s).b("input")),
            onMousedown: ue,
            onFocus: F,
            onBlur: Z,
            onInput: Ee,
            onChange: Ke
          }, null, 42, Nz),
          Me.clearIcon ? (M(), We(c(Ct), {
            key: 1,
            class: z(c(E)),
            onClick: De
          }, {
            default: fe(() => [
              (M(), We(Qt(Me.clearIcon)))
            ]),
            _: 1
          }, 8, ["class"])) : _e("v-if", !0)
        ], 38)) : (M(), We(c(nl), {
          key: 0,
          id: Me.id,
          ref_key: "inputRef",
          ref: m,
          "container-role": "combobox",
          "model-value": c(Oe),
          name: Me.name,
          size: c(Ze),
          disabled: c(te),
          placeholder: Me.placeholder,
          class: z([c(r).b("editor"), c(r).bm("editor", Me.type), Me.$attrs.class]),
          style: bt(Me.$attrs.style),
          readonly: !Me.editable || Me.readonly || c(Y) || c(ve) || Me.type === "week",
          "aria-label": Me.label || Me.ariaLabel,
          tabindex: Me.tabindex,
          "validate-event": !1,
          onInput: Le,
          onFocus: F,
          onBlur: Z,
          onKeydown: Ce,
          onChange: Ue,
          onMousedown: ue,
          onMouseenter: Ne,
          onMouseleave: je,
          onTouchstartPassive: Fe,
          onClick: et[0] || (et[0] = It(() => {
          }, ["stop"]))
        }, {
          prefix: fe(() => [
            c(ie) ? (M(), We(c(Ct), {
              key: 0,
              class: z(c(i).e("icon")),
              onMousedown: It(ue, ["prevent"]),
              onTouchstartPassive: Fe
            }, {
              default: fe(() => [
                (M(), We(Qt(c(ie))))
              ]),
              _: 1
            }, 8, ["class", "onMousedown"])) : _e("v-if", !0)
          ]),
          suffix: fe(() => [
            he.value && Me.clearIcon ? (M(), We(c(Ct), {
              key: 0,
              class: z(`${c(i).e("icon")} clear-icon`),
              onClick: It(De, ["stop"])
            }, {
              default: fe(() => [
                (M(), We(Qt(Me.clearIcon)))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : _e("v-if", !0)
          ]),
          _: 1
        }, 8, ["id", "model-value", "name", "size", "disabled", "placeholder", "class", "style", "readonly", "aria-label", "tabindex", "onKeydown"]))
      ]),
      content: fe(() => [
        Ie(Me.$slots, "default", {
          visible: p.value,
          actualVisible: C.value,
          parsedValue: c(de),
          format: Me.format,
          dateFormat: Me.dateFormat,
          timeFormat: Me.timeFormat,
          unlinkPanels: Me.unlinkPanels,
          type: Me.type,
          defaultValue: Me.defaultValue,
          onPick: H,
          onSelectRange: L,
          onSetPickerOption: we,
          onCalendarChange: ze,
          onPanelChange: Je,
          onKeydown: W,
          onMousedown: et[1] || (et[1] = It(() => {
          }, ["stop"]))
        })
      ]),
      _: 3
    }, 16, ["visible", "transition", "popper-class", "popper-options"]));
  }
});
var yT = /* @__PURE__ */ ut(Iz, [["__file", "picker.vue"]]);
const Rz = it({
  ...bT,
  datetimeRole: String,
  parsedValue: {
    type: Ae(Object)
  }
}), CT = ({
  getAvailableHours: e,
  getAvailableMinutes: t,
  getAvailableSeconds: n
}) => {
  const o = (r, i, s, u) => {
    const d = {
      hour: e,
      minute: t,
      second: n
    };
    let f = r;
    return ["hour", "minute", "second"].forEach((v) => {
      if (d[v]) {
        let h;
        const m = d[v];
        switch (v) {
          case "minute": {
            h = m(f.hour(), i, u);
            break;
          }
          case "second": {
            h = m(f.hour(), f.minute(), i, u);
            break;
          }
          default: {
            h = m(i, u);
            break;
          }
        }
        if (h != null && h.length && !h.includes(f[v]())) {
          const p = s ? 0 : h.length - 1;
          f = f[v](h[p]);
        }
      }
    }), f;
  }, l = {};
  return {
    timePickerOptions: l,
    getAvailableTime: o,
    onSetOption: ([r, i]) => {
      l[r] = i;
    }
  };
}, om = (e) => {
  const t = (o, l) => o || l, n = (o) => o !== !0;
  return e.map(t).filter(n);
}, wT = (e, t, n) => ({
  getHoursList: (r, i) => nm(24, e && (() => e == null ? void 0 : e(r, i))),
  getMinutesList: (r, i, s) => nm(60, t && (() => t == null ? void 0 : t(r, i, s))),
  getSecondsList: (r, i, s, u) => nm(60, n && (() => n == null ? void 0 : n(r, i, s, u)))
}), ET = (e, t, n) => {
  const { getHoursList: o, getMinutesList: l, getSecondsList: a } = wT(e, t, n);
  return {
    getAvailableHours: (u, d) => om(o(u, d)),
    getAvailableMinutes: (u, d, f) => om(l(u, d, f)),
    getAvailableSeconds: (u, d, f, v) => om(a(u, d, f, v))
  };
}, ST = (e) => {
  const t = B(e.parsedValue);
  return Pe(() => e.visible, (n) => {
    n || (t.value = e.parsedValue);
  }), t;
}, us = /* @__PURE__ */ new Map();
let Uw;
fn && (document.addEventListener("mousedown", (e) => Uw = e), document.addEventListener("mouseup", (e) => {
  for (const t of us.values())
    for (const { documentHandler: n } of t)
      n(e, Uw);
}));
function jw(e, t) {
  let n = [];
  return Array.isArray(t.arg) ? n = t.arg : wa(t.arg) && n.push(t.arg), function(o, l) {
    const a = t.instance.popperRef, r = o.target, i = l == null ? void 0 : l.target, s = !t || !t.instance, u = !r || !i, d = e.contains(r) || e.contains(i), f = e === r, v = n.length && n.some((m) => m == null ? void 0 : m.contains(r)) || n.length && n.includes(i), h = a && (a.contains(r) || a.contains(i));
    s || u || d || f || v || h || t.value(o, l);
  };
}
const Pr = {
  beforeMount(e, t) {
    us.has(e) || us.set(e, []), us.get(e).push({
      documentHandler: jw(e, t),
      bindingFn: t.value
    });
  },
  updated(e, t) {
    us.has(e) || us.set(e, []);
    const n = us.get(e), o = n.findIndex((a) => a.bindingFn === t.oldValue), l = {
      documentHandler: jw(e, t),
      bindingFn: t.value
    };
    o >= 0 ? n.splice(o, 1, l) : n.push(l);
  },
  unmounted(e) {
    us.delete(e);
  }
}, Dz = 100, Lz = 600, Qp = {
  beforeMount(e, t) {
    const n = t.value, { interval: o = Dz, delay: l = Lz } = vn(n) ? {} : n;
    let a, r;
    const i = () => vn(n) ? n() : n.handler(), s = () => {
      r && (clearTimeout(r), r = void 0), a && (clearInterval(a), a = void 0);
    };
    e.addEventListener("mousedown", (u) => {
      u.button === 0 && (s(), i(), document.addEventListener("mouseup", () => s(), {
        once: !0
      }), r = setTimeout(() => {
        a = setInterval(() => {
          i();
        }, o);
      }, l));
    });
  }
}, kg = "_trap-focus-children", ii = [], qw = (e) => {
  var t;
  if (ii.length === 0)
    return;
  const n = ii[ii.length - 1][kg];
  if (n.length > 0 && e.code === xt.tab) {
    if (n.length === 1) {
      e.preventDefault(), document.activeElement !== n[0] && n[0].focus();
      return;
    }
    const o = e.shiftKey, l = e.target === n[0], a = e.target === n[n.length - 1];
    if (l && o && (e.preventDefault(), n[n.length - 1].focus()), a && !o && (e.preventDefault(), n[0].focus()), process.env.NODE_ENV === "test") {
      const r = n.indexOf(e.target);
      r !== -1 && ((t = n[o ? r - 1 : r + 1]) == null || t.focus());
    }
  }
}, Pz = {
  beforeMount(e) {
    e[kg] = eC(e), ii.push(e), ii.length <= 1 && document.addEventListener("keydown", qw);
  },
  updated(e) {
    xe(() => {
      e[kg] = eC(e);
    });
  },
  unmounted() {
    ii.shift(), ii.length === 0 && document.removeEventListener("keydown", qw);
  }
};
var Yw = !1, oi, Tg, $g, yp, Cp, _T, wp, Og, Ng, Mg, xT, Ig, Rg, kT, TT;
function Ll() {
  if (!Yw) {
    Yw = !0;
    var e = navigator.userAgent, t = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e), n = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
    if (Ig = /\b(iPhone|iP[ao]d)/.exec(e), Rg = /\b(iP[ao]d)/.exec(e), Mg = /Android/i.exec(e), kT = /FBAN\/\w+;/i.exec(e), TT = /Mobile/i.exec(e), xT = !!/Win64/.exec(e), t) {
      oi = t[1] ? parseFloat(t[1]) : t[5] ? parseFloat(t[5]) : NaN, oi && document && document.documentMode && (oi = document.documentMode);
      var o = /(?:Trident\/(\d+.\d+))/.exec(e);
      _T = o ? parseFloat(o[1]) + 4 : oi, Tg = t[2] ? parseFloat(t[2]) : NaN, $g = t[3] ? parseFloat(t[3]) : NaN, yp = t[4] ? parseFloat(t[4]) : NaN, yp ? (t = /(?:Chrome\/(\d+\.\d+))/.exec(e), Cp = t && t[1] ? parseFloat(t[1]) : NaN) : Cp = NaN;
    } else
      oi = Tg = $g = Cp = yp = NaN;
    if (n) {
      if (n[1]) {
        var l = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
        wp = l ? parseFloat(l[1].replace("_", ".")) : !0;
      } else
        wp = !1;
      Og = !!n[2], Ng = !!n[3];
    } else
      wp = Og = Ng = !1;
  }
}
var Dg = { ie: function() {
  return Ll() || oi;
}, ieCompatibilityMode: function() {
  return Ll() || _T > oi;
}, ie64: function() {
  return Dg.ie() && xT;
}, firefox: function() {
  return Ll() || Tg;
}, opera: function() {
  return Ll() || $g;
}, webkit: function() {
  return Ll() || yp;
}, safari: function() {
  return Dg.webkit();
}, chrome: function() {
  return Ll() || Cp;
}, windows: function() {
  return Ll() || Og;
}, osx: function() {
  return Ll() || wp;
}, linux: function() {
  return Ll() || Ng;
}, iphone: function() {
  return Ll() || Ig;
}, mobile: function() {
  return Ll() || Ig || Rg || Mg || TT;
}, nativeApp: function() {
  return Ll() || kT;
}, android: function() {
  return Ll() || Mg;
}, ipad: function() {
  return Ll() || Rg;
} }, Az = Dg, Xf = !!(typeof window < "u" && window.document && window.document.createElement), Fz = { canUseDOM: Xf, canUseWorkers: typeof Worker < "u", canUseEventListeners: Xf && !!(window.addEventListener || window.attachEvent), canUseViewport: Xf && !!window.screen, isInWorker: !Xf }, $T = Fz, OT;
$T.canUseDOM && (OT = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0);
function Vz(e, t) {
  if (!$T.canUseDOM || t && !("addEventListener" in document))
    return !1;
  var n = "on" + e, o = n in document;
  if (!o) {
    var l = document.createElement("div");
    l.setAttribute(n, "return;"), o = typeof l[n] == "function";
  }
  return !o && OT && e === "wheel" && (o = document.implementation.hasFeature("Events.wheel", "3.0")), o;
}
var Bz = Vz, Gw = 10, Xw = 40, Zw = 800;
function NT(e) {
  var t = 0, n = 0, o = 0, l = 0;
  return "detail" in e && (n = e.detail), "wheelDelta" in e && (n = -e.wheelDelta / 120), "wheelDeltaY" in e && (n = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = n, n = 0), o = t * Gw, l = n * Gw, "deltaY" in e && (l = e.deltaY), "deltaX" in e && (o = e.deltaX), (o || l) && e.deltaMode && (e.deltaMode == 1 ? (o *= Xw, l *= Xw) : (o *= Zw, l *= Zw)), o && !t && (t = o < 1 ? -1 : 1), l && !n && (n = l < 1 ? -1 : 1), { spinX: t, spinY: n, pixelX: o, pixelY: l };
}
NT.getEventType = function() {
  return Az.firefox() ? "DOMMouseScroll" : Bz("wheel") ? "wheel" : "mousewheel";
};
var Hz = NT;
/**
* Checks if an event is supported in the current execution environment.
*
* NOTE: This will not work correctly for non-generic events such as `change`,
* `reset`, `load`, `error`, and `select`.
*
* Borrows from Modernizr.
*
* @param {string} eventNameSuffix Event name, e.g. "click".
* @param {?boolean} capture Check if the capture phase is supported.
* @return {boolean} True if the event is supported.
* @internal
* @license Modernizr 3.0.0pre (Custom Build) | MIT
*/
const zz = function(e, t) {
  if (e && e.addEventListener) {
    const n = function(o) {
      const l = Hz(o);
      t && Reflect.apply(t, this, [o, l]);
    };
    e.addEventListener("wheel", n, { passive: !0 });
  }
}, Wz = {
  beforeMount(e, t) {
    zz(e, t.value);
  }
}, Kz = it({
  role: {
    type: String,
    required: !0
  },
  spinnerDate: {
    type: Ae(Object),
    required: !0
  },
  showSeconds: {
    type: Boolean,
    default: !0
  },
  arrowControl: Boolean,
  amPmMode: {
    type: Ae(String),
    default: ""
  },
  ...gT
}), Uz = ["onClick"], jz = ["onMouseenter"], qz = /* @__PURE__ */ Q({
  __name: "basic-time-spinner",
  props: Kz,
  emits: ["change", "select-range", "set-option"],
  setup(e, { emit: t }) {
    const n = e, o = nt("time"), { getHoursList: l, getMinutesList: a, getSecondsList: r } = wT(n.disabledHours, n.disabledMinutes, n.disabledSeconds);
    let i = !1;
    const s = B(), u = B(), d = B(), f = B(), v = {
      hours: u,
      minutes: d,
      seconds: f
    }, h = x(() => n.showSeconds ? Bw : Bw.slice(0, 2)), m = x(() => {
      const { spinnerDate: O } = n, F = O.hour(), j = O.minute(), Z = O.second();
      return { hours: F, minutes: j, seconds: Z };
    }), p = x(() => {
      const { hours: O, minutes: F } = c(m);
      return {
        hours: l(n.role),
        minutes: a(O, n.role),
        seconds: r(O, F, n.role)
      };
    }), C = x(() => {
      const { hours: O, minutes: F, seconds: j } = c(m);
      return {
        hours: tm(O, 23),
        minutes: tm(F, 59),
        seconds: tm(j, 59)
      };
    }), g = Hl((O) => {
      i = !1, y(O);
    }, 200), w = (O) => {
      if (!!!n.amPmMode)
        return "";
      const j = n.amPmMode === "A";
      let Z = O < 12 ? " am" : " pm";
      return j && (Z = Z.toUpperCase()), Z;
    }, b = (O) => {
      let F;
      switch (O) {
        case "hours":
          F = [0, 2];
          break;
        case "minutes":
          F = [3, 5];
          break;
        case "seconds":
          F = [6, 8];
          break;
      }
      const [j, Z] = F;
      t("select-range", j, Z), s.value = O;
    }, y = (O) => {
      _(O, c(m)[O]);
    }, E = () => {
      y("hours"), y("minutes"), y("seconds");
    }, S = (O) => O.querySelector(`.${o.namespace.value}-scrollbar__wrap`), _ = (O, F) => {
      if (n.arrowControl)
        return;
      const j = c(v[O]);
      j && j.$el && (S(j.$el).scrollTop = Math.max(0, F * k(O)));
    }, k = (O) => {
      const F = c(v[O]), j = F == null ? void 0 : F.$el.querySelector("li");
      return j && Number.parseFloat(ps(j, "height")) || 0;
    }, N = () => {
      R(1);
    }, L = () => {
      R(-1);
    }, R = (O) => {
      s.value || b("hours");
      const F = s.value, j = c(m)[F], Z = s.value === "hours" ? 24 : 60, te = H(F, j, O, Z);
      K(F, te), _(F, te), xe(() => b(F));
    }, H = (O, F, j, Z) => {
      let te = (F + j + Z) % Z;
      const de = c(p)[O];
      for (; de[te] && te !== F; )
        te = (te + j + Z) % Z;
      return te;
    }, K = (O, F) => {
      if (c(p)[O][F])
        return;
      const { hours: te, minutes: de, seconds: Oe } = c(m);
      let ce;
      switch (O) {
        case "hours":
          ce = n.spinnerDate.hour(F).minute(de).second(Oe);
          break;
        case "minutes":
          ce = n.spinnerDate.hour(te).minute(F).second(Oe);
          break;
        case "seconds":
          ce = n.spinnerDate.hour(te).minute(de).second(F);
          break;
      }
      t("change", ce);
    }, U = (O, { value: F, disabled: j }) => {
      j || (K(O, F), b(O), _(O, F));
    }, W = (O) => {
      i = !0, g(O);
      const F = Math.min(Math.round((S(c(v[O]).$el).scrollTop - (A(O) * 0.5 - 10) / k(O) + 3) / k(O)), O === "hours" ? 23 : 59);
      K(O, F);
    }, A = (O) => c(v[O]).$el.offsetHeight, $ = () => {
      const O = (F) => {
        const j = c(v[F]);
        j && j.$el && (S(j.$el).onscroll = () => {
          W(F);
        });
      };
      O("hours"), O("minutes"), O("seconds");
    };
    Nt(() => {
      xe(() => {
        !n.arrowControl && $(), E(), n.role === "start" && b("hours");
      });
    });
    const D = (O, F) => {
      v[F].value = O;
    };
    return t("set-option", [`${n.role}_scrollDown`, R]), t("set-option", [`${n.role}_emitSelectRange`, b]), Pe(() => n.spinnerDate, () => {
      i || E();
    }), (O, F) => (M(), G("div", {
      class: z([c(o).b("spinner"), { "has-seconds": O.showSeconds }])
    }, [
      O.arrowControl ? _e("v-if", !0) : (M(!0), G(kt, { key: 0 }, ln(c(h), (j) => (M(), We(c(zr), {
        key: j,
        ref_for: !0,
        ref: (Z) => D(Z, j),
        class: z(c(o).be("spinner", "wrapper")),
        "wrap-style": "max-height: inherit;",
        "view-class": c(o).be("spinner", "list"),
        noresize: "",
        tag: "ul",
        onMouseenter: (Z) => b(j),
        onMousemove: (Z) => y(j)
      }, {
        default: fe(() => [
          (M(!0), G(kt, null, ln(c(p)[j], (Z, te) => (M(), G("li", {
            key: te,
            class: z([
              c(o).be("spinner", "item"),
              c(o).is("active", te === c(m)[j]),
              c(o).is("disabled", Z)
            ]),
            onClick: (de) => U(j, { value: te, disabled: Z })
          }, [
            j === "hours" ? (M(), G(kt, { key: 0 }, [
              Ut(Qe(("0" + (O.amPmMode ? te % 12 || 12 : te)).slice(-2)) + Qe(w(te)), 1)
            ], 64)) : (M(), G(kt, { key: 1 }, [
              Ut(Qe(("0" + te).slice(-2)), 1)
            ], 64))
          ], 10, Uz))), 128))
        ]),
        _: 2
      }, 1032, ["class", "view-class", "onMouseenter", "onMousemove"]))), 128)),
      O.arrowControl ? (M(!0), G(kt, { key: 1 }, ln(c(h), (j) => (M(), G("div", {
        key: j,
        class: z([c(o).be("spinner", "wrapper"), c(o).is("arrow")]),
        onMouseenter: (Z) => b(j)
      }, [
        Bt((M(), We(c(Ct), {
          class: z(["arrow-up", c(o).be("spinner", "arrow")])
        }, {
          default: fe(() => [
            oe(c(iy))
          ]),
          _: 1
        }, 8, ["class"])), [
          [c(Qp), L]
        ]),
        Bt((M(), We(c(Ct), {
          class: z(["arrow-down", c(o).be("spinner", "arrow")])
        }, {
          default: fe(() => [
            oe(c(Br))
          ]),
          _: 1
        }, 8, ["class"])), [
          [c(Qp), N]
        ]),
        X("ul", {
          class: z(c(o).be("spinner", "list"))
        }, [
          (M(!0), G(kt, null, ln(c(C)[j], (Z, te) => (M(), G("li", {
            key: te,
            class: z([
              c(o).be("spinner", "item"),
              c(o).is("active", Z === c(m)[j]),
              c(o).is("disabled", c(p)[j][Z])
            ])
          }, [
            typeof Z == "number" ? (M(), G(kt, { key: 0 }, [
              j === "hours" ? (M(), G(kt, { key: 0 }, [
                Ut(Qe(("0" + (O.amPmMode ? Z % 12 || 12 : Z)).slice(-2)) + Qe(w(Z)), 1)
              ], 64)) : (M(), G(kt, { key: 1 }, [
                Ut(Qe(("0" + Z).slice(-2)), 1)
              ], 64))
            ], 64)) : _e("v-if", !0)
          ], 2))), 128))
        ], 2)
      ], 42, jz))), 128)) : _e("v-if", !0)
    ], 2));
  }
});
var Lg = /* @__PURE__ */ ut(qz, [["__file", "basic-time-spinner.vue"]]);
const Yz = /* @__PURE__ */ Q({
  __name: "panel-time-pick",
  props: Rz,
  emits: ["pick", "select-range", "set-picker-option"],
  setup(e, { emit: t }) {
    const n = e, o = ot("EP_PICKER_BASE"), {
      arrowControl: l,
      disabledHours: a,
      disabledMinutes: r,
      disabledSeconds: i,
      defaultValue: s
    } = o.props, { getAvailableHours: u, getAvailableMinutes: d, getAvailableSeconds: f } = ET(a, r, i), v = nt("time"), { t: h, lang: m } = bn(), p = B([0, 2]), C = ST(n), g = x(() => To(n.actualVisible) ? `${v.namespace.value}-zoom-in-top` : ""), w = x(() => n.format.includes("ss")), b = x(() => n.format.includes("A") ? "A" : n.format.includes("a") ? "a" : ""), y = (D) => {
      const O = Gt(D).locale(m.value), F = U(O);
      return O.isSame(F);
    }, E = () => {
      t("pick", C.value, !1);
    }, S = (D = !1, O = !1) => {
      O || t("pick", n.parsedValue, D);
    }, _ = (D) => {
      if (!n.visible)
        return;
      const O = U(D).millisecond(0);
      t("pick", O, !0);
    }, k = (D, O) => {
      t("select-range", D, O), p.value = [D, O];
    }, N = (D) => {
      const O = [0, 3].concat(w.value ? [6] : []), F = ["hours", "minutes"].concat(w.value ? ["seconds"] : []), Z = (O.indexOf(p.value[0]) + D + O.length) % O.length;
      R.start_emitSelectRange(F[Z]);
    }, L = (D) => {
      const O = D.code, { left: F, right: j, up: Z, down: te } = xt;
      if ([F, j].includes(O)) {
        N(O === F ? -1 : 1), D.preventDefault();
        return;
      }
      if ([Z, te].includes(O)) {
        const de = O === Z ? -1 : 1;
        R.start_scrollDown(de), D.preventDefault();
        return;
      }
    }, { timePickerOptions: R, onSetOption: H, getAvailableTime: K } = CT({
      getAvailableHours: u,
      getAvailableMinutes: d,
      getAvailableSeconds: f
    }), U = (D) => K(D, n.datetimeRole || "", !0), W = (D) => D ? Gt(D, n.format).locale(m.value) : null, A = (D) => D ? D.format(n.format) : null, $ = () => Gt(s).locale(m.value);
    return t("set-picker-option", ["isValidValue", y]), t("set-picker-option", ["formatToString", A]), t("set-picker-option", ["parseUserInput", W]), t("set-picker-option", ["handleKeydownInput", L]), t("set-picker-option", ["getRangeAvailableTime", U]), t("set-picker-option", ["getDefaultValue", $]), (D, O) => (M(), We(Ko, { name: c(g) }, {
      default: fe(() => [
        D.actualVisible || D.visible ? (M(), G("div", {
          key: 0,
          class: z(c(v).b("panel"))
        }, [
          X("div", {
            class: z([c(v).be("panel", "content"), { "has-seconds": c(w) }])
          }, [
            oe(Lg, {
              ref: "spinner",
              role: D.datetimeRole || "start",
              "arrow-control": c(l),
              "show-seconds": c(w),
              "am-pm-mode": c(b),
              "spinner-date": D.parsedValue,
              "disabled-hours": c(a),
              "disabled-minutes": c(r),
              "disabled-seconds": c(i),
              onChange: _,
              onSetOption: c(H),
              onSelectRange: k
            }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onSetOption"])
          ], 2),
          X("div", {
            class: z(c(v).be("panel", "footer"))
          }, [
            X("button", {
              type: "button",
              class: z([c(v).be("panel", "btn"), "cancel"]),
              onClick: E
            }, Qe(c(h)("el.datepicker.cancel")), 3),
            X("button", {
              type: "button",
              class: z([c(v).be("panel", "btn"), "confirm"]),
              onClick: O[0] || (O[0] = (F) => S())
            }, Qe(c(h)("el.datepicker.confirm")), 3)
          ], 2)
        ], 2)) : _e("v-if", !0)
      ]),
      _: 1
    }, 8, ["name"]));
  }
});
var ev = /* @__PURE__ */ ut(Yz, [["__file", "panel-time-pick.vue"]]);
const Gz = it({
  ...bT,
  parsedValue: {
    type: Ae(Array)
  }
}), Xz = ["disabled"], Zz = /* @__PURE__ */ Q({
  __name: "panel-time-range",
  props: Gz,
  emits: ["pick", "select-range", "set-picker-option"],
  setup(e, { emit: t }) {
    const n = e, o = (he, De) => {
      const $e = [];
      for (let ue = he; ue <= De; ue++)
        $e.push(ue);
      return $e;
    }, { t: l, lang: a } = bn(), r = nt("time"), i = nt("picker"), s = ot("EP_PICKER_BASE"), {
      arrowControl: u,
      disabledHours: d,
      disabledMinutes: f,
      disabledSeconds: v,
      defaultValue: h
    } = s.props, m = x(() => [
      r.be("range-picker", "body"),
      r.be("panel", "content"),
      r.is("arrow", u),
      y.value ? "has-seconds" : ""
    ]), p = x(() => [
      r.be("range-picker", "body"),
      r.be("panel", "content"),
      r.is("arrow", u),
      y.value ? "has-seconds" : ""
    ]), C = x(() => n.parsedValue[0]), g = x(() => n.parsedValue[1]), w = ST(n), b = () => {
      t("pick", w.value, !1);
    }, y = x(() => n.format.includes("ss")), E = x(() => n.format.includes("A") ? "A" : n.format.includes("a") ? "a" : ""), S = (he = !1) => {
      t("pick", [C.value, g.value], he);
    }, _ = (he) => {
      L(he.millisecond(0), g.value);
    }, k = (he) => {
      L(C.value, he.millisecond(0));
    }, N = (he) => {
      const De = he.map((ue) => Gt(ue).locale(a.value)), $e = j(De);
      return De[0].isSame($e[0]) && De[1].isSame($e[1]);
    }, L = (he, De) => {
      t("pick", [he, De], !0);
    }, R = x(() => C.value > g.value), H = B([0, 2]), K = (he, De) => {
      t("select-range", he, De, "min"), H.value = [he, De];
    }, U = x(() => y.value ? 11 : 8), W = (he, De) => {
      t("select-range", he, De, "max");
      const $e = c(U);
      H.value = [he + $e, De + $e];
    }, A = (he) => {
      const De = y.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11], $e = ["hours", "minutes"].concat(y.value ? ["seconds"] : []), Ne = (De.indexOf(H.value[0]) + he + De.length) % De.length, je = De.length / 2;
      Ne < je ? Oe.start_emitSelectRange($e[Ne]) : Oe.end_emitSelectRange($e[Ne - je]);
    }, $ = (he) => {
      const De = he.code, { left: $e, right: ue, up: Ne, down: je } = xt;
      if ([$e, ue].includes(De)) {
        A(De === $e ? -1 : 1), he.preventDefault();
        return;
      }
      if ([Ne, je].includes(De)) {
        const Fe = De === Ne ? -1 : 1, Ve = H.value[0] < U.value ? "start" : "end";
        Oe[`${Ve}_scrollDown`](Fe), he.preventDefault();
        return;
      }
    }, D = (he, De) => {
      const $e = d ? d(he) : [], ue = he === "start", je = (De || (ue ? g.value : C.value)).hour(), Fe = ue ? o(je + 1, 23) : o(0, je - 1);
      return Uh($e, Fe);
    }, O = (he, De, $e) => {
      const ue = f ? f(he, De) : [], Ne = De === "start", je = $e || (Ne ? g.value : C.value), Fe = je.hour();
      if (he !== Fe)
        return ue;
      const Ve = je.minute(), Ze = Ne ? o(Ve + 1, 59) : o(0, Ve - 1);
      return Uh(ue, Ze);
    }, F = (he, De, $e, ue) => {
      const Ne = v ? v(he, De, $e) : [], je = $e === "start", Fe = ue || (je ? g.value : C.value), Ve = Fe.hour(), Ze = Fe.minute();
      if (he !== Ve || De !== Ze)
        return Ne;
      const ae = Fe.second(), pe = je ? o(ae + 1, 59) : o(0, ae - 1);
      return Uh(Ne, pe);
    }, j = ([he, De]) => [
      ce(he, "start", !0, De),
      ce(De, "end", !1, he)
    ], { getAvailableHours: Z, getAvailableMinutes: te, getAvailableSeconds: de } = ET(D, O, F), {
      timePickerOptions: Oe,
      getAvailableTime: ce,
      onSetOption: ne
    } = CT({
      getAvailableHours: Z,
      getAvailableMinutes: te,
      getAvailableSeconds: de
    }), Y = (he) => he ? Kt(he) ? he.map((De) => Gt(De, n.format).locale(a.value)) : Gt(he, n.format).locale(a.value) : null, ve = (he) => he ? Kt(he) ? he.map((De) => De.format(n.format)) : he.format(n.format) : null, ie = () => {
      if (Kt(h))
        return h.map((De) => Gt(De).locale(a.value));
      const he = Gt(h).locale(a.value);
      return [he, he.add(60, "m")];
    };
    return t("set-picker-option", ["formatToString", ve]), t("set-picker-option", ["parseUserInput", Y]), t("set-picker-option", ["isValidValue", N]), t("set-picker-option", ["handleKeydownInput", $]), t("set-picker-option", ["getDefaultValue", ie]), t("set-picker-option", ["getRangeAvailableTime", j]), (he, De) => he.actualVisible ? (M(), G("div", {
      key: 0,
      class: z([c(r).b("range-picker"), c(i).b("panel")])
    }, [
      X("div", {
        class: z(c(r).be("range-picker", "content"))
      }, [
        X("div", {
          class: z(c(r).be("range-picker", "cell"))
        }, [
          X("div", {
            class: z(c(r).be("range-picker", "header"))
          }, Qe(c(l)("el.datepicker.startTime")), 3),
          X("div", {
            class: z(c(m))
          }, [
            oe(Lg, {
              ref: "minSpinner",
              role: "start",
              "show-seconds": c(y),
              "am-pm-mode": c(E),
              "arrow-control": c(u),
              "spinner-date": c(C),
              "disabled-hours": D,
              "disabled-minutes": O,
              "disabled-seconds": F,
              onChange: _,
              onSetOption: c(ne),
              onSelectRange: K
            }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
          ], 2)
        ], 2),
        X("div", {
          class: z(c(r).be("range-picker", "cell"))
        }, [
          X("div", {
            class: z(c(r).be("range-picker", "header"))
          }, Qe(c(l)("el.datepicker.endTime")), 3),
          X("div", {
            class: z(c(p))
          }, [
            oe(Lg, {
              ref: "maxSpinner",
              role: "end",
              "show-seconds": c(y),
              "am-pm-mode": c(E),
              "arrow-control": c(u),
              "spinner-date": c(g),
              "disabled-hours": D,
              "disabled-minutes": O,
              "disabled-seconds": F,
              onChange: k,
              onSetOption: c(ne),
              onSelectRange: W
            }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
          ], 2)
        ], 2)
      ], 2),
      X("div", {
        class: z(c(r).be("panel", "footer"))
      }, [
        X("button", {
          type: "button",
          class: z([c(r).be("panel", "btn"), "cancel"]),
          onClick: De[0] || (De[0] = ($e) => b())
        }, Qe(c(l)("el.datepicker.cancel")), 3),
        X("button", {
          type: "button",
          class: z([c(r).be("panel", "btn"), "confirm"]),
          disabled: c(R),
          onClick: De[1] || (De[1] = ($e) => S())
        }, Qe(c(l)("el.datepicker.confirm")), 11, Xz)
      ], 2)
    ], 2)) : _e("v-if", !0);
  }
});
var Jz = /* @__PURE__ */ ut(Zz, [["__file", "panel-time-range.vue"]]);
Gt.extend(Wy);
var Qz = Q({
  name: "ElTimePicker",
  install: null,
  props: {
    ...Ky,
    isRange: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, t) {
    const n = B(), [o, l] = e.isRange ? ["timerange", Jz] : ["time", ev], a = (r) => t.emit("update:modelValue", r);
    return Mt("ElPopperOptions", e.popperOptions), t.expose({
      focus: (r) => {
        var i;
        (i = n.value) == null || i.handleFocusInput(r);
      },
      blur: (r) => {
        var i;
        (i = n.value) == null || i.handleBlurInput(r);
      },
      handleOpen: () => {
        var r;
        (r = n.value) == null || r.handleOpen();
      },
      handleClose: () => {
        var r;
        (r = n.value) == null || r.handleClose();
      }
    }), () => {
      var r;
      const i = (r = e.format) != null ? r : xg;
      return oe(yT, Et(e, {
        ref: n,
        type: o,
        format: i,
        "onUpdate:modelValue": a
      }), {
        default: (s) => oe(l, s, null)
      });
    };
  }
});
const Ep = Qz;
Ep.install = (e) => {
  e.component(Ep.name, Ep);
};
const e9 = Ep, t9 = (e, t) => {
  const n = e.subtract(1, "month").endOf("month").date();
  return ys(t).map((o, l) => n - (t - l - 1));
}, n9 = (e) => {
  const t = e.daysInMonth();
  return ys(t).map((n, o) => o + 1);
}, o9 = (e) => ys(e.length / 7).map((t) => {
  const n = t * 7;
  return e.slice(n, n + 7);
}), l9 = it({
  selectedDay: {
    type: Ae(Object)
  },
  range: {
    type: Ae(Array)
  },
  date: {
    type: Ae(Object),
    required: !0
  },
  hideHeader: {
    type: Boolean
  }
}), a9 = {
  pick: (e) => Mn(e)
};
var MT = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Wr, function() {
    return function(n, o, l) {
      var a = o.prototype, r = function(f) {
        return f && (f.indexOf ? f : f.s);
      }, i = function(f, v, h, m, p) {
        var C = f.name ? f : f.$locale(), g = r(C[v]), w = r(C[h]), b = g || w.map(function(E) {
          return E.slice(0, m);
        });
        if (!p)
          return b;
        var y = C.weekStart;
        return b.map(function(E, S) {
          return b[(S + (y || 0)) % 7];
        });
      }, s = function() {
        return l.Ls[l.locale()];
      }, u = function(f, v) {
        return f.formats[v] || function(h) {
          return h.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(m, p, C) {
            return p || C.slice(1);
          });
        }(f.formats[v.toUpperCase()]);
      }, d = function() {
        var f = this;
        return { months: function(v) {
          return v ? v.format("MMMM") : i(f, "months");
        }, monthsShort: function(v) {
          return v ? v.format("MMM") : i(f, "monthsShort", "months", 3);
        }, firstDayOfWeek: function() {
          return f.$locale().weekStart || 0;
        }, weekdays: function(v) {
          return v ? v.format("dddd") : i(f, "weekdays");
        }, weekdaysMin: function(v) {
          return v ? v.format("dd") : i(f, "weekdaysMin", "weekdays", 2);
        }, weekdaysShort: function(v) {
          return v ? v.format("ddd") : i(f, "weekdaysShort", "weekdays", 3);
        }, longDateFormat: function(v) {
          return u(f.$locale(), v);
        }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
      };
      a.localeData = function() {
        return d.bind(this)();
      }, l.localeData = function() {
        var f = s();
        return { firstDayOfWeek: function() {
          return f.weekStart || 0;
        }, weekdays: function() {
          return l.weekdays();
        }, weekdaysShort: function() {
          return l.weekdaysShort();
        }, weekdaysMin: function() {
          return l.weekdaysMin();
        }, months: function() {
          return l.months();
        }, monthsShort: function() {
          return l.monthsShort();
        }, longDateFormat: function(v) {
          return u(f, v);
        }, meridiem: f.meridiem, ordinal: f.ordinal };
      }, l.months = function() {
        return i(s(), "months");
      }, l.monthsShort = function() {
        return i(s(), "monthsShort", "months", 3);
      }, l.weekdays = function(f) {
        return i(s(), "weekdays", null, null, f);
      }, l.weekdaysShort = function(f) {
        return i(s(), "weekdaysShort", "weekdays", 3, f);
      }, l.weekdaysMin = function(f) {
        return i(s(), "weekdaysMin", "weekdays", 2, f);
      };
    };
  });
})(MT);
var r9 = MT.exports;
const IT = /* @__PURE__ */ pr(r9), s9 = (e, t) => {
  Gt.extend(IT);
  const n = Gt.localeData().firstDayOfWeek(), { t: o, lang: l } = bn(), a = Gt().locale(l.value), r = x(() => !!e.range && !!e.range.length), i = x(() => {
    let v = [];
    if (r.value) {
      const [h, m] = e.range, p = ys(m.date() - h.date() + 1).map((w) => ({
        text: h.date() + w,
        type: "current"
      }));
      let C = p.length % 7;
      C = C === 0 ? 0 : 7 - C;
      const g = ys(C).map((w, b) => ({
        text: b + 1,
        type: "next"
      }));
      v = p.concat(g);
    } else {
      const h = e.date.startOf("month").day(), m = t9(e.date, (h - n + 7) % 7).map((w) => ({
        text: w,
        type: "prev"
      })), p = n9(e.date).map((w) => ({
        text: w,
        type: "current"
      }));
      v = [...m, ...p];
      const C = 7 - (v.length % 7 || 7), g = ys(C).map((w, b) => ({
        text: b + 1,
        type: "next"
      }));
      v = v.concat(g);
    }
    return o9(v);
  }), s = x(() => {
    const v = n;
    return v === 0 ? jh.map((h) => o(`el.datepicker.weeks.${h}`)) : jh.slice(v).concat(jh.slice(0, v)).map((h) => o(`el.datepicker.weeks.${h}`));
  }), u = (v, h) => {
    switch (h) {
      case "prev":
        return e.date.startOf("month").subtract(1, "month").date(v);
      case "next":
        return e.date.startOf("month").add(1, "month").date(v);
      case "current":
        return e.date.date(v);
    }
  };
  return {
    now: a,
    isInRange: r,
    rows: i,
    weekDays: s,
    getFormattedDate: u,
    handlePickDay: ({ text: v, type: h }) => {
      const m = u(v, h);
      t("pick", m);
    },
    getSlotData: ({ text: v, type: h }) => {
      const m = u(v, h);
      return {
        isSelected: m.isSame(e.selectedDay),
        type: `${h}-month`,
        day: m.format("YYYY-MM-DD"),
        date: m.toDate()
      };
    }
  };
}, i9 = { key: 0 }, c9 = ["onClick"], u9 = Q({
  name: "DateTable"
}), d9 = /* @__PURE__ */ Q({
  ...u9,
  props: l9,
  emits: a9,
  setup(e, { expose: t, emit: n }) {
    const o = e, {
      isInRange: l,
      now: a,
      rows: r,
      weekDays: i,
      getFormattedDate: s,
      handlePickDay: u,
      getSlotData: d
    } = s9(o, n), f = nt("calendar-table"), v = nt("calendar-day"), h = ({ text: m, type: p }) => {
      const C = [p];
      if (p === "current") {
        const g = s(m, p);
        g.isSame(o.selectedDay, "day") && C.push(v.is("selected")), g.isSame(a, "day") && C.push(v.is("today"));
      }
      return C;
    };
    return t({
      getFormattedDate: s
    }), (m, p) => (M(), G("table", {
      class: z([c(f).b(), c(f).is("range", c(l))]),
      cellspacing: "0",
      cellpadding: "0"
    }, [
      m.hideHeader ? _e("v-if", !0) : (M(), G("thead", i9, [
        (M(!0), G(kt, null, ln(c(i), (C) => (M(), G("th", { key: C }, Qe(C), 1))), 128))
      ])),
      X("tbody", null, [
        (M(!0), G(kt, null, ln(c(r), (C, g) => (M(), G("tr", {
          key: g,
          class: z({
            [c(f).e("row")]: !0,
            [c(f).em("row", "hide-border")]: g === 0 && m.hideHeader
          })
        }, [
          (M(!0), G(kt, null, ln(C, (w, b) => (M(), G("td", {
            key: b,
            class: z(h(w)),
            onClick: (y) => c(u)(w)
          }, [
            X("div", {
              class: z(c(v).b())
            }, [
              Ie(m.$slots, "date-cell", {
                data: c(d)(w)
              }, () => [
                X("span", null, Qe(w.text), 1)
              ])
            ], 2)
          ], 10, c9))), 128))
        ], 2))), 128))
      ])
    ], 2));
  }
});
var Jw = /* @__PURE__ */ ut(d9, [["__file", "date-table.vue"]]);
const f9 = (e, t) => {
  const n = e.endOf("month"), o = t.startOf("month"), a = n.isSame(o, "week") ? o.add(1, "week") : o;
  return [
    [e, n],
    [a.startOf("week"), t]
  ];
}, p9 = (e, t) => {
  const n = e.endOf("month"), o = e.add(1, "month").startOf("month"), l = n.isSame(o, "week") ? o.add(1, "week") : o, a = l.endOf("month"), r = t.startOf("month"), i = a.isSame(r, "week") ? r.add(1, "week") : r;
  return [
    [e, n],
    [l.startOf("week"), a],
    [i.startOf("week"), t]
  ];
}, v9 = (e, t, n) => {
  const { lang: o } = bn(), l = B(), a = Gt().locale(o.value), r = x({
    get() {
      return e.modelValue ? s.value : l.value;
    },
    set(C) {
      if (!C)
        return;
      l.value = C;
      const g = C.toDate();
      t(kl, g), t(Jt, g);
    }
  }), i = x(() => {
    if (!e.range)
      return [];
    const C = e.range.map((b) => Gt(b).locale(o.value)), [g, w] = C;
    return g.isAfter(w) ? (dn(n, "end time should be greater than start time"), []) : g.isSame(w, "month") ? h(g, w) : g.add(1, "month").month() !== w.month() ? (dn(n, "start time and end time interval must not exceed two months"), []) : h(g, w);
  }), s = x(() => e.modelValue ? Gt(e.modelValue).locale(o.value) : r.value || (i.value.length ? i.value[0][0] : a)), u = x(() => s.value.subtract(1, "month").date(1)), d = x(() => s.value.add(1, "month").date(1)), f = x(() => s.value.subtract(1, "year").date(1)), v = x(() => s.value.add(1, "year").date(1)), h = (C, g) => {
    const w = C.startOf("week"), b = g.endOf("week"), y = w.get("month"), E = b.get("month");
    return y === E ? [[w, b]] : (y + 1) % 12 === E ? f9(w, b) : y + 2 === E || (y + 1) % 11 === E ? p9(w, b) : (dn(n, "start time and end time interval must not exceed two months"), []);
  }, m = (C) => {
    r.value = C;
  };
  return {
    calculateValidatedDateRange: h,
    date: s,
    realSelectedDay: r,
    pickDay: m,
    selectDate: (C) => {
      const w = {
        "prev-month": u.value,
        "next-month": d.value,
        "prev-year": f.value,
        "next-year": v.value,
        today: a
      }[C];
      w.isSame(s.value, "day") || m(w);
    },
    validatedRange: i
  };
}, h9 = (e) => Kt(e) && e.length === 2 && e.every((t) => _d(t)), m9 = it({
  modelValue: {
    type: Date
  },
  range: {
    type: Ae(Array),
    validator: h9
  }
}), g9 = {
  [Jt]: (e) => _d(e),
  [kl]: (e) => _d(e)
}, RT = "ElCalendar", b9 = Q({
  name: RT
}), y9 = /* @__PURE__ */ Q({
  ...b9,
  props: m9,
  emits: g9,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = nt("calendar"), {
      calculateValidatedDateRange: a,
      date: r,
      pickDay: i,
      realSelectedDay: s,
      selectDate: u,
      validatedRange: d
    } = v9(o, n, RT), { t: f } = bn(), v = x(() => {
      const h = `el.datepicker.month${r.value.format("M")}`;
      return `${r.value.year()} ${f("el.datepicker.year")} ${f(h)}`;
    });
    return t({
      selectedDay: s,
      pickDay: i,
      selectDate: u,
      calculateValidatedDateRange: a
    }), (h, m) => (M(), G("div", {
      class: z(c(l).b())
    }, [
      X("div", {
        class: z(c(l).e("header"))
      }, [
        Ie(h.$slots, "header", { date: c(v) }, () => [
          X("div", {
            class: z(c(l).e("title"))
          }, Qe(c(v)), 3),
          c(d).length === 0 ? (M(), G("div", {
            key: 0,
            class: z(c(l).e("button-group"))
          }, [
            oe(c(fT), null, {
              default: fe(() => [
                oe(c(Do), {
                  size: "small",
                  onClick: m[0] || (m[0] = (p) => c(u)("prev-month"))
                }, {
                  default: fe(() => [
                    Ut(Qe(c(f)("el.datepicker.prevMonth")), 1)
                  ]),
                  _: 1
                }),
                oe(c(Do), {
                  size: "small",
                  onClick: m[1] || (m[1] = (p) => c(u)("today"))
                }, {
                  default: fe(() => [
                    Ut(Qe(c(f)("el.datepicker.today")), 1)
                  ]),
                  _: 1
                }),
                oe(c(Do), {
                  size: "small",
                  onClick: m[2] || (m[2] = (p) => c(u)("next-month"))
                }, {
                  default: fe(() => [
                    Ut(Qe(c(f)("el.datepicker.nextMonth")), 1)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ], 2)) : _e("v-if", !0)
        ])
      ], 2),
      c(d).length === 0 ? (M(), G("div", {
        key: 0,
        class: z(c(l).e("body"))
      }, [
        oe(Jw, {
          date: c(r),
          "selected-day": c(s),
          onPick: c(i)
        }, rl({ _: 2 }, [
          h.$slots["date-cell"] ? {
            name: "date-cell",
            fn: fe((p) => [
              Ie(h.$slots, "date-cell", xo(Ao(p)))
            ])
          } : void 0
        ]), 1032, ["date", "selected-day", "onPick"])
      ], 2)) : (M(), G("div", {
        key: 1,
        class: z(c(l).e("body"))
      }, [
        (M(!0), G(kt, null, ln(c(d), (p, C) => (M(), We(Jw, {
          key: C,
          date: p[0],
          "selected-day": c(s),
          range: p,
          "hide-header": C !== 0,
          onPick: c(i)
        }, rl({ _: 2 }, [
          h.$slots["date-cell"] ? {
            name: "date-cell",
            fn: fe((g) => [
              Ie(h.$slots, "date-cell", xo(Ao(g)))
            ])
          } : void 0
        ]), 1032, ["date", "selected-day", "range", "hide-header", "onPick"]))), 128))
      ], 2))
    ], 2));
  }
});
var C9 = /* @__PURE__ */ ut(y9, [["__file", "calendar.vue"]]);
const w9 = Yt(C9), E9 = it({
  header: {
    type: String,
    default: ""
  },
  footer: {
    type: String,
    default: ""
  },
  bodyStyle: {
    type: Ae([String, Object, Array]),
    default: ""
  },
  bodyClass: String,
  shadow: {
    type: String,
    values: ["always", "hover", "never"],
    default: "always"
  }
}), S9 = Q({
  name: "ElCard"
}), _9 = /* @__PURE__ */ Q({
  ...S9,
  props: E9,
  setup(e) {
    const t = nt("card");
    return (n, o) => (M(), G("div", {
      class: z([c(t).b(), c(t).is(`${n.shadow}-shadow`)])
    }, [
      n.$slots.header || n.header ? (M(), G("div", {
        key: 0,
        class: z(c(t).e("header"))
      }, [
        Ie(n.$slots, "header", {}, () => [
          Ut(Qe(n.header), 1)
        ])
      ], 2)) : _e("v-if", !0),
      X("div", {
        class: z([c(t).e("body"), n.bodyClass]),
        style: bt(n.bodyStyle)
      }, [
        Ie(n.$slots, "default")
      ], 6),
      n.$slots.footer || n.footer ? (M(), G("div", {
        key: 1,
        class: z(c(t).e("footer"))
      }, [
        Ie(n.$slots, "footer", {}, () => [
          Ut(Qe(n.footer), 1)
        ])
      ], 2)) : _e("v-if", !0)
    ], 2));
  }
});
var x9 = /* @__PURE__ */ ut(_9, [["__file", "card.vue"]]);
const k9 = Yt(x9), T9 = it({
  initialIndex: {
    type: Number,
    default: 0
  },
  height: {
    type: String,
    default: ""
  },
  trigger: {
    type: String,
    values: ["hover", "click"],
    default: "hover"
  },
  autoplay: {
    type: Boolean,
    default: !0
  },
  interval: {
    type: Number,
    default: 3e3
  },
  indicatorPosition: {
    type: String,
    values: ["", "none", "outside"],
    default: ""
  },
  arrow: {
    type: String,
    values: ["always", "hover", "never"],
    default: "hover"
  },
  type: {
    type: String,
    values: ["", "card"],
    default: ""
  },
  loop: {
    type: Boolean,
    default: !0
  },
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  pauseOnHover: {
    type: Boolean,
    default: !0
  },
  motionBlur: {
    type: Boolean,
    default: !1
  }
}), $9 = {
  change: (e, t) => [e, t].every(Ot)
}, DT = Symbol("carouselContextKey"), Qw = 300, O9 = (e, t, n) => {
  const {
    children: o,
    addChild: l,
    removeChild: a
  } = Ly(Pt(), "ElCarouselItem"), r = Yn(), i = B(-1), s = B(null), u = B(!1), d = B(), f = B(0), v = B(!0), h = B(!0), m = B(!1), p = x(() => e.arrow !== "never" && !c(w)), C = x(() => o.value.some((ce) => ce.props.label.toString().length > 0)), g = x(() => e.type === "card"), w = x(() => e.direction === "vertical"), b = x(() => e.height !== "auto" ? {
    height: e.height
  } : {
    height: `${f.value}px`,
    overflow: "hidden"
  }), y = mi((ce) => {
    L(ce);
  }, Qw, { trailing: !0 }), E = mi((ce) => {
    O(ce);
  }, Qw), S = (ce) => v.value ? i.value <= 1 ? ce <= 1 : ce > 1 : !0;
  function _() {
    s.value && (clearInterval(s.value), s.value = null);
  }
  function k() {
    e.interval <= 0 || !e.autoplay || s.value || (s.value = setInterval(() => N(), e.interval));
  }
  const N = () => {
    h.value || (m.value = !0), h.value = !1, i.value < o.value.length - 1 ? i.value = i.value + 1 : e.loop && (i.value = 0);
  };
  function L(ce) {
    if (h.value || (m.value = !0), h.value = !1, on(ce)) {
      const ve = o.value.filter((ie) => ie.props.name === ce);
      ve.length > 0 && (ce = o.value.indexOf(ve[0]));
    }
    if (ce = Number(ce), Number.isNaN(ce) || ce !== Math.floor(ce)) {
      dn(n, "index must be integer.");
      return;
    }
    const ne = o.value.length, Y = i.value;
    ce < 0 ? i.value = e.loop ? ne - 1 : 0 : ce >= ne ? i.value = e.loop ? 0 : ne - 1 : i.value = ce, Y === i.value && R(Y), Z();
  }
  function R(ce) {
    o.value.forEach((ne, Y) => {
      ne.translateItem(Y, i.value, ce);
    });
  }
  function H(ce, ne) {
    var Y, ve, ie, he;
    const De = c(o), $e = De.length;
    if ($e === 0 || !ce.states.inStage)
      return !1;
    const ue = ne + 1, Ne = ne - 1, je = $e - 1, Fe = De[je].states.active, Ve = De[0].states.active, Ze = (ve = (Y = De[ue]) == null ? void 0 : Y.states) == null ? void 0 : ve.active, ae = (he = (ie = De[Ne]) == null ? void 0 : ie.states) == null ? void 0 : he.active;
    return ne === je && Ve || Ze ? "left" : ne === 0 && Fe || ae ? "right" : !1;
  }
  function K() {
    u.value = !0, e.pauseOnHover && _();
  }
  function U() {
    u.value = !1, k();
  }
  function W() {
    m.value = !1;
  }
  function A(ce) {
    c(w) || o.value.forEach((ne, Y) => {
      ce === H(ne, Y) && (ne.states.hover = !0);
    });
  }
  function $() {
    c(w) || o.value.forEach((ce) => {
      ce.states.hover = !1;
    });
  }
  function D(ce) {
    ce !== i.value && (h.value || (m.value = !0)), i.value = ce;
  }
  function O(ce) {
    e.trigger === "hover" && ce !== i.value && (i.value = ce, h.value || (m.value = !0));
  }
  function F() {
    L(i.value - 1);
  }
  function j() {
    L(i.value + 1);
  }
  function Z() {
    _(), e.pauseOnHover || k();
  }
  function te(ce) {
    e.height === "auto" && (f.value = ce);
  }
  function de() {
    var ce;
    const ne = (ce = r.default) == null ? void 0 : ce.call(r);
    if (!ne)
      return null;
    const Y = bs(ne), ve = "ElCarouselItem", ie = Y.filter((he) => yo(he) && he.type.name === ve);
    return (ie == null ? void 0 : ie.length) === 2 && e.loop && !g.value ? (v.value = !0, ie) : (v.value = !1, null);
  }
  Pe(() => i.value, (ce, ne) => {
    R(ne), v.value && (ce = ce % 2, ne = ne % 2), ne > -1 && t("change", ce, ne);
  }), Pe(() => e.autoplay, (ce) => {
    ce ? k() : _();
  }), Pe(() => e.loop, () => {
    L(i.value);
  }), Pe(() => e.interval, () => {
    Z();
  });
  const Oe = An();
  return Nt(() => {
    Pe(() => o.value, () => {
      o.value.length > 0 && L(e.initialIndex);
    }, {
      immediate: !0
    }), Oe.value = Xn(d.value, () => {
      R();
    }), k();
  }), zn(() => {
    _(), d.value && Oe.value && Oe.value.stop();
  }), Mt(DT, {
    root: d,
    isCardType: g,
    isVertical: w,
    items: o,
    loop: e.loop,
    addItem: l,
    removeItem: a,
    setActiveItem: L,
    setContainerHeight: te
  }), {
    root: d,
    activeIndex: i,
    arrowDisplay: p,
    hasLabel: C,
    hover: u,
    isCardType: g,
    isTransitioning: m,
    items: o,
    isVertical: w,
    containerStyle: b,
    isItemsTwoLength: v,
    handleButtonEnter: A,
    handleTransitionEnd: W,
    handleButtonLeave: $,
    handleIndicatorClick: D,
    handleMouseEnter: K,
    handleMouseLeave: U,
    setActiveItem: L,
    prev: F,
    next: j,
    PlaceholderItem: de,
    isTwoLengthShow: S,
    throttledArrowClick: y,
    throttledIndicatorHover: E
  };
}, N9 = ["aria-label"], M9 = ["aria-label"], I9 = ["onMouseenter", "onClick"], R9 = ["aria-label"], D9 = { key: 0 }, L9 = {
  key: 3,
  xmlns: "http://www.w3.org/2000/svg",
  version: "1.1",
  style: { display: "none" }
}, P9 = /* @__PURE__ */ X("defs", null, [
  /* @__PURE__ */ X("filter", { id: "elCarouselHorizontal" }, [
    /* @__PURE__ */ X("feGaussianBlur", {
      in: "SourceGraphic",
      stdDeviation: "12,0"
    })
  ]),
  /* @__PURE__ */ X("filter", { id: "elCarouselVertical" }, [
    /* @__PURE__ */ X("feGaussianBlur", {
      in: "SourceGraphic",
      stdDeviation: "0,10"
    })
  ])
], -1), A9 = [
  P9
], LT = "ElCarousel", F9 = Q({
  name: LT
}), V9 = /* @__PURE__ */ Q({
  ...F9,
  props: T9,
  emits: $9,
  setup(e, { expose: t, emit: n }) {
    const o = e, {
      root: l,
      activeIndex: a,
      arrowDisplay: r,
      hasLabel: i,
      hover: s,
      isCardType: u,
      items: d,
      isVertical: f,
      containerStyle: v,
      handleButtonEnter: h,
      handleButtonLeave: m,
      isTransitioning: p,
      handleIndicatorClick: C,
      handleMouseEnter: g,
      handleMouseLeave: w,
      handleTransitionEnd: b,
      setActiveItem: y,
      prev: E,
      next: S,
      PlaceholderItem: _,
      isTwoLengthShow: k,
      throttledArrowClick: N,
      throttledIndicatorHover: L
    } = O9(o, n, LT), R = nt("carousel"), { t: H } = bn(), K = x(() => {
      const A = [R.b(), R.m(o.direction)];
      return c(u) && A.push(R.m("card")), A;
    }), U = x(() => {
      const A = [R.e("container")];
      return o.motionBlur && c(p) && A.push(c(f) ? `${R.namespace.value}-transitioning-vertical` : `${R.namespace.value}-transitioning`), A;
    }), W = x(() => {
      const A = [R.e("indicators"), R.em("indicators", o.direction)];
      return c(i) && A.push(R.em("indicators", "labels")), o.indicatorPosition === "outside" && A.push(R.em("indicators", "outside")), c(f) && A.push(R.em("indicators", "right")), A;
    });
    return t({
      setActiveItem: y,
      prev: E,
      next: S
    }), (A, $) => (M(), G("div", {
      ref_key: "root",
      ref: l,
      class: z(c(K)),
      onMouseenter: $[7] || ($[7] = It((...D) => c(g) && c(g)(...D), ["stop"])),
      onMouseleave: $[8] || ($[8] = It((...D) => c(w) && c(w)(...D), ["stop"]))
    }, [
      c(r) ? (M(), We(Ko, {
        key: 0,
        name: "carousel-arrow-left",
        persisted: ""
      }, {
        default: fe(() => [
          Bt(X("button", {
            type: "button",
            class: z([c(R).e("arrow"), c(R).em("arrow", "left")]),
            "aria-label": c(H)("el.carousel.leftArrow"),
            onMouseenter: $[0] || ($[0] = (D) => c(h)("left")),
            onMouseleave: $[1] || ($[1] = (...D) => c(m) && c(m)(...D)),
            onClick: $[2] || ($[2] = It((D) => c(N)(c(a) - 1), ["stop"]))
          }, [
            oe(c(Ct), null, {
              default: fe(() => [
                oe(c(ks))
              ]),
              _: 1
            })
          ], 42, N9), [
            [
              pn,
              (A.arrow === "always" || c(s)) && (o.loop || c(a) > 0)
            ]
          ])
        ]),
        _: 1
      })) : _e("v-if", !0),
      c(r) ? (M(), We(Ko, {
        key: 1,
        name: "carousel-arrow-right",
        persisted: ""
      }, {
        default: fe(() => [
          Bt(X("button", {
            type: "button",
            class: z([c(R).e("arrow"), c(R).em("arrow", "right")]),
            "aria-label": c(H)("el.carousel.rightArrow"),
            onMouseenter: $[3] || ($[3] = (D) => c(h)("right")),
            onMouseleave: $[4] || ($[4] = (...D) => c(m) && c(m)(...D)),
            onClick: $[5] || ($[5] = It((D) => c(N)(c(a) + 1), ["stop"]))
          }, [
            oe(c(Ct), null, {
              default: fe(() => [
                oe(c(xl))
              ]),
              _: 1
            })
          ], 42, M9), [
            [
              pn,
              (A.arrow === "always" || c(s)) && (o.loop || c(a) < c(d).length - 1)
            ]
          ])
        ]),
        _: 1
      })) : _e("v-if", !0),
      X("div", {
        class: z(c(U)),
        style: bt(c(v)),
        onTransitionend: $[6] || ($[6] = (...D) => c(b) && c(b)(...D))
      }, [
        oe(c(_)),
        Ie(A.$slots, "default")
      ], 38),
      A.indicatorPosition !== "none" ? (M(), G("ul", {
        key: 2,
        class: z(c(W))
      }, [
        (M(!0), G(kt, null, ln(c(d), (D, O) => Bt((M(), G("li", {
          key: O,
          class: z([
            c(R).e("indicator"),
            c(R).em("indicator", A.direction),
            c(R).is("active", O === c(a))
          ]),
          onMouseenter: (F) => c(L)(O),
          onClick: It((F) => c(C)(O), ["stop"])
        }, [
          X("button", {
            class: z(c(R).e("button")),
            "aria-label": c(H)("el.carousel.indicator", { index: O + 1 })
          }, [
            c(i) ? (M(), G("span", D9, Qe(D.props.label), 1)) : _e("v-if", !0)
          ], 10, R9)
        ], 42, I9)), [
          [pn, c(k)(O)]
        ])), 128))
      ], 2)) : _e("v-if", !0),
      o.motionBlur ? (M(), G("svg", L9, A9)) : _e("v-if", !0)
    ], 34));
  }
});
var B9 = /* @__PURE__ */ ut(V9, [["__file", "carousel.vue"]]);
const H9 = it({
  name: { type: String, default: "" },
  label: {
    type: [String, Number],
    default: ""
  }
}), z9 = (e, t) => {
  const n = ot(DT), o = Pt();
  n || dn(t, "usage: <el-carousel></el-carousel-item></el-carousel>"), o || dn(t, "compositional hook can only be invoked inside setups");
  const l = 0.83, a = B(), r = B(!1), i = B(0), s = B(1), u = B(!1), d = B(!1), f = B(!1), v = B(!1), { isCardType: h, isVertical: m } = n;
  function p(y, E, S) {
    const _ = S - 1, k = E - 1, N = E + 1, L = S / 2;
    return E === 0 && y === _ ? -1 : E === _ && y === 0 ? S : y < k && E - y >= L ? S + 1 : y > N && y - E >= L ? -2 : y;
  }
  function C(y, E) {
    var S, _;
    const k = c(m) ? ((S = n.root.value) == null ? void 0 : S.offsetHeight) || 0 : ((_ = n.root.value) == null ? void 0 : _.offsetWidth) || 0;
    return f.value ? k * ((2 - l) * (y - E) + 1) / 4 : y < E ? -(1 + l) * k / 4 : (3 + l) * k / 4;
  }
  function g(y, E, S) {
    const _ = n.root.value;
    return _ ? ((S ? _.offsetHeight : _.offsetWidth) || 0) * (y - E) : 0;
  }
  const w = (y, E, S) => {
    var _;
    const k = c(h), N = (_ = n.items.value.length) != null ? _ : Number.NaN, L = y === E;
    !k && !To(S) && (v.value = L || y === S), !L && N > 2 && n.loop && (y = p(y, E, N));
    const R = c(m);
    u.value = L, k ? (f.value = Math.round(Math.abs(y - E)) <= 1, i.value = C(y, E), s.value = c(u) ? 1 : l) : i.value = g(y, E, R), d.value = !0, L && a.value && n.setContainerHeight(a.value.offsetHeight);
  };
  function b() {
    if (n && c(h)) {
      const y = n.items.value.findIndex(({ uid: E }) => E === o.uid);
      n.setActiveItem(y);
    }
  }
  return Nt(() => {
    n.addItem({
      props: e,
      states: en({
        hover: r,
        translate: i,
        scale: s,
        active: u,
        ready: d,
        inStage: f,
        animating: v
      }),
      uid: o.uid,
      translateItem: w
    });
  }), wo(() => {
    n.removeItem(o.uid);
  }), {
    carouselItemRef: a,
    active: u,
    animating: v,
    hover: r,
    inStage: f,
    isVertical: m,
    translate: i,
    isCardType: h,
    scale: s,
    ready: d,
    handleItemClick: b
  };
}, W9 = "ElCarouselItem", K9 = Q({
  name: "ElCarouselItem"
}), U9 = /* @__PURE__ */ Q({
  ...K9,
  props: H9,
  setup(e) {
    const t = e, n = nt("carousel"), {
      carouselItemRef: o,
      active: l,
      animating: a,
      hover: r,
      inStage: i,
      isVertical: s,
      translate: u,
      isCardType: d,
      scale: f,
      ready: v,
      handleItemClick: h
    } = z9(t, W9), m = x(() => [
      n.e("item"),
      n.is("active", l.value),
      n.is("in-stage", i.value),
      n.is("hover", r.value),
      n.is("animating", a.value),
      {
        [n.em("item", "card")]: d.value,
        [n.em("item", "card-vertical")]: d.value && s.value
      }
    ]), p = x(() => {
      const g = `${`translate${c(s) ? "Y" : "X"}`}(${c(u)}px)`, w = `scale(${c(f)})`;
      return {
        transform: [g, w].join(" ")
      };
    });
    return (C, g) => Bt((M(), G("div", {
      ref_key: "carouselItemRef",
      ref: o,
      class: z(c(m)),
      style: bt(c(p)),
      onClick: g[0] || (g[0] = (...w) => c(h) && c(h)(...w))
    }, [
      c(d) ? Bt((M(), G("div", {
        key: 0,
        class: z(c(n).e("mask"))
      }, null, 2)), [
        [pn, !c(l)]
      ]) : _e("v-if", !0),
      Ie(C.$slots, "default")
    ], 6)), [
      [pn, c(v)]
    ]);
  }
});
var PT = /* @__PURE__ */ ut(U9, [["__file", "carousel-item.vue"]]);
const j9 = Yt(B9, {
  CarouselItem: PT
}), q9 = Jn(PT), AT = {
  modelValue: {
    type: [Number, String, Boolean],
    default: void 0
  },
  label: {
    type: [String, Boolean, Number, Object],
    default: void 0
  },
  value: {
    type: [String, Boolean, Number, Object],
    default: void 0
  },
  indeterminate: Boolean,
  disabled: Boolean,
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueValue: {
    type: [String, Number],
    default: void 0
  },
  falseValue: {
    type: [String, Number],
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  id: {
    type: String,
    default: void 0
  },
  controls: {
    type: String,
    default: void 0
  },
  border: Boolean,
  size: Lo,
  tabindex: [String, Number],
  validateEvent: {
    type: Boolean,
    default: !0
  },
  ...Zo(["ariaControls"])
}, FT = {
  [Jt]: (e) => on(e) || Ot(e) || $o(e),
  change: (e) => on(e) || Ot(e) || $o(e)
}, su = Symbol("checkboxGroupContextKey"), Y9 = ({
  model: e,
  isChecked: t
}) => {
  const n = ot(su, void 0), o = x(() => {
    var a, r;
    const i = (a = n == null ? void 0 : n.max) == null ? void 0 : a.value, s = (r = n == null ? void 0 : n.min) == null ? void 0 : r.value;
    return !To(i) && e.value.length >= i && !t.value || !To(s) && e.value.length <= s && t.value;
  });
  return {
    isDisabled: Nl(x(() => (n == null ? void 0 : n.disabled.value) || o.value)),
    isLimitDisabled: o
  };
}, G9 = (e, {
  model: t,
  isLimitExceeded: n,
  hasOwnLabel: o,
  isDisabled: l,
  isLabeledByFormItem: a
}) => {
  const r = ot(su, void 0), { formItem: i } = ml(), { emit: s } = Pt();
  function u(m) {
    var p, C, g, w;
    return [!0, e.trueValue, e.trueLabel].includes(m) ? (C = (p = e.trueValue) != null ? p : e.trueLabel) != null ? C : !0 : (w = (g = e.falseValue) != null ? g : e.falseLabel) != null ? w : !1;
  }
  function d(m, p) {
    s("change", u(m), p);
  }
  function f(m) {
    if (n.value)
      return;
    const p = m.target;
    s("change", u(p.checked), m);
  }
  async function v(m) {
    n.value || !o.value && !l.value && a.value && (m.composedPath().some((g) => g.tagName === "LABEL") || (t.value = u([!1, e.falseValue, e.falseLabel].includes(t.value)), await xe(), d(t.value, m)));
  }
  const h = x(() => (r == null ? void 0 : r.validateEvent) || e.validateEvent);
  return Pe(() => e.modelValue, () => {
    h.value && (i == null || i.validate("change").catch((m) => dn(m)));
  }), {
    handleChange: f,
    onClickRoot: v
  };
}, X9 = (e) => {
  const t = B(!1), { emit: n } = Pt(), o = ot(su, void 0), l = x(() => To(o) === !1), a = B(!1), r = x({
    get() {
      var i, s;
      return l.value ? (i = o == null ? void 0 : o.modelValue) == null ? void 0 : i.value : (s = e.modelValue) != null ? s : t.value;
    },
    set(i) {
      var s, u;
      l.value && Kt(i) ? (a.value = ((s = o == null ? void 0 : o.max) == null ? void 0 : s.value) !== void 0 && i.length > (o == null ? void 0 : o.max.value) && i.length > r.value.length, a.value === !1 && ((u = o == null ? void 0 : o.changeEvent) == null || u.call(o, i))) : (n(Jt, i), t.value = i);
    }
  });
  return {
    model: r,
    isGroup: l,
    isLimitExceeded: a
  };
}, Z9 = (e, t, { model: n }) => {
  const o = ot(su, void 0), l = B(!1), a = x(() => $i(e.value) ? e.label : e.value), r = x(() => {
    const d = n.value;
    return $o(d) ? d : Kt(d) ? Mn(a.value) ? d.map(Sd).some((f) => pl(f, a.value)) : d.map(Sd).includes(a.value) : d != null ? d === e.trueValue || d === e.trueLabel : !!d;
  }), i = Mo(x(() => {
    var d;
    return (d = o == null ? void 0 : o.size) == null ? void 0 : d.value;
  }), {
    prop: !0
  }), s = Mo(x(() => {
    var d;
    return (d = o == null ? void 0 : o.size) == null ? void 0 : d.value;
  })), u = x(() => !!t.default || !$i(a.value));
  return {
    checkboxButtonSize: i,
    isChecked: r,
    isFocused: l,
    checkboxSize: s,
    hasOwnLabel: u,
    actualValue: a
  };
}, VT = (e, t) => {
  const { formItem: n } = ml(), { model: o, isGroup: l, isLimitExceeded: a } = X9(e), {
    isFocused: r,
    isChecked: i,
    checkboxButtonSize: s,
    checkboxSize: u,
    hasOwnLabel: d,
    actualValue: f
  } = Z9(e, t, { model: o }), { isDisabled: v } = Y9({ model: o, isChecked: i }), { inputId: h, isLabeledByFormItem: m } = Wa(e, {
    formItemContext: n,
    disableIdGeneration: d,
    disableIdManagement: l
  }), { handleChange: p, onClickRoot: C } = G9(e, {
    model: o,
    isLimitExceeded: a,
    hasOwnLabel: d,
    isDisabled: v,
    isLabeledByFormItem: m
  });
  return (() => {
    function w() {
      var b, y;
      Kt(o.value) && !o.value.includes(f.value) ? o.value.push(f.value) : o.value = (y = (b = e.trueValue) != null ? b : e.trueLabel) != null ? y : !0;
    }
    e.checked && w();
  })(), Ho({
    from: "controls",
    replacement: "aria-controls",
    version: "2.8.0",
    scope: "el-checkbox",
    ref: "https://element-plus.org/en-US/component/checkbox.html"
  }, x(() => !!e.controls)), Ho({
    from: "label act as value",
    replacement: "value",
    version: "3.0.0",
    scope: "el-checkbox",
    ref: "https://element-plus.org/en-US/component/checkbox.html"
  }, x(() => l.value && $i(e.value))), Ho({
    from: "true-label",
    replacement: "true-value",
    version: "3.0.0",
    scope: "el-checkbox",
    ref: "https://element-plus.org/en-US/component/checkbox.html"
  }, x(() => !!e.trueLabel)), Ho({
    from: "false-label",
    replacement: "false-value",
    version: "3.0.0",
    scope: "el-checkbox",
    ref: "https://element-plus.org/en-US/component/checkbox.html"
  }, x(() => !!e.falseLabel)), {
    inputId: h,
    isLabeledByFormItem: m,
    isChecked: i,
    isDisabled: v,
    isFocused: r,
    checkboxButtonSize: s,
    checkboxSize: u,
    hasOwnLabel: d,
    model: o,
    actualValue: f,
    handleChange: p,
    onClickRoot: C
  };
}, J9 = ["id", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value"], Q9 = ["id", "indeterminate", "disabled", "value", "name", "tabindex"], eW = Q({
  name: "ElCheckbox"
}), tW = /* @__PURE__ */ Q({
  ...eW,
  props: AT,
  emits: FT,
  setup(e) {
    const t = e, n = Yn(), {
      inputId: o,
      isLabeledByFormItem: l,
      isChecked: a,
      isDisabled: r,
      isFocused: i,
      checkboxSize: s,
      hasOwnLabel: u,
      model: d,
      actualValue: f,
      handleChange: v,
      onClickRoot: h
    } = VT(t, n), m = nt("checkbox"), p = x(() => [
      m.b(),
      m.m(s.value),
      m.is("disabled", r.value),
      m.is("bordered", t.border),
      m.is("checked", a.value)
    ]), C = x(() => [
      m.e("input"),
      m.is("disabled", r.value),
      m.is("checked", a.value),
      m.is("indeterminate", t.indeterminate),
      m.is("focus", i.value)
    ]);
    return (g, w) => (M(), We(Qt(!c(u) && c(l) ? "span" : "label"), {
      class: z(c(p)),
      "aria-controls": g.indeterminate ? g.controls || g.ariaControls : null,
      onClick: c(h)
    }, {
      default: fe(() => {
        var b, y;
        return [
          X("span", {
            class: z(c(C))
          }, [
            g.trueValue || g.falseValue || g.trueLabel || g.falseLabel ? Bt((M(), G("input", {
              key: 0,
              id: c(o),
              "onUpdate:modelValue": w[0] || (w[0] = (E) => fl(d) ? d.value = E : null),
              class: z(c(m).e("original")),
              type: "checkbox",
              indeterminate: g.indeterminate,
              name: g.name,
              tabindex: g.tabindex,
              disabled: c(r),
              "true-value": (b = g.trueValue) != null ? b : g.trueLabel,
              "false-value": (y = g.falseValue) != null ? y : g.falseLabel,
              onChange: w[1] || (w[1] = (...E) => c(v) && c(v)(...E)),
              onFocus: w[2] || (w[2] = (E) => i.value = !0),
              onBlur: w[3] || (w[3] = (E) => i.value = !1),
              onClick: w[4] || (w[4] = It(() => {
              }, ["stop"]))
            }, null, 42, J9)), [
              [Wp, c(d)]
            ]) : Bt((M(), G("input", {
              key: 1,
              id: c(o),
              "onUpdate:modelValue": w[5] || (w[5] = (E) => fl(d) ? d.value = E : null),
              class: z(c(m).e("original")),
              type: "checkbox",
              indeterminate: g.indeterminate,
              disabled: c(r),
              value: c(f),
              name: g.name,
              tabindex: g.tabindex,
              onChange: w[6] || (w[6] = (...E) => c(v) && c(v)(...E)),
              onFocus: w[7] || (w[7] = (E) => i.value = !0),
              onBlur: w[8] || (w[8] = (E) => i.value = !1),
              onClick: w[9] || (w[9] = It(() => {
              }, ["stop"]))
            }, null, 42, Q9)), [
              [Wp, c(d)]
            ]),
            X("span", {
              class: z(c(m).e("inner"))
            }, null, 2)
          ], 2),
          c(u) ? (M(), G("span", {
            key: 0,
            class: z(c(m).e("label"))
          }, [
            Ie(g.$slots, "default"),
            g.$slots.default ? _e("v-if", !0) : (M(), G(kt, { key: 0 }, [
              Ut(Qe(g.label), 1)
            ], 64))
          ], 2)) : _e("v-if", !0)
        ];
      }),
      _: 3
    }, 8, ["class", "aria-controls", "onClick"]));
  }
});
var nW = /* @__PURE__ */ ut(tW, [["__file", "checkbox.vue"]]);
const oW = ["name", "tabindex", "disabled", "true-value", "false-value"], lW = ["name", "tabindex", "disabled", "value"], aW = Q({
  name: "ElCheckboxButton"
}), rW = /* @__PURE__ */ Q({
  ...aW,
  props: AT,
  emits: FT,
  setup(e) {
    const t = e, n = Yn(), {
      isFocused: o,
      isChecked: l,
      isDisabled: a,
      checkboxButtonSize: r,
      model: i,
      actualValue: s,
      handleChange: u
    } = VT(t, n), d = ot(su, void 0), f = nt("checkbox"), v = x(() => {
      var m, p, C, g;
      const w = (p = (m = d == null ? void 0 : d.fill) == null ? void 0 : m.value) != null ? p : "";
      return {
        backgroundColor: w,
        borderColor: w,
        color: (g = (C = d == null ? void 0 : d.textColor) == null ? void 0 : C.value) != null ? g : "",
        boxShadow: w ? `-1px 0 0 0 ${w}` : void 0
      };
    }), h = x(() => [
      f.b("button"),
      f.bm("button", r.value),
      f.is("disabled", a.value),
      f.is("checked", l.value),
      f.is("focus", o.value)
    ]);
    return (m, p) => {
      var C, g;
      return M(), G("label", {
        class: z(c(h))
      }, [
        m.trueValue || m.falseValue || m.trueLabel || m.falseLabel ? Bt((M(), G("input", {
          key: 0,
          "onUpdate:modelValue": p[0] || (p[0] = (w) => fl(i) ? i.value = w : null),
          class: z(c(f).be("button", "original")),
          type: "checkbox",
          name: m.name,
          tabindex: m.tabindex,
          disabled: c(a),
          "true-value": (C = m.trueValue) != null ? C : m.trueLabel,
          "false-value": (g = m.falseValue) != null ? g : m.falseLabel,
          onChange: p[1] || (p[1] = (...w) => c(u) && c(u)(...w)),
          onFocus: p[2] || (p[2] = (w) => o.value = !0),
          onBlur: p[3] || (p[3] = (w) => o.value = !1),
          onClick: p[4] || (p[4] = It(() => {
          }, ["stop"]))
        }, null, 42, oW)), [
          [Wp, c(i)]
        ]) : Bt((M(), G("input", {
          key: 1,
          "onUpdate:modelValue": p[5] || (p[5] = (w) => fl(i) ? i.value = w : null),
          class: z(c(f).be("button", "original")),
          type: "checkbox",
          name: m.name,
          tabindex: m.tabindex,
          disabled: c(a),
          value: c(s),
          onChange: p[6] || (p[6] = (...w) => c(u) && c(u)(...w)),
          onFocus: p[7] || (p[7] = (w) => o.value = !0),
          onBlur: p[8] || (p[8] = (w) => o.value = !1),
          onClick: p[9] || (p[9] = It(() => {
          }, ["stop"]))
        }, null, 42, lW)), [
          [Wp, c(i)]
        ]),
        m.$slots.default || m.label ? (M(), G("span", {
          key: 2,
          class: z(c(f).be("button", "inner")),
          style: bt(c(l) ? c(v) : void 0)
        }, [
          Ie(m.$slots, "default", {}, () => [
            Ut(Qe(m.label), 1)
          ])
        ], 6)) : _e("v-if", !0)
      ], 2);
    };
  }
});
var BT = /* @__PURE__ */ ut(rW, [["__file", "checkbox-button.vue"]]);
const sW = it({
  modelValue: {
    type: Ae(Array),
    default: () => []
  },
  disabled: Boolean,
  min: Number,
  max: Number,
  size: Lo,
  label: String,
  fill: String,
  textColor: String,
  tag: {
    type: String,
    default: "div"
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  ...Zo(["ariaLabel"])
}), iW = {
  [Jt]: (e) => Kt(e),
  change: (e) => Kt(e)
}, cW = Q({
  name: "ElCheckboxGroup"
}), uW = /* @__PURE__ */ Q({
  ...cW,
  props: sW,
  emits: iW,
  setup(e, { emit: t }) {
    const n = e, o = nt("checkbox"), { formItem: l } = ml(), { inputId: a, isLabeledByFormItem: r } = Wa(n, {
      formItemContext: l
    }), i = async (u) => {
      t(Jt, u), await xe(), t("change", u);
    }, s = x({
      get() {
        return n.modelValue;
      },
      set(u) {
        i(u);
      }
    });
    return Mt(su, {
      ...er(Xo(n), [
        "size",
        "min",
        "max",
        "disabled",
        "validateEvent",
        "fill",
        "textColor"
      ]),
      modelValue: s,
      changeEvent: i
    }), Ho({
      from: "label",
      replacement: "aria-label",
      version: "2.8.0",
      scope: "el-checkbox-group",
      ref: "https://element-plus.org/en-US/component/checkbox.html"
    }, x(() => !!n.label)), Pe(() => n.modelValue, () => {
      n.validateEvent && (l == null || l.validate("change").catch((u) => dn(u)));
    }), (u, d) => {
      var f;
      return M(), We(Qt(u.tag), {
        id: c(a),
        class: z(c(o).b("group")),
        role: "group",
        "aria-label": c(r) ? void 0 : u.label || u.ariaLabel || "checkbox-group",
        "aria-labelledby": c(r) ? (f = c(l)) == null ? void 0 : f.labelId : void 0
      }, {
        default: fe(() => [
          Ie(u.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
    };
  }
});
var HT = /* @__PURE__ */ ut(uW, [["__file", "checkbox-group.vue"]]);
const ta = Yt(nW, {
  CheckboxButton: BT,
  CheckboxGroup: HT
}), dW = Jn(BT), Uy = Jn(HT), zT = it({
  modelValue: {
    type: [String, Number, Boolean],
    default: void 0
  },
  size: Lo,
  disabled: Boolean,
  label: {
    type: [String, Number, Boolean],
    default: void 0
  },
  value: {
    type: [String, Number, Boolean],
    default: void 0
  },
  name: {
    type: String,
    default: void 0
  }
}), fW = it({
  ...zT,
  border: Boolean
}), WT = {
  [Jt]: (e) => on(e) || Ot(e) || $o(e),
  [qn]: (e) => on(e) || Ot(e) || $o(e)
}, KT = Symbol("radioGroupKey"), UT = (e, t) => {
  const n = B(), o = ot(KT, void 0), l = x(() => !!o), a = x(() => $i(e.value) ? e.label : e.value), r = x({
    get() {
      return l.value ? o.modelValue : e.modelValue;
    },
    set(f) {
      l.value ? o.changeEvent(f) : t && t(Jt, f), n.value.checked = e.modelValue === a.value;
    }
  }), i = Mo(x(() => o == null ? void 0 : o.size)), s = Nl(x(() => o == null ? void 0 : o.disabled)), u = B(!1), d = x(() => s.value || l.value && r.value !== a.value ? -1 : 0);
  return Ho({
    from: "label act as value",
    replacement: "value",
    version: "3.0.0",
    scope: "el-radio",
    ref: "https://element-plus.org/en-US/component/radio.html"
  }, x(() => l.value && $i(e.value))), {
    radioRef: n,
    isGroup: l,
    radioGroup: o,
    focus: u,
    size: i,
    disabled: s,
    tabIndex: d,
    modelValue: r,
    actualValue: a
  };
}, pW = ["value", "name", "disabled"], vW = Q({
  name: "ElRadio"
}), hW = /* @__PURE__ */ Q({
  ...vW,
  props: fW,
  emits: WT,
  setup(e, { emit: t }) {
    const n = e, o = nt("radio"), { radioRef: l, radioGroup: a, focus: r, size: i, disabled: s, modelValue: u, actualValue: d } = UT(n, t);
    function f() {
      xe(() => t("change", u.value));
    }
    return (v, h) => {
      var m;
      return M(), G("label", {
        class: z([
          c(o).b(),
          c(o).is("disabled", c(s)),
          c(o).is("focus", c(r)),
          c(o).is("bordered", v.border),
          c(o).is("checked", c(u) === c(d)),
          c(o).m(c(i))
        ])
      }, [
        X("span", {
          class: z([
            c(o).e("input"),
            c(o).is("disabled", c(s)),
            c(o).is("checked", c(u) === c(d))
          ])
        }, [
          Bt(X("input", {
            ref_key: "radioRef",
            ref: l,
            "onUpdate:modelValue": h[0] || (h[0] = (p) => fl(u) ? u.value = p : null),
            class: z(c(o).e("original")),
            value: c(d),
            name: v.name || ((m = c(a)) == null ? void 0 : m.name),
            disabled: c(s),
            type: "radio",
            onFocus: h[1] || (h[1] = (p) => r.value = !0),
            onBlur: h[2] || (h[2] = (p) => r.value = !1),
            onChange: f,
            onClick: h[3] || (h[3] = It(() => {
            }, ["stop"]))
          }, null, 42, pW), [
            [W2, c(u)]
          ]),
          X("span", {
            class: z(c(o).e("inner"))
          }, null, 2)
        ], 2),
        X("span", {
          class: z(c(o).e("label")),
          onKeydown: h[4] || (h[4] = It(() => {
          }, ["stop"]))
        }, [
          Ie(v.$slots, "default", {}, () => [
            Ut(Qe(v.label), 1)
          ])
        ], 34)
      ], 2);
    };
  }
});
var mW = /* @__PURE__ */ ut(hW, [["__file", "radio.vue"]]);
const gW = it({
  ...zT
}), bW = ["value", "name", "disabled"], yW = Q({
  name: "ElRadioButton"
}), CW = /* @__PURE__ */ Q({
  ...yW,
  props: gW,
  setup(e) {
    const t = e, n = nt("radio"), { radioRef: o, focus: l, size: a, disabled: r, modelValue: i, radioGroup: s, actualValue: u } = UT(t), d = x(() => ({
      backgroundColor: (s == null ? void 0 : s.fill) || "",
      borderColor: (s == null ? void 0 : s.fill) || "",
      boxShadow: s != null && s.fill ? `-1px 0 0 0 ${s.fill}` : "",
      color: (s == null ? void 0 : s.textColor) || ""
    }));
    return (f, v) => {
      var h;
      return M(), G("label", {
        class: z([
          c(n).b("button"),
          c(n).is("active", c(i) === c(u)),
          c(n).is("disabled", c(r)),
          c(n).is("focus", c(l)),
          c(n).bm("button", c(a))
        ])
      }, [
        Bt(X("input", {
          ref_key: "radioRef",
          ref: o,
          "onUpdate:modelValue": v[0] || (v[0] = (m) => fl(i) ? i.value = m : null),
          class: z(c(n).be("button", "original-radio")),
          value: c(u),
          type: "radio",
          name: f.name || ((h = c(s)) == null ? void 0 : h.name),
          disabled: c(r),
          onFocus: v[1] || (v[1] = (m) => l.value = !0),
          onBlur: v[2] || (v[2] = (m) => l.value = !1),
          onClick: v[3] || (v[3] = It(() => {
          }, ["stop"]))
        }, null, 42, bW), [
          [W2, c(i)]
        ]),
        X("span", {
          class: z(c(n).be("button", "inner")),
          style: bt(c(i) === c(u) ? c(d) : {}),
          onKeydown: v[4] || (v[4] = It(() => {
          }, ["stop"]))
        }, [
          Ie(f.$slots, "default", {}, () => [
            Ut(Qe(f.label), 1)
          ])
        ], 38)
      ], 2);
    };
  }
});
var jT = /* @__PURE__ */ ut(CW, [["__file", "radio-button.vue"]]);
const wW = it({
  id: {
    type: String,
    default: void 0
  },
  size: Lo,
  disabled: Boolean,
  modelValue: {
    type: [String, Number, Boolean],
    default: void 0
  },
  fill: {
    type: String,
    default: ""
  },
  label: {
    type: String,
    default: void 0
  },
  textColor: {
    type: String,
    default: ""
  },
  name: {
    type: String,
    default: void 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  ...Zo(["ariaLabel"])
}), EW = WT, SW = ["id", "aria-label", "aria-labelledby"], _W = Q({
  name: "ElRadioGroup"
}), xW = /* @__PURE__ */ Q({
  ..._W,
  props: wW,
  emits: EW,
  setup(e, { emit: t }) {
    const n = e, o = nt("radio"), l = il(), a = B(), { formItem: r } = ml(), { inputId: i, isLabeledByFormItem: s } = Wa(n, {
      formItemContext: r
    }), u = (f) => {
      t(Jt, f), xe(() => t("change", f));
    };
    Nt(() => {
      const f = a.value.querySelectorAll("[type=radio]"), v = f[0];
      !Array.from(f).some((h) => h.checked) && v && (v.tabIndex = 0);
    });
    const d = x(() => n.name || l.value);
    return Mt(KT, en({
      ...Xo(n),
      changeEvent: u,
      name: d
    })), Pe(() => n.modelValue, () => {
      n.validateEvent && (r == null || r.validate("change").catch((f) => dn(f)));
    }), Ho({
      from: "label",
      replacement: "aria-label",
      version: "2.8.0",
      scope: "el-radio-group",
      ref: "https://element-plus.org/en-US/component/radio.html"
    }, x(() => !!n.label)), (f, v) => (M(), G("div", {
      id: c(i),
      ref_key: "radioGroupRef",
      ref: a,
      class: z(c(o).b("group")),
      role: "radiogroup",
      "aria-label": c(s) ? void 0 : f.label || f.ariaLabel || "radio-group",
      "aria-labelledby": c(s) ? c(r).labelId : void 0
    }, [
      Ie(f.$slots, "default")
    ], 10, SW));
  }
});
var qT = /* @__PURE__ */ ut(xW, [["__file", "radio-group.vue"]]);
const jy = Yt(mW, {
  RadioButton: jT,
  RadioGroup: qT
}), YT = Jn(qT), kW = Jn(jT);
var TW = Q({
  name: "NodeContent",
  setup() {
    return {
      ns: nt("cascader-node")
    };
  },
  render() {
    const { ns: e } = this, { node: t, panel: n } = this.$parent, { data: o, label: l } = t, { renderLabelFn: a } = n;
    return V("span", { class: e.e("label") }, a ? a({ node: t, data: o }) : l);
  }
});
const qy = Symbol(), $W = Q({
  name: "ElCascaderNode",
  components: {
    ElCheckbox: ta,
    ElRadio: jy,
    NodeContent: TW,
    ElIcon: Ct,
    Check: lf,
    Loading: Ps,
    ArrowRight: xl
  },
  props: {
    node: {
      type: Object,
      required: !0
    },
    menuId: String
  },
  emits: ["expand"],
  setup(e, { emit: t }) {
    const n = ot(qy), o = nt("cascader-node"), l = x(() => n.isHoverMenu), a = x(() => n.config.multiple), r = x(() => n.config.checkStrictly), i = x(() => {
      var S;
      return (S = n.checkedNodes[0]) == null ? void 0 : S.uid;
    }), s = x(() => e.node.isDisabled), u = x(() => e.node.isLeaf), d = x(() => r.value && !u.value || !s.value), f = x(() => h(n.expandingNode)), v = x(() => r.value && n.checkedNodes.some(h)), h = (S) => {
      var _;
      const { level: k, uid: N } = e.node;
      return ((_ = S == null ? void 0 : S.pathNodes[k - 1]) == null ? void 0 : _.uid) === N;
    }, m = () => {
      f.value || n.expandNode(e.node);
    }, p = (S) => {
      const { node: _ } = e;
      S !== _.checked && n.handleCheckChange(_, S);
    }, C = () => {
      n.lazyLoad(e.node, () => {
        u.value || m();
      });
    }, g = (S) => {
      l.value && (w(), !u.value && t("expand", S));
    }, w = () => {
      const { node: S } = e;
      !d.value || S.loading || (S.loaded ? m() : C());
    }, b = () => {
      l.value && !u.value || (u.value && !s.value && !r.value && !a.value ? E(!0) : w());
    }, y = (S) => {
      r.value ? (p(S), e.node.loaded && m()) : E(S);
    }, E = (S) => {
      e.node.loaded ? (p(S), !r.value && m()) : C();
    };
    return {
      panel: n,
      isHoverMenu: l,
      multiple: a,
      checkStrictly: r,
      checkedNodeId: i,
      isDisabled: s,
      isLeaf: u,
      expandable: d,
      inExpandingPath: f,
      inCheckedPath: v,
      ns: o,
      handleHoverExpand: g,
      handleExpand: w,
      handleClick: b,
      handleCheck: E,
      handleSelectCheck: y
    };
  }
}), OW = ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"], NW = /* @__PURE__ */ X("span", null, null, -1);
function MW(e, t, n, o, l, a) {
  const r = Dt("el-checkbox"), i = Dt("el-radio"), s = Dt("check"), u = Dt("el-icon"), d = Dt("node-content"), f = Dt("loading"), v = Dt("arrow-right");
  return M(), G("li", {
    id: `${e.menuId}-${e.node.uid}`,
    role: "menuitem",
    "aria-haspopup": !e.isLeaf,
    "aria-owns": e.isLeaf ? null : e.menuId,
    "aria-expanded": e.inExpandingPath,
    tabindex: e.expandable ? -1 : void 0,
    class: z([
      e.ns.b(),
      e.ns.is("selectable", e.checkStrictly),
      e.ns.is("active", e.node.checked),
      e.ns.is("disabled", !e.expandable),
      e.inExpandingPath && "in-active-path",
      e.inCheckedPath && "in-checked-path"
    ]),
    onMouseenter: t[2] || (t[2] = (...h) => e.handleHoverExpand && e.handleHoverExpand(...h)),
    onFocus: t[3] || (t[3] = (...h) => e.handleHoverExpand && e.handleHoverExpand(...h)),
    onClick: t[4] || (t[4] = (...h) => e.handleClick && e.handleClick(...h))
  }, [
    _e(" prefix "),
    e.multiple ? (M(), We(r, {
      key: 0,
      "model-value": e.node.checked,
      indeterminate: e.node.indeterminate,
      disabled: e.isDisabled,
      onClick: t[0] || (t[0] = It(() => {
      }, ["stop"])),
      "onUpdate:modelValue": e.handleSelectCheck
    }, null, 8, ["model-value", "indeterminate", "disabled", "onUpdate:modelValue"])) : e.checkStrictly ? (M(), We(i, {
      key: 1,
      "model-value": e.checkedNodeId,
      label: e.node.uid,
      disabled: e.isDisabled,
      "onUpdate:modelValue": e.handleSelectCheck,
      onClick: t[1] || (t[1] = It(() => {
      }, ["stop"]))
    }, {
      default: fe(() => [
        _e(`
        Add an empty element to avoid render label,
        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485
      `),
        NW
      ]),
      _: 1
    }, 8, ["model-value", "label", "disabled", "onUpdate:modelValue"])) : e.isLeaf && e.node.checked ? (M(), We(u, {
      key: 2,
      class: z(e.ns.e("prefix"))
    }, {
      default: fe(() => [
        oe(s)
      ]),
      _: 1
    }, 8, ["class"])) : _e("v-if", !0),
    _e(" content "),
    oe(d),
    _e(" postfix "),
    e.isLeaf ? _e("v-if", !0) : (M(), G(kt, { key: 3 }, [
      e.node.loading ? (M(), We(u, {
        key: 0,
        class: z([e.ns.is("loading"), e.ns.e("postfix")])
      }, {
        default: fe(() => [
          oe(f)
        ]),
        _: 1
      }, 8, ["class"])) : (M(), We(u, {
        key: 1,
        class: z(["arrow-right", e.ns.e("postfix")])
      }, {
        default: fe(() => [
          oe(v)
        ]),
        _: 1
      }, 8, ["class"]))
    ], 64))
  ], 42, OW);
}
var IW = /* @__PURE__ */ ut($W, [["render", MW], ["__file", "node.vue"]]);
const RW = Q({
  name: "ElCascaderMenu",
  components: {
    Loading: Ps,
    ElIcon: Ct,
    ElScrollbar: zr,
    ElCascaderNode: IW
  },
  props: {
    nodes: {
      type: Array,
      required: !0
    },
    index: {
      type: Number,
      required: !0
    }
  },
  setup(e) {
    const t = Pt(), n = nt("cascader-menu"), { t: o } = bn(), l = il();
    let a = null, r = null;
    const i = ot(qy), s = B(null), u = x(() => !e.nodes.length), d = x(() => !i.initialLoaded), f = x(() => `${l.value}-${e.index}`), v = (C) => {
      a = C.target;
    }, h = (C) => {
      if (!(!i.isHoverMenu || !a || !s.value))
        if (a.contains(C.target)) {
          m();
          const g = t.vnode.el, { left: w } = g.getBoundingClientRect(), { offsetWidth: b, offsetHeight: y } = g, E = C.clientX - w, S = a.offsetTop, _ = S + a.offsetHeight;
          s.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${E} ${S} L${b} 0 V${S} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${E} ${_} L${b} ${y} V${_} Z" />
        `;
        } else
          r || (r = window.setTimeout(p, i.config.hoverThreshold));
    }, m = () => {
      r && (clearTimeout(r), r = null);
    }, p = () => {
      s.value && (s.value.innerHTML = "", m());
    };
    return {
      ns: n,
      panel: i,
      hoverZone: s,
      isEmpty: u,
      isLoading: d,
      menuId: f,
      t: o,
      handleExpand: v,
      handleMouseMove: h,
      clearHoverZone: p
    };
  }
});
function DW(e, t, n, o, l, a) {
  const r = Dt("el-cascader-node"), i = Dt("loading"), s = Dt("el-icon"), u = Dt("el-scrollbar");
  return M(), We(u, {
    key: e.menuId,
    tag: "ul",
    role: "menu",
    class: z(e.ns.b()),
    "wrap-class": e.ns.e("wrap"),
    "view-class": [e.ns.e("list"), e.ns.is("empty", e.isEmpty)],
    onMousemove: e.handleMouseMove,
    onMouseleave: e.clearHoverZone
  }, {
    default: fe(() => {
      var d;
      return [
        (M(!0), G(kt, null, ln(e.nodes, (f) => (M(), We(r, {
          key: f.uid,
          node: f,
          "menu-id": e.menuId,
          onExpand: e.handleExpand
        }, null, 8, ["node", "menu-id", "onExpand"]))), 128)),
        e.isLoading ? (M(), G("div", {
          key: 0,
          class: z(e.ns.e("empty-text"))
        }, [
          oe(s, {
            size: "14",
            class: z(e.ns.is("loading"))
          }, {
            default: fe(() => [
              oe(i)
            ]),
            _: 1
          }, 8, ["class"]),
          Ut(" " + Qe(e.t("el.cascader.loading")), 1)
        ], 2)) : e.isEmpty ? (M(), G("div", {
          key: 1,
          class: z(e.ns.e("empty-text"))
        }, Qe(e.t("el.cascader.noData")), 3)) : (d = e.panel) != null && d.isHoverMenu ? (M(), G("svg", {
          key: 2,
          ref: "hoverZone",
          class: z(e.ns.e("hover-zone"))
        }, null, 2)) : _e("v-if", !0)
      ];
    }),
    _: 1
  }, 8, ["class", "wrap-class", "view-class", "onMousemove", "onMouseleave"]);
}
var LW = /* @__PURE__ */ ut(RW, [["render", DW], ["__file", "menu.vue"]]);
let PW = 0;
const AW = (e) => {
  const t = [e];
  let { parent: n } = e;
  for (; n; )
    t.unshift(n), n = n.parent;
  return t;
};
let Pg = class Ag {
  constructor(t, n, o, l = !1) {
    this.data = t, this.config = n, this.parent = o, this.root = l, this.uid = PW++, this.checked = !1, this.indeterminate = !1, this.loading = !1;
    const { value: a, label: r, children: i } = n, s = t[i], u = AW(this);
    this.level = l ? 0 : o ? o.level + 1 : 1, this.value = t[a], this.label = t[r], this.pathNodes = u, this.pathValues = u.map((d) => d.value), this.pathLabels = u.map((d) => d.label), this.childrenData = s, this.children = (s || []).map((d) => new Ag(d, n, this)), this.loaded = !n.lazy || this.isLeaf || !ha(s);
  }
  get isDisabled() {
    const { data: t, parent: n, config: o } = this, { disabled: l, checkStrictly: a } = o;
    return (vn(l) ? l(t, this) : !!t[l]) || !a && (n == null ? void 0 : n.isDisabled);
  }
  get isLeaf() {
    const { data: t, config: n, childrenData: o, loaded: l } = this, { lazy: a, leaf: r } = n, i = vn(r) ? r(t, this) : t[r];
    return To(i) ? a && !l ? !1 : !(Array.isArray(o) && o.length) : !!i;
  }
  get valueByOption() {
    return this.config.emitPath ? this.pathValues : this.value;
  }
  appendChild(t) {
    const { childrenData: n, children: o } = this, l = new Ag(t, this.config, this);
    return Array.isArray(n) ? n.push(t) : this.childrenData = [t], o.push(l), l;
  }
  calcText(t, n) {
    const o = t ? this.pathLabels.join(n) : this.label;
    return this.text = o, o;
  }
  broadcast(t, ...n) {
    const o = `onParent${Qa(t)}`;
    this.children.forEach((l) => {
      l && (l.broadcast(t, ...n), l[o] && l[o](...n));
    });
  }
  emit(t, ...n) {
    const { parent: o } = this, l = `onChild${Qa(t)}`;
    o && (o[l] && o[l](...n), o.emit(t, ...n));
  }
  onParentCheck(t) {
    this.isDisabled || this.setCheckState(t);
  }
  onChildCheck() {
    const { children: t } = this, n = t.filter((l) => !l.isDisabled), o = n.length ? n.every((l) => l.checked) : !1;
    this.setCheckState(o);
  }
  setCheckState(t) {
    const n = this.children.length, o = this.children.reduce((l, a) => {
      const r = a.checked ? 1 : a.indeterminate ? 0.5 : 0;
      return l + r;
    }, 0);
    this.checked = this.loaded && this.children.filter((l) => !l.isDisabled).every((l) => l.loaded && l.checked) && t, this.indeterminate = this.loaded && o !== n && o > 0;
  }
  doCheck(t) {
    if (this.checked === t)
      return;
    const { checkStrictly: n, multiple: o } = this.config;
    n || !o ? this.checked = t : (this.broadcast("check", t), this.setCheckState(t), this.emit("check"));
  }
};
const Fg = (e, t) => e.reduce((n, o) => (o.isLeaf ? n.push(o) : (!t && n.push(o), n = n.concat(Fg(o.children, t))), n), []);
let eE = class {
  constructor(t, n) {
    this.config = n;
    const o = (t || []).map((l) => new Pg(l, this.config));
    this.nodes = o, this.allNodes = Fg(o, !1), this.leafNodes = Fg(o, !0);
  }
  getNodes() {
    return this.nodes;
  }
  getFlattedNodes(t) {
    return t ? this.leafNodes : this.allNodes;
  }
  appendNode(t, n) {
    const o = n ? n.appendChild(t) : new Pg(t, this.config);
    n || this.nodes.push(o), this.allNodes.push(o), o.isLeaf && this.leafNodes.push(o);
  }
  appendNodes(t, n) {
    t.forEach((o) => this.appendNode(o, n));
  }
  getNodeByValue(t, n = !1) {
    return !t && t !== 0 ? null : this.getFlattedNodes(n).find((l) => pl(l.value, t) || pl(l.pathValues, t)) || null;
  }
  getSameNode(t) {
    return t && this.getFlattedNodes(!1).find(({ value: o, level: l }) => pl(t.value, o) && t.level === l) || null;
  }
};
const GT = it({
  modelValue: {
    type: Ae([Number, String, Array])
  },
  options: {
    type: Ae(Array),
    default: () => []
  },
  props: {
    type: Ae(Object),
    default: () => ({})
  }
}), FW = {
  expandTrigger: "click",
  multiple: !1,
  checkStrictly: !1,
  emitPath: !0,
  lazy: !1,
  lazyLoad: no,
  value: "value",
  label: "label",
  children: "children",
  leaf: "leaf",
  disabled: "disabled",
  hoverThreshold: 500
}, VW = (e) => x(() => ({
  ...FW,
  ...e.props
})), tE = (e) => {
  if (!e)
    return 0;
  const t = e.id.split("-");
  return Number(t[t.length - 2]);
}, BW = (e) => {
  if (!e)
    return;
  const t = e.querySelector("input");
  t ? t.click() : q2(e) && e.click();
}, HW = (e, t) => {
  const n = t.slice(0), o = n.map((a) => a.uid), l = e.reduce((a, r) => {
    const i = o.indexOf(r.uid);
    return i > -1 && (a.push(r), n.splice(i, 1), o.splice(i, 1)), a;
  }, []);
  return l.push(...n), l;
}, zW = Q({
  name: "ElCascaderPanel",
  components: {
    ElCascaderMenu: LW
  },
  props: {
    ...GT,
    border: {
      type: Boolean,
      default: !0
    },
    renderLabel: Function
  },
  emits: [Jt, qn, "close", "expand-change"],
  setup(e, { emit: t, slots: n }) {
    let o = !1;
    const l = nt("cascader"), a = VW(e);
    let r = null;
    const i = B(!0), s = B([]), u = B(null), d = B([]), f = B(null), v = B([]), h = x(() => a.value.expandTrigger === "hover"), m = x(() => e.renderLabel || n.default), p = () => {
      const { options: H } = e, K = a.value;
      o = !1, r = new eE(H, K), d.value = [r.getNodes()], K.lazy && ha(e.options) ? (i.value = !1, C(void 0, (U) => {
        U && (r = new eE(U, K), d.value = [r.getNodes()]), i.value = !0, k(!1, !0);
      })) : k(!1, !0);
    }, C = (H, K) => {
      const U = a.value;
      H = H || new Pg({}, U, void 0, !0), H.loading = !0;
      const W = (A) => {
        const $ = H, D = $.root ? null : $;
        A && (r == null || r.appendNodes(A, D)), $.loading = !1, $.loaded = !0, $.childrenData = $.childrenData || [], K && K(A);
      };
      U.lazyLoad(H, W);
    }, g = (H, K) => {
      var U;
      const { level: W } = H, A = d.value.slice(0, W);
      let $;
      H.isLeaf ? $ = H.pathNodes[W - 2] : ($ = H, A.push(H.children)), ((U = f.value) == null ? void 0 : U.uid) !== ($ == null ? void 0 : $.uid) && (f.value = H, d.value = A, !K && t("expand-change", (H == null ? void 0 : H.pathValues) || []));
    }, w = (H, K, U = !0) => {
      const { checkStrictly: W, multiple: A } = a.value, $ = v.value[0];
      o = !0, !A && ($ == null || $.doCheck(!1)), H.doCheck(K), _(), U && !A && !W && t("close"), !U && !A && !W && b(H);
    }, b = (H) => {
      H && (H = H.parent, b(H), H && g(H));
    }, y = (H) => r == null ? void 0 : r.getFlattedNodes(H), E = (H) => {
      var K;
      return (K = y(H)) == null ? void 0 : K.filter((U) => U.checked !== !1);
    }, S = () => {
      v.value.forEach((H) => H.doCheck(!1)), _(), d.value = d.value.slice(0, 1), f.value = null, t("expand-change", []);
    }, _ = () => {
      var H;
      const { checkStrictly: K, multiple: U } = a.value, W = v.value, A = E(!K), $ = HW(W, A), D = $.map((O) => O.valueByOption);
      v.value = $, u.value = U ? D : (H = D[0]) != null ? H : null;
    }, k = (H = !1, K = !1) => {
      const { modelValue: U } = e, { lazy: W, multiple: A, checkStrictly: $ } = a.value, D = !$;
      if (!(!i.value || o || !K && pl(U, u.value)))
        if (W && !H) {
          const F = JC(OF(Gl(U))).map((j) => r == null ? void 0 : r.getNodeByValue(j)).filter((j) => !!j && !j.loaded && !j.loading);
          F.length ? F.forEach((j) => {
            C(j, () => k(!1, K));
          }) : k(!0, K);
        } else {
          const O = A ? Gl(U) : [U], F = JC(O.map((j) => r == null ? void 0 : r.getNodeByValue(j, D)));
          N(F, K), u.value = jp(U);
        }
    }, N = (H, K = !0) => {
      const { checkStrictly: U } = a.value, W = v.value, A = H.filter((O) => !!O && (U || O.isLeaf)), $ = r == null ? void 0 : r.getSameNode(f.value), D = K && $ || A[0];
      D ? D.pathNodes.forEach((O) => g(O, !0)) : f.value = null, W.forEach((O) => O.doCheck(!1)), en(A).forEach((O) => O.doCheck(!0)), v.value = A, xe(L);
    }, L = () => {
      fn && s.value.forEach((H) => {
        const K = H == null ? void 0 : H.$el;
        if (K) {
          const U = K.querySelector(`.${l.namespace.value}-scrollbar__wrap`), W = K.querySelector(`.${l.b("node")}.${l.is("active")}`) || K.querySelector(`.${l.b("node")}.in-active-path`);
          jx(U, W);
        }
      });
    }, R = (H) => {
      const K = H.target, { code: U } = H;
      switch (U) {
        case xt.up:
        case xt.down: {
          H.preventDefault();
          const W = U === xt.up ? -1 : 1;
          vp(Y2(K, W, `.${l.b("node")}[tabindex="-1"]`));
          break;
        }
        case xt.left: {
          H.preventDefault();
          const W = s.value[tE(K) - 1], A = W == null ? void 0 : W.$el.querySelector(`.${l.b("node")}[aria-expanded="true"]`);
          vp(A);
          break;
        }
        case xt.right: {
          H.preventDefault();
          const W = s.value[tE(K) + 1], A = W == null ? void 0 : W.$el.querySelector(`.${l.b("node")}[tabindex="-1"]`);
          vp(A);
          break;
        }
        case xt.enter:
          BW(K);
          break;
      }
    };
    return Mt(qy, en({
      config: a,
      expandingNode: f,
      checkedNodes: v,
      isHoverMenu: h,
      initialLoaded: i,
      renderLabelFn: m,
      lazyLoad: C,
      expandNode: g,
      handleCheckChange: w
    })), Pe([a, () => e.options], p, {
      deep: !0,
      immediate: !0
    }), Pe(() => e.modelValue, () => {
      o = !1, k();
    }, {
      deep: !0
    }), Pe(() => u.value, (H) => {
      pl(H, e.modelValue) || (t(Jt, H), t(qn, H));
    }), h3(() => s.value = []), Nt(() => !ha(e.modelValue) && k()), {
      ns: l,
      menuList: s,
      menus: d,
      checkedNodes: v,
      handleKeyDown: R,
      handleCheckChange: w,
      getFlattedNodes: y,
      getCheckedNodes: E,
      clearCheckedNodes: S,
      calculateCheckedValue: _,
      scrollToExpandingNode: L
    };
  }
});
function WW(e, t, n, o, l, a) {
  const r = Dt("el-cascader-menu");
  return M(), G("div", {
    class: z([e.ns.b("panel"), e.ns.is("bordered", e.border)]),
    onKeydown: t[0] || (t[0] = (...i) => e.handleKeyDown && e.handleKeyDown(...i))
  }, [
    (M(!0), G(kt, null, ln(e.menus, (i, s) => (M(), We(r, {
      key: s,
      ref_for: !0,
      ref: (u) => e.menuList[s] = u,
      index: s,
      nodes: [...i]
    }, null, 8, ["index", "nodes"]))), 128))
  ], 34);
}
var Sp = /* @__PURE__ */ ut(zW, [["render", WW], ["__file", "index.vue"]]);
Sp.install = (e) => {
  e.component(Sp.name, Sp);
};
const XT = Sp, KW = XT, Uv = it({
  type: {
    type: String,
    values: ["primary", "success", "info", "warning", "danger"],
    default: "primary"
  },
  closable: Boolean,
  disableTransitions: Boolean,
  hit: Boolean,
  color: String,
  size: {
    type: String,
    values: fr
  },
  effect: {
    type: String,
    values: ["dark", "light", "plain"],
    default: "light"
  },
  round: Boolean
}), UW = {
  close: (e) => e instanceof MouseEvent,
  click: (e) => e instanceof MouseEvent
}, jW = Q({
  name: "ElTag"
}), qW = /* @__PURE__ */ Q({
  ...jW,
  props: Uv,
  emits: UW,
  setup(e, { emit: t }) {
    const n = e, o = Mo(), l = nt("tag"), a = x(() => {
      const { type: s, hit: u, effect: d, closable: f, round: v } = n;
      return [
        l.b(),
        l.is("closable", f),
        l.m(s || "primary"),
        l.m(o.value),
        l.m(d),
        l.is("hit", u),
        l.is("round", v)
      ];
    }), r = (s) => {
      t("close", s);
    }, i = (s) => {
      t("click", s);
    };
    return (s, u) => s.disableTransitions ? (M(), G("span", {
      key: 0,
      class: z(c(a)),
      style: bt({ backgroundColor: s.color }),
      onClick: i
    }, [
      X("span", {
        class: z(c(l).e("content"))
      }, [
        Ie(s.$slots, "default")
      ], 2),
      s.closable ? (M(), We(c(Ct), {
        key: 0,
        class: z(c(l).e("close")),
        onClick: It(r, ["stop"])
      }, {
        default: fe(() => [
          oe(c(Fa))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : _e("v-if", !0)
    ], 6)) : (M(), We(Ko, {
      key: 1,
      name: `${c(l).namespace.value}-zoom-in-center`,
      appear: ""
    }, {
      default: fe(() => [
        X("span", {
          class: z(c(a)),
          style: bt({ backgroundColor: s.color }),
          onClick: i
        }, [
          X("span", {
            class: z(c(l).e("content"))
          }, [
            Ie(s.$slots, "default")
          ], 2),
          s.closable ? (M(), We(c(Ct), {
            key: 0,
            class: z(c(l).e("close")),
            onClick: It(r, ["stop"])
          }, {
            default: fe(() => [
              oe(c(Fa))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : _e("v-if", !0)
        ], 6)
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
var YW = /* @__PURE__ */ ut(qW, [["__file", "tag.vue"]]);
const Uc = Yt(YW), GW = it({
  ...GT,
  size: Lo,
  placeholder: String,
  disabled: Boolean,
  clearable: Boolean,
  filterable: Boolean,
  filterMethod: {
    type: Ae(Function),
    default: (e, t) => e.text.includes(t)
  },
  separator: {
    type: String,
    default: " / "
  },
  showAllLevels: {
    type: Boolean,
    default: !0
  },
  collapseTags: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  collapseTagsTooltip: {
    type: Boolean,
    default: !1
  },
  debounce: {
    type: Number,
    default: 300
  },
  beforeFilter: {
    type: Ae(Function),
    default: () => !0
  },
  popperClass: {
    type: String,
    default: ""
  },
  teleported: Fo.teleported,
  tagType: { ...Uv.type, default: "info" },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  ...ru
}), XW = {
  [Jt]: (e) => !0,
  [qn]: (e) => !0,
  focus: (e) => e instanceof FocusEvent,
  blur: (e) => e instanceof FocusEvent,
  visibleChange: (e) => $o(e),
  expandChange: (e) => !!e,
  removeTag: (e) => !!e
}, ZW = { key: 0 }, JW = ["placeholder", "onKeydown"], QW = ["onClick"], eK = "ElCascader", tK = Q({
  name: eK
}), nK = /* @__PURE__ */ Q({
  ...tK,
  props: GW,
  emits: XW,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = {
      modifiers: [
        {
          name: "arrowPosition",
          enabled: !0,
          phase: "main",
          fn: ({ state: we }) => {
            const { modifiersData: ze, placement: Je } = we;
            ["right", "left", "bottom", "top"].includes(Je) || (ze.arrow.x = 35);
          },
          requires: ["arrow"]
        }
      ]
    }, a = Ai();
    let r = 0, i = 0;
    const s = nt("cascader"), u = nt("input"), { t: d } = bn(), { form: f, formItem: v } = ml(), { valueOnClear: h } = Hv(o), m = B(null), p = B(null), C = B(null), g = B(null), w = B(null), b = B(!1), y = B(!1), E = B(!1), S = B(!1), _ = B(""), k = B(""), N = B([]), L = B([]), R = B([]), H = B(!1), K = x(() => a.style), U = x(() => o.disabled || (f == null ? void 0 : f.disabled)), W = x(() => o.placeholder || d("el.cascader.placeholder")), A = x(() => k.value || N.value.length > 0 || H.value ? "" : W.value), $ = Mo(), D = x(() => ["small"].includes($.value) ? "small" : "default"), O = x(() => !!o.props.multiple), F = x(() => !o.filterable || O.value), j = x(() => O.value ? k.value : _.value), Z = x(() => {
      var we;
      return ((we = g.value) == null ? void 0 : we.checkedNodes) || [];
    }), te = x(() => !o.clearable || U.value || E.value || !y.value ? !1 : !!Z.value.length), de = x(() => {
      const { showAllLevels: we, separator: ze } = o, Je = Z.value;
      return Je.length ? O.value ? "" : Je[0].calcText(we, ze) : "";
    }), Oe = x(() => (v == null ? void 0 : v.validateState) || ""), ce = x({
      get() {
        return jp(o.modelValue);
      },
      set(we) {
        const ze = we || h.value;
        n(Jt, ze), n(qn, ze), o.validateEvent && (v == null || v.validate("change").catch((Je) => dn(Je)));
      }
    }), ne = x(() => [
      s.b(),
      s.m($.value),
      s.is("disabled", U.value),
      a.class
    ]), Y = x(() => [
      u.e("icon"),
      "icon-arrow-down",
      s.is("reverse", b.value)
    ]), ve = x(() => s.is("focus", b.value || S.value)), ie = x(() => {
      var we, ze;
      return (ze = (we = m.value) == null ? void 0 : we.popperRef) == null ? void 0 : ze.contentRef;
    }), he = (we) => {
      var ze, Je, Me;
      U.value || (we = we ?? !b.value, we !== b.value && (b.value = we, (Je = (ze = p.value) == null ? void 0 : ze.input) == null || Je.setAttribute("aria-expanded", `${we}`), we ? (De(), xe((Me = g.value) == null ? void 0 : Me.scrollToExpandingNode)) : o.filterable && re(), n("visibleChange", we)));
    }, De = () => {
      xe(() => {
        var we;
        (we = m.value) == null || we.updatePopper();
      });
    }, $e = () => {
      E.value = !1;
    }, ue = (we) => {
      const { showAllLevels: ze, separator: Je } = o;
      return {
        node: we,
        key: we.uid,
        text: we.calcText(ze, Je),
        hitState: !1,
        closable: !U.value && !we.isDisabled,
        isCollapseTag: !1
      };
    }, Ne = (we) => {
      var ze;
      const Je = we.node;
      Je.doCheck(!1), (ze = g.value) == null || ze.calculateCheckedValue(), n("removeTag", Je.valueByOption);
    }, je = () => {
      if (!O.value)
        return;
      const we = Z.value, ze = [], Je = [];
      if (we.forEach((Me) => Je.push(ue(Me))), L.value = Je, we.length) {
        we.slice(0, o.maxCollapseTags).forEach((mt) => ze.push(ue(mt)));
        const Me = we.slice(o.maxCollapseTags), et = Me.length;
        et && (o.collapseTags ? ze.push({
          key: -1,
          text: `+ ${et}`,
          closable: !1,
          isCollapseTag: !0
        }) : Me.forEach((mt) => ze.push(ue(mt))));
      }
      N.value = ze;
    }, Fe = () => {
      var we, ze;
      const { filterMethod: Je, showAllLevels: Me, separator: et } = o, mt = (ze = (we = g.value) == null ? void 0 : we.getFlattedNodes(!o.props.checkStrictly)) == null ? void 0 : ze.filter((Lt) => Lt.isDisabled ? !1 : (Lt.calcText(Me, et), Je(Lt, j.value)));
      O.value && (N.value.forEach((Lt) => {
        Lt.hitState = !1;
      }), L.value.forEach((Lt) => {
        Lt.hitState = !1;
      })), E.value = !0, R.value = mt, De();
    }, Ve = () => {
      var we;
      let ze;
      E.value && w.value ? ze = w.value.$el.querySelector(`.${s.e("suggestion-item")}`) : ze = (we = g.value) == null ? void 0 : we.$el.querySelector(`.${s.b("node")}[tabindex="-1"]`), ze && (ze.focus(), !E.value && ze.click());
    }, Ze = () => {
      var we, ze;
      const Je = (we = p.value) == null ? void 0 : we.input, Me = C.value, et = (ze = w.value) == null ? void 0 : ze.$el;
      if (!(!fn || !Je)) {
        if (et) {
          const mt = et.querySelector(`.${s.e("suggestion-list")}`);
          mt.style.minWidth = `${Je.offsetWidth}px`;
        }
        if (Me) {
          const { offsetHeight: mt } = Me, Lt = N.value.length > 0 ? `${Math.max(mt + 6, r)}px` : `${r}px`;
          Je.style.height = Lt, De();
        }
      }
    }, ae = (we) => {
      var ze;
      return (ze = g.value) == null ? void 0 : ze.getCheckedNodes(we);
    }, pe = (we) => {
      De(), n("expandChange", we);
    }, ke = (we) => {
      var ze;
      const Je = (ze = we.target) == null ? void 0 : ze.value;
      if (we.type === "compositionend")
        H.value = !1, xe(() => Ke(Je));
      else {
        const Me = Je[Je.length - 1] || "";
        H.value = !hy(Me);
      }
    }, Ue = (we) => {
      if (!H.value)
        switch (we.code) {
          case xt.enter:
            he();
            break;
          case xt.down:
            he(!0), xe(Ve), we.preventDefault();
            break;
          case xt.esc:
            b.value === !0 && (we.preventDefault(), we.stopPropagation(), he(!1));
            break;
          case xt.tab:
            he(!1);
            break;
        }
    }, Xe = () => {
      var we;
      (we = g.value) == null || we.clearCheckedNodes(), !b.value && o.filterable && re(), he(!1);
    }, re = () => {
      const { value: we } = de;
      _.value = we, k.value = we;
    }, Te = (we) => {
      var ze, Je;
      const { checked: Me } = we;
      O.value ? (ze = g.value) == null || ze.handleCheckChange(we, !Me, !1) : (!Me && ((Je = g.value) == null || Je.handleCheckChange(we, !0, !1)), he(!1));
    }, Ce = (we) => {
      const ze = we.target, { code: Je } = we;
      switch (Je) {
        case xt.up:
        case xt.down: {
          const Me = Je === xt.up ? -1 : 1;
          vp(Y2(ze, Me, `.${s.e("suggestion-item")}[tabindex="-1"]`));
          break;
        }
        case xt.enter:
          ze.click();
          break;
      }
    }, Le = () => {
      const we = N.value, ze = we[we.length - 1];
      i = k.value ? 0 : i + 1, !(!ze || !i || o.collapseTags && we.length > 1) && (ze.hitState ? Ne(ze) : ze.hitState = !0);
    }, ge = (we) => {
      const ze = we.target, Je = s.e("search-input");
      ze.className === Je && (S.value = !0), n("focus", we);
    }, Ee = (we) => {
      S.value = !1, n("blur", we);
    }, me = Hl(() => {
      const { value: we } = j;
      if (!we)
        return;
      const ze = o.beforeFilter(we);
      eg(ze) ? ze.then(Fe).catch(() => {
      }) : ze !== !1 ? Fe() : $e();
    }, o.debounce), Ke = (we, ze) => {
      !b.value && he(!0), !(ze != null && ze.isComposing) && (we ? me() : $e());
    }, Re = (we) => Number.parseFloat(H3(u.cssVarName("input-height"), we).value) - 2;
    return Pe(E, De), Pe([Z, U], je), Pe(N, () => {
      xe(() => Ze());
    }), Pe($, async () => {
      await xe();
      const we = p.value.input;
      r = Re(we) || r, Ze();
    }), Pe(de, re, { immediate: !0 }), Nt(() => {
      const we = p.value.input, ze = Re(we);
      r = we.offsetHeight || ze, Xn(we, Ze);
    }), t({
      getCheckedNodes: ae,
      cascaderPanelRef: g,
      togglePopperVisible: he,
      contentRef: ie
    }), (we, ze) => (M(), We(c(hl), {
      ref_key: "tooltipRef",
      ref: m,
      visible: b.value,
      teleported: we.teleported,
      "popper-class": [c(s).e("dropdown"), we.popperClass],
      "popper-options": l,
      "fallback-placements": [
        "bottom-start",
        "bottom",
        "top-start",
        "top",
        "right",
        "left"
      ],
      "stop-popper-mouse-event": !1,
      "gpu-acceleration": !1,
      placement: "bottom-start",
      transition: `${c(s).namespace.value}-zoom-in-top`,
      effect: "light",
      pure: "",
      persistent: "",
      onHide: $e
    }, {
      default: fe(() => [
        Bt((M(), G("div", {
          class: z(c(ne)),
          style: bt(c(K)),
          onClick: ze[5] || (ze[5] = () => he(c(F) ? void 0 : !0)),
          onKeydown: Ue,
          onMouseenter: ze[6] || (ze[6] = (Je) => y.value = !0),
          onMouseleave: ze[7] || (ze[7] = (Je) => y.value = !1)
        }, [
          oe(c(nl), {
            ref_key: "input",
            ref: p,
            modelValue: _.value,
            "onUpdate:modelValue": ze[1] || (ze[1] = (Je) => _.value = Je),
            placeholder: c(A),
            readonly: c(F),
            disabled: c(U),
            "validate-event": !1,
            size: c($),
            class: z(c(ve)),
            tabindex: c(O) && we.filterable && !c(U) ? -1 : void 0,
            onCompositionstart: ke,
            onCompositionupdate: ke,
            onCompositionend: ke,
            onFocus: ge,
            onBlur: Ee,
            onInput: Ke
          }, {
            suffix: fe(() => [
              c(te) ? (M(), We(c(Ct), {
                key: "clear",
                class: z([c(u).e("icon"), "icon-circle-close"]),
                onClick: It(Xe, ["stop"])
              }, {
                default: fe(() => [
                  oe(c(Ls))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : (M(), We(c(Ct), {
                key: "arrow-down",
                class: z(c(Y)),
                onClick: ze[0] || (ze[0] = It((Je) => he(), ["stop"]))
              }, {
                default: fe(() => [
                  oe(c(Br))
                ]),
                _: 1
              }, 8, ["class"]))
            ]),
            _: 1
          }, 8, ["modelValue", "placeholder", "readonly", "disabled", "size", "class", "tabindex"]),
          c(O) ? (M(), G("div", {
            key: 0,
            ref_key: "tagWrapper",
            ref: C,
            class: z([
              c(s).e("tags"),
              c(s).is("validate", !!c(Oe))
            ])
          }, [
            (M(!0), G(kt, null, ln(N.value, (Je) => (M(), We(c(Uc), {
              key: Je.key,
              type: we.tagType,
              size: c(D),
              hit: Je.hitState,
              closable: Je.closable,
              "disable-transitions": "",
              onClose: (Me) => Ne(Je)
            }, {
              default: fe(() => [
                Je.isCollapseTag === !1 ? (M(), G("span", ZW, Qe(Je.text), 1)) : (M(), We(c(hl), {
                  key: 1,
                  disabled: b.value || !we.collapseTagsTooltip,
                  "fallback-placements": ["bottom", "top", "right", "left"],
                  placement: "bottom",
                  effect: "light"
                }, {
                  default: fe(() => [
                    X("span", null, Qe(Je.text), 1)
                  ]),
                  content: fe(() => [
                    X("div", {
                      class: z(c(s).e("collapse-tags"))
                    }, [
                      (M(!0), G(kt, null, ln(L.value.slice(we.maxCollapseTags), (Me, et) => (M(), G("div", {
                        key: et,
                        class: z(c(s).e("collapse-tag"))
                      }, [
                        (M(), We(c(Uc), {
                          key: Me.key,
                          class: "in-tooltip",
                          type: we.tagType,
                          size: c(D),
                          hit: Me.hitState,
                          closable: Me.closable,
                          "disable-transitions": "",
                          onClose: (mt) => Ne(Me)
                        }, {
                          default: fe(() => [
                            X("span", null, Qe(Me.text), 1)
                          ]),
                          _: 2
                        }, 1032, ["type", "size", "hit", "closable", "onClose"]))
                      ], 2))), 128))
                    ], 2)
                  ]),
                  _: 2
                }, 1032, ["disabled"]))
              ]),
              _: 2
            }, 1032, ["type", "size", "hit", "closable", "onClose"]))), 128)),
            we.filterable && !c(U) ? Bt((M(), G("input", {
              key: 0,
              "onUpdate:modelValue": ze[2] || (ze[2] = (Je) => k.value = Je),
              type: "text",
              class: z(c(s).e("search-input")),
              placeholder: c(de) ? "" : c(W),
              onInput: ze[3] || (ze[3] = (Je) => Ke(k.value, Je)),
              onClick: ze[4] || (ze[4] = It((Je) => he(!0), ["stop"])),
              onKeydown: Rn(Le, ["delete"]),
              onCompositionstart: ke,
              onCompositionupdate: ke,
              onCompositionend: ke,
              onFocus: ge,
              onBlur: Ee
            }, null, 42, JW)), [
              [Vb, k.value]
            ]) : _e("v-if", !0)
          ], 2)) : _e("v-if", !0)
        ], 38)), [
          [c(Pr), () => he(!1), c(ie)]
        ])
      ]),
      content: fe(() => [
        Bt(oe(c(XT), {
          ref_key: "cascaderPanelRef",
          ref: g,
          modelValue: c(ce),
          "onUpdate:modelValue": ze[8] || (ze[8] = (Je) => fl(ce) ? ce.value = Je : null),
          options: we.options,
          props: o.props,
          border: !1,
          "render-label": we.$slots.default,
          onExpandChange: pe,
          onClose: ze[9] || (ze[9] = (Je) => we.$nextTick(() => he(!1)))
        }, null, 8, ["modelValue", "options", "props", "render-label"]), [
          [pn, !E.value]
        ]),
        we.filterable ? Bt((M(), We(c(zr), {
          key: 0,
          ref_key: "suggestionPanel",
          ref: w,
          tag: "ul",
          class: z(c(s).e("suggestion-panel")),
          "view-class": c(s).e("suggestion-list"),
          onKeydown: Ce
        }, {
          default: fe(() => [
            R.value.length ? (M(!0), G(kt, { key: 0 }, ln(R.value, (Je) => (M(), G("li", {
              key: Je.uid,
              class: z([
                c(s).e("suggestion-item"),
                c(s).is("checked", Je.checked)
              ]),
              tabindex: -1,
              onClick: (Me) => Te(Je)
            }, [
              X("span", null, Qe(Je.text), 1),
              Je.checked ? (M(), We(c(Ct), { key: 0 }, {
                default: fe(() => [
                  oe(c(lf))
                ]),
                _: 1
              })) : _e("v-if", !0)
            ], 10, QW))), 128)) : Ie(we.$slots, "empty", { key: 1 }, () => [
              X("li", {
                class: z(c(s).e("empty-text"))
              }, Qe(c(d)("el.cascader.noMatch")), 3)
            ])
          ]),
          _: 3
        }, 8, ["class", "view-class"])), [
          [pn, E.value]
        ]) : _e("v-if", !0)
      ]),
      _: 3
    }, 8, ["visible", "teleported", "popper-class", "transition"]));
  }
});
var _p = /* @__PURE__ */ ut(nK, [["__file", "cascader.vue"]]);
_p.install = (e) => {
  e.component(_p.name, _p);
};
const oK = _p, ZT = oK, lK = it({
  checked: {
    type: Boolean,
    default: !1
  },
  type: {
    type: String,
    values: ["primary", "success", "info", "warning", "danger"],
    default: "primary"
  }
}), aK = {
  "update:checked": (e) => $o(e),
  [qn]: (e) => $o(e)
}, rK = Q({
  name: "ElCheckTag"
}), sK = /* @__PURE__ */ Q({
  ...rK,
  props: lK,
  emits: aK,
  setup(e, { emit: t }) {
    const n = e, o = nt("check-tag"), l = x(() => [
      o.b(),
      o.is("checked", n.checked),
      o.m(n.type || "primary")
    ]), a = () => {
      const r = !n.checked;
      t(qn, r), t("update:checked", r);
    };
    return (r, i) => (M(), G("span", {
      class: z(c(l)),
      onClick: a
    }, [
      Ie(r.$slots, "default")
    ], 2));
  }
});
var iK = /* @__PURE__ */ ut(sK, [["__file", "check-tag.vue"]]);
const cK = Yt(iK), JT = Symbol("rowContextKey"), uK = [
  "start",
  "center",
  "end",
  "space-around",
  "space-between",
  "space-evenly"
], dK = ["top", "middle", "bottom"], fK = it({
  tag: {
    type: String,
    default: "div"
  },
  gutter: {
    type: Number,
    default: 0
  },
  justify: {
    type: String,
    values: uK,
    default: "start"
  },
  align: {
    type: String,
    values: dK
  }
}), pK = Q({
  name: "ElRow"
}), vK = /* @__PURE__ */ Q({
  ...pK,
  props: fK,
  setup(e) {
    const t = e, n = nt("row"), o = x(() => t.gutter);
    Mt(JT, {
      gutter: o
    });
    const l = x(() => {
      const r = {};
      return t.gutter && (r.marginRight = r.marginLeft = `-${t.gutter / 2}px`), r;
    }), a = x(() => [
      n.b(),
      n.is(`justify-${t.justify}`, t.justify !== "start"),
      n.is(`align-${t.align}`, !!t.align)
    ]);
    return (r, i) => (M(), We(Qt(r.tag), {
      class: z(c(a)),
      style: bt(c(l))
    }, {
      default: fe(() => [
        Ie(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "style"]));
  }
});
var hK = /* @__PURE__ */ ut(vK, [["__file", "row.vue"]]);
const mK = Yt(hK), gK = it({
  tag: {
    type: String,
    default: "div"
  },
  span: {
    type: Number,
    default: 24
  },
  offset: {
    type: Number,
    default: 0
  },
  pull: {
    type: Number,
    default: 0
  },
  push: {
    type: Number,
    default: 0
  },
  xs: {
    type: Ae([Number, Object]),
    default: () => Zn({})
  },
  sm: {
    type: Ae([Number, Object]),
    default: () => Zn({})
  },
  md: {
    type: Ae([Number, Object]),
    default: () => Zn({})
  },
  lg: {
    type: Ae([Number, Object]),
    default: () => Zn({})
  },
  xl: {
    type: Ae([Number, Object]),
    default: () => Zn({})
  }
}), bK = Q({
  name: "ElCol"
}), yK = /* @__PURE__ */ Q({
  ...bK,
  props: gK,
  setup(e) {
    const t = e, { gutter: n } = ot(JT, { gutter: x(() => 0) }), o = nt("col"), l = x(() => {
      const r = {};
      return n.value && (r.paddingLeft = r.paddingRight = `${n.value / 2}px`), r;
    }), a = x(() => {
      const r = [];
      return ["span", "offset", "pull", "push"].forEach((u) => {
        const d = t[u];
        Ot(d) && (u === "span" ? r.push(o.b(`${t[u]}`)) : d > 0 && r.push(o.b(`${u}-${t[u]}`)));
      }), ["xs", "sm", "md", "lg", "xl"].forEach((u) => {
        Ot(t[u]) ? r.push(o.b(`${u}-${t[u]}`)) : Mn(t[u]) && Object.entries(t[u]).forEach(([d, f]) => {
          r.push(d !== "span" ? o.b(`${u}-${d}-${f}`) : o.b(`${u}-${f}`));
        });
      }), n.value && r.push(o.is("guttered")), [o.b(), r];
    });
    return (r, i) => (M(), We(Qt(r.tag), {
      class: z(c(a)),
      style: bt(c(l))
    }, {
      default: fe(() => [
        Ie(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "style"]));
  }
});
var CK = /* @__PURE__ */ ut(yK, [["__file", "col.vue"]]);
const wK = Yt(CK), nE = (e) => Ot(e) || on(e) || Kt(e), EK = it({
  accordion: Boolean,
  modelValue: {
    type: Ae([Array, String, Number]),
    default: () => Zn([])
  }
}), SK = {
  [Jt]: nE,
  [qn]: nE
}, QT = Symbol("collapseContextKey"), _K = (e, t) => {
  const n = B(_s(e.modelValue)), o = (a) => {
    n.value = a;
    const r = e.accordion ? n.value[0] : n.value;
    t(Jt, r), t(qn, r);
  }, l = (a) => {
    if (e.accordion)
      o([n.value[0] === a ? "" : a]);
    else {
      const r = [...n.value], i = r.indexOf(a);
      i > -1 ? r.splice(i, 1) : r.push(a), o(r);
    }
  };
  return Pe(() => e.modelValue, () => n.value = _s(e.modelValue), { deep: !0 }), Mt(QT, {
    activeNames: n,
    handleItemClick: l
  }), {
    activeNames: n,
    setActiveNames: o
  };
}, xK = () => {
  const e = nt("collapse");
  return {
    rootKls: x(() => e.b())
  };
}, kK = Q({
  name: "ElCollapse"
}), TK = /* @__PURE__ */ Q({
  ...kK,
  props: EK,
  emits: SK,
  setup(e, { expose: t, emit: n }) {
    const o = e, { activeNames: l, setActiveNames: a } = _K(o, n), { rootKls: r } = xK();
    return t({
      activeNames: l,
      setActiveNames: a
    }), (i, s) => (M(), G("div", {
      class: z(c(r))
    }, [
      Ie(i.$slots, "default")
    ], 2));
  }
});
var $K = /* @__PURE__ */ ut(TK, [["__file", "collapse.vue"]]);
const OK = Q({
  name: "ElCollapseTransition"
}), NK = /* @__PURE__ */ Q({
  ...OK,
  setup(e) {
    const t = nt("collapse-transition"), n = (l) => {
      l.style.maxHeight = "", l.style.overflow = l.dataset.oldOverflow, l.style.paddingTop = l.dataset.oldPaddingTop, l.style.paddingBottom = l.dataset.oldPaddingBottom;
    }, o = {
      beforeEnter(l) {
        l.dataset || (l.dataset = {}), l.dataset.oldPaddingTop = l.style.paddingTop, l.dataset.oldPaddingBottom = l.style.paddingBottom, l.style.height && (l.dataset.elExistsHeight = l.style.height), l.style.maxHeight = 0, l.style.paddingTop = 0, l.style.paddingBottom = 0;
      },
      enter(l) {
        requestAnimationFrame(() => {
          l.dataset.oldOverflow = l.style.overflow, l.dataset.elExistsHeight ? l.style.maxHeight = l.dataset.elExistsHeight : l.scrollHeight !== 0 ? l.style.maxHeight = `${l.scrollHeight}px` : l.style.maxHeight = 0, l.style.paddingTop = l.dataset.oldPaddingTop, l.style.paddingBottom = l.dataset.oldPaddingBottom, l.style.overflow = "hidden";
        });
      },
      afterEnter(l) {
        l.style.maxHeight = "", l.style.overflow = l.dataset.oldOverflow;
      },
      enterCancelled(l) {
        n(l);
      },
      beforeLeave(l) {
        l.dataset || (l.dataset = {}), l.dataset.oldPaddingTop = l.style.paddingTop, l.dataset.oldPaddingBottom = l.style.paddingBottom, l.dataset.oldOverflow = l.style.overflow, l.style.maxHeight = `${l.scrollHeight}px`, l.style.overflow = "hidden";
      },
      leave(l) {
        l.scrollHeight !== 0 && (l.style.maxHeight = 0, l.style.paddingTop = 0, l.style.paddingBottom = 0);
      },
      afterLeave(l) {
        n(l);
      },
      leaveCancelled(l) {
        n(l);
      }
    };
    return (l, a) => (M(), We(Ko, Et({
      name: c(t).b()
    }, m3(o)), {
      default: fe(() => [
        Ie(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["name"]));
  }
});
var xp = /* @__PURE__ */ ut(NK, [["__file", "collapse-transition.vue"]]);
xp.install = (e) => {
  e.component(xp.name, xp);
};
const jv = xp, MK = jv, IK = it({
  title: {
    type: String,
    default: ""
  },
  name: {
    type: Ae([String, Number]),
    default: void 0
  },
  disabled: Boolean
}), RK = (e) => {
  const t = ot(QT), { namespace: n } = nt("collapse"), o = B(!1), l = B(!1), a = $y(), r = x(() => a.current++), i = x(() => {
    var v;
    return (v = e.name) != null ? v : `${n.value}-id-${a.prefix}-${c(r)}`;
  }), s = x(() => t == null ? void 0 : t.activeNames.value.includes(c(i)));
  return {
    focusing: o,
    id: r,
    isActive: s,
    handleFocus: () => {
      setTimeout(() => {
        l.value ? l.value = !1 : o.value = !0;
      }, 50);
    },
    handleHeaderClick: () => {
      e.disabled || (t == null || t.handleItemClick(c(i)), o.value = !1, l.value = !0);
    },
    handleEnterClick: () => {
      t == null || t.handleItemClick(c(i));
    }
  };
}, DK = (e, { focusing: t, isActive: n, id: o }) => {
  const l = nt("collapse"), a = x(() => [
    l.b("item"),
    l.is("active", c(n)),
    l.is("disabled", e.disabled)
  ]), r = x(() => [
    l.be("item", "header"),
    l.is("active", c(n)),
    { focusing: c(t) && !e.disabled }
  ]), i = x(() => [
    l.be("item", "arrow"),
    l.is("active", c(n))
  ]), s = x(() => l.be("item", "wrap")), u = x(() => l.be("item", "content")), d = x(() => l.b(`content-${c(o)}`)), f = x(() => l.b(`head-${c(o)}`));
  return {
    arrowKls: i,
    headKls: r,
    rootKls: a,
    itemWrapperKls: s,
    itemContentKls: u,
    scopedContentId: d,
    scopedHeadId: f
  };
}, LK = ["id", "aria-expanded", "aria-controls", "aria-describedby", "tabindex"], PK = ["id", "aria-hidden", "aria-labelledby"], AK = Q({
  name: "ElCollapseItem"
}), FK = /* @__PURE__ */ Q({
  ...AK,
  props: IK,
  setup(e, { expose: t }) {
    const n = e, {
      focusing: o,
      id: l,
      isActive: a,
      handleFocus: r,
      handleHeaderClick: i,
      handleEnterClick: s
    } = RK(n), {
      arrowKls: u,
      headKls: d,
      rootKls: f,
      itemWrapperKls: v,
      itemContentKls: h,
      scopedContentId: m,
      scopedHeadId: p
    } = DK(n, { focusing: o, isActive: a, id: l });
    return t({
      isActive: a
    }), (C, g) => (M(), G("div", {
      class: z(c(f))
    }, [
      X("button", {
        id: c(p),
        class: z(c(d)),
        "aria-expanded": c(a),
        "aria-controls": c(m),
        "aria-describedby": c(m),
        tabindex: C.disabled ? -1 : 0,
        type: "button",
        onClick: g[0] || (g[0] = (...w) => c(i) && c(i)(...w)),
        onKeydown: g[1] || (g[1] = Rn(It((...w) => c(s) && c(s)(...w), ["stop", "prevent"]), ["space", "enter"])),
        onFocus: g[2] || (g[2] = (...w) => c(r) && c(r)(...w)),
        onBlur: g[3] || (g[3] = (w) => o.value = !1)
      }, [
        Ie(C.$slots, "title", {}, () => [
          Ut(Qe(C.title), 1)
        ]),
        oe(c(Ct), {
          class: z(c(u))
        }, {
          default: fe(() => [
            oe(c(xl))
          ]),
          _: 1
        }, 8, ["class"])
      ], 42, LK),
      oe(c(jv), null, {
        default: fe(() => [
          Bt(X("div", {
            id: c(m),
            role: "region",
            class: z(c(v)),
            "aria-hidden": !c(a),
            "aria-labelledby": c(p)
          }, [
            X("div", {
              class: z(c(h))
            }, [
              Ie(C.$slots, "default")
            ], 2)
          ], 10, PK), [
            [pn, c(a)]
          ])
        ]),
        _: 3
      })
    ], 2));
  }
});
var e$ = /* @__PURE__ */ ut(FK, [["__file", "collapse-item.vue"]]);
const t$ = Yt($K, {
  CollapseItem: e$
}), n$ = Jn(e$), VK = it({
  color: {
    type: Ae(Object),
    required: !0
  },
  vertical: {
    type: Boolean,
    default: !1
  }
});
let lm = !1;
function Pd(e, t) {
  if (!fn)
    return;
  const n = function(a) {
    var r;
    (r = t.drag) == null || r.call(t, a);
  }, o = function(a) {
    var r;
    document.removeEventListener("mousemove", n), document.removeEventListener("mouseup", o), document.removeEventListener("touchmove", n), document.removeEventListener("touchend", o), document.onselectstart = null, document.ondragstart = null, lm = !1, (r = t.end) == null || r.call(t, a);
  }, l = function(a) {
    var r;
    lm || (a.preventDefault(), document.onselectstart = () => !1, document.ondragstart = () => !1, document.addEventListener("mousemove", n), document.addEventListener("mouseup", o), document.addEventListener("touchmove", n), document.addEventListener("touchend", o), lm = !0, (r = t.start) == null || r.call(t, a));
  };
  e.addEventListener("mousedown", l), e.addEventListener("touchstart", l);
}
const BK = (e) => {
  const t = Pt(), n = An(), o = An();
  function l(r) {
    r.target !== n.value && a(r);
  }
  function a(r) {
    if (!o.value || !n.value)
      return;
    const s = t.vnode.el.getBoundingClientRect(), { clientX: u, clientY: d } = zb(r);
    if (e.vertical) {
      let f = d - s.top;
      f = Math.max(n.value.offsetHeight / 2, f), f = Math.min(f, s.height - n.value.offsetHeight / 2), e.color.set("alpha", Math.round((f - n.value.offsetHeight / 2) / (s.height - n.value.offsetHeight) * 100));
    } else {
      let f = u - s.left;
      f = Math.max(n.value.offsetWidth / 2, f), f = Math.min(f, s.width - n.value.offsetWidth / 2), e.color.set("alpha", Math.round((f - n.value.offsetWidth / 2) / (s.width - n.value.offsetWidth) * 100));
    }
  }
  return {
    thumb: n,
    bar: o,
    handleDrag: a,
    handleClick: l
  };
}, HK = (e, {
  bar: t,
  thumb: n,
  handleDrag: o
}) => {
  const l = Pt(), a = nt("color-alpha-slider"), r = B(0), i = B(0), s = B();
  function u() {
    if (!n.value || e.vertical)
      return 0;
    const w = l.vnode.el, b = e.color.get("alpha");
    return w ? Math.round(b * (w.offsetWidth - n.value.offsetWidth / 2) / 100) : 0;
  }
  function d() {
    if (!n.value)
      return 0;
    const w = l.vnode.el;
    if (!e.vertical)
      return 0;
    const b = e.color.get("alpha");
    return w ? Math.round(b * (w.offsetHeight - n.value.offsetHeight / 2) / 100) : 0;
  }
  function f() {
    if (e.color && e.color.value) {
      const { r: w, g: b, b: y } = e.color.toRgb();
      return `linear-gradient(to right, rgba(${w}, ${b}, ${y}, 0) 0%, rgba(${w}, ${b}, ${y}, 1) 100%)`;
    }
    return "";
  }
  function v() {
    r.value = u(), i.value = d(), s.value = f();
  }
  Nt(() => {
    if (!t.value || !n.value)
      return;
    const w = {
      drag: (b) => {
        o(b);
      },
      end: (b) => {
        o(b);
      }
    };
    Pd(t.value, w), Pd(n.value, w), v();
  }), Pe(() => e.color.get("alpha"), () => v()), Pe(() => e.color.value, () => v());
  const h = x(() => [a.b(), a.is("vertical", e.vertical)]), m = x(() => a.e("bar")), p = x(() => a.e("thumb")), C = x(() => ({ background: s.value })), g = x(() => ({
    left: po(r.value),
    top: po(i.value)
  }));
  return { rootKls: h, barKls: m, barStyle: C, thumbKls: p, thumbStyle: g, update: v };
}, zK = "ElColorAlphaSlider", WK = Q({
  name: zK
}), KK = /* @__PURE__ */ Q({
  ...WK,
  props: VK,
  setup(e, { expose: t }) {
    const n = e, { bar: o, thumb: l, handleDrag: a, handleClick: r } = BK(n), { rootKls: i, barKls: s, barStyle: u, thumbKls: d, thumbStyle: f, update: v } = HK(n, {
      bar: o,
      thumb: l,
      handleDrag: a
    });
    return t({
      update: v,
      bar: o,
      thumb: l
    }), (h, m) => (M(), G("div", {
      class: z(c(i))
    }, [
      X("div", {
        ref_key: "bar",
        ref: o,
        class: z(c(s)),
        style: bt(c(u)),
        onClick: m[0] || (m[0] = (...p) => c(r) && c(r)(...p))
      }, null, 6),
      X("div", {
        ref_key: "thumb",
        ref: l,
        class: z(c(d)),
        style: bt(c(f))
      }, null, 6)
    ], 2));
  }
});
var UK = /* @__PURE__ */ ut(KK, [["__file", "alpha-slider.vue"]]);
const jK = Q({
  name: "ElColorHueSlider",
  props: {
    color: {
      type: Object,
      required: !0
    },
    vertical: Boolean
  },
  setup(e) {
    const t = nt("color-hue-slider"), n = Pt(), o = B(), l = B(), a = B(0), r = B(0), i = x(() => e.color.get("hue"));
    Pe(() => i.value, () => {
      v();
    });
    function s(h) {
      h.target !== o.value && u(h);
    }
    function u(h) {
      if (!l.value || !o.value)
        return;
      const p = n.vnode.el.getBoundingClientRect(), { clientX: C, clientY: g } = zb(h);
      let w;
      if (e.vertical) {
        let b = g - p.top;
        b = Math.min(b, p.height - o.value.offsetHeight / 2), b = Math.max(o.value.offsetHeight / 2, b), w = Math.round((b - o.value.offsetHeight / 2) / (p.height - o.value.offsetHeight) * 360);
      } else {
        let b = C - p.left;
        b = Math.min(b, p.width - o.value.offsetWidth / 2), b = Math.max(o.value.offsetWidth / 2, b), w = Math.round((b - o.value.offsetWidth / 2) / (p.width - o.value.offsetWidth) * 360);
      }
      e.color.set("hue", w);
    }
    function d() {
      if (!o.value)
        return 0;
      const h = n.vnode.el;
      if (e.vertical)
        return 0;
      const m = e.color.get("hue");
      return h ? Math.round(m * (h.offsetWidth - o.value.offsetWidth / 2) / 360) : 0;
    }
    function f() {
      if (!o.value)
        return 0;
      const h = n.vnode.el;
      if (!e.vertical)
        return 0;
      const m = e.color.get("hue");
      return h ? Math.round(m * (h.offsetHeight - o.value.offsetHeight / 2) / 360) : 0;
    }
    function v() {
      a.value = d(), r.value = f();
    }
    return Nt(() => {
      if (!l.value || !o.value)
        return;
      const h = {
        drag: (m) => {
          u(m);
        },
        end: (m) => {
          u(m);
        }
      };
      Pd(l.value, h), Pd(o.value, h), v();
    }), {
      bar: l,
      thumb: o,
      thumbLeft: a,
      thumbTop: r,
      hueValue: i,
      handleClick: s,
      update: v,
      ns: t
    };
  }
});
function qK(e, t, n, o, l, a) {
  return M(), G("div", {
    class: z([e.ns.b(), e.ns.is("vertical", e.vertical)])
  }, [
    X("div", {
      ref: "bar",
      class: z(e.ns.e("bar")),
      onClick: t[0] || (t[0] = (...r) => e.handleClick && e.handleClick(...r))
    }, null, 2),
    X("div", {
      ref: "thumb",
      class: z(e.ns.e("thumb")),
      style: bt({
        left: e.thumbLeft + "px",
        top: e.thumbTop + "px"
      })
    }, null, 6)
  ], 2);
}
var YK = /* @__PURE__ */ ut(jK, [["render", qK], ["__file", "hue-slider.vue"]]);
const GK = it({
  modelValue: String,
  id: String,
  showAlpha: Boolean,
  colorFormat: String,
  disabled: Boolean,
  size: Lo,
  popperClass: {
    type: String,
    default: ""
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  teleported: Fo.teleported,
  predefine: {
    type: Ae(Array)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  ...Zo(["ariaLabel"])
}), XK = {
  [Jt]: (e) => on(e) || zo(e),
  [qn]: (e) => on(e) || zo(e),
  activeChange: (e) => on(e) || zo(e),
  focus: (e) => e instanceof FocusEvent,
  blur: (e) => e instanceof FocusEvent
}, o$ = Symbol("colorPickerContextKey"), oE = function(e, t, n) {
  return [
    e,
    t * n / ((e = (2 - t) * n) < 1 ? e : 2 - e) || 0,
    e / 2
  ];
}, ZK = function(e) {
  return typeof e == "string" && e.includes(".") && Number.parseFloat(e) === 1;
}, JK = function(e) {
  return typeof e == "string" && e.includes("%");
}, Tc = function(e, t) {
  ZK(e) && (e = "100%");
  const n = JK(e);
  return e = Math.min(t, Math.max(0, Number.parseFloat(`${e}`))), n && (e = Number.parseInt(`${e * t}`, 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : e % t / Number.parseFloat(t);
}, lE = {
  10: "A",
  11: "B",
  12: "C",
  13: "D",
  14: "E",
  15: "F"
}, kp = (e) => {
  e = Math.min(Math.round(e), 255);
  const t = Math.floor(e / 16), n = e % 16;
  return `${lE[t] || t}${lE[n] || n}`;
}, aE = function({ r: e, g: t, b: n }) {
  return Number.isNaN(+e) || Number.isNaN(+t) || Number.isNaN(+n) ? "" : `#${kp(e)}${kp(t)}${kp(n)}`;
}, am = {
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
}, Zs = function(e) {
  return e.length === 2 ? (am[e[0].toUpperCase()] || +e[0]) * 16 + (am[e[1].toUpperCase()] || +e[1]) : am[e[1].toUpperCase()] || +e[1];
}, QK = function(e, t, n) {
  t = t / 100, n = n / 100;
  let o = t;
  const l = Math.max(n, 0.01);
  n *= 2, t *= n <= 1 ? n : 2 - n, o *= l <= 1 ? l : 2 - l;
  const a = (n + t) / 2, r = n === 0 ? 2 * o / (l + o) : 2 * t / (n + t);
  return {
    h: e,
    s: r * 100,
    v: a * 100
  };
}, rE = (e, t, n) => {
  e = Tc(e, 255), t = Tc(t, 255), n = Tc(n, 255);
  const o = Math.max(e, t, n), l = Math.min(e, t, n);
  let a;
  const r = o, i = o - l, s = o === 0 ? 0 : i / o;
  if (o === l)
    a = 0;
  else {
    switch (o) {
      case e: {
        a = (t - n) / i + (t < n ? 6 : 0);
        break;
      }
      case t: {
        a = (n - e) / i + 2;
        break;
      }
      case n: {
        a = (e - t) / i + 4;
        break;
      }
    }
    a /= 6;
  }
  return { h: a * 360, s: s * 100, v: r * 100 };
}, Tu = function(e, t, n) {
  e = Tc(e, 360) * 6, t = Tc(t, 100), n = Tc(n, 100);
  const o = Math.floor(e), l = e - o, a = n * (1 - t), r = n * (1 - l * t), i = n * (1 - (1 - l) * t), s = o % 6, u = [n, r, a, a, i, n][s], d = [i, n, n, r, a, a][s], f = [a, a, i, n, n, r][s];
  return {
    r: Math.round(u * 255),
    g: Math.round(d * 255),
    b: Math.round(f * 255)
  };
};
class Qu {
  constructor(t = {}) {
    this._hue = 0, this._saturation = 100, this._value = 100, this._alpha = 100, this.enableAlpha = !1, this.format = "hex", this.value = "";
    for (const n in t)
      sl(t, n) && (this[n] = t[n]);
    t.value ? this.fromString(t.value) : this.doOnChange();
  }
  set(t, n) {
    if (arguments.length === 1 && typeof t == "object") {
      for (const o in t)
        sl(t, o) && this.set(o, t[o]);
      return;
    }
    this[`_${t}`] = n, this.doOnChange();
  }
  get(t) {
    return t === "alpha" ? Math.floor(this[`_${t}`]) : this[`_${t}`];
  }
  toRgb() {
    return Tu(this._hue, this._saturation, this._value);
  }
  fromString(t) {
    if (!t) {
      this._hue = 0, this._saturation = 100, this._value = 100, this.doOnChange();
      return;
    }
    const n = (o, l, a) => {
      this._hue = Math.max(0, Math.min(360, o)), this._saturation = Math.max(0, Math.min(100, l)), this._value = Math.max(0, Math.min(100, a)), this.doOnChange();
    };
    if (t.includes("hsl")) {
      const o = t.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter((l) => l !== "").map((l, a) => a > 2 ? Number.parseFloat(l) : Number.parseInt(l, 10));
      if (o.length === 4 ? this._alpha = Number.parseFloat(o[3]) * 100 : o.length === 3 && (this._alpha = 100), o.length >= 3) {
        const { h: l, s: a, v: r } = QK(o[0], o[1], o[2]);
        n(l, a, r);
      }
    } else if (t.includes("hsv")) {
      const o = t.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter((l) => l !== "").map((l, a) => a > 2 ? Number.parseFloat(l) : Number.parseInt(l, 10));
      o.length === 4 ? this._alpha = Number.parseFloat(o[3]) * 100 : o.length === 3 && (this._alpha = 100), o.length >= 3 && n(o[0], o[1], o[2]);
    } else if (t.includes("rgb")) {
      const o = t.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter((l) => l !== "").map((l, a) => a > 2 ? Number.parseFloat(l) : Number.parseInt(l, 10));
      if (o.length === 4 ? this._alpha = Number.parseFloat(o[3]) * 100 : o.length === 3 && (this._alpha = 100), o.length >= 3) {
        const { h: l, s: a, v: r } = rE(o[0], o[1], o[2]);
        n(l, a, r);
      }
    } else if (t.includes("#")) {
      const o = t.replace("#", "").trim();
      if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(o))
        return;
      let l, a, r;
      o.length === 3 ? (l = Zs(o[0] + o[0]), a = Zs(o[1] + o[1]), r = Zs(o[2] + o[2])) : (o.length === 6 || o.length === 8) && (l = Zs(o.slice(0, 2)), a = Zs(o.slice(2, 4)), r = Zs(o.slice(4, 6))), o.length === 8 ? this._alpha = Zs(o.slice(6)) / 255 * 100 : (o.length === 3 || o.length === 6) && (this._alpha = 100);
      const { h: i, s, v: u } = rE(l, a, r);
      n(i, s, u);
    }
  }
  compare(t) {
    return Math.abs(t._hue - this._hue) < 2 && Math.abs(t._saturation - this._saturation) < 1 && Math.abs(t._value - this._value) < 1 && Math.abs(t._alpha - this._alpha) < 1;
  }
  doOnChange() {
    const { _hue: t, _saturation: n, _value: o, _alpha: l, format: a } = this;
    if (this.enableAlpha)
      switch (a) {
        case "hsl": {
          const r = oE(t, n / 100, o / 100);
          this.value = `hsla(${t}, ${Math.round(r[1] * 100)}%, ${Math.round(r[2] * 100)}%, ${this.get("alpha") / 100})`;
          break;
        }
        case "hsv": {
          this.value = `hsva(${t}, ${Math.round(n)}%, ${Math.round(o)}%, ${this.get("alpha") / 100})`;
          break;
        }
        case "hex": {
          this.value = `${aE(Tu(t, n, o))}${kp(l * 255 / 100)}`;
          break;
        }
        default: {
          const { r, g: i, b: s } = Tu(t, n, o);
          this.value = `rgba(${r}, ${i}, ${s}, ${this.get("alpha") / 100})`;
        }
      }
    else
      switch (a) {
        case "hsl": {
          const r = oE(t, n / 100, o / 100);
          this.value = `hsl(${t}, ${Math.round(r[1] * 100)}%, ${Math.round(r[2] * 100)}%)`;
          break;
        }
        case "hsv": {
          this.value = `hsv(${t}, ${Math.round(n)}%, ${Math.round(o)}%)`;
          break;
        }
        case "rgb": {
          const { r, g: i, b: s } = Tu(t, n, o);
          this.value = `rgb(${r}, ${i}, ${s})`;
          break;
        }
        default:
          this.value = aE(Tu(t, n, o));
      }
  }
}
const eU = Q({
  props: {
    colors: {
      type: Array,
      required: !0
    },
    color: {
      type: Object,
      required: !0
    }
  },
  setup(e) {
    const t = nt("color-predefine"), { currentColor: n } = ot(o$), o = B(a(e.colors, e.color));
    Pe(() => n.value, (r) => {
      const i = new Qu();
      i.fromString(r), o.value.forEach((s) => {
        s.selected = i.compare(s);
      });
    }), ol(() => {
      o.value = a(e.colors, e.color);
    });
    function l(r) {
      e.color.fromString(e.colors[r]);
    }
    function a(r, i) {
      return r.map((s) => {
        const u = new Qu();
        return u.enableAlpha = !0, u.format = "rgba", u.fromString(s), u.selected = u.value === i.value, u;
      });
    }
    return {
      rgbaColors: o,
      handleSelect: l,
      ns: t
    };
  }
}), tU = ["onClick"];
function nU(e, t, n, o, l, a) {
  return M(), G("div", {
    class: z(e.ns.b())
  }, [
    X("div", {
      class: z(e.ns.e("colors"))
    }, [
      (M(!0), G(kt, null, ln(e.rgbaColors, (r, i) => (M(), G("div", {
        key: e.colors[i],
        class: z([
          e.ns.e("color-selector"),
          e.ns.is("alpha", r._alpha < 100),
          { selected: r.selected }
        ]),
        onClick: (s) => e.handleSelect(i)
      }, [
        X("div", {
          style: bt({ backgroundColor: r.value })
        }, null, 4)
      ], 10, tU))), 128))
    ], 2)
  ], 2);
}
var oU = /* @__PURE__ */ ut(eU, [["render", nU], ["__file", "predefine.vue"]]);
const lU = Q({
  name: "ElSlPanel",
  props: {
    color: {
      type: Object,
      required: !0
    }
  },
  setup(e) {
    const t = nt("color-svpanel"), n = Pt(), o = B(0), l = B(0), a = B("hsl(0, 100%, 50%)"), r = x(() => {
      const u = e.color.get("hue"), d = e.color.get("value");
      return { hue: u, value: d };
    });
    function i() {
      const u = e.color.get("saturation"), d = e.color.get("value"), f = n.vnode.el, { clientWidth: v, clientHeight: h } = f;
      l.value = u * v / 100, o.value = (100 - d) * h / 100, a.value = `hsl(${e.color.get("hue")}, 100%, 50%)`;
    }
    function s(u) {
      const f = n.vnode.el.getBoundingClientRect(), { clientX: v, clientY: h } = zb(u);
      let m = v - f.left, p = h - f.top;
      m = Math.max(0, m), m = Math.min(m, f.width), p = Math.max(0, p), p = Math.min(p, f.height), l.value = m, o.value = p, e.color.set({
        saturation: m / f.width * 100,
        value: 100 - p / f.height * 100
      });
    }
    return Pe(() => r.value, () => {
      i();
    }), Nt(() => {
      Pd(n.vnode.el, {
        drag: (u) => {
          s(u);
        },
        end: (u) => {
          s(u);
        }
      }), i();
    }), {
      cursorTop: o,
      cursorLeft: l,
      background: a,
      colorValue: r,
      handleDrag: s,
      update: i,
      ns: t
    };
  }
}), aU = /* @__PURE__ */ X("div", null, null, -1), rU = [
  aU
];
function sU(e, t, n, o, l, a) {
  return M(), G("div", {
    class: z(e.ns.b()),
    style: bt({
      backgroundColor: e.background
    })
  }, [
    X("div", {
      class: z(e.ns.e("white"))
    }, null, 2),
    X("div", {
      class: z(e.ns.e("black"))
    }, null, 2),
    X("div", {
      class: z(e.ns.e("cursor")),
      style: bt({
        top: e.cursorTop + "px",
        left: e.cursorLeft + "px"
      })
    }, rU, 6)
  ], 6);
}
var iU = /* @__PURE__ */ ut(lU, [["render", sU], ["__file", "sv-panel.vue"]]);
const cU = ["onKeydown"], uU = ["id", "aria-label", "aria-labelledby", "aria-description", "aria-disabled", "tabindex"], dU = Q({
  name: "ElColorPicker"
}), fU = /* @__PURE__ */ Q({
  ...dU,
  props: GK,
  emits: XK,
  setup(e, { expose: t, emit: n }) {
    const o = e, { t: l } = bn(), a = nt("color"), { formItem: r } = ml(), i = Mo(), s = Nl(), { inputId: u, isLabeledByFormItem: d } = Wa(o, {
      formItemContext: r
    }), f = B(), v = B(), h = B(), m = B(), p = B(), C = B(), {
      isFocused: g,
      handleFocus: w,
      handleBlur: b
    } = Bv(p, {
      beforeBlur(ie) {
        var he;
        return (he = m.value) == null ? void 0 : he.isFocusInsideContent(ie);
      },
      afterBlur() {
        A(!1), F();
      }
    }), y = (ie) => {
      if (s.value)
        return ve();
      w(ie);
    };
    let E = !0;
    const S = en(new Qu({
      enableAlpha: o.showAlpha,
      format: o.colorFormat || "",
      value: o.modelValue
    })), _ = B(!1), k = B(!1), N = B(""), L = x(() => !o.modelValue && !k.value ? "transparent" : W(S, o.showAlpha)), R = x(() => !o.modelValue && !k.value ? "" : S.value), H = x(() => d.value ? void 0 : o.label || o.ariaLabel || l("el.colorpicker.defaultLabel"));
    Ho({
      from: "label",
      replacement: "aria-label",
      version: "2.8.0",
      scope: "el-color-picker",
      ref: "https://element-plus.org/en-US/component/color-picker.html"
    }, x(() => !!o.label));
    const K = x(() => d.value ? r == null ? void 0 : r.labelId : void 0), U = x(() => [
      a.b("picker"),
      a.is("disabled", s.value),
      a.bm("picker", i.value),
      a.is("focused", g.value)
    ]);
    function W(ie, he) {
      if (!(ie instanceof Qu))
        throw new TypeError("color should be instance of _color Class");
      const { r: De, g: $e, b: ue } = ie.toRgb();
      return he ? `rgba(${De}, ${$e}, ${ue}, ${ie.get("alpha") / 100})` : `rgb(${De}, ${$e}, ${ue})`;
    }
    function A(ie) {
      _.value = ie;
    }
    const $ = Hl(A, 100, { leading: !0 });
    function D() {
      s.value || A(!0);
    }
    function O() {
      $(!1), F();
    }
    function F() {
      xe(() => {
        o.modelValue ? S.fromString(o.modelValue) : (S.value = "", xe(() => {
          k.value = !1;
        }));
      });
    }
    function j() {
      s.value || $(!_.value);
    }
    function Z() {
      S.fromString(N.value);
    }
    function te() {
      const ie = S.value;
      n(Jt, ie), n("change", ie), o.validateEvent && (r == null || r.validate("change").catch((he) => dn(he))), $(!1), xe(() => {
        const he = new Qu({
          enableAlpha: o.showAlpha,
          format: o.colorFormat || "",
          value: o.modelValue
        });
        S.compare(he) || F();
      });
    }
    function de() {
      $(!1), n(Jt, null), n("change", null), o.modelValue !== null && o.validateEvent && (r == null || r.validate("change").catch((ie) => dn(ie))), F();
    }
    function Oe(ie) {
      if (_.value && (O(), g.value)) {
        const he = new FocusEvent("focus", ie);
        b(he);
      }
    }
    function ce(ie) {
      ie.preventDefault(), ie.stopPropagation(), A(!1), F();
    }
    function ne(ie) {
      switch (ie.code) {
        case xt.enter:
        case xt.space:
          ie.preventDefault(), ie.stopPropagation(), D(), C.value.focus();
          break;
        case xt.esc:
          ce(ie);
          break;
      }
    }
    function Y() {
      p.value.focus();
    }
    function ve() {
      p.value.blur();
    }
    return Nt(() => {
      o.modelValue && (N.value = R.value);
    }), Pe(() => o.modelValue, (ie) => {
      ie ? ie && ie !== S.value && (E = !1, S.fromString(ie)) : k.value = !1;
    }), Pe(() => R.value, (ie) => {
      N.value = ie, E && n("activeChange", ie), E = !0;
    }), Pe(() => S.value, () => {
      !o.modelValue && !k.value && (k.value = !0);
    }), Pe(() => _.value, () => {
      xe(() => {
        var ie, he, De;
        (ie = f.value) == null || ie.update(), (he = v.value) == null || he.update(), (De = h.value) == null || De.update();
      });
    }), Mt(o$, {
      currentColor: R
    }), t({
      color: S,
      show: D,
      hide: O,
      focus: Y,
      blur: ve
    }), (ie, he) => (M(), We(c(hl), {
      ref_key: "popper",
      ref: m,
      visible: _.value,
      "show-arrow": !1,
      "fallback-placements": ["bottom", "top", "right", "left"],
      offset: 0,
      "gpu-acceleration": !1,
      "popper-class": [c(a).be("picker", "panel"), c(a).b("dropdown"), ie.popperClass],
      "stop-popper-mouse-event": !1,
      effect: "light",
      trigger: "click",
      teleported: ie.teleported,
      transition: `${c(a).namespace.value}-zoom-in-top`,
      persistent: "",
      onHide: he[2] || (he[2] = (De) => A(!1))
    }, {
      content: fe(() => [
        Bt((M(), G("div", {
          onKeydown: Rn(ce, ["esc"])
        }, [
          X("div", {
            class: z(c(a).be("dropdown", "main-wrapper"))
          }, [
            oe(YK, {
              ref_key: "hue",
              ref: f,
              class: "hue-slider",
              color: c(S),
              vertical: ""
            }, null, 8, ["color"]),
            oe(iU, {
              ref_key: "sv",
              ref: v,
              color: c(S)
            }, null, 8, ["color"])
          ], 2),
          ie.showAlpha ? (M(), We(UK, {
            key: 0,
            ref_key: "alpha",
            ref: h,
            color: c(S)
          }, null, 8, ["color"])) : _e("v-if", !0),
          ie.predefine ? (M(), We(oU, {
            key: 1,
            ref: "predefine",
            color: c(S),
            colors: ie.predefine
          }, null, 8, ["color", "colors"])) : _e("v-if", !0),
          X("div", {
            class: z(c(a).be("dropdown", "btns"))
          }, [
            X("span", {
              class: z(c(a).be("dropdown", "value"))
            }, [
              oe(c(nl), {
                ref_key: "inputRef",
                ref: C,
                modelValue: N.value,
                "onUpdate:modelValue": he[0] || (he[0] = (De) => N.value = De),
                "validate-event": !1,
                size: "small",
                onKeyup: Rn(Z, ["enter"]),
                onBlur: Z
              }, null, 8, ["modelValue", "onKeyup"])
            ], 2),
            oe(c(Do), {
              class: z(c(a).be("dropdown", "link-btn")),
              text: "",
              size: "small",
              onClick: de
            }, {
              default: fe(() => [
                Ut(Qe(c(l)("el.colorpicker.clear")), 1)
              ]),
              _: 1
            }, 8, ["class"]),
            oe(c(Do), {
              plain: "",
              size: "small",
              class: z(c(a).be("dropdown", "btn")),
              onClick: te
            }, {
              default: fe(() => [
                Ut(Qe(c(l)("el.colorpicker.confirm")), 1)
              ]),
              _: 1
            }, 8, ["class"])
          ], 2)
        ], 40, cU)), [
          [c(Pr), Oe]
        ])
      ]),
      default: fe(() => [
        X("div", {
          id: c(u),
          ref_key: "triggerRef",
          ref: p,
          class: z(c(U)),
          role: "button",
          "aria-label": c(H),
          "aria-labelledby": c(K),
          "aria-description": c(l)("el.colorpicker.description", { color: ie.modelValue || "" }),
          "aria-disabled": c(s),
          tabindex: c(s) ? -1 : ie.tabindex,
          onKeydown: ne,
          onFocus: y,
          onBlur: he[1] || (he[1] = (...De) => c(b) && c(b)(...De))
        }, [
          c(s) ? (M(), G("div", {
            key: 0,
            class: z(c(a).be("picker", "mask"))
          }, null, 2)) : _e("v-if", !0),
          X("div", {
            class: z(c(a).be("picker", "trigger")),
            onClick: j
          }, [
            X("span", {
              class: z([c(a).be("picker", "color"), c(a).is("alpha", ie.showAlpha)])
            }, [
              X("span", {
                class: z(c(a).be("picker", "color-inner")),
                style: bt({
                  backgroundColor: c(L)
                })
              }, [
                Bt(oe(c(Ct), {
                  class: z([c(a).be("picker", "icon"), c(a).is("icon-arrow-down")])
                }, {
                  default: fe(() => [
                    oe(c(Br))
                  ]),
                  _: 1
                }, 8, ["class"]), [
                  [pn, ie.modelValue || k.value]
                ]),
                Bt(oe(c(Ct), {
                  class: z([c(a).be("picker", "empty"), c(a).is("icon-close")])
                }, {
                  default: fe(() => [
                    oe(c(Fa))
                  ]),
                  _: 1
                }, 8, ["class"]), [
                  [pn, !ie.modelValue && !k.value]
                ])
              ], 6)
            ], 2)
          ], 2)
        ], 42, uU)
      ]),
      _: 1
    }, 8, ["visible", "popper-class", "teleported", "transition"]));
  }
});
var pU = /* @__PURE__ */ ut(fU, [["__file", "color-picker.vue"]]);
const vU = Yt(pU), hU = Q({
  name: "ElContainer"
}), mU = /* @__PURE__ */ Q({
  ...hU,
  props: {
    direction: {
      type: String
    }
  },
  setup(e) {
    const t = e, n = Yn(), o = nt("container"), l = x(() => t.direction === "vertical" ? !0 : t.direction === "horizontal" ? !1 : n && n.default ? n.default().some((r) => {
      const i = r.type.name;
      return i === "ElHeader" || i === "ElFooter";
    }) : !1);
    return (a, r) => (M(), G("section", {
      class: z([c(o).b(), c(o).is("vertical", c(l))])
    }, [
      Ie(a.$slots, "default")
    ], 2));
  }
});
var gU = /* @__PURE__ */ ut(mU, [["__file", "container.vue"]]);
const bU = Q({
  name: "ElAside"
}), yU = /* @__PURE__ */ Q({
  ...bU,
  props: {
    width: {
      type: String,
      default: null
    }
  },
  setup(e) {
    const t = e, n = nt("aside"), o = x(() => t.width ? n.cssVarBlock({ width: t.width }) : {});
    return (l, a) => (M(), G("aside", {
      class: z(c(n).b()),
      style: bt(c(o))
    }, [
      Ie(l.$slots, "default")
    ], 6));
  }
});
var l$ = /* @__PURE__ */ ut(yU, [["__file", "aside.vue"]]);
const CU = Q({
  name: "ElFooter"
}), wU = /* @__PURE__ */ Q({
  ...CU,
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(e) {
    const t = e, n = nt("footer"), o = x(() => t.height ? n.cssVarBlock({ height: t.height }) : {});
    return (l, a) => (M(), G("footer", {
      class: z(c(n).b()),
      style: bt(c(o))
    }, [
      Ie(l.$slots, "default")
    ], 6));
  }
});
var a$ = /* @__PURE__ */ ut(wU, [["__file", "footer.vue"]]);
const EU = Q({
  name: "ElHeader"
}), SU = /* @__PURE__ */ Q({
  ...EU,
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(e) {
    const t = e, n = nt("header"), o = x(() => t.height ? n.cssVarBlock({
      height: t.height
    }) : {});
    return (l, a) => (M(), G("header", {
      class: z(c(n).b()),
      style: bt(c(o))
    }, [
      Ie(l.$slots, "default")
    ], 6));
  }
});
var r$ = /* @__PURE__ */ ut(SU, [["__file", "header.vue"]]);
const _U = Q({
  name: "ElMain"
}), xU = /* @__PURE__ */ Q({
  ..._U,
  setup(e) {
    const t = nt("main");
    return (n, o) => (M(), G("main", {
      class: z(c(t).b())
    }, [
      Ie(n.$slots, "default")
    ], 2));
  }
});
var s$ = /* @__PURE__ */ ut(xU, [["__file", "main.vue"]]);
const kU = Yt(gU, {
  Aside: l$,
  Footer: a$,
  Header: r$,
  Main: s$
}), TU = Jn(l$), $U = Jn(a$), OU = Jn(r$), NU = Jn(s$);
var i$ = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Wr, function() {
    return function(n, o) {
      var l = o.prototype, a = l.format;
      l.format = function(r) {
        var i = this, s = this.$locale();
        if (!this.isValid())
          return a.bind(this)(r);
        var u = this.$utils(), d = (r || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(f) {
          switch (f) {
            case "Q":
              return Math.ceil((i.$M + 1) / 3);
            case "Do":
              return s.ordinal(i.$D);
            case "gggg":
              return i.weekYear();
            case "GGGG":
              return i.isoWeekYear();
            case "wo":
              return s.ordinal(i.week(), "W");
            case "w":
            case "ww":
              return u.s(i.week(), f === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return u.s(i.isoWeek(), f === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return u.s(String(i.$H === 0 ? 24 : i.$H), f === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(i.$d.getTime() / 1e3);
            case "x":
              return i.$d.getTime();
            case "z":
              return "[" + i.offsetName() + "]";
            case "zzz":
              return "[" + i.offsetName("long") + "]";
            default:
              return f;
          }
        });
        return a.bind(this)(d);
      };
    };
  });
})(i$);
var MU = i$.exports;
const IU = /* @__PURE__ */ pr(MU);
var c$ = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Wr, function() {
    var n = "week", o = "year";
    return function(l, a, r) {
      var i = a.prototype;
      i.week = function(s) {
        if (s === void 0 && (s = null), s !== null)
          return this.add(7 * (s - this.week()), "day");
        var u = this.$locale().yearStart || 1;
        if (this.month() === 11 && this.date() > 25) {
          var d = r(this).startOf(o).add(1, o).date(u), f = r(this).endOf(n);
          if (d.isBefore(f))
            return 1;
        }
        var v = r(this).startOf(o).date(u).startOf(n).subtract(1, "millisecond"), h = this.diff(v, n, !0);
        return h < 0 ? r(this).startOf("week").week() : Math.ceil(h);
      }, i.weeks = function(s) {
        return s === void 0 && (s = null), this.week(s);
      };
    };
  });
})(c$);
var RU = c$.exports;
const DU = /* @__PURE__ */ pr(RU);
var u$ = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Wr, function() {
    return function(n, o) {
      o.prototype.weekYear = function() {
        var l = this.month(), a = this.week(), r = this.year();
        return a === 1 && l === 11 ? r + 1 : l === 0 && a >= 52 ? r - 1 : r;
      };
    };
  });
})(u$);
var LU = u$.exports;
const PU = /* @__PURE__ */ pr(LU);
var d$ = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Wr, function() {
    return function(n, o, l) {
      o.prototype.dayOfYear = function(a) {
        var r = Math.round((l(this).startOf("day") - l(this).startOf("year")) / 864e5) + 1;
        return a == null ? r : this.add(a - r, "day");
      };
    };
  });
})(d$);
var AU = d$.exports;
const FU = /* @__PURE__ */ pr(AU);
var f$ = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Wr, function() {
    return function(n, o) {
      o.prototype.isSameOrAfter = function(l, a) {
        return this.isSame(l, a) || this.isAfter(l, a);
      };
    };
  });
})(f$);
var VU = f$.exports;
const BU = /* @__PURE__ */ pr(VU);
var p$ = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Wr, function() {
    return function(n, o) {
      o.prototype.isSameOrBefore = function(l, a) {
        return this.isSame(l, a) || this.isBefore(l, a);
      };
    };
  });
})(p$);
var HU = p$.exports;
const zU = /* @__PURE__ */ pr(HU), Yy = Symbol(), WU = it({
  ...Ky,
  type: {
    type: Ae(String),
    default: "date"
  }
}), KU = [
  "date",
  "dates",
  "year",
  "years",
  "month",
  "week",
  "range"
], Gy = it({
  disabledDate: {
    type: Ae(Function)
  },
  date: {
    type: Ae(Object),
    required: !0
  },
  minDate: {
    type: Ae(Object)
  },
  maxDate: {
    type: Ae(Object)
  },
  parsedValue: {
    type: Ae([Object, Array])
  },
  rangeState: {
    type: Ae(Object),
    default: () => ({
      endDate: null,
      selecting: !1
    })
  }
}), v$ = it({
  type: {
    type: Ae(String),
    required: !0,
    values: iV
  },
  dateFormat: String,
  timeFormat: String
}), h$ = it({
  unlinkPanels: Boolean,
  parsedValue: {
    type: Ae(Array)
  }
}), Xy = (e) => ({
  type: String,
  values: KU,
  default: e
}), UU = it({
  ...v$,
  parsedValue: {
    type: Ae([Object, Array])
  },
  visible: {
    type: Boolean
  },
  format: {
    type: String,
    default: ""
  }
}), jU = it({
  ...Gy,
  cellClassName: {
    type: Ae(Function)
  },
  showWeekNumber: Boolean,
  selectionMode: Xy("date")
}), qU = ["changerange", "pick", "select"], Vg = (e) => {
  if (!Kt(e))
    return !1;
  const [t, n] = e;
  return Gt.isDayjs(t) && Gt.isDayjs(n) && t.isSameOrBefore(n);
}, m$ = (e, { lang: t, unit: n, unlinkPanels: o }) => {
  let l;
  if (Kt(e)) {
    let [a, r] = e.map((i) => Gt(i).locale(t));
    return o || (r = a.add(1, n)), [a, r];
  } else
    e ? l = Gt(e) : l = Gt();
  return l = l.locale(t), [l, l.add(1, n)];
}, YU = (e, t, {
  columnIndexOffset: n,
  startDate: o,
  nextEndDate: l,
  now: a,
  unit: r,
  relativeDateGetter: i,
  setCellMetadata: s,
  setRowMetadata: u
}) => {
  for (let d = 0; d < e.row; d++) {
    const f = t[d];
    for (let v = 0; v < e.column; v++) {
      let h = f[v + n];
      h || (h = {
        row: d,
        column: v,
        type: "normal",
        inRange: !1,
        start: !1,
        end: !1
      });
      const m = d * e.column + v, p = i(m);
      h.dayjs = p, h.date = p.toDate(), h.timestamp = p.valueOf(), h.type = "normal", h.inRange = !!(o && p.isSameOrAfter(o, r) && l && p.isSameOrBefore(l, r)) || !!(o && p.isSameOrBefore(o, r) && l && p.isSameOrAfter(l, r)), o != null && o.isSameOrAfter(l) ? (h.start = !!l && p.isSame(l, r), h.end = o && p.isSame(o, r)) : (h.start = !!o && p.isSame(o, r), h.end = !!l && p.isSame(l, r)), p.isSame(a, r) && (h.type = "today"), s == null || s(h, { rowIndex: d, columnIndex: v }), f[v + n] = h;
    }
    u == null || u(f);
  }
}, Bg = (e = "") => ["normal", "today"].includes(e), GU = (e, t) => {
  const { lang: n } = bn(), o = B(), l = B(), a = B(), r = B(), i = B([[], [], [], [], [], []]);
  let s = !1;
  const u = e.date.$locale().weekStart || 7, d = e.date.locale("en").localeData().weekdaysShort().map((O) => O.toLowerCase()), f = x(() => u > 3 ? 7 - u : -u), v = x(() => {
    const O = e.date.startOf("month");
    return O.subtract(O.day() || 7, "day");
  }), h = x(() => d.concat(d).slice(u, u + 7)), m = x(() => mx(c(y)).some((O) => O.isCurrent)), p = x(() => {
    const O = e.date.startOf("month"), F = O.day() || 7, j = O.daysInMonth(), Z = O.subtract(1, "month").daysInMonth();
    return {
      startOfMonthDay: F,
      dateCountOfMonth: j,
      dateCountOfLastMonth: Z
    };
  }), C = x(() => e.selectionMode === "dates" ? Gl(e.parsedValue) : []), g = (O, { count: F, rowIndex: j, columnIndex: Z }) => {
    const { startOfMonthDay: te, dateCountOfMonth: de, dateCountOfLastMonth: Oe } = c(p), ce = c(f);
    if (j >= 0 && j <= 1) {
      const ne = te + ce < 0 ? 7 + te + ce : te + ce;
      if (Z + j * 7 >= ne)
        return O.text = F, !0;
      O.text = Oe - (ne - Z % 7) + 1 + j * 7, O.type = "prev-month";
    } else
      return F <= de ? O.text = F : (O.text = F - de, O.type = "next-month"), !0;
    return !1;
  }, w = (O, { columnIndex: F, rowIndex: j }, Z) => {
    const { disabledDate: te, cellClassName: de } = e, Oe = c(C), ce = g(O, { count: Z, rowIndex: j, columnIndex: F }), ne = O.dayjs.toDate();
    return O.selected = Oe.find((Y) => Y.isSame(O.dayjs, "day")), O.isSelected = !!O.selected, O.isCurrent = S(O), O.disabled = te == null ? void 0 : te(ne), O.customClass = de == null ? void 0 : de(ne), ce;
  }, b = (O) => {
    if (e.selectionMode === "week") {
      const [F, j] = e.showWeekNumber ? [1, 7] : [0, 6], Z = D(O[F + 1]);
      O[F].inRange = Z, O[F].start = Z, O[j].inRange = Z, O[j].end = Z;
    }
  }, y = x(() => {
    const { minDate: O, maxDate: F, rangeState: j, showWeekNumber: Z } = e, te = c(f), de = c(i), Oe = "day";
    let ce = 1;
    if (Z)
      for (let ne = 0; ne < 6; ne++)
        de[ne][0] || (de[ne][0] = {
          type: "week",
          text: c(v).add(ne * 7 + 1, Oe).week()
        });
    return YU({ row: 6, column: 7 }, de, {
      startDate: O,
      columnIndexOffset: Z ? 1 : 0,
      nextEndDate: j.endDate || F || j.selecting && O || null,
      now: Gt().locale(c(n)).startOf(Oe),
      unit: Oe,
      relativeDateGetter: (ne) => c(v).add(ne - te, Oe),
      setCellMetadata: (...ne) => {
        w(...ne, ce) && (ce += 1);
      },
      setRowMetadata: b
    }), de;
  });
  Pe(() => e.date, async () => {
    var O;
    (O = c(o)) != null && O.contains(document.activeElement) && (await xe(), await E());
  });
  const E = async () => {
    var O;
    return (O = c(l)) == null ? void 0 : O.focus();
  }, S = (O) => e.selectionMode === "date" && Bg(O.type) && _(O, e.parsedValue), _ = (O, F) => F ? Gt(F).locale(c(n)).isSame(e.date.date(Number(O.text)), "day") : !1, k = (O, F) => {
    const j = O * 7 + (F - (e.showWeekNumber ? 1 : 0)) - c(f);
    return c(v).add(j, "day");
  }, N = (O) => {
    var F;
    if (!e.rangeState.selecting)
      return;
    let j = O.target;
    if (j.tagName === "SPAN" && (j = (F = j.parentNode) == null ? void 0 : F.parentNode), j.tagName === "DIV" && (j = j.parentNode), j.tagName !== "TD")
      return;
    const Z = j.parentNode.rowIndex - 1, te = j.cellIndex;
    c(y)[Z][te].disabled || (Z !== c(a) || te !== c(r)) && (a.value = Z, r.value = te, t("changerange", {
      selecting: !0,
      endDate: k(Z, te)
    }));
  }, L = (O) => !c(m) && (O == null ? void 0 : O.text) === 1 && O.type === "normal" || O.isCurrent, R = (O) => {
    s || c(m) || e.selectionMode !== "date" || $(O, !0);
  }, H = (O) => {
    O.target.closest("td") && (s = !0);
  }, K = (O) => {
    O.target.closest("td") && (s = !1);
  }, U = (O) => {
    !e.rangeState.selecting || !e.minDate ? (t("pick", { minDate: O, maxDate: null }), t("select", !0)) : (O >= e.minDate ? t("pick", { minDate: e.minDate, maxDate: O }) : t("pick", { minDate: O, maxDate: e.minDate }), t("select", !1));
  }, W = (O) => {
    const F = O.week(), j = `${O.year()}w${F}`;
    t("pick", {
      year: O.year(),
      week: F,
      value: j,
      date: O.startOf("week")
    });
  }, A = (O, F) => {
    const j = F ? Gl(e.parsedValue).filter((Z) => (Z == null ? void 0 : Z.valueOf()) !== O.valueOf()) : Gl(e.parsedValue).concat([O]);
    t("pick", j);
  }, $ = (O, F = !1) => {
    const j = O.target.closest("td");
    if (!j)
      return;
    const Z = j.parentNode.rowIndex - 1, te = j.cellIndex, de = c(y)[Z][te];
    if (de.disabled || de.type === "week")
      return;
    const Oe = k(Z, te);
    switch (e.selectionMode) {
      case "range": {
        U(Oe);
        break;
      }
      case "date": {
        t("pick", Oe, F);
        break;
      }
      case "week": {
        W(Oe);
        break;
      }
      case "dates": {
        A(Oe, !!de.selected);
        break;
      }
    }
  }, D = (O) => {
    if (e.selectionMode !== "week")
      return !1;
    let F = e.date.startOf("day");
    if (O.type === "prev-month" && (F = F.subtract(1, "month")), O.type === "next-month" && (F = F.add(1, "month")), F = F.date(Number.parseInt(O.text, 10)), e.parsedValue && !Array.isArray(e.parsedValue)) {
      const j = (e.parsedValue.day() - u + 7) % 7 - 1;
      return e.parsedValue.subtract(j, "day").isSame(F, "day");
    }
    return !1;
  };
  return {
    WEEKS: h,
    rows: y,
    tbodyRef: o,
    currentCellRef: l,
    focus: E,
    isCurrent: S,
    isWeekActive: D,
    isSelectedCell: L,
    handlePickDate: $,
    handleMouseUp: K,
    handleMouseDown: H,
    handleMouseMove: N,
    handleFocus: R
  };
}, XU = (e, {
  isCurrent: t,
  isWeekActive: n
}) => {
  const o = nt("date-table"), { t: l } = bn(), a = x(() => [
    o.b(),
    { "is-week-mode": e.selectionMode === "week" }
  ]), r = x(() => l("el.datepicker.dateTablePrompt")), i = x(() => l("el.datepicker.week"));
  return {
    tableKls: a,
    tableLabel: r,
    weekLabel: i,
    getCellClasses: (d) => {
      const f = [];
      return Bg(d.type) && !d.disabled ? (f.push("available"), d.type === "today" && f.push("today")) : f.push(d.type), t(d) && f.push("current"), d.inRange && (Bg(d.type) || e.selectionMode === "week") && (f.push("in-range"), d.start && f.push("start-date"), d.end && f.push("end-date")), d.disabled && f.push("disabled"), d.selected && f.push("selected"), d.customClass && f.push(d.customClass), f.join(" ");
    },
    getRowKls: (d) => [
      o.e("row"),
      { current: n(d) }
    ],
    t: l
  };
}, ZU = it({
  cell: {
    type: Ae(Object)
  }
});
var JU = Q({
  name: "ElDatePickerCell",
  props: ZU,
  setup(e) {
    const t = nt("date-table-cell"), {
      slots: n
    } = ot(Yy);
    return () => {
      const {
        cell: o
      } = e;
      return Ie(n, "default", {
        ...o
      }, () => [oe("div", {
        class: t.b()
      }, [oe("span", {
        class: t.e("text")
      }, [o == null ? void 0 : o.text])])]);
    };
  }
});
const QU = ["aria-label"], ej = {
  key: 0,
  scope: "col"
}, tj = ["aria-label"], nj = ["aria-current", "aria-selected", "tabindex"], oj = /* @__PURE__ */ Q({
  __name: "basic-date-table",
  props: jU,
  emits: qU,
  setup(e, { expose: t, emit: n }) {
    const o = e, {
      WEEKS: l,
      rows: a,
      tbodyRef: r,
      currentCellRef: i,
      focus: s,
      isCurrent: u,
      isWeekActive: d,
      isSelectedCell: f,
      handlePickDate: v,
      handleMouseUp: h,
      handleMouseDown: m,
      handleMouseMove: p,
      handleFocus: C
    } = GU(o, n), { tableLabel: g, tableKls: w, weekLabel: b, getCellClasses: y, getRowKls: E, t: S } = XU(o, {
      isCurrent: u,
      isWeekActive: d
    });
    return t({
      focus: s
    }), (_, k) => (M(), G("table", {
      "aria-label": c(g),
      class: z(c(w)),
      cellspacing: "0",
      cellpadding: "0",
      role: "grid",
      onClick: k[1] || (k[1] = (...N) => c(v) && c(v)(...N)),
      onMousemove: k[2] || (k[2] = (...N) => c(p) && c(p)(...N)),
      onMousedown: k[3] || (k[3] = It((...N) => c(m) && c(m)(...N), ["prevent"])),
      onMouseup: k[4] || (k[4] = (...N) => c(h) && c(h)(...N))
    }, [
      X("tbody", {
        ref_key: "tbodyRef",
        ref: r
      }, [
        X("tr", null, [
          _.showWeekNumber ? (M(), G("th", ej, Qe(c(b)), 1)) : _e("v-if", !0),
          (M(!0), G(kt, null, ln(c(l), (N, L) => (M(), G("th", {
            key: L,
            "aria-label": c(S)("el.datepicker.weeksFull." + N),
            scope: "col"
          }, Qe(c(S)("el.datepicker.weeks." + N)), 9, tj))), 128))
        ]),
        (M(!0), G(kt, null, ln(c(a), (N, L) => (M(), G("tr", {
          key: L,
          class: z(c(E)(N[1]))
        }, [
          (M(!0), G(kt, null, ln(N, (R, H) => (M(), G("td", {
            key: `${L}.${H}`,
            ref_for: !0,
            ref: (K) => c(f)(R) && (i.value = K),
            class: z(c(y)(R)),
            "aria-current": R.isCurrent ? "date" : void 0,
            "aria-selected": R.isCurrent,
            tabindex: c(f)(R) ? 0 : -1,
            onFocus: k[0] || (k[0] = (...K) => c(C) && c(C)(...K))
          }, [
            oe(c(JU), { cell: R }, null, 8, ["cell"])
          ], 42, nj))), 128))
        ], 2))), 128))
      ], 512)
    ], 42, QU));
  }
});
var Hg = /* @__PURE__ */ ut(oj, [["__file", "basic-date-table.vue"]]);
const lj = it({
  ...Gy,
  selectionMode: Xy("month")
}), aj = ["aria-label"], rj = ["aria-selected", "aria-label", "tabindex", "onKeydown"], sj = { class: "cell" }, ij = /* @__PURE__ */ Q({
  __name: "basic-month-table",
  props: lj,
  emits: ["changerange", "pick", "select"],
  setup(e, { expose: t, emit: n }) {
    const o = e, l = (y, E, S) => {
      const _ = Gt().locale(S).startOf("month").month(E).year(y), k = _.daysInMonth();
      return ys(k).map((N) => _.add(N, "day").toDate());
    }, a = nt("month-table"), { t: r, lang: i } = bn(), s = B(), u = B(), d = B(o.date.locale("en").localeData().monthsShort().map((y) => y.toLowerCase())), f = B([
      [],
      [],
      []
    ]), v = B(), h = B(), m = x(() => {
      var y, E;
      const S = f.value, _ = Gt().locale(i.value).startOf("month");
      for (let k = 0; k < 3; k++) {
        const N = S[k];
        for (let L = 0; L < 4; L++) {
          const R = N[L] || (N[L] = {
            row: k,
            column: L,
            type: "normal",
            inRange: !1,
            start: !1,
            end: !1,
            text: -1,
            disabled: !1
          });
          R.type = "normal";
          const H = k * 4 + L, K = o.date.startOf("year").month(H), U = o.rangeState.endDate || o.maxDate || o.rangeState.selecting && o.minDate || null;
          R.inRange = !!(o.minDate && K.isSameOrAfter(o.minDate, "month") && U && K.isSameOrBefore(U, "month")) || !!(o.minDate && K.isSameOrBefore(o.minDate, "month") && U && K.isSameOrAfter(U, "month")), (y = o.minDate) != null && y.isSameOrAfter(U) ? (R.start = !!(U && K.isSame(U, "month")), R.end = o.minDate && K.isSame(o.minDate, "month")) : (R.start = !!(o.minDate && K.isSame(o.minDate, "month")), R.end = !!(U && K.isSame(U, "month"))), _.isSame(K) && (R.type = "today"), R.text = H, R.disabled = ((E = o.disabledDate) == null ? void 0 : E.call(o, K.toDate())) || !1;
        }
      }
      return S;
    }), p = () => {
      var y;
      (y = u.value) == null || y.focus();
    }, C = (y) => {
      const E = {}, S = o.date.year(), _ = /* @__PURE__ */ new Date(), k = y.text;
      return E.disabled = o.disabledDate ? l(S, k, i.value).every(o.disabledDate) : !1, E.current = Gl(o.parsedValue).findIndex((N) => Gt.isDayjs(N) && N.year() === S && N.month() === k) >= 0, E.today = _.getFullYear() === S && _.getMonth() === k, y.inRange && (E["in-range"] = !0, y.start && (E["start-date"] = !0), y.end && (E["end-date"] = !0)), E;
    }, g = (y) => {
      const E = o.date.year(), S = y.text;
      return Gl(o.date).findIndex((_) => _.year() === E && _.month() === S) >= 0;
    }, w = (y) => {
      var E;
      if (!o.rangeState.selecting)
        return;
      let S = y.target;
      if (S.tagName === "SPAN" && (S = (E = S.parentNode) == null ? void 0 : E.parentNode), S.tagName === "DIV" && (S = S.parentNode), S.tagName !== "TD")
        return;
      const _ = S.parentNode.rowIndex, k = S.cellIndex;
      m.value[_][k].disabled || (_ !== v.value || k !== h.value) && (v.value = _, h.value = k, n("changerange", {
        selecting: !0,
        endDate: o.date.startOf("year").month(_ * 4 + k)
      }));
    }, b = (y) => {
      var E;
      const S = (E = y.target) == null ? void 0 : E.closest("td");
      if ((S == null ? void 0 : S.tagName) !== "TD" || ba(S, "disabled"))
        return;
      const _ = S.cellIndex, N = S.parentNode.rowIndex * 4 + _, L = o.date.startOf("year").month(N);
      o.selectionMode === "range" ? o.rangeState.selecting ? (o.minDate && L >= o.minDate ? n("pick", { minDate: o.minDate, maxDate: L }) : n("pick", { minDate: L, maxDate: o.minDate }), n("select", !1)) : (n("pick", { minDate: L, maxDate: null }), n("select", !0)) : n("pick", N);
    };
    return Pe(() => o.date, async () => {
      var y, E;
      (y = s.value) != null && y.contains(document.activeElement) && (await xe(), (E = u.value) == null || E.focus());
    }), t({
      focus: p
    }), (y, E) => (M(), G("table", {
      role: "grid",
      "aria-label": c(r)("el.datepicker.monthTablePrompt"),
      class: z(c(a).b()),
      onClick: b,
      onMousemove: w
    }, [
      X("tbody", {
        ref_key: "tbodyRef",
        ref: s
      }, [
        (M(!0), G(kt, null, ln(c(m), (S, _) => (M(), G("tr", { key: _ }, [
          (M(!0), G(kt, null, ln(S, (k, N) => (M(), G("td", {
            key: N,
            ref_for: !0,
            ref: (L) => g(k) && (u.value = L),
            class: z(C(k)),
            "aria-selected": `${g(k)}`,
            "aria-label": c(r)(`el.datepicker.month${+k.text + 1}`),
            tabindex: g(k) ? 0 : -1,
            onKeydown: [
              Rn(It(b, ["prevent", "stop"]), ["space"]),
              Rn(It(b, ["prevent", "stop"]), ["enter"])
            ]
          }, [
            X("div", null, [
              X("span", sj, Qe(c(r)("el.datepicker.months." + d.value[k.text])), 1)
            ])
          ], 42, rj))), 128))
        ]))), 128))
      ], 512)
    ], 42, aj));
  }
});
var zg = /* @__PURE__ */ ut(ij, [["__file", "basic-month-table.vue"]]);
const { date: cj, disabledDate: uj, parsedValue: dj } = Gy, fj = it({
  date: cj,
  disabledDate: uj,
  parsedValue: dj,
  selectionMode: Xy("year")
}), pj = ["aria-label"], vj = ["aria-selected", "tabindex", "onKeydown"], hj = { class: "cell" }, mj = { key: 1 }, gj = /* @__PURE__ */ Q({
  __name: "basic-year-table",
  props: fj,
  emits: ["pick"],
  setup(e, { expose: t, emit: n }) {
    const o = e, l = (p, C) => {
      const g = Gt(String(p)).locale(C).startOf("year"), b = g.endOf("year").dayOfYear();
      return ys(b).map((y) => g.add(y, "day").toDate());
    }, a = nt("year-table"), { t: r, lang: i } = bn(), s = B(), u = B(), d = x(() => Math.floor(o.date.year() / 10) * 10), f = () => {
      var p;
      (p = u.value) == null || p.focus();
    }, v = (p) => {
      const C = {}, g = Gt().locale(i.value);
      return C.disabled = o.disabledDate ? l(p, i.value).every(o.disabledDate) : !1, C.current = Gl(o.parsedValue).findIndex((w) => w.year() === p) >= 0, C.today = g.year() === p, C;
    }, h = (p) => p === d.value && o.date.year() < d.value && o.date.year() > d.value + 9 || Gl(o.date).findIndex((C) => C.year() === p) >= 0 || Gl(o.parsedValue).findIndex((C) => (C == null ? void 0 : C.year()) === p) >= 0, m = (p) => {
      const g = p.target.closest("td");
      if (g && g.textContent) {
        if (ba(g, "disabled"))
          return;
        const w = g.textContent || g.innerText;
        if (o.selectionMode === "years") {
          if (p.type === "keydown") {
            n("pick", Gl(o.parsedValue), !1);
            return;
          }
          const b = ba(g, "current") ? Gl(o.parsedValue).filter((y) => (y == null ? void 0 : y.year()) !== Number(w)) : Gl(o.parsedValue).concat([Gt(w)]);
          n("pick", b);
        } else
          n("pick", Number(w));
      }
    };
    return Pe(() => o.date, async () => {
      var p, C;
      (p = s.value) != null && p.contains(document.activeElement) && (await xe(), (C = u.value) == null || C.focus());
    }), t({
      focus: f
    }), (p, C) => (M(), G("table", {
      role: "grid",
      "aria-label": c(r)("el.datepicker.yearTablePrompt"),
      class: z(c(a).b()),
      onClick: m
    }, [
      X("tbody", {
        ref_key: "tbodyRef",
        ref: s
      }, [
        (M(), G(kt, null, ln(3, (g, w) => X("tr", { key: w }, [
          (M(), G(kt, null, ln(4, (b, y) => (M(), G(kt, {
            key: w + "_" + y
          }, [
            w * 4 + y < 10 ? (M(), G("td", {
              key: 0,
              ref_for: !0,
              ref: (E) => h(c(d) + w * 4 + y) && (u.value = E),
              class: z(["available", v(c(d) + w * 4 + y)]),
              "aria-selected": `${h(c(d) + w * 4 + y)}`,
              tabindex: h(c(d) + w * 4 + y) ? 0 : -1,
              onKeydown: [
                Rn(It(m, ["prevent", "stop"]), ["space"]),
                Rn(It(m, ["prevent", "stop"]), ["enter"])
              ]
            }, [
              X("div", null, [
                X("span", hj, Qe(c(d) + w * 4 + y), 1)
              ])
            ], 42, vj)) : (M(), G("td", mj))
          ], 64))), 64))
        ])), 64))
      ], 512)
    ], 10, pj));
  }
});
var bj = /* @__PURE__ */ ut(gj, [["__file", "basic-year-table.vue"]]);
const yj = ["onClick"], Cj = ["aria-label"], wj = ["aria-label"], Ej = ["aria-label"], Sj = ["aria-label"], _j = /* @__PURE__ */ Q({
  __name: "panel-date-pick",
  props: UU,
  emits: ["pick", "set-picker-option", "panel-change"],
  setup(e, { emit: t }) {
    const n = e, o = (me, Ke, Re) => !0, l = nt("picker-panel"), a = nt("date-picker"), r = Ai(), i = Yn(), { t: s, lang: u } = bn(), d = ot("EP_PICKER_BASE"), f = ot(Kv), { shortcuts: v, disabledDate: h, cellClassName: m, defaultTime: p } = d.props, C = Pn(d.props, "defaultValue"), g = B(), w = B(Gt().locale(u.value)), b = B(!1);
    let y = !1;
    const E = x(() => Gt(p).locale(u.value)), S = x(() => w.value.month()), _ = x(() => w.value.year()), k = B([]), N = B(null), L = B(null), R = (me) => k.value.length > 0 ? o(me, k.value, n.format || "HH:mm:ss") : !0, H = (me) => p && !ue.value && !b.value && !y ? E.value.year(me.year()).month(me.month()).date(me.date()) : ce.value ? me.millisecond(0) : me.startOf("day"), K = (me, ...Ke) => {
      if (!me)
        t("pick", me, ...Ke);
      else if (Kt(me)) {
        const Re = me.map(H);
        t("pick", Re, ...Ke);
      } else
        t("pick", H(me), ...Ke);
      N.value = null, L.value = null, b.value = !1, y = !1;
    }, U = async (me, Ke) => {
      if (F.value === "date") {
        me = me;
        let Re = n.parsedValue ? n.parsedValue.year(me.year()).month(me.month()).date(me.date()) : me;
        R(Re) || (Re = k.value[0][0].year(me.year()).month(me.month()).date(me.date())), w.value = Re, K(Re, ce.value || Ke), n.type === "datetime" && (await xe(), Ce());
      } else
        F.value === "week" ? K(me.date) : F.value === "dates" && K(me, !0);
    }, W = (me) => {
      const Ke = me ? "add" : "subtract";
      w.value = w.value[Ke](1, "month"), Ee("month");
    }, A = (me) => {
      const Ke = w.value, Re = me ? "add" : "subtract";
      w.value = $.value === "year" ? Ke[Re](10, "year") : Ke[Re](1, "year"), Ee("year");
    }, $ = B("date"), D = x(() => {
      const me = s("el.datepicker.year");
      if ($.value === "year") {
        const Ke = Math.floor(_.value / 10) * 10;
        return me ? `${Ke} ${me} - ${Ke + 9} ${me}` : `${Ke} - ${Ke + 9}`;
      }
      return `${_.value} ${me}`;
    }), O = (me) => {
      const Ke = vn(me.value) ? me.value() : me.value;
      if (Ke) {
        y = !0, K(Gt(Ke).locale(u.value));
        return;
      }
      me.onClick && me.onClick({
        attrs: r,
        slots: i,
        emit: t
      });
    }, F = x(() => {
      const { type: me } = n;
      return ["week", "month", "year", "years", "dates"].includes(me) ? me : "date";
    }), j = x(() => F.value === "date" ? $.value : F.value), Z = x(() => !!v.length), te = async (me) => {
      w.value = w.value.startOf("month").month(me), F.value === "month" ? K(w.value, !1) : ($.value = "date", ["month", "year", "date", "week"].includes(F.value) && (K(w.value, !0), await xe(), Ce())), Ee("month");
    }, de = async (me, Ke) => {
      F.value === "year" ? (w.value = w.value.startOf("year").year(me), K(w.value, !1)) : F.value === "years" ? K(me, Ke ?? !0) : (w.value = w.value.year(me), $.value = "month", ["month", "year", "date", "week"].includes(F.value) && (K(w.value, !0), await xe(), Ce())), Ee("year");
    }, Oe = async (me) => {
      $.value = me, await xe(), Ce();
    }, ce = x(() => n.type === "datetime" || n.type === "datetimerange"), ne = x(() => {
      const me = ce.value || F.value === "dates", Ke = F.value === "years", Re = $.value === "date", we = $.value === "year";
      return me && Re || Ke && we;
    }), Y = x(() => h ? n.parsedValue ? Kt(n.parsedValue) ? h(n.parsedValue[0].toDate()) : h(n.parsedValue.toDate()) : !0 : !1), ve = () => {
      if (F.value === "dates" || F.value === "years")
        K(n.parsedValue);
      else {
        let me = n.parsedValue;
        if (!me) {
          const Ke = Gt(p).locale(u.value), Re = Te();
          me = Ke.year(Re.year()).month(Re.month()).date(Re.date());
        }
        w.value = me, K(me);
      }
    }, ie = x(() => h ? h(Gt().locale(u.value).toDate()) : !1), he = () => {
      const Ke = Gt().locale(u.value).toDate();
      b.value = !0, (!h || !h(Ke)) && R(Ke) && (w.value = Gt().locale(u.value), K(w.value));
    }, De = x(() => n.timeFormat || mT(n.format)), $e = x(() => n.dateFormat || hT(n.format)), ue = x(() => {
      if (L.value)
        return L.value;
      if (!(!n.parsedValue && !C.value))
        return (n.parsedValue || w.value).format(De.value);
    }), Ne = x(() => {
      if (N.value)
        return N.value;
      if (!(!n.parsedValue && !C.value))
        return (n.parsedValue || w.value).format($e.value);
    }), je = B(!1), Fe = () => {
      je.value = !0;
    }, Ve = () => {
      je.value = !1;
    }, Ze = (me) => ({
      hour: me.hour(),
      minute: me.minute(),
      second: me.second(),
      year: me.year(),
      month: me.month(),
      date: me.date()
    }), ae = (me, Ke, Re) => {
      const { hour: we, minute: ze, second: Je } = Ze(me), Me = n.parsedValue ? n.parsedValue.hour(we).minute(ze).second(Je) : me;
      w.value = Me, K(w.value, !0), Re || (je.value = Ke);
    }, pe = (me) => {
      const Ke = Gt(me, De.value).locale(u.value);
      if (Ke.isValid() && R(Ke)) {
        const { year: Re, month: we, date: ze } = Ze(w.value);
        w.value = Ke.year(Re).month(we).date(ze), L.value = null, je.value = !1, K(w.value, !0);
      }
    }, ke = (me) => {
      const Ke = Gt(me, $e.value).locale(u.value);
      if (Ke.isValid()) {
        if (h && h(Ke.toDate()))
          return;
        const { hour: Re, minute: we, second: ze } = Ze(w.value);
        w.value = Ke.hour(Re).minute(we).second(ze), N.value = null, K(w.value, !0);
      }
    }, Ue = (me) => Gt.isDayjs(me) && me.isValid() && (h ? !h(me.toDate()) : !0), Xe = (me) => Kt(me) ? me.map((Ke) => Ke.format(n.format)) : me.format(n.format), re = (me) => Gt(me, n.format).locale(u.value), Te = () => {
      const me = Gt(C.value).locale(u.value);
      if (!C.value) {
        const Ke = E.value;
        return Gt().hour(Ke.hour()).minute(Ke.minute()).second(Ke.second()).locale(u.value);
      }
      return me;
    }, Ce = async () => {
      var me;
      ["week", "month", "year", "date"].includes(F.value) && ((me = g.value) == null || me.focus(), F.value === "week" && ge(xt.down));
    }, Le = (me) => {
      const { code: Ke } = me;
      [
        xt.up,
        xt.down,
        xt.left,
        xt.right,
        xt.home,
        xt.end,
        xt.pageUp,
        xt.pageDown
      ].includes(Ke) && (ge(Ke), me.stopPropagation(), me.preventDefault()), [xt.enter, xt.space, xt.numpadEnter].includes(Ke) && N.value === null && L.value === null && (me.preventDefault(), K(w.value, !1));
    }, ge = (me) => {
      var Ke;
      const { up: Re, down: we, left: ze, right: Je, home: Me, end: et, pageUp: mt, pageDown: Lt } = xt, be = {
        year: {
          [Re]: -4,
          [we]: 4,
          [ze]: -1,
          [Je]: 1,
          offset: (_t, zt) => _t.setFullYear(_t.getFullYear() + zt)
        },
        month: {
          [Re]: -4,
          [we]: 4,
          [ze]: -1,
          [Je]: 1,
          offset: (_t, zt) => _t.setMonth(_t.getMonth() + zt)
        },
        week: {
          [Re]: -1,
          [we]: 1,
          [ze]: -1,
          [Je]: 1,
          offset: (_t, zt) => _t.setDate(_t.getDate() + zt * 7)
        },
        date: {
          [Re]: -7,
          [we]: 7,
          [ze]: -1,
          [Je]: 1,
          [Me]: (_t) => -_t.getDay(),
          [et]: (_t) => -_t.getDay() + 6,
          [mt]: (_t) => -new Date(_t.getFullYear(), _t.getMonth(), 0).getDate(),
          [Lt]: (_t) => new Date(_t.getFullYear(), _t.getMonth() + 1, 0).getDate(),
          offset: (_t, zt) => _t.setDate(_t.getDate() + zt)
        }
      }, an = w.value.toDate();
      for (; Math.abs(w.value.diff(an, "year", !0)) < 1; ) {
        const _t = be[j.value];
        if (!_t)
          return;
        if (_t.offset(an, vn(_t[me]) ? _t[me](an) : (Ke = _t[me]) != null ? Ke : 0), h && h(an))
          break;
        const zt = Gt(an).locale(u.value);
        w.value = zt, t("pick", zt, !0);
        break;
      }
    }, Ee = (me) => {
      t("panel-change", w.value.toDate(), me, $.value);
    };
    return Pe(() => F.value, (me) => {
      if (["month", "year"].includes(me)) {
        $.value = me;
        return;
      } else if (me === "years") {
        $.value = "year";
        return;
      }
      $.value = "date";
    }, { immediate: !0 }), Pe(() => $.value, () => {
      f == null || f.updatePopper();
    }), Pe(() => C.value, (me) => {
      me && (w.value = Te());
    }, { immediate: !0 }), Pe(() => n.parsedValue, (me) => {
      if (me) {
        if (F.value === "dates" || F.value === "years" || Array.isArray(me))
          return;
        w.value = me;
      } else
        w.value = Te();
    }, { immediate: !0 }), t("set-picker-option", ["isValidValue", Ue]), t("set-picker-option", ["formatToString", Xe]), t("set-picker-option", ["parseUserInput", re]), t("set-picker-option", ["handleFocusPicker", Ce]), (me, Ke) => (M(), G("div", {
      class: z([
        c(l).b(),
        c(a).b(),
        {
          "has-sidebar": me.$slots.sidebar || c(Z),
          "has-time": c(ce)
        }
      ])
    }, [
      X("div", {
        class: z(c(l).e("body-wrapper"))
      }, [
        Ie(me.$slots, "sidebar", {
          class: z(c(l).e("sidebar"))
        }),
        c(Z) ? (M(), G("div", {
          key: 0,
          class: z(c(l).e("sidebar"))
        }, [
          (M(!0), G(kt, null, ln(c(v), (Re, we) => (M(), G("button", {
            key: we,
            type: "button",
            class: z(c(l).e("shortcut")),
            onClick: (ze) => O(Re)
          }, Qe(Re.text), 11, yj))), 128))
        ], 2)) : _e("v-if", !0),
        X("div", {
          class: z(c(l).e("body"))
        }, [
          c(ce) ? (M(), G("div", {
            key: 0,
            class: z(c(a).e("time-header"))
          }, [
            X("span", {
              class: z(c(a).e("editor-wrap"))
            }, [
              oe(c(nl), {
                placeholder: c(s)("el.datepicker.selectDate"),
                "model-value": c(Ne),
                size: "small",
                "validate-event": !1,
                onInput: Ke[0] || (Ke[0] = (Re) => N.value = Re),
                onChange: ke
              }, null, 8, ["placeholder", "model-value"])
            ], 2),
            Bt((M(), G("span", {
              class: z(c(a).e("editor-wrap"))
            }, [
              oe(c(nl), {
                placeholder: c(s)("el.datepicker.selectTime"),
                "model-value": c(ue),
                size: "small",
                "validate-event": !1,
                onFocus: Fe,
                onInput: Ke[1] || (Ke[1] = (Re) => L.value = Re),
                onChange: pe
              }, null, 8, ["placeholder", "model-value"]),
              oe(c(ev), {
                visible: je.value,
                format: c(De),
                "parsed-value": w.value,
                onPick: ae
              }, null, 8, ["visible", "format", "parsed-value"])
            ], 2)), [
              [c(Pr), Ve]
            ])
          ], 2)) : _e("v-if", !0),
          Bt(X("div", {
            class: z([
              c(a).e("header"),
              ($.value === "year" || $.value === "month") && c(a).e("header--bordered")
            ])
          }, [
            X("span", {
              class: z(c(a).e("prev-btn"))
            }, [
              X("button", {
                type: "button",
                "aria-label": c(s)("el.datepicker.prevYear"),
                class: z(["d-arrow-left", c(l).e("icon-btn")]),
                onClick: Ke[2] || (Ke[2] = (Re) => A(!1))
              }, [
                oe(c(Ct), null, {
                  default: fe(() => [
                    oe(c(Pc))
                  ]),
                  _: 1
                })
              ], 10, Cj),
              Bt(X("button", {
                type: "button",
                "aria-label": c(s)("el.datepicker.prevMonth"),
                class: z([c(l).e("icon-btn"), "arrow-left"]),
                onClick: Ke[3] || (Ke[3] = (Re) => W(!1))
              }, [
                oe(c(Ct), null, {
                  default: fe(() => [
                    oe(c(ks))
                  ]),
                  _: 1
                })
              ], 10, wj), [
                [pn, $.value === "date"]
              ])
            ], 2),
            X("span", {
              role: "button",
              class: z(c(a).e("header-label")),
              "aria-live": "polite",
              tabindex: "0",
              onKeydown: Ke[4] || (Ke[4] = Rn((Re) => Oe("year"), ["enter"])),
              onClick: Ke[5] || (Ke[5] = (Re) => Oe("year"))
            }, Qe(c(D)), 35),
            Bt(X("span", {
              role: "button",
              "aria-live": "polite",
              tabindex: "0",
              class: z([
                c(a).e("header-label"),
                { active: $.value === "month" }
              ]),
              onKeydown: Ke[6] || (Ke[6] = Rn((Re) => Oe("month"), ["enter"])),
              onClick: Ke[7] || (Ke[7] = (Re) => Oe("month"))
            }, Qe(c(s)(`el.datepicker.month${c(S) + 1}`)), 35), [
              [pn, $.value === "date"]
            ]),
            X("span", {
              class: z(c(a).e("next-btn"))
            }, [
              Bt(X("button", {
                type: "button",
                "aria-label": c(s)("el.datepicker.nextMonth"),
                class: z([c(l).e("icon-btn"), "arrow-right"]),
                onClick: Ke[8] || (Ke[8] = (Re) => W(!0))
              }, [
                oe(c(Ct), null, {
                  default: fe(() => [
                    oe(c(xl))
                  ]),
                  _: 1
                })
              ], 10, Ej), [
                [pn, $.value === "date"]
              ]),
              X("button", {
                type: "button",
                "aria-label": c(s)("el.datepicker.nextYear"),
                class: z([c(l).e("icon-btn"), "d-arrow-right"]),
                onClick: Ke[9] || (Ke[9] = (Re) => A(!0))
              }, [
                oe(c(Ct), null, {
                  default: fe(() => [
                    oe(c(Ac))
                  ]),
                  _: 1
                })
              ], 10, Sj)
            ], 2)
          ], 2), [
            [pn, $.value !== "time"]
          ]),
          X("div", {
            class: z(c(l).e("content")),
            onKeydown: Le
          }, [
            $.value === "date" ? (M(), We(Hg, {
              key: 0,
              ref_key: "currentViewRef",
              ref: g,
              "selection-mode": c(F),
              date: w.value,
              "parsed-value": me.parsedValue,
              "disabled-date": c(h),
              "cell-class-name": c(m),
              onPick: U
            }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "cell-class-name"])) : _e("v-if", !0),
            $.value === "year" ? (M(), We(bj, {
              key: 1,
              ref_key: "currentViewRef",
              ref: g,
              "selection-mode": c(F),
              date: w.value,
              "disabled-date": c(h),
              "parsed-value": me.parsedValue,
              onPick: de
            }, null, 8, ["selection-mode", "date", "disabled-date", "parsed-value"])) : _e("v-if", !0),
            $.value === "month" ? (M(), We(zg, {
              key: 2,
              ref_key: "currentViewRef",
              ref: g,
              date: w.value,
              "parsed-value": me.parsedValue,
              "disabled-date": c(h),
              onPick: te
            }, null, 8, ["date", "parsed-value", "disabled-date"])) : _e("v-if", !0)
          ], 34)
        ], 2)
      ], 2),
      Bt(X("div", {
        class: z(c(l).e("footer"))
      }, [
        Bt(oe(c(Do), {
          text: "",
          size: "small",
          class: z(c(l).e("link-btn")),
          disabled: c(ie),
          onClick: he
        }, {
          default: fe(() => [
            Ut(Qe(c(s)("el.datepicker.now")), 1)
          ]),
          _: 1
        }, 8, ["class", "disabled"]), [
          [pn, c(F) !== "dates" && c(F) !== "years"]
        ]),
        oe(c(Do), {
          plain: "",
          size: "small",
          class: z(c(l).e("link-btn")),
          disabled: c(Y),
          onClick: ve
        }, {
          default: fe(() => [
            Ut(Qe(c(s)("el.datepicker.confirm")), 1)
          ]),
          _: 1
        }, 8, ["class", "disabled"])
      ], 2), [
        [pn, c(ne)]
      ])
    ], 2));
  }
});
var xj = /* @__PURE__ */ ut(_j, [["__file", "panel-date-pick.vue"]]);
const kj = it({
  ...v$,
  ...h$
}), Tj = (e) => {
  const { emit: t } = Pt(), n = Ai(), o = Yn();
  return (a) => {
    const r = vn(a.value) ? a.value() : a.value;
    if (r) {
      t("pick", [
        Gt(r[0]).locale(e.value),
        Gt(r[1]).locale(e.value)
      ]);
      return;
    }
    a.onClick && a.onClick({
      attrs: n,
      slots: o,
      emit: t
    });
  };
}, g$ = (e, {
  defaultValue: t,
  leftDate: n,
  rightDate: o,
  unit: l,
  onParsedValueChanged: a
}) => {
  const { emit: r } = Pt(), { pickerNs: i } = ot(Yy), s = nt("date-range-picker"), { t: u, lang: d } = bn(), f = Tj(d), v = B(), h = B(), m = B({
    endDate: null,
    selecting: !1
  }), p = (b) => {
    m.value = b;
  }, C = (b = !1) => {
    const y = c(v), E = c(h);
    Vg([y, E]) && r("pick", [y, E], b);
  }, g = (b) => {
    m.value.selecting = b, b || (m.value.endDate = null);
  }, w = () => {
    const [b, y] = m$(c(t), {
      lang: c(d),
      unit: l,
      unlinkPanels: e.unlinkPanels
    });
    v.value = void 0, h.value = void 0, n.value = b, o.value = y;
  };
  return Pe(t, (b) => {
    b && w();
  }, { immediate: !0 }), Pe(() => e.parsedValue, (b) => {
    if (Kt(b) && b.length === 2) {
      const [y, E] = b;
      v.value = y, n.value = y, h.value = E, a(c(v), c(h));
    } else
      w();
  }, { immediate: !0 }), {
    minDate: v,
    maxDate: h,
    rangeState: m,
    lang: d,
    ppNs: i,
    drpNs: s,
    handleChangeRange: p,
    handleRangeConfirm: C,
    handleShortcutClick: f,
    onSelect: g,
    t: u
  };
}, $j = ["onClick"], Oj = ["aria-label"], Nj = ["aria-label"], Mj = ["disabled", "aria-label"], Ij = ["disabled", "aria-label"], Rj = ["disabled", "aria-label"], Dj = ["disabled", "aria-label"], Lj = ["aria-label"], Pj = ["aria-label"], Zf = "month", Aj = /* @__PURE__ */ Q({
  __name: "panel-date-range",
  props: kj,
  emits: [
    "pick",
    "set-picker-option",
    "calendar-change",
    "panel-change"
  ],
  setup(e, { emit: t }) {
    const n = e, o = ot("EP_PICKER_BASE"), { disabledDate: l, cellClassName: a, format: r, defaultTime: i, clearable: s } = o.props, u = Pn(o.props, "shortcuts"), d = Pn(o.props, "defaultValue"), { lang: f } = bn(), v = B(Gt().locale(f.value)), h = B(Gt().locale(f.value).add(1, Zf)), {
      minDate: m,
      maxDate: p,
      rangeState: C,
      ppNs: g,
      drpNs: w,
      handleChangeRange: b,
      handleRangeConfirm: y,
      handleShortcutClick: E,
      onSelect: S,
      t: _
    } = g$(n, {
      defaultValue: d,
      leftDate: v,
      rightDate: h,
      unit: Zf,
      onParsedValueChanged: Ke
    }), k = B({
      min: null,
      max: null
    }), N = B({
      min: null,
      max: null
    }), L = x(() => `${v.value.year()} ${_("el.datepicker.year")} ${_(`el.datepicker.month${v.value.month() + 1}`)}`), R = x(() => `${h.value.year()} ${_("el.datepicker.year")} ${_(`el.datepicker.month${h.value.month() + 1}`)}`), H = x(() => v.value.year()), K = x(() => v.value.month()), U = x(() => h.value.year()), W = x(() => h.value.month()), A = x(() => !!u.value.length), $ = x(() => k.value.min !== null ? k.value.min : m.value ? m.value.format(Z.value) : ""), D = x(() => k.value.max !== null ? k.value.max : p.value || m.value ? (p.value || m.value).format(Z.value) : ""), O = x(() => N.value.min !== null ? N.value.min : m.value ? m.value.format(j.value) : ""), F = x(() => N.value.max !== null ? N.value.max : p.value || m.value ? (p.value || m.value).format(j.value) : ""), j = x(() => n.timeFormat || mT(r)), Z = x(() => n.dateFormat || hT(r)), te = (Re) => Vg(Re) && (l ? !l(Re[0].toDate()) && !l(Re[1].toDate()) : !0), de = () => {
      v.value = v.value.subtract(1, "year"), n.unlinkPanels || (h.value = v.value.add(1, "month")), De("year");
    }, Oe = () => {
      v.value = v.value.subtract(1, "month"), n.unlinkPanels || (h.value = v.value.add(1, "month")), De("month");
    }, ce = () => {
      n.unlinkPanels ? h.value = h.value.add(1, "year") : (v.value = v.value.add(1, "year"), h.value = v.value.add(1, "month")), De("year");
    }, ne = () => {
      n.unlinkPanels ? h.value = h.value.add(1, "month") : (v.value = v.value.add(1, "month"), h.value = v.value.add(1, "month")), De("month");
    }, Y = () => {
      v.value = v.value.add(1, "year"), De("year");
    }, ve = () => {
      v.value = v.value.add(1, "month"), De("month");
    }, ie = () => {
      h.value = h.value.subtract(1, "year"), De("year");
    }, he = () => {
      h.value = h.value.subtract(1, "month"), De("month");
    }, De = (Re) => {
      t("panel-change", [v.value.toDate(), h.value.toDate()], Re);
    }, $e = x(() => {
      const Re = (K.value + 1) % 12, we = K.value + 1 >= 12 ? 1 : 0;
      return n.unlinkPanels && new Date(H.value + we, Re) < new Date(U.value, W.value);
    }), ue = x(() => n.unlinkPanels && U.value * 12 + W.value - (H.value * 12 + K.value + 1) >= 12), Ne = x(() => !(m.value && p.value && !C.value.selecting && Vg([m.value, p.value]))), je = x(() => n.type === "datetime" || n.type === "datetimerange"), Fe = (Re, we) => {
      if (Re)
        return i ? Gt(i[we] || i).locale(f.value).year(Re.year()).month(Re.month()).date(Re.date()) : Re;
    }, Ve = (Re, we = !0) => {
      const ze = Re.minDate, Je = Re.maxDate, Me = Fe(ze, 0), et = Fe(Je, 1);
      p.value === et && m.value === Me || (t("calendar-change", [ze.toDate(), Je && Je.toDate()]), p.value = et, m.value = Me, !(!we || je.value) && y());
    }, Ze = B(!1), ae = B(!1), pe = () => {
      Ze.value = !1;
    }, ke = () => {
      ae.value = !1;
    }, Ue = (Re, we) => {
      k.value[we] = Re;
      const ze = Gt(Re, Z.value).locale(f.value);
      if (ze.isValid()) {
        if (l && l(ze.toDate()))
          return;
        we === "min" ? (v.value = ze, m.value = (m.value || v.value).year(ze.year()).month(ze.month()).date(ze.date()), !n.unlinkPanels && (!p.value || p.value.isBefore(m.value)) && (h.value = ze.add(1, "month"), p.value = m.value.add(1, "month"))) : (h.value = ze, p.value = (p.value || h.value).year(ze.year()).month(ze.month()).date(ze.date()), !n.unlinkPanels && (!m.value || m.value.isAfter(p.value)) && (v.value = ze.subtract(1, "month"), m.value = p.value.subtract(1, "month")));
      }
    }, Xe = (Re, we) => {
      k.value[we] = null;
    }, re = (Re, we) => {
      N.value[we] = Re;
      const ze = Gt(Re, j.value).locale(f.value);
      ze.isValid() && (we === "min" ? (Ze.value = !0, m.value = (m.value || v.value).hour(ze.hour()).minute(ze.minute()).second(ze.second()), (!p.value || p.value.isBefore(m.value)) && (p.value = m.value)) : (ae.value = !0, p.value = (p.value || h.value).hour(ze.hour()).minute(ze.minute()).second(ze.second()), h.value = p.value, p.value && p.value.isBefore(m.value) && (m.value = p.value)));
    }, Te = (Re, we) => {
      N.value[we] = null, we === "min" ? (v.value = m.value, Ze.value = !1) : (h.value = p.value, ae.value = !1);
    }, Ce = (Re, we, ze) => {
      N.value.min || (Re && (v.value = Re, m.value = (m.value || v.value).hour(Re.hour()).minute(Re.minute()).second(Re.second())), ze || (Ze.value = we), (!p.value || p.value.isBefore(m.value)) && (p.value = m.value, h.value = Re));
    }, Le = (Re, we, ze) => {
      N.value.max || (Re && (h.value = Re, p.value = (p.value || h.value).hour(Re.hour()).minute(Re.minute()).second(Re.second())), ze || (ae.value = we), p.value && p.value.isBefore(m.value) && (m.value = p.value));
    }, ge = () => {
      v.value = m$(c(d), {
        lang: c(f),
        unit: "month",
        unlinkPanels: n.unlinkPanels
      })[0], h.value = v.value.add(1, "month"), p.value = void 0, m.value = void 0, t("pick", null);
    }, Ee = (Re) => Kt(Re) ? Re.map((we) => we.format(r)) : Re.format(r), me = (Re) => Kt(Re) ? Re.map((we) => Gt(we, r).locale(f.value)) : Gt(Re, r).locale(f.value);
    function Ke(Re, we) {
      if (n.unlinkPanels && we) {
        const ze = (Re == null ? void 0 : Re.year()) || 0, Je = (Re == null ? void 0 : Re.month()) || 0, Me = we.year(), et = we.month();
        h.value = ze === Me && Je === et ? we.add(1, Zf) : we;
      } else
        h.value = v.value.add(1, Zf), we && (h.value = h.value.hour(we.hour()).minute(we.minute()).second(we.second()));
    }
    return t("set-picker-option", ["isValidValue", te]), t("set-picker-option", ["parseUserInput", me]), t("set-picker-option", ["formatToString", Ee]), t("set-picker-option", ["handleClear", ge]), (Re, we) => (M(), G("div", {
      class: z([
        c(g).b(),
        c(w).b(),
        {
          "has-sidebar": Re.$slots.sidebar || c(A),
          "has-time": c(je)
        }
      ])
    }, [
      X("div", {
        class: z(c(g).e("body-wrapper"))
      }, [
        Ie(Re.$slots, "sidebar", {
          class: z(c(g).e("sidebar"))
        }),
        c(A) ? (M(), G("div", {
          key: 0,
          class: z(c(g).e("sidebar"))
        }, [
          (M(!0), G(kt, null, ln(c(u), (ze, Je) => (M(), G("button", {
            key: Je,
            type: "button",
            class: z(c(g).e("shortcut")),
            onClick: (Me) => c(E)(ze)
          }, Qe(ze.text), 11, $j))), 128))
        ], 2)) : _e("v-if", !0),
        X("div", {
          class: z(c(g).e("body"))
        }, [
          c(je) ? (M(), G("div", {
            key: 0,
            class: z(c(w).e("time-header"))
          }, [
            X("span", {
              class: z(c(w).e("editors-wrap"))
            }, [
              X("span", {
                class: z(c(w).e("time-picker-wrap"))
              }, [
                oe(c(nl), {
                  size: "small",
                  disabled: c(C).selecting,
                  placeholder: c(_)("el.datepicker.startDate"),
                  class: z(c(w).e("editor")),
                  "model-value": c($),
                  "validate-event": !1,
                  onInput: we[0] || (we[0] = (ze) => Ue(ze, "min")),
                  onChange: we[1] || (we[1] = (ze) => Xe(ze, "min"))
                }, null, 8, ["disabled", "placeholder", "class", "model-value"])
              ], 2),
              Bt((M(), G("span", {
                class: z(c(w).e("time-picker-wrap"))
              }, [
                oe(c(nl), {
                  size: "small",
                  class: z(c(w).e("editor")),
                  disabled: c(C).selecting,
                  placeholder: c(_)("el.datepicker.startTime"),
                  "model-value": c(O),
                  "validate-event": !1,
                  onFocus: we[2] || (we[2] = (ze) => Ze.value = !0),
                  onInput: we[3] || (we[3] = (ze) => re(ze, "min")),
                  onChange: we[4] || (we[4] = (ze) => Te(ze, "min"))
                }, null, 8, ["class", "disabled", "placeholder", "model-value"]),
                oe(c(ev), {
                  visible: Ze.value,
                  format: c(j),
                  "datetime-role": "start",
                  "parsed-value": v.value,
                  onPick: Ce
                }, null, 8, ["visible", "format", "parsed-value"])
              ], 2)), [
                [c(Pr), pe]
              ])
            ], 2),
            X("span", null, [
              oe(c(Ct), null, {
                default: fe(() => [
                  oe(c(xl))
                ]),
                _: 1
              })
            ]),
            X("span", {
              class: z([c(w).e("editors-wrap"), "is-right"])
            }, [
              X("span", {
                class: z(c(w).e("time-picker-wrap"))
              }, [
                oe(c(nl), {
                  size: "small",
                  class: z(c(w).e("editor")),
                  disabled: c(C).selecting,
                  placeholder: c(_)("el.datepicker.endDate"),
                  "model-value": c(D),
                  readonly: !c(m),
                  "validate-event": !1,
                  onInput: we[5] || (we[5] = (ze) => Ue(ze, "max")),
                  onChange: we[6] || (we[6] = (ze) => Xe(ze, "max"))
                }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"])
              ], 2),
              Bt((M(), G("span", {
                class: z(c(w).e("time-picker-wrap"))
              }, [
                oe(c(nl), {
                  size: "small",
                  class: z(c(w).e("editor")),
                  disabled: c(C).selecting,
                  placeholder: c(_)("el.datepicker.endTime"),
                  "model-value": c(F),
                  readonly: !c(m),
                  "validate-event": !1,
                  onFocus: we[7] || (we[7] = (ze) => c(m) && (ae.value = !0)),
                  onInput: we[8] || (we[8] = (ze) => re(ze, "max")),
                  onChange: we[9] || (we[9] = (ze) => Te(ze, "max"))
                }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"]),
                oe(c(ev), {
                  "datetime-role": "end",
                  visible: ae.value,
                  format: c(j),
                  "parsed-value": h.value,
                  onPick: Le
                }, null, 8, ["visible", "format", "parsed-value"])
              ], 2)), [
                [c(Pr), ke]
              ])
            ], 2)
          ], 2)) : _e("v-if", !0),
          X("div", {
            class: z([[c(g).e("content"), c(w).e("content")], "is-left"])
          }, [
            X("div", {
              class: z(c(w).e("header"))
            }, [
              X("button", {
                type: "button",
                class: z([c(g).e("icon-btn"), "d-arrow-left"]),
                "aria-label": c(_)("el.datepicker.prevYear"),
                onClick: de
              }, [
                oe(c(Ct), null, {
                  default: fe(() => [
                    oe(c(Pc))
                  ]),
                  _: 1
                })
              ], 10, Oj),
              X("button", {
                type: "button",
                class: z([c(g).e("icon-btn"), "arrow-left"]),
                "aria-label": c(_)("el.datepicker.prevMonth"),
                onClick: Oe
              }, [
                oe(c(Ct), null, {
                  default: fe(() => [
                    oe(c(ks))
                  ]),
                  _: 1
                })
              ], 10, Nj),
              Re.unlinkPanels ? (M(), G("button", {
                key: 0,
                type: "button",
                disabled: !c(ue),
                class: z([[c(g).e("icon-btn"), { "is-disabled": !c(ue) }], "d-arrow-right"]),
                "aria-label": c(_)("el.datepicker.nextYear"),
                onClick: Y
              }, [
                oe(c(Ct), null, {
                  default: fe(() => [
                    oe(c(Ac))
                  ]),
                  _: 1
                })
              ], 10, Mj)) : _e("v-if", !0),
              Re.unlinkPanels ? (M(), G("button", {
                key: 1,
                type: "button",
                disabled: !c($e),
                class: z([[
                  c(g).e("icon-btn"),
                  { "is-disabled": !c($e) }
                ], "arrow-right"]),
                "aria-label": c(_)("el.datepicker.nextMonth"),
                onClick: ve
              }, [
                oe(c(Ct), null, {
                  default: fe(() => [
                    oe(c(xl))
                  ]),
                  _: 1
                })
              ], 10, Ij)) : _e("v-if", !0),
              X("div", null, Qe(c(L)), 1)
            ], 2),
            oe(Hg, {
              "selection-mode": "range",
              date: v.value,
              "min-date": c(m),
              "max-date": c(p),
              "range-state": c(C),
              "disabled-date": c(l),
              "cell-class-name": c(a),
              onChangerange: c(b),
              onPick: Ve,
              onSelect: c(S)
            }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onSelect"])
          ], 2),
          X("div", {
            class: z([[c(g).e("content"), c(w).e("content")], "is-right"])
          }, [
            X("div", {
              class: z(c(w).e("header"))
            }, [
              Re.unlinkPanels ? (M(), G("button", {
                key: 0,
                type: "button",
                disabled: !c(ue),
                class: z([[c(g).e("icon-btn"), { "is-disabled": !c(ue) }], "d-arrow-left"]),
                "aria-label": c(_)("el.datepicker.prevYear"),
                onClick: ie
              }, [
                oe(c(Ct), null, {
                  default: fe(() => [
                    oe(c(Pc))
                  ]),
                  _: 1
                })
              ], 10, Rj)) : _e("v-if", !0),
              Re.unlinkPanels ? (M(), G("button", {
                key: 1,
                type: "button",
                disabled: !c($e),
                class: z([[
                  c(g).e("icon-btn"),
                  { "is-disabled": !c($e) }
                ], "arrow-left"]),
                "aria-label": c(_)("el.datepicker.prevMonth"),
                onClick: he
              }, [
                oe(c(Ct), null, {
                  default: fe(() => [
                    oe(c(ks))
                  ]),
                  _: 1
                })
              ], 10, Dj)) : _e("v-if", !0),
              X("button", {
                type: "button",
                "aria-label": c(_)("el.datepicker.nextYear"),
                class: z([c(g).e("icon-btn"), "d-arrow-right"]),
                onClick: ce
              }, [
                oe(c(Ct), null, {
                  default: fe(() => [
                    oe(c(Ac))
                  ]),
                  _: 1
                })
              ], 10, Lj),
              X("button", {
                type: "button",
                class: z([c(g).e("icon-btn"), "arrow-right"]),
                "aria-label": c(_)("el.datepicker.nextMonth"),
                onClick: ne
              }, [
                oe(c(Ct), null, {
                  default: fe(() => [
                    oe(c(xl))
                  ]),
                  _: 1
                })
              ], 10, Pj),
              X("div", null, Qe(c(R)), 1)
            ], 2),
            oe(Hg, {
              "selection-mode": "range",
              date: h.value,
              "min-date": c(m),
              "max-date": c(p),
              "range-state": c(C),
              "disabled-date": c(l),
              "cell-class-name": c(a),
              onChangerange: c(b),
              onPick: Ve,
              onSelect: c(S)
            }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onSelect"])
          ], 2)
        ], 2)
      ], 2),
      c(je) ? (M(), G("div", {
        key: 0,
        class: z(c(g).e("footer"))
      }, [
        c(s) ? (M(), We(c(Do), {
          key: 0,
          text: "",
          size: "small",
          class: z(c(g).e("link-btn")),
          onClick: ge
        }, {
          default: fe(() => [
            Ut(Qe(c(_)("el.datepicker.clear")), 1)
          ]),
          _: 1
        }, 8, ["class"])) : _e("v-if", !0),
        oe(c(Do), {
          plain: "",
          size: "small",
          class: z(c(g).e("link-btn")),
          disabled: c(Ne),
          onClick: we[10] || (we[10] = (ze) => c(y)(!1))
        }, {
          default: fe(() => [
            Ut(Qe(c(_)("el.datepicker.confirm")), 1)
          ]),
          _: 1
        }, 8, ["class", "disabled"])
      ], 2)) : _e("v-if", !0)
    ], 2));
  }
});
var Fj = /* @__PURE__ */ ut(Aj, [["__file", "panel-date-range.vue"]]);
const Vj = it({
  ...h$
}), Bj = [
  "pick",
  "set-picker-option",
  "calendar-change"
], Hj = ({
  unlinkPanels: e,
  leftDate: t,
  rightDate: n
}) => {
  const { t: o } = bn(), l = () => {
    t.value = t.value.subtract(1, "year"), e.value || (n.value = n.value.subtract(1, "year"));
  }, a = () => {
    e.value || (t.value = t.value.add(1, "year")), n.value = n.value.add(1, "year");
  }, r = () => {
    t.value = t.value.add(1, "year");
  }, i = () => {
    n.value = n.value.subtract(1, "year");
  }, s = x(() => `${t.value.year()} ${o("el.datepicker.year")}`), u = x(() => `${n.value.year()} ${o("el.datepicker.year")}`), d = x(() => t.value.year()), f = x(() => n.value.year() === t.value.year() ? t.value.year() + 1 : n.value.year());
  return {
    leftPrevYear: l,
    rightNextYear: a,
    leftNextYear: r,
    rightPrevYear: i,
    leftLabel: s,
    rightLabel: u,
    leftYear: d,
    rightYear: f
  };
}, zj = ["onClick"], Wj = ["disabled"], Kj = ["disabled"], Jf = "year", Uj = Q({
  name: "DatePickerMonthRange"
}), jj = /* @__PURE__ */ Q({
  ...Uj,
  props: Vj,
  emits: Bj,
  setup(e, { emit: t }) {
    const n = e, { lang: o } = bn(), l = ot("EP_PICKER_BASE"), { shortcuts: a, disabledDate: r, format: i } = l.props, s = Pn(l.props, "defaultValue"), u = B(Gt().locale(o.value)), d = B(Gt().locale(o.value).add(1, Jf)), {
      minDate: f,
      maxDate: v,
      rangeState: h,
      ppNs: m,
      drpNs: p,
      handleChangeRange: C,
      handleRangeConfirm: g,
      handleShortcutClick: w,
      onSelect: b
    } = g$(n, {
      defaultValue: s,
      leftDate: u,
      rightDate: d,
      unit: Jf,
      onParsedValueChanged: A
    }), y = x(() => !!a.length), {
      leftPrevYear: E,
      rightNextYear: S,
      leftNextYear: _,
      rightPrevYear: k,
      leftLabel: N,
      rightLabel: L,
      leftYear: R,
      rightYear: H
    } = Hj({
      unlinkPanels: Pn(n, "unlinkPanels"),
      leftDate: u,
      rightDate: d
    }), K = x(() => n.unlinkPanels && H.value > R.value + 1), U = ($, D = !0) => {
      const O = $.minDate, F = $.maxDate;
      v.value === F && f.value === O || (t("calendar-change", [O.toDate(), F && F.toDate()]), v.value = F, f.value = O, D && g());
    }, W = ($) => $.map((D) => D.format(i));
    function A($, D) {
      if (n.unlinkPanels && D) {
        const O = ($ == null ? void 0 : $.year()) || 0, F = D.year();
        d.value = O === F ? D.add(1, Jf) : D;
      } else
        d.value = u.value.add(1, Jf);
    }
    return t("set-picker-option", ["formatToString", W]), ($, D) => (M(), G("div", {
      class: z([
        c(m).b(),
        c(p).b(),
        {
          "has-sidebar": !!$.$slots.sidebar || c(y)
        }
      ])
    }, [
      X("div", {
        class: z(c(m).e("body-wrapper"))
      }, [
        Ie($.$slots, "sidebar", {
          class: z(c(m).e("sidebar"))
        }),
        c(y) ? (M(), G("div", {
          key: 0,
          class: z(c(m).e("sidebar"))
        }, [
          (M(!0), G(kt, null, ln(c(a), (O, F) => (M(), G("button", {
            key: F,
            type: "button",
            class: z(c(m).e("shortcut")),
            onClick: (j) => c(w)(O)
          }, Qe(O.text), 11, zj))), 128))
        ], 2)) : _e("v-if", !0),
        X("div", {
          class: z(c(m).e("body"))
        }, [
          X("div", {
            class: z([[c(m).e("content"), c(p).e("content")], "is-left"])
          }, [
            X("div", {
              class: z(c(p).e("header"))
            }, [
              X("button", {
                type: "button",
                class: z([c(m).e("icon-btn"), "d-arrow-left"]),
                onClick: D[0] || (D[0] = (...O) => c(E) && c(E)(...O))
              }, [
                oe(c(Ct), null, {
                  default: fe(() => [
                    oe(c(Pc))
                  ]),
                  _: 1
                })
              ], 2),
              $.unlinkPanels ? (M(), G("button", {
                key: 0,
                type: "button",
                disabled: !c(K),
                class: z([[
                  c(m).e("icon-btn"),
                  { [c(m).is("disabled")]: !c(K) }
                ], "d-arrow-right"]),
                onClick: D[1] || (D[1] = (...O) => c(_) && c(_)(...O))
              }, [
                oe(c(Ct), null, {
                  default: fe(() => [
                    oe(c(Ac))
                  ]),
                  _: 1
                })
              ], 10, Wj)) : _e("v-if", !0),
              X("div", null, Qe(c(N)), 1)
            ], 2),
            oe(zg, {
              "selection-mode": "range",
              date: u.value,
              "min-date": c(f),
              "max-date": c(v),
              "range-state": c(h),
              "disabled-date": c(r),
              onChangerange: c(C),
              onPick: U,
              onSelect: c(b)
            }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])
          ], 2),
          X("div", {
            class: z([[c(m).e("content"), c(p).e("content")], "is-right"])
          }, [
            X("div", {
              class: z(c(p).e("header"))
            }, [
              $.unlinkPanels ? (M(), G("button", {
                key: 0,
                type: "button",
                disabled: !c(K),
                class: z([[c(m).e("icon-btn"), { "is-disabled": !c(K) }], "d-arrow-left"]),
                onClick: D[2] || (D[2] = (...O) => c(k) && c(k)(...O))
              }, [
                oe(c(Ct), null, {
                  default: fe(() => [
                    oe(c(Pc))
                  ]),
                  _: 1
                })
              ], 10, Kj)) : _e("v-if", !0),
              X("button", {
                type: "button",
                class: z([c(m).e("icon-btn"), "d-arrow-right"]),
                onClick: D[3] || (D[3] = (...O) => c(S) && c(S)(...O))
              }, [
                oe(c(Ct), null, {
                  default: fe(() => [
                    oe(c(Ac))
                  ]),
                  _: 1
                })
              ], 2),
              X("div", null, Qe(c(L)), 1)
            ], 2),
            oe(zg, {
              "selection-mode": "range",
              date: d.value,
              "min-date": c(f),
              "max-date": c(v),
              "range-state": c(h),
              "disabled-date": c(r),
              onChangerange: c(C),
              onPick: U,
              onSelect: c(b)
            }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])
          ], 2)
        ], 2)
      ], 2)
    ], 2));
  }
});
var qj = /* @__PURE__ */ ut(jj, [["__file", "panel-month-range.vue"]]);
const Yj = function(e) {
  switch (e) {
    case "daterange":
    case "datetimerange":
      return Fj;
    case "monthrange":
      return qj;
    default:
      return xj;
  }
};
Gt.extend(IT);
Gt.extend(IU);
Gt.extend(Wy);
Gt.extend(DU);
Gt.extend(PU);
Gt.extend(FU);
Gt.extend(BU);
Gt.extend(zU);
var Gj = Q({
  name: "ElDatePicker",
  install: null,
  props: WU,
  emits: ["update:modelValue"],
  setup(e, {
    expose: t,
    emit: n,
    slots: o
  }) {
    const l = nt("picker-panel");
    Mt("ElPopperOptions", en(Pn(e, "popperOptions"))), Mt(Yy, {
      slots: o,
      pickerNs: l
    });
    const a = B();
    t({
      focus: (s = !0) => {
        var u;
        (u = a.value) == null || u.focus(s);
      },
      handleOpen: () => {
        var s;
        (s = a.value) == null || s.handleOpen();
      },
      handleClose: () => {
        var s;
        (s = a.value) == null || s.handleClose();
      }
    });
    const i = (s) => {
      n("update:modelValue", s);
    };
    return () => {
      var s;
      const u = (s = e.format) != null ? s : $z[e.type] || fc, d = Yj(e.type);
      return oe(yT, Et(e, {
        format: u,
        type: e.type,
        ref: a,
        "onUpdate:modelValue": i
      }), {
        default: (f) => oe(d, f, null),
        "range-separator": o["range-separator"]
      });
    };
  }
});
const Tp = Gj;
Tp.install = (e) => {
  e.component(Tp.name, Tp);
};
const b$ = Tp, Zy = Symbol("elDescriptions");
var $u = Q({
  name: "ElDescriptionsCell",
  props: {
    cell: {
      type: Object
    },
    tag: {
      type: String,
      default: "td"
    },
    type: {
      type: String
    }
  },
  setup() {
    return {
      descriptions: ot(Zy, {})
    };
  },
  render() {
    var e, t, n, o, l, a, r;
    const i = fV(this.cell), s = (((e = this.cell) == null ? void 0 : e.dirs) || []).map((E) => {
      const { dir: S, arg: _, modifiers: k, value: N } = E;
      return [S, N, _, k];
    }), { border: u, direction: d } = this.descriptions, f = d === "vertical", v = ((o = (n = (t = this.cell) == null ? void 0 : t.children) == null ? void 0 : n.label) == null ? void 0 : o.call(n)) || i.label, h = (r = (a = (l = this.cell) == null ? void 0 : l.children) == null ? void 0 : a.default) == null ? void 0 : r.call(a), m = i.span, p = i.align ? `is-${i.align}` : "", C = i.labelAlign ? `is-${i.labelAlign}` : p, g = i.className, w = i.labelClassName, b = {
      width: po(i.width),
      minWidth: po(i.minWidth)
    }, y = nt("descriptions");
    switch (this.type) {
      case "label":
        return Bt(V(this.tag, {
          style: b,
          class: [
            y.e("cell"),
            y.e("label"),
            y.is("bordered-label", u),
            y.is("vertical-label", f),
            C,
            w
          ],
          colSpan: f ? m : 1
        }, v), s);
      case "content":
        return Bt(V(this.tag, {
          style: b,
          class: [
            y.e("cell"),
            y.e("content"),
            y.is("bordered-content", u),
            y.is("vertical-content", f),
            p,
            g
          ],
          colSpan: f ? m : m * 2 - 1
        }, h), s);
      default:
        return Bt(V("td", {
          style: b,
          class: [y.e("cell"), p],
          colSpan: m
        }, [
          zo(v) ? void 0 : V("span", {
            class: [y.e("label"), w]
          }, v),
          V("span", {
            class: [y.e("content"), g]
          }, h)
        ]), s);
    }
  }
});
const Xj = it({
  row: {
    type: Ae(Array),
    default: () => []
  }
}), Zj = { key: 1 }, Jj = Q({
  name: "ElDescriptionsRow"
}), Qj = /* @__PURE__ */ Q({
  ...Jj,
  props: Xj,
  setup(e) {
    const t = ot(Zy, {});
    return (n, o) => c(t).direction === "vertical" ? (M(), G(kt, { key: 0 }, [
      X("tr", null, [
        (M(!0), G(kt, null, ln(n.row, (l, a) => (M(), We(c($u), {
          key: `tr1-${a}`,
          cell: l,
          tag: "th",
          type: "label"
        }, null, 8, ["cell"]))), 128))
      ]),
      X("tr", null, [
        (M(!0), G(kt, null, ln(n.row, (l, a) => (M(), We(c($u), {
          key: `tr2-${a}`,
          cell: l,
          tag: "td",
          type: "content"
        }, null, 8, ["cell"]))), 128))
      ])
    ], 64)) : (M(), G("tr", Zj, [
      (M(!0), G(kt, null, ln(n.row, (l, a) => (M(), G(kt, {
        key: `tr3-${a}`
      }, [
        c(t).border ? (M(), G(kt, { key: 0 }, [
          oe(c($u), {
            cell: l,
            tag: "td",
            type: "label"
          }, null, 8, ["cell"]),
          oe(c($u), {
            cell: l,
            tag: "td",
            type: "content"
          }, null, 8, ["cell"])
        ], 64)) : (M(), We(c($u), {
          key: 1,
          cell: l,
          tag: "td",
          type: "both"
        }, null, 8, ["cell"]))
      ], 64))), 128))
    ]));
  }
});
var eq = /* @__PURE__ */ ut(Qj, [["__file", "descriptions-row.vue"]]);
const tq = it({
  border: {
    type: Boolean,
    default: !1
  },
  column: {
    type: Number,
    default: 3
  },
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  size: Lo,
  title: {
    type: String,
    default: ""
  },
  extra: {
    type: String,
    default: ""
  }
}), nq = Q({
  name: "ElDescriptions"
}), oq = /* @__PURE__ */ Q({
  ...nq,
  props: tq,
  setup(e) {
    const t = e, n = nt("descriptions"), o = Mo(), l = Yn();
    Mt(Zy, t);
    const a = x(() => [n.b(), n.m(o.value)]), r = (s, u, d, f = !1) => (s.props || (s.props = {}), u > d && (s.props.span = d), f && (s.props.span = u), s), i = () => {
      if (!l.default)
        return [];
      const s = bs(l.default()).filter((h) => {
        var m;
        return ((m = h == null ? void 0 : h.type) == null ? void 0 : m.name) === "ElDescriptionsItem";
      }), u = [];
      let d = [], f = t.column, v = 0;
      return s.forEach((h, m) => {
        var p;
        const C = ((p = h.props) == null ? void 0 : p.span) || 1;
        if (m < s.length - 1 && (v += C > f ? f : C), m === s.length - 1) {
          const g = t.column - v % t.column;
          d.push(r(h, g, f, !0)), u.push(d);
          return;
        }
        C < f ? (f -= C, d.push(h)) : (d.push(r(h, C, f)), u.push(d), f = t.column, d = []);
      }), u;
    };
    return (s, u) => (M(), G("div", {
      class: z(c(a))
    }, [
      s.title || s.extra || s.$slots.title || s.$slots.extra ? (M(), G("div", {
        key: 0,
        class: z(c(n).e("header"))
      }, [
        X("div", {
          class: z(c(n).e("title"))
        }, [
          Ie(s.$slots, "title", {}, () => [
            Ut(Qe(s.title), 1)
          ])
        ], 2),
        X("div", {
          class: z(c(n).e("extra"))
        }, [
          Ie(s.$slots, "extra", {}, () => [
            Ut(Qe(s.extra), 1)
          ])
        ], 2)
      ], 2)) : _e("v-if", !0),
      X("div", {
        class: z(c(n).e("body"))
      }, [
        X("table", {
          class: z([c(n).e("table"), c(n).is("bordered", s.border)])
        }, [
          X("tbody", null, [
            (M(!0), G(kt, null, ln(i(), (d, f) => (M(), We(eq, {
              key: f,
              row: d
            }, null, 8, ["row"]))), 128))
          ])
        ], 2)
      ], 2)
    ], 2));
  }
});
var lq = /* @__PURE__ */ ut(oq, [["__file", "description.vue"]]);
const aq = it({
  label: {
    type: String,
    default: ""
  },
  span: {
    type: Number,
    default: 1
  },
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  align: {
    type: String,
    default: "left"
  },
  labelAlign: {
    type: String,
    default: ""
  },
  className: {
    type: String,
    default: ""
  },
  labelClassName: {
    type: String,
    default: ""
  }
}), y$ = Q({
  name: "ElDescriptionsItem",
  props: aq
}), rq = Yt(lq, {
  DescriptionsItem: y$
}), sq = Jn(y$), iq = it({
  mask: {
    type: Boolean,
    default: !0
  },
  customMaskEvent: {
    type: Boolean,
    default: !1
  },
  overlayClass: {
    type: Ae([
      String,
      Array,
      Object
    ])
  },
  zIndex: {
    type: Ae([String, Number])
  }
}), cq = {
  click: (e) => e instanceof MouseEvent
}, uq = "overlay";
var dq = Q({
  name: "ElOverlay",
  props: iq,
  emits: cq,
  setup(e, { slots: t, emit: n }) {
    const o = nt(uq), l = (s) => {
      n("click", s);
    }, { onClick: a, onMousedown: r, onMouseup: i } = Ty(e.customMaskEvent ? void 0 : l);
    return () => e.mask ? oe("div", {
      class: [o.b(), e.overlayClass],
      style: {
        zIndex: e.zIndex
      },
      onClick: a,
      onMousedown: r,
      onMouseup: i
    }, [Ie(t, "default")], fa.STYLE | fa.CLASS | fa.PROPS, ["onClick", "onMouseup", "onMousedown"]) : V("div", {
      class: e.overlayClass,
      style: {
        zIndex: e.zIndex,
        position: "fixed",
        top: "0px",
        right: "0px",
        bottom: "0px",
        left: "0px"
      }
    }, [Ie(t, "default")]);
  }
});
const Jy = dq, C$ = Symbol("dialogInjectionKey"), w$ = it({
  center: Boolean,
  alignCenter: Boolean,
  closeIcon: {
    type: Dn
  },
  draggable: Boolean,
  overflow: Boolean,
  fullscreen: Boolean,
  showClose: {
    type: Boolean,
    default: !0
  },
  title: {
    type: String,
    default: ""
  },
  ariaLevel: {
    type: String,
    default: "2"
  }
}), fq = {
  close: () => !0
}, pq = ["aria-level"], vq = ["aria-label"], hq = ["id"], mq = Q({ name: "ElDialogContent" }), gq = /* @__PURE__ */ Q({
  ...mq,
  props: w$,
  emits: fq,
  setup(e) {
    const t = e, { t: n } = bn(), { Close: o } = fy, { dialogRef: l, headerRef: a, bodyId: r, ns: i, style: s } = ot(C$), { focusTrapRef: u } = ot(Vy), d = x(() => [
      i.b(),
      i.is("fullscreen", t.fullscreen),
      i.is("draggable", t.draggable),
      i.is("align-center", t.alignCenter),
      { [i.m("center")]: t.center }
    ]), f = Dv(u, l), v = x(() => t.draggable), h = x(() => t.overflow);
    return nk(l, a, v, h), (m, p) => (M(), G("div", {
      ref: c(f),
      class: z(c(d)),
      style: bt(c(s)),
      tabindex: "-1"
    }, [
      X("header", {
        ref_key: "headerRef",
        ref: a,
        class: z([c(i).e("header"), { "show-close": m.showClose }])
      }, [
        Ie(m.$slots, "header", {}, () => [
          X("span", {
            role: "heading",
            "aria-level": m.ariaLevel,
            class: z(c(i).e("title"))
          }, Qe(m.title), 11, pq)
        ]),
        m.showClose ? (M(), G("button", {
          key: 0,
          "aria-label": c(n)("el.dialog.close"),
          class: z(c(i).e("headerbtn")),
          type: "button",
          onClick: p[0] || (p[0] = (C) => m.$emit("close"))
        }, [
          oe(c(Ct), {
            class: z(c(i).e("close"))
          }, {
            default: fe(() => [
              (M(), We(Qt(m.closeIcon || c(o))))
            ]),
            _: 1
          }, 8, ["class"])
        ], 10, vq)) : _e("v-if", !0)
      ], 2),
      X("div", {
        id: c(r),
        class: z(c(i).e("body"))
      }, [
        Ie(m.$slots, "default")
      ], 10, hq),
      m.$slots.footer ? (M(), G("footer", {
        key: 0,
        class: z(c(i).e("footer"))
      }, [
        Ie(m.$slots, "footer")
      ], 2)) : _e("v-if", !0)
    ], 6));
  }
});
var bq = /* @__PURE__ */ ut(gq, [["__file", "dialog-content.vue"]]);
const E$ = it({
  ...w$,
  appendToBody: Boolean,
  appendTo: {
    type: Ae(String),
    default: "body"
  },
  beforeClose: {
    type: Ae(Function)
  },
  destroyOnClose: Boolean,
  closeOnClickModal: {
    type: Boolean,
    default: !0
  },
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  lockScroll: {
    type: Boolean,
    default: !0
  },
  modal: {
    type: Boolean,
    default: !0
  },
  openDelay: {
    type: Number,
    default: 0
  },
  closeDelay: {
    type: Number,
    default: 0
  },
  top: {
    type: String
  },
  modelValue: Boolean,
  modalClass: String,
  width: {
    type: [String, Number]
  },
  zIndex: {
    type: Number
  },
  trapFocus: {
    type: Boolean,
    default: !1
  },
  headerAriaLevel: {
    type: String,
    default: "2"
  }
}), S$ = {
  open: () => !0,
  opened: () => !0,
  close: () => !0,
  closed: () => !0,
  [Jt]: (e) => $o(e),
  openAutoFocus: () => !0,
  closeAutoFocus: () => !0
}, _$ = (e, t) => {
  var n;
  const l = Pt().emit, { nextZIndex: a } = au();
  let r = "";
  const i = il(), s = il(), u = B(!1), d = B(!1), f = B(!1), v = B((n = e.zIndex) != null ? n : a());
  let h, m;
  const p = df("namespace", Gu), C = x(() => {
    const W = {}, A = `--${p.value}-dialog`;
    return e.fullscreen || (e.top && (W[`${A}-margin-top`] = e.top), e.width && (W[`${A}-width`] = po(e.width))), W;
  }), g = x(() => e.alignCenter ? { display: "flex" } : {});
  function w() {
    l("opened");
  }
  function b() {
    l("closed"), l(Jt, !1), e.destroyOnClose && (f.value = !1);
  }
  function y() {
    l("close");
  }
  function E() {
    m == null || m(), h == null || h(), e.openDelay && e.openDelay > 0 ? { stop: h } = ki(() => N(), e.openDelay) : N();
  }
  function S() {
    h == null || h(), m == null || m(), e.closeDelay && e.closeDelay > 0 ? { stop: m } = ki(() => L(), e.closeDelay) : L();
  }
  function _() {
    function W(A) {
      A || (d.value = !0, u.value = !1);
    }
    e.beforeClose ? e.beforeClose(W) : S();
  }
  function k() {
    e.closeOnClickModal && _();
  }
  function N() {
    fn && (u.value = !0);
  }
  function L() {
    u.value = !1;
  }
  function R() {
    l("openAutoFocus");
  }
  function H() {
    l("closeAutoFocus");
  }
  function K(W) {
    var A;
    ((A = W.detail) == null ? void 0 : A.focusReason) === "pointer" && W.preventDefault();
  }
  e.lockScroll && by(u);
  function U() {
    e.closeOnPressEscape && _();
  }
  return Pe(() => e.modelValue, (W) => {
    W ? (d.value = !1, E(), f.value = !0, v.value = Hx(e.zIndex) ? a() : v.value++, xe(() => {
      l("open"), t.value && (t.value.scrollTop = 0);
    })) : u.value && S();
  }), Pe(() => e.fullscreen, (W) => {
    t.value && (W ? (r = t.value.style.transform, t.value.style.transform = "") : t.value.style.transform = r);
  }), Nt(() => {
    e.modelValue && (u.value = !0, f.value = !0, E());
  }), {
    afterEnter: w,
    afterLeave: b,
    beforeLeave: y,
    handleClose: _,
    onModalClick: k,
    close: S,
    doClose: L,
    onOpenAutoFocus: R,
    onCloseAutoFocus: H,
    onCloseRequested: U,
    onFocusoutPrevented: K,
    titleId: i,
    bodyId: s,
    closed: d,
    style: C,
    overlayDialogStyle: g,
    rendered: f,
    visible: u,
    zIndex: v
  };
}, yq = ["aria-label", "aria-labelledby", "aria-describedby"], Cq = Q({
  name: "ElDialog",
  inheritAttrs: !1
}), wq = /* @__PURE__ */ Q({
  ...Cq,
  props: E$,
  emits: S$,
  setup(e, { expose: t }) {
    const n = e, o = Yn();
    Ho({
      scope: "el-dialog",
      from: "the title slot",
      replacement: "the header slot",
      version: "3.0.0",
      ref: "https://element-plus.org/en-US/component/dialog.html#slots"
    }, x(() => !!o.title));
    const l = nt("dialog"), a = B(), r = B(), i = B(), {
      visible: s,
      titleId: u,
      bodyId: d,
      style: f,
      overlayDialogStyle: v,
      rendered: h,
      zIndex: m,
      afterEnter: p,
      afterLeave: C,
      beforeLeave: g,
      handleClose: w,
      onModalClick: b,
      onOpenAutoFocus: y,
      onCloseAutoFocus: E,
      onCloseRequested: S,
      onFocusoutPrevented: _
    } = _$(n, a);
    Mt(C$, {
      dialogRef: a,
      headerRef: r,
      bodyId: d,
      ns: l,
      rendered: h,
      style: f
    });
    const k = Ty(b), N = x(() => n.draggable && !n.fullscreen);
    return t({
      visible: s,
      dialogContentRef: i
    }), (L, R) => (M(), We(ka, {
      to: L.appendTo,
      disabled: L.appendTo !== "body" ? !1 : !L.appendToBody
    }, [
      oe(Ko, {
        name: "dialog-fade",
        onAfterEnter: c(p),
        onAfterLeave: c(C),
        onBeforeLeave: c(g),
        persisted: ""
      }, {
        default: fe(() => [
          Bt(oe(c(Jy), {
            "custom-mask-event": "",
            mask: L.modal,
            "overlay-class": L.modalClass,
            "z-index": c(m)
          }, {
            default: fe(() => [
              X("div", {
                role: "dialog",
                "aria-modal": "true",
                "aria-label": L.title || void 0,
                "aria-labelledby": L.title ? void 0 : c(u),
                "aria-describedby": c(d),
                class: z(`${c(l).namespace.value}-overlay-dialog`),
                style: bt(c(v)),
                onClick: R[0] || (R[0] = (...H) => c(k).onClick && c(k).onClick(...H)),
                onMousedown: R[1] || (R[1] = (...H) => c(k).onMousedown && c(k).onMousedown(...H)),
                onMouseup: R[2] || (R[2] = (...H) => c(k).onMouseup && c(k).onMouseup(...H))
              }, [
                oe(c(pf), {
                  loop: "",
                  trapped: c(s),
                  "focus-start-el": "container",
                  onFocusAfterTrapped: c(y),
                  onFocusAfterReleased: c(E),
                  onFocusoutPrevented: c(_),
                  onReleaseRequested: c(S)
                }, {
                  default: fe(() => [
                    c(h) ? (M(), We(bq, Et({
                      key: 0,
                      ref_key: "dialogContentRef",
                      ref: i
                    }, L.$attrs, {
                      center: L.center,
                      "align-center": L.alignCenter,
                      "close-icon": L.closeIcon,
                      draggable: c(N),
                      overflow: L.overflow,
                      fullscreen: L.fullscreen,
                      "show-close": L.showClose,
                      title: L.title,
                      "aria-level": L.headerAriaLevel,
                      onClose: c(w)
                    }), rl({
                      header: fe(() => [
                        L.$slots.title ? Ie(L.$slots, "title", { key: 1 }) : Ie(L.$slots, "header", {
                          key: 0,
                          close: c(w),
                          titleId: c(u),
                          titleClass: c(l).e("title")
                        })
                      ]),
                      default: fe(() => [
                        Ie(L.$slots, "default")
                      ]),
                      _: 2
                    }, [
                      L.$slots.footer ? {
                        name: "footer",
                        fn: fe(() => [
                          Ie(L.$slots, "footer")
                        ])
                      } : void 0
                    ]), 1040, ["center", "align-center", "close-icon", "draggable", "overflow", "fullscreen", "show-close", "title", "aria-level", "onClose"])) : _e("v-if", !0)
                  ]),
                  _: 3
                }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
              ], 46, yq)
            ]),
            _: 3
          }, 8, ["mask", "overlay-class", "z-index"]), [
            [pn, c(s)]
          ])
        ]),
        _: 3
      }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
    ], 8, ["to", "disabled"]));
  }
});
var Eq = /* @__PURE__ */ ut(wq, [["__file", "dialog.vue"]]);
const x$ = Yt(Eq), Sq = it({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  contentPosition: {
    type: String,
    values: ["left", "center", "right"],
    default: "center"
  },
  borderStyle: {
    type: Ae(String),
    default: "solid"
  }
}), _q = Q({
  name: "ElDivider"
}), xq = /* @__PURE__ */ Q({
  ..._q,
  props: Sq,
  setup(e) {
    const t = e, n = nt("divider"), o = x(() => n.cssVar({
      "border-style": t.borderStyle
    }));
    return (l, a) => (M(), G("div", {
      class: z([c(n).b(), c(n).m(l.direction)]),
      style: bt(c(o)),
      role: "separator"
    }, [
      l.$slots.default && l.direction !== "vertical" ? (M(), G("div", {
        key: 0,
        class: z([c(n).e("text"), c(n).is(l.contentPosition)])
      }, [
        Ie(l.$slots, "default")
      ], 2)) : _e("v-if", !0)
    ], 6));
  }
});
var kq = /* @__PURE__ */ ut(xq, [["__file", "divider.vue"]]);
const k$ = Yt(kq), Tq = it({
  ...E$,
  direction: {
    type: String,
    default: "rtl",
    values: ["ltr", "rtl", "ttb", "btt"]
  },
  size: {
    type: [String, Number],
    default: "30%"
  },
  withHeader: {
    type: Boolean,
    default: !0
  },
  modalFade: {
    type: Boolean,
    default: !0
  },
  headerAriaLevel: {
    type: String,
    default: "2"
  }
}), $q = S$, Oq = ["aria-label", "aria-labelledby", "aria-describedby"], Nq = ["id", "aria-level"], Mq = ["aria-label"], Iq = ["id"], Rq = Q({
  name: "ElDrawer",
  inheritAttrs: !1
}), Dq = /* @__PURE__ */ Q({
  ...Rq,
  props: Tq,
  emits: $q,
  setup(e, { expose: t }) {
    const n = e, o = Yn();
    Ho({
      scope: "el-drawer",
      from: "the title slot",
      replacement: "the header slot",
      version: "3.0.0",
      ref: "https://element-plus.org/en-US/component/drawer.html#slots"
    }, x(() => !!o.title));
    const l = B(), a = B(), r = nt("drawer"), { t: i } = bn(), {
      afterEnter: s,
      afterLeave: u,
      beforeLeave: d,
      visible: f,
      rendered: v,
      titleId: h,
      bodyId: m,
      zIndex: p,
      onModalClick: C,
      onOpenAutoFocus: g,
      onCloseAutoFocus: w,
      onFocusoutPrevented: b,
      onCloseRequested: y,
      handleClose: E
    } = _$(n, l), S = x(() => n.direction === "rtl" || n.direction === "ltr"), _ = x(() => po(n.size));
    return t({
      handleClose: E,
      afterEnter: s,
      afterLeave: u
    }), (k, N) => (M(), We(ka, {
      to: "body",
      disabled: !k.appendToBody
    }, [
      oe(Ko, {
        name: c(r).b("fade"),
        onAfterEnter: c(s),
        onAfterLeave: c(u),
        onBeforeLeave: c(d),
        persisted: ""
      }, {
        default: fe(() => [
          Bt(oe(c(Jy), {
            mask: k.modal,
            "overlay-class": k.modalClass,
            "z-index": c(p),
            onClick: c(C)
          }, {
            default: fe(() => [
              oe(c(pf), {
                loop: "",
                trapped: c(f),
                "focus-trap-el": l.value,
                "focus-start-el": a.value,
                onFocusAfterTrapped: c(g),
                onFocusAfterReleased: c(w),
                onFocusoutPrevented: c(b),
                onReleaseRequested: c(y)
              }, {
                default: fe(() => [
                  X("div", Et({
                    ref_key: "drawerRef",
                    ref: l,
                    "aria-modal": "true",
                    "aria-label": k.title || void 0,
                    "aria-labelledby": k.title ? void 0 : c(h),
                    "aria-describedby": c(m)
                  }, k.$attrs, {
                    class: [c(r).b(), k.direction, c(f) && "open"],
                    style: c(S) ? "width: " + c(_) : "height: " + c(_),
                    role: "dialog",
                    onClick: N[1] || (N[1] = It(() => {
                    }, ["stop"]))
                  }), [
                    X("span", {
                      ref_key: "focusStartRef",
                      ref: a,
                      class: z(c(r).e("sr-focus")),
                      tabindex: "-1"
                    }, null, 2),
                    k.withHeader ? (M(), G("header", {
                      key: 0,
                      class: z(c(r).e("header"))
                    }, [
                      k.$slots.title ? Ie(k.$slots, "title", { key: 1 }, () => [
                        _e(" DEPRECATED SLOT ")
                      ]) : Ie(k.$slots, "header", {
                        key: 0,
                        close: c(E),
                        titleId: c(h),
                        titleClass: c(r).e("title")
                      }, () => [
                        k.$slots.title ? _e("v-if", !0) : (M(), G("span", {
                          key: 0,
                          id: c(h),
                          role: "heading",
                          "aria-level": k.headerAriaLevel,
                          class: z(c(r).e("title"))
                        }, Qe(k.title), 11, Nq))
                      ]),
                      k.showClose ? (M(), G("button", {
                        key: 2,
                        "aria-label": c(i)("el.drawer.close"),
                        class: z(c(r).e("close-btn")),
                        type: "button",
                        onClick: N[0] || (N[0] = (...L) => c(E) && c(E)(...L))
                      }, [
                        oe(c(Ct), {
                          class: z(c(r).e("close"))
                        }, {
                          default: fe(() => [
                            oe(c(Fa))
                          ]),
                          _: 1
                        }, 8, ["class"])
                      ], 10, Mq)) : _e("v-if", !0)
                    ], 2)) : _e("v-if", !0),
                    c(v) ? (M(), G("div", {
                      key: 1,
                      id: c(m),
                      class: z(c(r).e("body"))
                    }, [
                      Ie(k.$slots, "default")
                    ], 10, Iq)) : _e("v-if", !0),
                    k.$slots.footer ? (M(), G("div", {
                      key: 2,
                      class: z(c(r).e("footer"))
                    }, [
                      Ie(k.$slots, "footer")
                    ], 2)) : _e("v-if", !0)
                  ], 16, Oq)
                ]),
                _: 3
              }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
            ]),
            _: 3
          }, 8, ["mask", "overlay-class", "z-index", "onClick"]), [
            [pn, c(f)]
          ])
        ]),
        _: 3
      }, 8, ["name", "onAfterEnter", "onAfterLeave", "onBeforeLeave"])
    ], 8, ["disabled"]));
  }
});
var Lq = /* @__PURE__ */ ut(Dq, [["__file", "drawer.vue"]]);
const T$ = Yt(Lq), Pq = /* @__PURE__ */ Q({
  inheritAttrs: !1
});
function Aq(e, t, n, o, l, a) {
  return Ie(e.$slots, "default");
}
var Fq = /* @__PURE__ */ ut(Pq, [["render", Aq], ["__file", "collection.vue"]]);
const Vq = /* @__PURE__ */ Q({
  name: "ElCollectionItem",
  inheritAttrs: !1
});
function Bq(e, t, n, o, l, a) {
  return Ie(e.$slots, "default");
}
var Hq = /* @__PURE__ */ ut(Vq, [["render", Bq], ["__file", "collection-item.vue"]]);
const $$ = "data-el-collection-item", O$ = (e) => {
  const t = `El${e}Collection`, n = `${t}Item`, o = Symbol(t), l = Symbol(n), a = {
    ...Fq,
    name: t,
    setup() {
      const i = B(null), s = /* @__PURE__ */ new Map();
      Mt(o, {
        itemMap: s,
        getItems: () => {
          const d = c(i);
          if (!d)
            return [];
          const f = Array.from(d.querySelectorAll(`[${$$}]`));
          return [...s.values()].sort((h, m) => f.indexOf(h.ref) - f.indexOf(m.ref));
        },
        collectionRef: i
      });
    }
  }, r = {
    ...Hq,
    name: n,
    setup(i, { attrs: s }) {
      const u = B(null), d = ot(o, void 0);
      Mt(l, {
        collectionItemRef: u
      }), Nt(() => {
        const f = c(u);
        f && d.itemMap.set(f, {
          ref: f,
          ...s
        });
      }), zn(() => {
        const f = c(u);
        d.itemMap.delete(f);
      });
    }
  };
  return {
    COLLECTION_INJECTION_KEY: o,
    COLLECTION_ITEM_INJECTION_KEY: l,
    ElCollection: a,
    ElCollectionItem: r
  };
}, zq = it({
  style: { type: Ae([String, Array, Object]) },
  currentTabId: {
    type: Ae(String)
  },
  defaultCurrentTabId: String,
  loop: Boolean,
  dir: {
    type: String,
    values: ["ltr", "rtl"],
    default: "ltr"
  },
  orientation: {
    type: Ae(String)
  },
  onBlur: Function,
  onFocus: Function,
  onMousedown: Function
}), {
  ElCollection: Wq,
  ElCollectionItem: Kq,
  COLLECTION_INJECTION_KEY: Qy,
  COLLECTION_ITEM_INJECTION_KEY: Uq
} = O$("RovingFocusGroup"), e0 = Symbol("elRovingFocusGroup"), N$ = Symbol("elRovingFocusGroupItem"), jq = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
}, qq = (e, t) => {
  if (t !== "rtl")
    return e;
  switch (e) {
    case xt.right:
      return xt.left;
    case xt.left:
      return xt.right;
    default:
      return e;
  }
}, Yq = (e, t, n) => {
  const o = qq(e.key, n);
  if (!(t === "vertical" && [xt.left, xt.right].includes(o)) && !(t === "horizontal" && [xt.up, xt.down].includes(o)))
    return jq[o];
}, Gq = (e, t) => e.map((n, o) => e[(o + t) % e.length]), t0 = (e) => {
  const { activeElement: t } = document;
  for (const n of e)
    if (n === t || (n.focus(), t !== document.activeElement))
      return;
}, sE = "currentTabIdChange", iE = "rovingFocusGroup.entryFocus", Xq = { bubbles: !1, cancelable: !0 }, Zq = Q({
  name: "ElRovingFocusGroupImpl",
  inheritAttrs: !1,
  props: zq,
  emits: [sE, "entryFocus"],
  setup(e, { emit: t }) {
    var n;
    const o = B((n = e.currentTabId || e.defaultCurrentTabId) != null ? n : null), l = B(!1), a = B(!1), r = B(null), { getItems: i } = ot(Qy, void 0), s = x(() => [
      {
        outline: "none"
      },
      e.style
    ]), u = (p) => {
      t(sE, p);
    }, d = () => {
      l.value = !0;
    }, f = uo((p) => {
      var C;
      (C = e.onMousedown) == null || C.call(e, p);
    }, () => {
      a.value = !0;
    }), v = uo((p) => {
      var C;
      (C = e.onFocus) == null || C.call(e, p);
    }, (p) => {
      const C = !c(a), { target: g, currentTarget: w } = p;
      if (g === w && C && !c(l)) {
        const b = new Event(iE, Xq);
        if (w == null || w.dispatchEvent(b), !b.defaultPrevented) {
          const y = i().filter((N) => N.focusable), E = y.find((N) => N.active), S = y.find((N) => N.id === c(o)), k = [E, S, ...y].filter(Boolean).map((N) => N.ref);
          t0(k);
        }
      }
      a.value = !1;
    }), h = uo((p) => {
      var C;
      (C = e.onBlur) == null || C.call(e, p);
    }, () => {
      l.value = !1;
    }), m = (...p) => {
      t("entryFocus", ...p);
    };
    Mt(e0, {
      currentTabbedId: Ev(o),
      loop: Pn(e, "loop"),
      tabIndex: x(() => c(l) ? -1 : 0),
      rovingFocusGroupRef: r,
      rovingFocusGroupRootStyle: s,
      orientation: Pn(e, "orientation"),
      dir: Pn(e, "dir"),
      onItemFocus: u,
      onItemShiftTab: d,
      onBlur: h,
      onFocus: v,
      onMousedown: f
    }), Pe(() => e.currentTabId, (p) => {
      o.value = p ?? null;
    }), jn(r, iE, m);
  }
});
function Jq(e, t, n, o, l, a) {
  return Ie(e.$slots, "default");
}
var Qq = /* @__PURE__ */ ut(Zq, [["render", Jq], ["__file", "roving-focus-group-impl.vue"]]);
const eY = Q({
  name: "ElRovingFocusGroup",
  components: {
    ElFocusGroupCollection: Wq,
    ElRovingFocusGroupImpl: Qq
  }
});
function tY(e, t, n, o, l, a) {
  const r = Dt("el-roving-focus-group-impl"), i = Dt("el-focus-group-collection");
  return M(), We(i, null, {
    default: fe(() => [
      oe(r, xo(Ao(e.$attrs)), {
        default: fe(() => [
          Ie(e.$slots, "default")
        ]),
        _: 3
      }, 16)
    ]),
    _: 3
  });
}
var nY = /* @__PURE__ */ ut(eY, [["render", tY], ["__file", "roving-focus-group.vue"]]);
const oY = Q({
  components: {
    ElRovingFocusCollectionItem: Kq
  },
  props: {
    focusable: {
      type: Boolean,
      default: !0
    },
    active: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["mousedown", "focus", "keydown"],
  setup(e, { emit: t }) {
    const { currentTabbedId: n, loop: o, onItemFocus: l, onItemShiftTab: a } = ot(e0, void 0), { getItems: r } = ot(Qy, void 0), i = il(), s = B(null), u = uo((h) => {
      t("mousedown", h);
    }, (h) => {
      e.focusable ? l(c(i)) : h.preventDefault();
    }), d = uo((h) => {
      t("focus", h);
    }, () => {
      l(c(i));
    }), f = uo((h) => {
      t("keydown", h);
    }, (h) => {
      const { key: m, shiftKey: p, target: C, currentTarget: g } = h;
      if (m === xt.tab && p) {
        a();
        return;
      }
      if (C !== g)
        return;
      const w = Yq(h);
      if (w) {
        h.preventDefault();
        let y = r().filter((E) => E.focusable).map((E) => E.ref);
        switch (w) {
          case "last": {
            y.reverse();
            break;
          }
          case "prev":
          case "next": {
            w === "prev" && y.reverse();
            const E = y.indexOf(g);
            y = o.value ? Gq(y, E + 1) : y.slice(E + 1);
            break;
          }
        }
        xe(() => {
          t0(y);
        });
      }
    }), v = x(() => n.value === c(i));
    return Mt(N$, {
      rovingFocusGroupItemRef: s,
      tabIndex: x(() => c(v) ? 0 : -1),
      handleMousedown: u,
      handleFocus: d,
      handleKeydown: f
    }), {
      id: i,
      handleKeydown: f,
      handleFocus: d,
      handleMousedown: u
    };
  }
});
function lY(e, t, n, o, l, a) {
  const r = Dt("el-roving-focus-collection-item");
  return M(), We(r, {
    id: e.id,
    focusable: e.focusable,
    active: e.active
  }, {
    default: fe(() => [
      Ie(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["id", "focusable", "active"]);
}
var aY = /* @__PURE__ */ ut(oY, [["render", lY], ["__file", "roving-focus-item.vue"]]);
const $p = it({
  trigger: Ld.trigger,
  effect: {
    ...Fo.effect,
    default: "light"
  },
  type: {
    type: Ae(String)
  },
  placement: {
    type: Ae(String),
    default: "bottom"
  },
  popperOptions: {
    type: Ae(Object),
    default: () => ({})
  },
  id: String,
  size: {
    type: String,
    default: ""
  },
  splitButton: Boolean,
  hideOnClick: {
    type: Boolean,
    default: !0
  },
  loop: {
    type: Boolean,
    default: !0
  },
  showTimeout: {
    type: Number,
    default: 150
  },
  hideTimeout: {
    type: Number,
    default: 150
  },
  tabindex: {
    type: Ae([Number, String]),
    default: 0
  },
  maxHeight: {
    type: Ae([Number, String]),
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  role: {
    type: String,
    default: "menu"
  },
  buttonProps: {
    type: Ae(Object)
  },
  teleported: Fo.teleported
}), M$ = it({
  command: {
    type: [Object, String, Number],
    default: () => ({})
  },
  disabled: Boolean,
  divided: Boolean,
  textValue: String,
  icon: {
    type: Dn
  }
}), rY = it({
  onKeydown: { type: Ae(Function) }
}), sY = [
  xt.down,
  xt.pageDown,
  xt.home
], I$ = [xt.up, xt.pageUp, xt.end], iY = [...sY, ...I$], {
  ElCollection: cY,
  ElCollectionItem: uY,
  COLLECTION_INJECTION_KEY: dY,
  COLLECTION_ITEM_INJECTION_KEY: fY
} = O$("Dropdown"), qv = Symbol("elDropdown"), { ButtonGroup: pY } = Do, vY = Q({
  name: "ElDropdown",
  components: {
    ElButton: Do,
    ElButtonGroup: pY,
    ElScrollbar: zr,
    ElDropdownCollection: cY,
    ElTooltip: hl,
    ElRovingFocusGroup: nY,
    ElOnlyChild: Jk,
    ElIcon: Ct,
    ArrowDown: Br
  },
  props: $p,
  emits: ["visible-change", "click", "command"],
  setup(e, { emit: t }) {
    const n = Pt(), o = nt("dropdown"), { t: l } = bn(), a = B(), r = B(), i = B(null), s = B(null), u = B(null), d = B(null), f = B(!1), v = [xt.enter, xt.space, xt.down], h = x(() => ({
      maxHeight: po(e.maxHeight)
    })), m = x(() => [o.m(E.value)]), p = x(() => _s(e.trigger)), C = il().value, g = x(() => e.id || C);
    Pe([a, p], ([$, D], [O]) => {
      var F, j, Z;
      (F = O == null ? void 0 : O.$el) != null && F.removeEventListener && O.$el.removeEventListener("pointerenter", _), (j = $ == null ? void 0 : $.$el) != null && j.removeEventListener && $.$el.removeEventListener("pointerenter", _), (Z = $ == null ? void 0 : $.$el) != null && Z.addEventListener && D.includes("hover") && $.$el.addEventListener("pointerenter", _);
    }, { immediate: !0 }), zn(() => {
      var $, D;
      (D = ($ = a.value) == null ? void 0 : $.$el) != null && D.removeEventListener && a.value.$el.removeEventListener("pointerenter", _);
    });
    function w() {
      b();
    }
    function b() {
      var $;
      ($ = i.value) == null || $.onClose();
    }
    function y() {
      var $;
      ($ = i.value) == null || $.onOpen();
    }
    const E = Mo();
    function S(...$) {
      t("command", ...$);
    }
    function _() {
      var $, D;
      (D = ($ = a.value) == null ? void 0 : $.$el) == null || D.focus();
    }
    function k() {
    }
    function N() {
      const $ = c(s);
      p.value.includes("hover") && ($ == null || $.focus()), d.value = null;
    }
    function L($) {
      d.value = $;
    }
    function R($) {
      f.value || ($.preventDefault(), $.stopImmediatePropagation());
    }
    function H() {
      t("visible-change", !0);
    }
    function K($) {
      ($ == null ? void 0 : $.type) === "keydown" && s.value.focus();
    }
    function U() {
      t("visible-change", !1);
    }
    return Mt(qv, {
      contentRef: s,
      role: x(() => e.role),
      triggerId: g,
      isUsingKeyboard: f,
      onItemEnter: k,
      onItemLeave: N
    }), Mt("elDropdown", {
      instance: n,
      dropdownSize: E,
      handleClick: w,
      commandHandler: S,
      trigger: Pn(e, "trigger"),
      hideOnClick: Pn(e, "hideOnClick")
    }), {
      t: l,
      ns: o,
      scrollbar: u,
      wrapStyle: h,
      dropdownTriggerKls: m,
      dropdownSize: E,
      triggerId: g,
      triggerKeys: v,
      currentTabId: d,
      handleCurrentTabIdChange: L,
      handlerMainButtonClick: ($) => {
        t("click", $);
      },
      handleEntryFocus: R,
      handleClose: b,
      handleOpen: y,
      handleBeforeShowTooltip: H,
      handleShowTooltip: K,
      handleBeforeHideTooltip: U,
      onFocusAfterTrapped: ($) => {
        var D, O;
        $.preventDefault(), (O = (D = s.value) == null ? void 0 : D.focus) == null || O.call(D, {
          preventScroll: !0
        });
      },
      popperRef: i,
      contentRef: s,
      triggeringElementRef: a,
      referenceElementRef: r
    };
  }
});
function hY(e, t, n, o, l, a) {
  var r;
  const i = Dt("el-dropdown-collection"), s = Dt("el-roving-focus-group"), u = Dt("el-scrollbar"), d = Dt("el-only-child"), f = Dt("el-tooltip"), v = Dt("el-button"), h = Dt("arrow-down"), m = Dt("el-icon"), p = Dt("el-button-group");
  return M(), G("div", {
    class: z([e.ns.b(), e.ns.is("disabled", e.disabled)])
  }, [
    oe(f, {
      ref: "popperRef",
      role: e.role,
      effect: e.effect,
      "fallback-placements": ["bottom", "top"],
      "popper-options": e.popperOptions,
      "gpu-acceleration": !1,
      "hide-after": e.trigger === "hover" ? e.hideTimeout : 0,
      "manual-mode": !0,
      placement: e.placement,
      "popper-class": [e.ns.e("popper"), e.popperClass],
      "reference-element": (r = e.referenceElementRef) == null ? void 0 : r.$el,
      trigger: e.trigger,
      "trigger-keys": e.triggerKeys,
      "trigger-target-el": e.contentRef,
      "show-after": e.trigger === "hover" ? e.showTimeout : 0,
      "stop-popper-mouse-event": !1,
      "virtual-ref": e.triggeringElementRef,
      "virtual-triggering": e.splitButton,
      disabled: e.disabled,
      transition: `${e.ns.namespace.value}-zoom-in-top`,
      teleported: e.teleported,
      pure: "",
      persistent: "",
      onBeforeShow: e.handleBeforeShowTooltip,
      onShow: e.handleShowTooltip,
      onBeforeHide: e.handleBeforeHideTooltip
    }, rl({
      content: fe(() => [
        oe(u, {
          ref: "scrollbar",
          "wrap-style": e.wrapStyle,
          tag: "div",
          "view-class": e.ns.e("list")
        }, {
          default: fe(() => [
            oe(s, {
              loop: e.loop,
              "current-tab-id": e.currentTabId,
              orientation: "horizontal",
              onCurrentTabIdChange: e.handleCurrentTabIdChange,
              onEntryFocus: e.handleEntryFocus
            }, {
              default: fe(() => [
                oe(i, null, {
                  default: fe(() => [
                    Ie(e.$slots, "dropdown")
                  ]),
                  _: 3
                })
              ]),
              _: 3
            }, 8, ["loop", "current-tab-id", "onCurrentTabIdChange", "onEntryFocus"])
          ]),
          _: 3
        }, 8, ["wrap-style", "view-class"])
      ]),
      _: 2
    }, [
      e.splitButton ? void 0 : {
        name: "default",
        fn: fe(() => [
          oe(d, {
            id: e.triggerId,
            ref: "triggeringElementRef",
            role: "button",
            tabindex: e.tabindex
          }, {
            default: fe(() => [
              Ie(e.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "tabindex"])
        ])
      }
    ]), 1032, ["role", "effect", "popper-options", "hide-after", "placement", "popper-class", "reference-element", "trigger", "trigger-keys", "trigger-target-el", "show-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "teleported", "onBeforeShow", "onShow", "onBeforeHide"]),
    e.splitButton ? (M(), We(p, { key: 0 }, {
      default: fe(() => [
        oe(v, Et({ ref: "referenceElementRef" }, e.buttonProps, {
          size: e.dropdownSize,
          type: e.type,
          disabled: e.disabled,
          tabindex: e.tabindex,
          onClick: e.handlerMainButtonClick
        }), {
          default: fe(() => [
            Ie(e.$slots, "default")
          ]),
          _: 3
        }, 16, ["size", "type", "disabled", "tabindex", "onClick"]),
        oe(v, Et({
          id: e.triggerId,
          ref: "triggeringElementRef"
        }, e.buttonProps, {
          role: "button",
          size: e.dropdownSize,
          type: e.type,
          class: e.ns.e("caret-button"),
          disabled: e.disabled,
          tabindex: e.tabindex,
          "aria-label": e.t("el.dropdown.toggleDropdown")
        }), {
          default: fe(() => [
            oe(m, {
              class: z(e.ns.e("icon"))
            }, {
              default: fe(() => [
                oe(h)
              ]),
              _: 1
            }, 8, ["class"])
          ]),
          _: 1
        }, 16, ["id", "size", "type", "class", "disabled", "tabindex", "aria-label"])
      ]),
      _: 3
    })) : _e("v-if", !0)
  ], 2);
}
var mY = /* @__PURE__ */ ut(vY, [["render", hY], ["__file", "dropdown.vue"]]);
const gY = Q({
  name: "DropdownItemImpl",
  components: {
    ElIcon: Ct
  },
  props: M$,
  emits: ["pointermove", "pointerleave", "click", "clickimpl"],
  setup(e, { emit: t }) {
    const n = nt("dropdown"), { role: o } = ot(qv, void 0), { collectionItemRef: l } = ot(fY, void 0), { collectionItemRef: a } = ot(Uq, void 0), {
      rovingFocusGroupItemRef: r,
      tabIndex: i,
      handleFocus: s,
      handleKeydown: u,
      handleMousedown: d
    } = ot(N$, void 0), f = Dv(l, a, r), v = x(() => o.value === "menu" ? "menuitem" : o.value === "navigation" ? "link" : "button"), h = uo((m) => {
      const { code: p } = m;
      if (p === xt.enter || p === xt.space)
        return m.preventDefault(), m.stopImmediatePropagation(), t("clickimpl", m), !0;
    }, u);
    return {
      ns: n,
      itemRef: f,
      dataset: {
        [$$]: ""
      },
      role: v,
      tabIndex: i,
      handleFocus: s,
      handleKeydown: h,
      handleMousedown: d
    };
  }
}), bY = ["aria-disabled", "tabindex", "role"];
function yY(e, t, n, o, l, a) {
  const r = Dt("el-icon");
  return M(), G(kt, null, [
    e.divided ? (M(), G("li", Et({
      key: 0,
      role: "separator",
      class: e.ns.bem("menu", "item", "divided")
    }, e.$attrs), null, 16)) : _e("v-if", !0),
    X("li", Et({ ref: e.itemRef }, { ...e.dataset, ...e.$attrs }, {
      "aria-disabled": e.disabled,
      class: [e.ns.be("menu", "item"), e.ns.is("disabled", e.disabled)],
      tabindex: e.tabIndex,
      role: e.role,
      onClick: t[0] || (t[0] = (i) => e.$emit("clickimpl", i)),
      onFocus: t[1] || (t[1] = (...i) => e.handleFocus && e.handleFocus(...i)),
      onKeydown: t[2] || (t[2] = It((...i) => e.handleKeydown && e.handleKeydown(...i), ["self"])),
      onMousedown: t[3] || (t[3] = (...i) => e.handleMousedown && e.handleMousedown(...i)),
      onPointermove: t[4] || (t[4] = (i) => e.$emit("pointermove", i)),
      onPointerleave: t[5] || (t[5] = (i) => e.$emit("pointerleave", i))
    }), [
      e.icon ? (M(), We(r, { key: 0 }, {
        default: fe(() => [
          (M(), We(Qt(e.icon)))
        ]),
        _: 1
      })) : _e("v-if", !0),
      Ie(e.$slots, "default")
    ], 16, bY)
  ], 64);
}
var CY = /* @__PURE__ */ ut(gY, [["render", yY], ["__file", "dropdown-item-impl.vue"]]);
const R$ = () => {
  const e = ot("elDropdown", {}), t = x(() => e == null ? void 0 : e.dropdownSize);
  return {
    elDropdown: e,
    _elDropdownSize: t
  };
}, wY = Q({
  name: "ElDropdownItem",
  components: {
    ElDropdownCollectionItem: uY,
    ElRovingFocusItem: aY,
    ElDropdownItemImpl: CY
  },
  inheritAttrs: !1,
  props: M$,
  emits: ["pointermove", "pointerleave", "click"],
  setup(e, { emit: t, attrs: n }) {
    const { elDropdown: o } = R$(), l = Pt(), a = B(null), r = x(() => {
      var h, m;
      return (m = (h = c(a)) == null ? void 0 : h.textContent) != null ? m : "";
    }), { onItemEnter: i, onItemLeave: s } = ot(qv, void 0), u = uo((h) => (t("pointermove", h), h.defaultPrevented), tC((h) => {
      if (e.disabled) {
        s(h);
        return;
      }
      const m = h.currentTarget;
      m === document.activeElement || m.contains(document.activeElement) || (i(h), h.defaultPrevented || m == null || m.focus());
    })), d = uo((h) => (t("pointerleave", h), h.defaultPrevented), tC((h) => {
      s(h);
    })), f = uo((h) => {
      if (!e.disabled)
        return t("click", h), h.type !== "keydown" && h.defaultPrevented;
    }, (h) => {
      var m, p, C;
      if (e.disabled) {
        h.stopImmediatePropagation();
        return;
      }
      (m = o == null ? void 0 : o.hideOnClick) != null && m.value && ((p = o.handleClick) == null || p.call(o)), (C = o.commandHandler) == null || C.call(o, e.command, l, h);
    }), v = x(() => ({ ...e, ...n }));
    return {
      handleClick: f,
      handlePointerMove: u,
      handlePointerLeave: d,
      textContent: r,
      propsAndAttrs: v
    };
  }
});
function EY(e, t, n, o, l, a) {
  var r;
  const i = Dt("el-dropdown-item-impl"), s = Dt("el-roving-focus-item"), u = Dt("el-dropdown-collection-item");
  return M(), We(u, {
    disabled: e.disabled,
    "text-value": (r = e.textValue) != null ? r : e.textContent
  }, {
    default: fe(() => [
      oe(s, {
        focusable: !e.disabled
      }, {
        default: fe(() => [
          oe(i, Et(e.propsAndAttrs, {
            onPointerleave: e.handlePointerLeave,
            onPointermove: e.handlePointerMove,
            onClickimpl: e.handleClick
          }), {
            default: fe(() => [
              Ie(e.$slots, "default")
            ]),
            _: 3
          }, 16, ["onPointerleave", "onPointermove", "onClickimpl"])
        ]),
        _: 3
      }, 8, ["focusable"])
    ]),
    _: 3
  }, 8, ["disabled", "text-value"]);
}
var D$ = /* @__PURE__ */ ut(wY, [["render", EY], ["__file", "dropdown-item.vue"]]);
const SY = Q({
  name: "ElDropdownMenu",
  props: rY,
  setup(e) {
    const t = nt("dropdown"), { _elDropdownSize: n } = R$(), o = n.value, { focusTrapRef: l, onKeydown: a } = ot(Vy, void 0), { contentRef: r, role: i, triggerId: s } = ot(qv, void 0), { collectionRef: u, getItems: d } = ot(dY, void 0), {
      rovingFocusGroupRef: f,
      rovingFocusGroupRootStyle: v,
      tabIndex: h,
      onBlur: m,
      onFocus: p,
      onMousedown: C
    } = ot(e0, void 0), { collectionRef: g } = ot(Qy, void 0), w = x(() => [t.b("menu"), t.bm("menu", o == null ? void 0 : o.value)]), b = Dv(r, u, l, f, g), y = uo((S) => {
      var _;
      (_ = e.onKeydown) == null || _.call(e, S);
    }, (S) => {
      const { currentTarget: _, code: k, target: N } = S;
      if (_.contains(N), xt.tab === k && S.stopImmediatePropagation(), S.preventDefault(), N !== c(r) || !iY.includes(k))
        return;
      const R = d().filter((H) => !H.disabled).map((H) => H.ref);
      I$.includes(k) && R.reverse(), t0(R);
    });
    return {
      size: o,
      rovingFocusGroupRootStyle: v,
      tabIndex: h,
      dropdownKls: w,
      role: i,
      triggerId: s,
      dropdownListWrapperRef: b,
      handleKeydown: (S) => {
        y(S), a(S);
      },
      onBlur: m,
      onFocus: p,
      onMousedown: C
    };
  }
}), _Y = ["role", "aria-labelledby"];
function xY(e, t, n, o, l, a) {
  return M(), G("ul", {
    ref: e.dropdownListWrapperRef,
    class: z(e.dropdownKls),
    style: bt(e.rovingFocusGroupRootStyle),
    tabindex: -1,
    role: e.role,
    "aria-labelledby": e.triggerId,
    onBlur: t[0] || (t[0] = (...r) => e.onBlur && e.onBlur(...r)),
    onFocus: t[1] || (t[1] = (...r) => e.onFocus && e.onFocus(...r)),
    onKeydown: t[2] || (t[2] = It((...r) => e.handleKeydown && e.handleKeydown(...r), ["self"])),
    onMousedown: t[3] || (t[3] = It((...r) => e.onMousedown && e.onMousedown(...r), ["self"]))
  }, [
    Ie(e.$slots, "default")
  ], 46, _Y);
}
var L$ = /* @__PURE__ */ ut(SY, [["render", xY], ["__file", "dropdown-menu.vue"]]);
const n0 = Yt(mY, {
  DropdownItem: D$,
  DropdownMenu: L$
}), o0 = Jn(D$), l0 = Jn(L$), kY = {
  viewBox: "0 0 79 86",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
}, TY = ["id"], $Y = ["stop-color"], OY = ["stop-color"], NY = ["id"], MY = ["stop-color"], IY = ["stop-color"], RY = ["id"], DY = {
  id: "Illustrations",
  stroke: "none",
  "stroke-width": "1",
  fill: "none",
  "fill-rule": "evenodd"
}, LY = {
  id: "B-type",
  transform: "translate(-1268.000000, -535.000000)"
}, PY = {
  id: "Group-2",
  transform: "translate(1268.000000, 535.000000)"
}, AY = ["fill"], FY = ["fill"], VY = {
  id: "Group-Copy",
  transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)"
}, BY = ["fill"], HY = ["fill"], zY = ["fill"], WY = ["fill"], KY = ["fill"], UY = {
  id: "Rectangle-Copy-17",
  transform: "translate(53.000000, 45.000000)"
}, jY = ["fill", "xlink:href"], qY = ["fill", "mask"], YY = ["fill"], GY = Q({
  name: "ImgEmpty"
}), XY = /* @__PURE__ */ Q({
  ...GY,
  setup(e) {
    const t = nt("empty"), n = il();
    return (o, l) => (M(), G("svg", kY, [
      X("defs", null, [
        X("linearGradient", {
          id: `linearGradient-1-${c(n)}`,
          x1: "38.8503086%",
          y1: "0%",
          x2: "61.1496914%",
          y2: "100%"
        }, [
          X("stop", {
            "stop-color": `var(${c(t).cssVarBlockName("fill-color-1")})`,
            offset: "0%"
          }, null, 8, $Y),
          X("stop", {
            "stop-color": `var(${c(t).cssVarBlockName("fill-color-4")})`,
            offset: "100%"
          }, null, 8, OY)
        ], 8, TY),
        X("linearGradient", {
          id: `linearGradient-2-${c(n)}`,
          x1: "0%",
          y1: "9.5%",
          x2: "100%",
          y2: "90.5%"
        }, [
          X("stop", {
            "stop-color": `var(${c(t).cssVarBlockName("fill-color-1")})`,
            offset: "0%"
          }, null, 8, MY),
          X("stop", {
            "stop-color": `var(${c(t).cssVarBlockName("fill-color-6")})`,
            offset: "100%"
          }, null, 8, IY)
        ], 8, NY),
        X("rect", {
          id: `path-3-${c(n)}`,
          x: "0",
          y: "0",
          width: "17",
          height: "36"
        }, null, 8, RY)
      ]),
      X("g", DY, [
        X("g", LY, [
          X("g", PY, [
            X("path", {
              id: "Oval-Copy-2",
              d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z",
              fill: `var(${c(t).cssVarBlockName("fill-color-3")})`
            }, null, 8, AY),
            X("polygon", {
              id: "Rectangle-Copy-14",
              fill: `var(${c(t).cssVarBlockName("fill-color-7")})`,
              transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ",
              points: "13 58 53 58 42 45 2 45"
            }, null, 8, FY),
            X("g", VY, [
              X("polygon", {
                id: "Rectangle-Copy-10",
                fill: `var(${c(t).cssVarBlockName("fill-color-7")})`,
                transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ",
                points: "2.84078316e-14 3 18 3 23 7 5 7"
              }, null, 8, BY),
              X("polygon", {
                id: "Rectangle-Copy-11",
                fill: `var(${c(t).cssVarBlockName("fill-color-5")})`,
                points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43"
              }, null, 8, HY),
              X("rect", {
                id: "Rectangle-Copy-12",
                fill: `url(#linearGradient-1-${c(n)})`,
                transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ",
                x: "38",
                y: "7",
                width: "17",
                height: "36"
              }, null, 8, zY),
              X("polygon", {
                id: "Rectangle-Copy-13",
                fill: `var(${c(t).cssVarBlockName("fill-color-2")})`,
                transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ",
                points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12"
              }, null, 8, WY)
            ]),
            X("rect", {
              id: "Rectangle-Copy-15",
              fill: `url(#linearGradient-2-${c(n)})`,
              x: "13",
              y: "45",
              width: "40",
              height: "36"
            }, null, 8, KY),
            X("g", UY, [
              X("use", {
                id: "Mask",
                fill: `var(${c(t).cssVarBlockName("fill-color-8")})`,
                transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ",
                "xlink:href": `#path-3-${c(n)}`
              }, null, 8, jY),
              X("polygon", {
                id: "Rectangle-Copy",
                fill: `var(${c(t).cssVarBlockName("fill-color-9")})`,
                mask: `url(#mask-4-${c(n)})`,
                transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ",
                points: "7 0 24 0 20 18 7 16.5"
              }, null, 8, qY)
            ]),
            X("polygon", {
              id: "Rectangle-Copy-18",
              fill: `var(${c(t).cssVarBlockName("fill-color-2")})`,
              transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ",
              points: "62 45 79 45 70 58 53 58"
            }, null, 8, YY)
          ])
        ])
      ])
    ]));
  }
});
var ZY = /* @__PURE__ */ ut(XY, [["__file", "img-empty.vue"]]);
const JY = it({
  image: {
    type: String,
    default: ""
  },
  imageSize: Number,
  description: {
    type: String,
    default: ""
  }
}), QY = ["src"], eG = { key: 1 }, tG = Q({
  name: "ElEmpty"
}), nG = /* @__PURE__ */ Q({
  ...tG,
  props: JY,
  setup(e) {
    const t = e, { t: n } = bn(), o = nt("empty"), l = x(() => t.description || n("el.table.emptyText")), a = x(() => ({
      width: po(t.imageSize)
    }));
    return (r, i) => (M(), G("div", {
      class: z(c(o).b())
    }, [
      X("div", {
        class: z(c(o).e("image")),
        style: bt(c(a))
      }, [
        r.image ? (M(), G("img", {
          key: 0,
          src: r.image,
          ondragstart: "return false"
        }, null, 8, QY)) : Ie(r.$slots, "image", { key: 1 }, () => [
          oe(ZY)
        ])
      ], 6),
      X("div", {
        class: z(c(o).e("description"))
      }, [
        r.$slots.description ? Ie(r.$slots, "description", { key: 0 }) : (M(), G("p", eG, Qe(c(l)), 1))
      ], 2),
      r.$slots.default ? (M(), G("div", {
        key: 0,
        class: z(c(o).e("bottom"))
      }, [
        Ie(r.$slots, "default")
      ], 2)) : _e("v-if", !0)
    ], 2));
  }
});
var oG = /* @__PURE__ */ ut(nG, [["__file", "empty.vue"]]);
const P$ = Yt(oG), lG = it({
  urlList: {
    type: Ae(Array),
    default: () => Zn([])
  },
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: !0
  },
  hideOnClickModal: Boolean,
  teleported: Boolean,
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  zoomRate: {
    type: Number,
    default: 1.2
  },
  minScale: {
    type: Number,
    default: 0.2
  },
  maxScale: {
    type: Number,
    default: 7
  },
  crossorigin: {
    type: Ae(String)
  }
}), aG = {
  close: () => !0,
  switch: (e) => Ot(e),
  rotate: (e) => Ot(e)
}, rG = ["src", "crossorigin"], sG = Q({
  name: "ElImageViewer"
}), iG = /* @__PURE__ */ Q({
  ...sG,
  props: lG,
  emits: aG,
  setup(e, { expose: t, emit: n }) {
    var o;
    const l = e, a = {
      CONTAIN: {
        name: "contain",
        icon: ju(_8)
      },
      ORIGINAL: {
        name: "original",
        icon: ju(K8)
      }
    }, { t: r } = bn(), i = nt("image-viewer"), { nextZIndex: s } = au(), u = B(), d = B([]), f = K2(), v = B(!0), h = B(l.initialIndex), m = An(a.CONTAIN), p = B({
      scale: 1,
      deg: 0,
      offsetX: 0,
      offsetY: 0,
      enableTransition: !1
    }), C = B((o = l.zIndex) != null ? o : s()), g = x(() => {
      const { urlList: F } = l;
      return F.length <= 1;
    }), w = x(() => h.value === 0), b = x(() => h.value === l.urlList.length - 1), y = x(() => l.urlList[h.value]), E = x(() => [
      i.e("btn"),
      i.e("prev"),
      i.is("disabled", !l.infinite && w.value)
    ]), S = x(() => [
      i.e("btn"),
      i.e("next"),
      i.is("disabled", !l.infinite && b.value)
    ]), _ = x(() => {
      const { scale: F, deg: j, offsetX: Z, offsetY: te, enableTransition: de } = p.value;
      let Oe = Z / F, ce = te / F;
      switch (j % 360) {
        case 90:
        case -270:
          [Oe, ce] = [ce, -Oe];
          break;
        case 180:
        case -180:
          [Oe, ce] = [-Oe, -ce];
          break;
        case 270:
        case -90:
          [Oe, ce] = [-ce, Oe];
          break;
      }
      const ne = {
        transform: `scale(${F}) rotate(${j}deg) translate(${Oe}px, ${ce}px)`,
        transition: de ? "transform .3s" : ""
      };
      return m.value.name === a.CONTAIN.name && (ne.maxWidth = ne.maxHeight = "100%"), ne;
    });
    function k() {
      L(), n("close");
    }
    function N() {
      const F = mi((Z) => {
        switch (Z.code) {
          case xt.esc:
            l.closeOnPressEscape && k();
            break;
          case xt.space:
            W();
            break;
          case xt.left:
            $();
            break;
          case xt.up:
            O("zoomIn");
            break;
          case xt.right:
            D();
            break;
          case xt.down:
            O("zoomOut");
            break;
        }
      }), j = mi((Z) => {
        const te = Z.deltaY || Z.deltaX;
        O(te < 0 ? "zoomIn" : "zoomOut", {
          zoomRate: l.zoomRate,
          enableTransition: !1
        });
      });
      f.run(() => {
        jn(document, "keydown", F), jn(document, "wheel", j);
      });
    }
    function L() {
      f.stop();
    }
    function R() {
      v.value = !1;
    }
    function H(F) {
      v.value = !1, F.target.alt = r("el.image.error");
    }
    function K(F) {
      if (v.value || F.button !== 0 || !u.value)
        return;
      p.value.enableTransition = !1;
      const { offsetX: j, offsetY: Z } = p.value, te = F.pageX, de = F.pageY, Oe = mi((ne) => {
        p.value = {
          ...p.value,
          offsetX: j + ne.pageX - te,
          offsetY: Z + ne.pageY - de
        };
      }), ce = jn(document, "mousemove", Oe);
      jn(document, "mouseup", () => {
        ce();
      }), F.preventDefault();
    }
    function U() {
      p.value = {
        scale: 1,
        deg: 0,
        offsetX: 0,
        offsetY: 0,
        enableTransition: !1
      };
    }
    function W() {
      if (v.value)
        return;
      const F = Lc(a), j = Object.values(a), Z = m.value.name, de = (j.findIndex((Oe) => Oe.name === Z) + 1) % F.length;
      m.value = a[F[de]], U();
    }
    function A(F) {
      const j = l.urlList.length;
      h.value = (F + j) % j;
    }
    function $() {
      w.value && !l.infinite || A(h.value - 1);
    }
    function D() {
      b.value && !l.infinite || A(h.value + 1);
    }
    function O(F, j = {}) {
      if (v.value)
        return;
      const { minScale: Z, maxScale: te } = l, { zoomRate: de, rotateDeg: Oe, enableTransition: ce } = {
        zoomRate: l.zoomRate,
        rotateDeg: 90,
        enableTransition: !0,
        ...j
      };
      switch (F) {
        case "zoomOut":
          p.value.scale > Z && (p.value.scale = Number.parseFloat((p.value.scale / de).toFixed(3)));
          break;
        case "zoomIn":
          p.value.scale < te && (p.value.scale = Number.parseFloat((p.value.scale * de).toFixed(3)));
          break;
        case "clockwise":
          p.value.deg += Oe, n("rotate", p.value.deg);
          break;
        case "anticlockwise":
          p.value.deg -= Oe, n("rotate", p.value.deg);
          break;
      }
      p.value.enableTransition = ce;
    }
    return Pe(y, () => {
      xe(() => {
        const F = d.value[0];
        F != null && F.complete || (v.value = !0);
      });
    }), Pe(h, (F) => {
      U(), n("switch", F);
    }), Nt(() => {
      var F, j;
      N(), (j = (F = u.value) == null ? void 0 : F.focus) == null || j.call(F);
    }), t({
      setActiveItem: A
    }), (F, j) => (M(), We(ka, {
      to: "body",
      disabled: !F.teleported
    }, [
      oe(Ko, {
        name: "viewer-fade",
        appear: ""
      }, {
        default: fe(() => [
          X("div", {
            ref_key: "wrapper",
            ref: u,
            tabindex: -1,
            class: z(c(i).e("wrapper")),
            style: bt({ zIndex: C.value })
          }, [
            X("div", {
              class: z(c(i).e("mask")),
              onClick: j[0] || (j[0] = It((Z) => F.hideOnClickModal && k(), ["self"]))
            }, null, 2),
            _e(" CLOSE "),
            X("span", {
              class: z([c(i).e("btn"), c(i).e("close")]),
              onClick: k
            }, [
              oe(c(Ct), null, {
                default: fe(() => [
                  oe(c(Fa))
                ]),
                _: 1
              })
            ], 2),
            _e(" ARROW "),
            c(g) ? _e("v-if", !0) : (M(), G(kt, { key: 0 }, [
              X("span", {
                class: z(c(E)),
                onClick: $
              }, [
                oe(c(Ct), null, {
                  default: fe(() => [
                    oe(c(ks))
                  ]),
                  _: 1
                })
              ], 2),
              X("span", {
                class: z(c(S)),
                onClick: D
              }, [
                oe(c(Ct), null, {
                  default: fe(() => [
                    oe(c(xl))
                  ]),
                  _: 1
                })
              ], 2)
            ], 64)),
            _e(" ACTIONS "),
            X("div", {
              class: z([c(i).e("btn"), c(i).e("actions")])
            }, [
              X("div", {
                class: z(c(i).e("actions__inner"))
              }, [
                oe(c(Ct), {
                  onClick: j[1] || (j[1] = (Z) => O("zoomOut"))
                }, {
                  default: fe(() => [
                    oe(c(aV))
                  ]),
                  _: 1
                }),
                oe(c(Ct), {
                  onClick: j[2] || (j[2] = (Z) => O("zoomIn"))
                }, {
                  default: fe(() => [
                    oe(c(Jx))
                  ]),
                  _: 1
                }),
                X("i", {
                  class: z(c(i).e("actions__divider"))
                }, null, 2),
                oe(c(Ct), { onClick: W }, {
                  default: fe(() => [
                    (M(), We(Qt(c(m).icon)))
                  ]),
                  _: 1
                }),
                X("i", {
                  class: z(c(i).e("actions__divider"))
                }, null, 2),
                oe(c(Ct), {
                  onClick: j[3] || (j[3] = (Z) => O("anticlockwise"))
                }, {
                  default: fe(() => [
                    oe(c(B8))
                  ]),
                  _: 1
                }),
                oe(c(Ct), {
                  onClick: j[4] || (j[4] = (Z) => O("clockwise"))
                }, {
                  default: fe(() => [
                    oe(c(z8))
                  ]),
                  _: 1
                })
              ], 2)
            ], 2),
            _e(" CANVAS "),
            X("div", {
              class: z(c(i).e("canvas"))
            }, [
              (M(!0), G(kt, null, ln(F.urlList, (Z, te) => Bt((M(), G("img", {
                ref_for: !0,
                ref: (de) => d.value[te] = de,
                key: Z,
                src: Z,
                style: bt(c(_)),
                class: z(c(i).e("img")),
                crossorigin: F.crossorigin,
                onLoad: R,
                onError: H,
                onMousedown: K
              }, null, 46, rG)), [
                [pn, te === h.value]
              ])), 128))
            ], 2),
            Ie(F.$slots, "default")
          ], 6)
        ]),
        _: 3
      })
    ], 8, ["disabled"]));
  }
});
var cG = /* @__PURE__ */ ut(iG, [["__file", "image-viewer.vue"]]);
const A$ = Yt(cG), uG = it({
  hideOnClickModal: Boolean,
  src: {
    type: String,
    default: ""
  },
  fit: {
    type: String,
    values: ["", "contain", "cover", "fill", "none", "scale-down"],
    default: ""
  },
  loading: {
    type: String,
    values: ["eager", "lazy"]
  },
  lazy: Boolean,
  scrollContainer: {
    type: Ae([String, Object])
  },
  previewSrcList: {
    type: Ae(Array),
    default: () => Zn([])
  },
  previewTeleported: Boolean,
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: !0
  },
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  zoomRate: {
    type: Number,
    default: 1.2
  },
  minScale: {
    type: Number,
    default: 0.2
  },
  maxScale: {
    type: Number,
    default: 7
  },
  crossorigin: {
    type: Ae(String)
  }
}), dG = {
  load: (e) => e instanceof Event,
  error: (e) => e instanceof Event,
  switch: (e) => Ot(e),
  close: () => !0,
  show: () => !0
}, fG = ["src", "loading", "crossorigin"], pG = { key: 0 }, vG = Q({
  name: "ElImage",
  inheritAttrs: !1
}), hG = /* @__PURE__ */ Q({
  ...vG,
  props: uG,
  emits: dG,
  setup(e, { emit: t }) {
    const n = e;
    let o = "";
    const { t: l } = bn(), a = nt("image"), r = Ai(), i = my(), s = B(), u = B(!1), d = B(!0), f = B(!1), v = B(), h = B(), m = fn && "loading" in HTMLImageElement.prototype;
    let p, C;
    const g = x(() => [
      a.e("inner"),
      y.value && a.e("preview"),
      d.value && a.is("loading")
    ]), w = x(() => r.style), b = x(() => {
      const { fit: D } = n;
      return fn && D ? { objectFit: D } : {};
    }), y = x(() => {
      const { previewSrcList: D } = n;
      return Array.isArray(D) && D.length > 0;
    }), E = x(() => {
      const { previewSrcList: D, initialIndex: O } = n;
      let F = O;
      return O > D.length - 1 && (F = 0), F;
    }), S = x(() => n.loading === "eager" ? !1 : !m && n.loading === "lazy" || n.lazy), _ = () => {
      fn && (d.value = !0, u.value = !1, s.value = n.src);
    };
    function k(D) {
      d.value = !1, u.value = !1, t("load", D);
    }
    function N(D) {
      d.value = !1, u.value = !0, t("error", D);
    }
    function L() {
      nD(v.value, h.value) && (_(), K());
    }
    const R = X2(L, 200, !0);
    async function H() {
      var D;
      if (!fn)
        return;
      await xe();
      const { scrollContainer: O } = n;
      wa(O) ? h.value = O : on(O) && O !== "" ? h.value = (D = document.querySelector(O)) != null ? D : void 0 : v.value && (h.value = sy(v.value)), h.value && (p = jn(h, "scroll", R), setTimeout(() => L(), 100));
    }
    function K() {
      !fn || !h.value || !R || (p == null || p(), h.value = void 0);
    }
    function U(D) {
      if (D.ctrlKey) {
        if (D.deltaY < 0)
          return D.preventDefault(), !1;
        if (D.deltaY > 0)
          return D.preventDefault(), !1;
      }
    }
    function W() {
      y.value && (C = jn("wheel", U, {
        passive: !1
      }), o = document.body.style.overflow, document.body.style.overflow = "hidden", f.value = !0, t("show"));
    }
    function A() {
      C == null || C(), document.body.style.overflow = o, f.value = !1, t("close");
    }
    function $(D) {
      t("switch", D);
    }
    return Pe(() => n.src, () => {
      S.value ? (d.value = !0, u.value = !1, K(), H()) : _();
    }), Nt(() => {
      S.value ? H() : _();
    }), (D, O) => (M(), G("div", {
      ref_key: "container",
      ref: v,
      class: z([c(a).b(), D.$attrs.class]),
      style: bt(c(w))
    }, [
      u.value ? Ie(D.$slots, "error", { key: 0 }, () => [
        X("div", {
          class: z(c(a).e("error"))
        }, Qe(c(l)("el.image.error")), 3)
      ]) : (M(), G(kt, { key: 1 }, [
        s.value !== void 0 ? (M(), G("img", Et({ key: 0 }, c(i), {
          src: s.value,
          loading: D.loading,
          style: c(b),
          class: c(g),
          crossorigin: D.crossorigin,
          onClick: W,
          onLoad: k,
          onError: N
        }), null, 16, fG)) : _e("v-if", !0),
        d.value ? (M(), G("div", {
          key: 1,
          class: z(c(a).e("wrapper"))
        }, [
          Ie(D.$slots, "placeholder", {}, () => [
            X("div", {
              class: z(c(a).e("placeholder"))
            }, null, 2)
          ])
        ], 2)) : _e("v-if", !0)
      ], 64)),
      c(y) ? (M(), G(kt, { key: 2 }, [
        f.value ? (M(), We(c(A$), {
          key: 0,
          "z-index": D.zIndex,
          "initial-index": c(E),
          infinite: D.infinite,
          "zoom-rate": D.zoomRate,
          "min-scale": D.minScale,
          "max-scale": D.maxScale,
          "url-list": D.previewSrcList,
          "hide-on-click-modal": D.hideOnClickModal,
          teleported: D.previewTeleported,
          "close-on-press-escape": D.closeOnPressEscape,
          onClose: A,
          onSwitch: $
        }, {
          default: fe(() => [
            D.$slots.viewer ? (M(), G("div", pG, [
              Ie(D.$slots, "viewer")
            ])) : _e("v-if", !0)
          ]),
          _: 3
        }, 8, ["z-index", "initial-index", "infinite", "zoom-rate", "min-scale", "max-scale", "url-list", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : _e("v-if", !0)
      ], 64)) : _e("v-if", !0)
    ], 6));
  }
});
var mG = /* @__PURE__ */ ut(hG, [["__file", "image.vue"]]);
const gG = Yt(mG), bG = it({
  id: {
    type: String,
    default: void 0
  },
  step: {
    type: Number,
    default: 1
  },
  stepStrictly: Boolean,
  max: {
    type: Number,
    default: Number.POSITIVE_INFINITY
  },
  min: {
    type: Number,
    default: Number.NEGATIVE_INFINITY
  },
  modelValue: Number,
  readonly: Boolean,
  disabled: Boolean,
  size: Lo,
  controls: {
    type: Boolean,
    default: !0
  },
  controlsPosition: {
    type: String,
    default: "",
    values: ["", "right"]
  },
  valueOnClear: {
    type: [String, Number, null],
    validator: (e) => e === null || Ot(e) || ["min", "max"].includes(e),
    default: null
  },
  name: String,
  label: String,
  placeholder: String,
  precision: {
    type: Number,
    validator: (e) => e >= 0 && e === Number.parseInt(`${e}`, 10)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  ...Zo(["ariaLabel"])
}), yG = {
  [qn]: (e, t) => t !== e,
  blur: (e) => e instanceof FocusEvent,
  focus: (e) => e instanceof FocusEvent,
  [kl]: (e) => Ot(e) || zo(e),
  [Jt]: (e) => Ot(e) || zo(e)
}, CG = ["aria-label", "onKeydown"], wG = ["aria-label", "onKeydown"], EG = Q({
  name: "ElInputNumber"
}), SG = /* @__PURE__ */ Q({
  ...EG,
  props: bG,
  emits: yG,
  setup(e, { expose: t, emit: n }) {
    const o = e, { t: l } = bn(), a = nt("input-number"), r = B(), i = en({
      currentValue: o.modelValue,
      userInput: null
    }), { formItem: s } = ml(), u = x(() => Ot(o.modelValue) && o.modelValue <= o.min), d = x(() => Ot(o.modelValue) && o.modelValue >= o.max), f = x(() => {
      const W = g(o.step);
      return To(o.precision) ? Math.max(g(o.modelValue), W) : (W > o.precision && dn("InputNumber", "precision should not be less than the decimal places of step"), o.precision);
    }), v = x(() => o.controls && o.controlsPosition === "right"), h = Mo(), m = Nl(), p = x(() => {
      if (i.userInput !== null)
        return i.userInput;
      let W = i.currentValue;
      if (zo(W))
        return "";
      if (Ot(W)) {
        if (Number.isNaN(W))
          return "";
        To(o.precision) || (W = W.toFixed(o.precision));
      }
      return W;
    }), C = (W, A) => {
      if (To(A) && (A = f.value), A === 0)
        return Math.round(W);
      let $ = String(W);
      const D = $.indexOf(".");
      if (D === -1 || !$.replace(".", "").split("")[D + A])
        return W;
      const j = $.length;
      return $.charAt(j - 1) === "5" && ($ = `${$.slice(0, Math.max(0, j - 1))}6`), Number.parseFloat(Number($).toFixed(A));
    }, g = (W) => {
      if (zo(W))
        return 0;
      const A = W.toString(), $ = A.indexOf(".");
      let D = 0;
      return $ !== -1 && (D = A.length - $ - 1), D;
    }, w = (W, A = 1) => Ot(W) ? C(W + o.step * A) : i.currentValue, b = () => {
      if (o.readonly || m.value || d.value)
        return;
      const W = Number(p.value) || 0, A = w(W);
      S(A), n(kl, i.currentValue), K();
    }, y = () => {
      if (o.readonly || m.value || u.value)
        return;
      const W = Number(p.value) || 0, A = w(W, -1);
      S(A), n(kl, i.currentValue), K();
    }, E = (W, A) => {
      const { max: $, min: D, step: O, precision: F, stepStrictly: j, valueOnClear: Z } = o;
      $ < D && lo("InputNumber", "min should not be greater than max.");
      let te = Number(W);
      if (zo(W) || Number.isNaN(te))
        return null;
      if (W === "") {
        if (Z === null)
          return null;
        te = on(Z) ? { min: D, max: $ }[Z] : Z;
      }
      return j && (te = C(Math.round(te / O) * O, F)), To(F) || (te = C(te, F)), (te > $ || te < D) && (te = te > $ ? $ : D, A && n(Jt, te)), te;
    }, S = (W, A = !0) => {
      var $;
      const D = i.currentValue, O = E(W);
      if (!A) {
        n(Jt, O);
        return;
      }
      D === O && W || (i.userInput = null, n(Jt, O), D !== O && n(qn, O, D), o.validateEvent && (($ = s == null ? void 0 : s.validate) == null || $.call(s, "change").catch((F) => dn(F))), i.currentValue = O);
    }, _ = (W) => {
      i.userInput = W;
      const A = W === "" ? null : Number(W);
      n(kl, A), S(A, !1);
    }, k = (W) => {
      const A = W !== "" ? Number(W) : "";
      (Ot(A) && !Number.isNaN(A) || W === "") && S(A), K(), i.userInput = null;
    }, N = () => {
      var W, A;
      (A = (W = r.value) == null ? void 0 : W.focus) == null || A.call(W);
    }, L = () => {
      var W, A;
      (A = (W = r.value) == null ? void 0 : W.blur) == null || A.call(W);
    }, R = (W) => {
      n("focus", W);
    }, H = (W) => {
      var A;
      i.userInput = null, n("blur", W), o.validateEvent && ((A = s == null ? void 0 : s.validate) == null || A.call(s, "blur").catch(($) => dn($)));
    }, K = () => {
      i.currentValue !== o.modelValue && (i.currentValue = o.modelValue);
    }, U = (W) => {
      document.activeElement === W.target && W.preventDefault();
    };
    return Pe(() => o.modelValue, (W, A) => {
      const $ = E(W, !0);
      i.userInput === null && $ !== A && (i.currentValue = $);
    }, { immediate: !0 }), Nt(() => {
      var W;
      const { min: A, max: $, modelValue: D } = o, O = (W = r.value) == null ? void 0 : W.input;
      if (O.setAttribute("role", "spinbutton"), Number.isFinite($) ? O.setAttribute("aria-valuemax", String($)) : O.removeAttribute("aria-valuemax"), Number.isFinite(A) ? O.setAttribute("aria-valuemin", String(A)) : O.removeAttribute("aria-valuemin"), O.setAttribute("aria-valuenow", i.currentValue || i.currentValue === 0 ? String(i.currentValue) : ""), O.setAttribute("aria-disabled", String(m.value)), !Ot(D) && D != null) {
        let F = Number(D);
        Number.isNaN(F) && (F = null), n(Jt, F);
      }
      O.addEventListener("wheel", U, { passive: !1 });
    }), Pi(() => {
      var W, A;
      const $ = (W = r.value) == null ? void 0 : W.input;
      $ == null || $.setAttribute("aria-valuenow", `${(A = i.currentValue) != null ? A : ""}`);
    }), Ho({
      from: "label",
      replacement: "aria-label",
      version: "2.8.0",
      scope: "el-input-number",
      ref: "https://element-plus.org/en-US/component/input-number.html"
    }, x(() => !!o.label)), t({
      focus: N,
      blur: L
    }), (W, A) => (M(), G("div", {
      class: z([
        c(a).b(),
        c(a).m(c(h)),
        c(a).is("disabled", c(m)),
        c(a).is("without-controls", !W.controls),
        c(a).is("controls-right", c(v))
      ]),
      onDragstart: A[0] || (A[0] = It(() => {
      }, ["prevent"]))
    }, [
      W.controls ? Bt((M(), G("span", {
        key: 0,
        role: "button",
        "aria-label": c(l)("el.inputNumber.decrease"),
        class: z([c(a).e("decrease"), c(a).is("disabled", c(u))]),
        onKeydown: Rn(y, ["enter"])
      }, [
        Ie(W.$slots, "decrease-icon", {}, () => [
          oe(c(Ct), null, {
            default: fe(() => [
              c(v) ? (M(), We(c(Br), { key: 0 })) : (M(), We(c(N8), { key: 1 }))
            ]),
            _: 1
          })
        ])
      ], 42, CG)), [
        [c(Qp), y]
      ]) : _e("v-if", !0),
      W.controls ? Bt((M(), G("span", {
        key: 1,
        role: "button",
        "aria-label": c(l)("el.inputNumber.increase"),
        class: z([c(a).e("increase"), c(a).is("disabled", c(d))]),
        onKeydown: Rn(b, ["enter"])
      }, [
        Ie(W.$slots, "increase-icon", {}, () => [
          oe(c(Ct), null, {
            default: fe(() => [
              c(v) ? (M(), We(c(iy), { key: 0 })) : (M(), We(c(Gx), { key: 1 }))
            ]),
            _: 1
          })
        ])
      ], 42, wG)), [
        [c(Qp), b]
      ]) : _e("v-if", !0),
      oe(c(nl), {
        id: W.id,
        ref_key: "input",
        ref: r,
        type: "number",
        step: W.step,
        "model-value": c(p),
        placeholder: W.placeholder,
        readonly: W.readonly,
        disabled: c(m),
        size: c(h),
        max: W.max,
        min: W.min,
        name: W.name,
        "aria-label": W.label || W.ariaLabel,
        "validate-event": !1,
        onKeydown: [
          Rn(It(b, ["prevent"]), ["up"]),
          Rn(It(y, ["prevent"]), ["down"])
        ],
        onBlur: H,
        onFocus: R,
        onInput: _,
        onChange: k
      }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "aria-label", "onKeydown"])
    ], 34));
  }
});
var _G = /* @__PURE__ */ ut(SG, [["__file", "input-number.vue"]]);
const a0 = Yt(_G), xG = it({
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger", "default"],
    default: "default"
  },
  underline: {
    type: Boolean,
    default: !0
  },
  disabled: { type: Boolean, default: !1 },
  href: { type: String, default: "" },
  target: {
    type: String,
    default: "_self"
  },
  icon: {
    type: Dn
  }
}), kG = {
  click: (e) => e instanceof MouseEvent
}, TG = ["href", "target"], $G = Q({
  name: "ElLink"
}), OG = /* @__PURE__ */ Q({
  ...$G,
  props: xG,
  emits: kG,
  setup(e, { emit: t }) {
    const n = e, o = nt("link"), l = x(() => [
      o.b(),
      o.m(n.type),
      o.is("disabled", n.disabled),
      o.is("underline", n.underline && !n.disabled)
    ]);
    function a(r) {
      n.disabled || t("click", r);
    }
    return (r, i) => (M(), G("a", {
      class: z(c(l)),
      href: r.disabled || !r.href ? void 0 : r.href,
      target: r.disabled || !r.href ? void 0 : r.target,
      onClick: a
    }, [
      r.icon ? (M(), We(c(Ct), { key: 0 }, {
        default: fe(() => [
          (M(), We(Qt(r.icon)))
        ]),
        _: 1
      })) : _e("v-if", !0),
      r.$slots.default ? (M(), G("span", {
        key: 1,
        class: z(c(o).e("inner"))
      }, [
        Ie(r.$slots, "default")
      ], 2)) : _e("v-if", !0),
      r.$slots.icon ? Ie(r.$slots, "icon", { key: 2 }) : _e("v-if", !0)
    ], 10, TG));
  }
});
var NG = /* @__PURE__ */ ut(OG, [["__file", "link.vue"]]);
const MG = Yt(NG);
let IG = class {
  constructor(t, n) {
    this.parent = t, this.domNode = n, this.subIndex = 0, this.subIndex = 0, this.init();
  }
  init() {
    this.subMenuItems = this.domNode.querySelectorAll("li"), this.addListeners();
  }
  gotoSubIndex(t) {
    t === this.subMenuItems.length ? t = 0 : t < 0 && (t = this.subMenuItems.length - 1), this.subMenuItems[t].focus(), this.subIndex = t;
  }
  addListeners() {
    const t = this.parent.domNode;
    Array.prototype.forEach.call(this.subMenuItems, (n) => {
      n.addEventListener("keydown", (o) => {
        let l = !1;
        switch (o.code) {
          case xt.down: {
            this.gotoSubIndex(this.subIndex + 1), l = !0;
            break;
          }
          case xt.up: {
            this.gotoSubIndex(this.subIndex - 1), l = !0;
            break;
          }
          case xt.tab: {
            pp(t, "mouseleave");
            break;
          }
          case xt.enter:
          case xt.space: {
            l = !0, o.currentTarget.click();
            break;
          }
        }
        return l && (o.preventDefault(), o.stopPropagation()), !1;
      });
    });
  }
}, RG = class {
  constructor(t, n) {
    this.domNode = t, this.submenu = null, this.submenu = null, this.init(n);
  }
  init(t) {
    this.domNode.setAttribute("tabindex", "0");
    const n = this.domNode.querySelector(`.${t}-menu`);
    n && (this.submenu = new IG(this, n)), this.addListeners();
  }
  addListeners() {
    this.domNode.addEventListener("keydown", (t) => {
      let n = !1;
      switch (t.code) {
        case xt.down: {
          pp(t.currentTarget, "mouseenter"), this.submenu && this.submenu.gotoSubIndex(0), n = !0;
          break;
        }
        case xt.up: {
          pp(t.currentTarget, "mouseenter"), this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1), n = !0;
          break;
        }
        case xt.tab: {
          pp(t.currentTarget, "mouseleave");
          break;
        }
        case xt.enter:
        case xt.space: {
          n = !0, t.currentTarget.click();
          break;
        }
      }
      n && t.preventDefault();
    });
  }
}, DG = class {
  constructor(t, n) {
    this.domNode = t, this.init(n);
  }
  init(t) {
    const n = this.domNode.childNodes;
    Array.from(n).forEach((o) => {
      o.nodeType === 1 && new RG(o, t);
    });
  }
};
const LG = Q({
  name: "ElMenuCollapseTransition",
  setup() {
    const e = nt("menu");
    return {
      listeners: {
        onBeforeEnter: (n) => n.style.opacity = "0.2",
        onEnter(n, o) {
          ma(n, `${e.namespace.value}-opacity-transition`), n.style.opacity = "1", o();
        },
        onAfterEnter(n) {
          vl(n, `${e.namespace.value}-opacity-transition`), n.style.opacity = "";
        },
        onBeforeLeave(n) {
          n.dataset || (n.dataset = {}), ba(n, e.m("collapse")) ? (vl(n, e.m("collapse")), n.dataset.oldOverflow = n.style.overflow, n.dataset.scrollWidth = n.clientWidth.toString(), ma(n, e.m("collapse"))) : (ma(n, e.m("collapse")), n.dataset.oldOverflow = n.style.overflow, n.dataset.scrollWidth = n.clientWidth.toString(), vl(n, e.m("collapse"))), n.style.width = `${n.scrollWidth}px`, n.style.overflow = "hidden";
        },
        onLeave(n) {
          ma(n, "horizontal-collapse-transition"), n.style.width = `${n.dataset.scrollWidth}px`;
        }
      }
    };
  }
});
function PG(e, t, n, o, l, a) {
  return M(), We(Ko, Et({ mode: "out-in" }, e.listeners), {
    default: fe(() => [
      Ie(e.$slots, "default")
    ]),
    _: 3
  }, 16);
}
var AG = /* @__PURE__ */ ut(LG, [["render", PG], ["__file", "menu-collapse-transition.vue"]]);
function F$(e, t) {
  const n = x(() => {
    let l = e.parent;
    const a = [t.value];
    for (; l.type.name !== "ElMenu"; )
      l.props.index && a.unshift(l.props.index), l = l.parent;
    return a;
  });
  return {
    parentMenu: x(() => {
      let l = e.parent;
      for (; l && !["ElMenu", "ElSubMenu"].includes(l.type.name); )
        l = l.parent;
      return l;
    }),
    indexPath: n
  };
}
function FG(e) {
  return x(() => {
    const n = e.backgroundColor;
    return n ? new uT(n).shade(20).toString() : "";
  });
}
const V$ = (e, t) => {
  const n = nt("menu");
  return x(() => n.cssVarBlock({
    "text-color": e.textColor || "",
    "hover-text-color": e.textColor || "",
    "bg-color": e.backgroundColor || "",
    "hover-bg-color": FG(e).value || "",
    "active-color": e.activeTextColor || "",
    level: `${t}`
  }));
}, VG = it({
  index: {
    type: String,
    required: !0
  },
  showTimeout: Number,
  hideTimeout: Number,
  popperClass: String,
  disabled: Boolean,
  teleported: {
    type: Boolean,
    default: void 0
  },
  popperOffset: Number,
  expandCloseIcon: {
    type: Dn
  },
  expandOpenIcon: {
    type: Dn
  },
  collapseCloseIcon: {
    type: Dn
  },
  collapseOpenIcon: {
    type: Dn
  }
}), rm = "ElSubMenu";
var r0 = Q({
  name: rm,
  props: VG,
  setup(e, { slots: t, expose: n }) {
    const o = Pt(), { indexPath: l, parentMenu: a } = F$(o, x(() => e.index)), r = nt("menu"), i = nt("sub-menu"), s = ot("rootMenu");
    s || lo(rm, "can not inject root menu");
    const u = ot(`subMenu:${a.value.uid}`);
    u || lo(rm, "can not inject sub menu");
    const d = B({}), f = B({});
    let v;
    const h = B(!1), m = B(), p = B(null), C = x(() => k.value === "horizontal" && w.value ? "bottom-start" : "right-start"), g = x(() => k.value === "horizontal" && w.value || k.value === "vertical" && !s.props.collapse ? e.expandCloseIcon && e.expandOpenIcon ? S.value ? e.expandOpenIcon : e.expandCloseIcon : Br : e.collapseCloseIcon && e.collapseOpenIcon ? S.value ? e.collapseOpenIcon : e.collapseCloseIcon : xl), w = x(() => u.level === 0), b = x(() => {
      const F = e.teleported;
      return F === void 0 ? w.value : F;
    }), y = x(() => s.props.collapse ? `${r.namespace.value}-zoom-in-left` : `${r.namespace.value}-zoom-in-top`), E = x(() => k.value === "horizontal" && w.value ? [
      "bottom-start",
      "bottom-end",
      "top-start",
      "top-end",
      "right-start",
      "left-start"
    ] : [
      "right-start",
      "right",
      "right-end",
      "left-start",
      "bottom-start",
      "bottom-end",
      "top-start",
      "top-end"
    ]), S = x(() => s.openedMenus.includes(e.index)), _ = x(() => {
      let F = !1;
      return Object.values(d.value).forEach((j) => {
        j.active && (F = !0);
      }), Object.values(f.value).forEach((j) => {
        j.active && (F = !0);
      }), F;
    }), k = x(() => s.props.mode), N = en({
      index: e.index,
      indexPath: l,
      active: _
    }), L = V$(s.props, u.level + 1), R = x(() => {
      var F;
      return (F = e.popperOffset) != null ? F : s.props.popperOffset;
    }), H = x(() => {
      var F;
      return (F = e.popperClass) != null ? F : s.props.popperClass;
    }), K = x(() => {
      var F;
      return (F = e.showTimeout) != null ? F : s.props.showTimeout;
    }), U = x(() => {
      var F;
      return (F = e.hideTimeout) != null ? F : s.props.hideTimeout;
    }), W = () => {
      var F, j, Z;
      return (Z = (j = (F = p.value) == null ? void 0 : F.popperRef) == null ? void 0 : j.popperInstanceRef) == null ? void 0 : Z.destroy();
    }, A = (F) => {
      F || W();
    }, $ = () => {
      s.props.menuTrigger === "hover" && s.props.mode === "horizontal" || s.props.collapse && s.props.mode === "vertical" || e.disabled || s.handleSubMenuClick({
        index: e.index,
        indexPath: l.value,
        active: _.value
      });
    }, D = (F, j = K.value) => {
      var Z;
      if (F.type !== "focus") {
        if (s.props.menuTrigger === "click" && s.props.mode === "horizontal" || !s.props.collapse && s.props.mode === "vertical" || e.disabled) {
          u.mouseInChild.value = !0;
          return;
        }
        u.mouseInChild.value = !0, v == null || v(), { stop: v } = ki(() => {
          s.openMenu(e.index, l.value);
        }, j), b.value && ((Z = a.value.vnode.el) == null || Z.dispatchEvent(new MouseEvent("mouseenter")));
      }
    }, O = (F = !1) => {
      var j;
      if (s.props.menuTrigger === "click" && s.props.mode === "horizontal" || !s.props.collapse && s.props.mode === "vertical") {
        u.mouseInChild.value = !1;
        return;
      }
      v == null || v(), u.mouseInChild.value = !1, { stop: v } = ki(() => !h.value && s.closeMenu(e.index, l.value), U.value), b.value && F && ((j = u.handleMouseleave) == null || j.call(u, !0));
    };
    Pe(() => s.props.collapse, (F) => A(!!F));
    {
      const F = (Z) => {
        f.value[Z.index] = Z;
      }, j = (Z) => {
        delete f.value[Z.index];
      };
      Mt(`subMenu:${o.uid}`, {
        addSubMenu: F,
        removeSubMenu: j,
        handleMouseleave: O,
        mouseInChild: h,
        level: u.level + 1
      });
    }
    return n({
      opened: S
    }), Nt(() => {
      s.addSubMenu(N), u.addSubMenu(N);
    }), zn(() => {
      u.removeSubMenu(N), s.removeSubMenu(N);
    }), () => {
      var F;
      const j = [
        (F = t.title) == null ? void 0 : F.call(t),
        V(Ct, {
          class: i.e("icon-arrow"),
          style: {
            transform: S.value ? e.expandCloseIcon && e.expandOpenIcon || e.collapseCloseIcon && e.collapseOpenIcon && s.props.collapse ? "none" : "rotateZ(180deg)" : "none"
          }
        }, {
          default: () => on(g.value) ? V(o.appContext.components[g.value]) : V(g.value)
        })
      ], Z = s.isMenuPopup ? V(hl, {
        ref: p,
        visible: S.value,
        effect: "light",
        pure: !0,
        offset: R.value,
        showArrow: !1,
        persistent: !0,
        popperClass: H.value,
        placement: C.value,
        teleported: b.value,
        fallbackPlacements: E.value,
        transition: y.value,
        gpuAcceleration: !1
      }, {
        content: () => {
          var te;
          return V("div", {
            class: [
              r.m(k.value),
              r.m("popup-container"),
              H.value
            ],
            onMouseenter: (de) => D(de, 100),
            onMouseleave: () => O(!0),
            onFocus: (de) => D(de, 100)
          }, [
            V("ul", {
              class: [
                r.b(),
                r.m("popup"),
                r.m(`popup-${C.value}`)
              ],
              style: L.value
            }, [(te = t.default) == null ? void 0 : te.call(t)])
          ]);
        },
        default: () => V("div", {
          class: i.e("title"),
          onClick: $
        }, j)
      }) : V(kt, {}, [
        V("div", {
          class: i.e("title"),
          ref: m,
          onClick: $
        }, j),
        V(jv, {}, {
          default: () => {
            var te;
            return Bt(V("ul", {
              role: "menu",
              class: [r.b(), r.m("inline")],
              style: L.value
            }, [(te = t.default) == null ? void 0 : te.call(t)]), [[pn, S.value]]);
          }
        })
      ]);
      return V("li", {
        class: [
          i.b(),
          i.is("active", _.value),
          i.is("opened", S.value),
          i.is("disabled", e.disabled)
        ],
        role: "menuitem",
        ariaHaspopup: !0,
        ariaExpanded: S.value,
        onMouseenter: D,
        onMouseleave: () => O(),
        onFocus: D
      }, [Z]);
    };
  }
});
const BG = it({
  mode: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "vertical"
  },
  defaultActive: {
    type: String,
    default: ""
  },
  defaultOpeneds: {
    type: Ae(Array),
    default: () => Zn([])
  },
  uniqueOpened: Boolean,
  router: Boolean,
  menuTrigger: {
    type: String,
    values: ["hover", "click"],
    default: "hover"
  },
  collapse: Boolean,
  backgroundColor: String,
  textColor: String,
  activeTextColor: String,
  closeOnClickOutside: Boolean,
  collapseTransition: {
    type: Boolean,
    default: !0
  },
  ellipsis: {
    type: Boolean,
    default: !0
  },
  popperOffset: {
    type: Number,
    default: 6
  },
  ellipsisIcon: {
    type: Dn,
    default: () => R8
  },
  popperEffect: {
    type: String,
    values: ["dark", "light"],
    default: "dark"
  },
  popperClass: String,
  showTimeout: {
    type: Number,
    default: 300
  },
  hideTimeout: {
    type: Number,
    default: 300
  }
}), sm = (e) => Array.isArray(e) && e.every((t) => on(t)), HG = {
  close: (e, t) => on(e) && sm(t),
  open: (e, t) => on(e) && sm(t),
  select: (e, t, n, o) => on(e) && sm(t) && Mn(n) && (o === void 0 || o instanceof Promise)
};
var zG = Q({
  name: "ElMenu",
  props: BG,
  emits: HG,
  setup(e, { emit: t, slots: n, expose: o }) {
    const l = Pt(), a = l.appContext.config.globalProperties.$router, r = B(), i = nt("menu"), s = nt("sub-menu"), u = B(-1), d = B(e.defaultOpeneds && !e.collapse ? e.defaultOpeneds.slice(0) : []), f = B(e.defaultActive), v = B({}), h = B({}), m = x(() => e.mode === "horizontal" || e.mode === "vertical" && e.collapse), p = () => {
      const U = f.value && v.value[f.value];
      if (!U || e.mode === "horizontal" || e.collapse)
        return;
      U.indexPath.forEach((A) => {
        const $ = h.value[A];
        $ && C(A, $.indexPath);
      });
    }, C = (U, W) => {
      d.value.includes(U) || (e.uniqueOpened && (d.value = d.value.filter((A) => W.includes(A))), d.value.push(U), t("open", U, W));
    }, g = (U) => {
      const W = d.value.indexOf(U);
      W !== -1 && d.value.splice(W, 1);
    }, w = (U, W) => {
      g(U), t("close", U, W);
    }, b = ({
      index: U,
      indexPath: W
    }) => {
      d.value.includes(U) ? w(U, W) : C(U, W);
    }, y = (U) => {
      (e.mode === "horizontal" || e.collapse) && (d.value = []);
      const { index: W, indexPath: A } = U;
      if (!(zo(W) || zo(A)))
        if (e.router && a) {
          const $ = U.route || W, D = a.push($).then((O) => (O || (f.value = W), O));
          t("select", W, A, { index: W, indexPath: A, route: $ }, D);
        } else
          f.value = W, t("select", W, A, { index: W, indexPath: A });
    }, E = (U) => {
      const W = v.value, A = W[U] || f.value && W[f.value] || W[e.defaultActive];
      A ? f.value = A.index : f.value = U;
    }, S = (U) => {
      const W = getComputedStyle(U), A = Number.parseInt(W.marginLeft, 10), $ = Number.parseInt(W.marginRight, 10);
      return U.offsetWidth + A + $ || 0;
    }, _ = () => {
      var U, W;
      if (!r.value)
        return -1;
      const A = Array.from((W = (U = r.value) == null ? void 0 : U.childNodes) != null ? W : []).filter((de) => de.nodeName !== "#comment" && (de.nodeName !== "#text" || de.nodeValue)), $ = 64, D = getComputedStyle(r.value), O = Number.parseInt(D.paddingLeft, 10), F = Number.parseInt(D.paddingRight, 10), j = r.value.clientWidth - O - F;
      let Z = 0, te = 0;
      return A.forEach((de, Oe) => {
        Z += S(de), Z <= j - $ && (te = Oe + 1);
      }), te === A.length ? -1 : te;
    }, k = (U) => h.value[U].indexPath, N = (U, W = 33.34) => {
      let A;
      return () => {
        A && clearTimeout(A), A = setTimeout(() => {
          U();
        }, W);
      };
    };
    let L = !0;
    const R = () => {
      if (u.value === _())
        return;
      const U = () => {
        u.value = -1, xe(() => {
          u.value = _();
        });
      };
      L ? U() : N(U)(), L = !1;
    };
    Pe(() => e.defaultActive, (U) => {
      v.value[U] || (f.value = ""), E(U);
    }), Pe(() => e.collapse, (U) => {
      U && (d.value = []);
    }), Pe(v.value, p);
    let H;
    ol(() => {
      e.mode === "horizontal" && e.ellipsis ? H = Xn(r, R).stop : H == null || H();
    });
    const K = B(!1);
    {
      const U = (D) => {
        h.value[D.index] = D;
      }, W = (D) => {
        delete h.value[D.index];
      };
      Mt("rootMenu", en({
        props: e,
        openedMenus: d,
        items: v,
        subMenus: h,
        activeIndex: f,
        isMenuPopup: m,
        addMenuItem: (D) => {
          v.value[D.index] = D;
        },
        removeMenuItem: (D) => {
          delete v.value[D.index];
        },
        addSubMenu: U,
        removeSubMenu: W,
        openMenu: C,
        closeMenu: w,
        handleMenuItemClick: y,
        handleSubMenuClick: b
      })), Mt(`subMenu:${l.uid}`, {
        addSubMenu: U,
        removeSubMenu: W,
        mouseInChild: K,
        level: 0
      });
    }
    return Nt(() => {
      e.mode === "horizontal" && new DG(l.vnode.el, i.namespace.value);
    }), o({
      open: (W) => {
        const { indexPath: A } = h.value[W];
        A.forEach(($) => C($, A));
      },
      close: g,
      handleResize: R
    }), () => {
      var U, W;
      let A = (W = (U = n.default) == null ? void 0 : U.call(n)) != null ? W : [];
      const $ = [];
      if (e.mode === "horizontal" && r.value) {
        const j = bs(A), Z = u.value === -1 ? j : j.slice(0, u.value), te = u.value === -1 ? [] : j.slice(u.value);
        te != null && te.length && e.ellipsis && (A = Z, $.push(V(r0, {
          index: "sub-menu-more",
          class: s.e("hide-arrow"),
          popperOffset: e.popperOffset
        }, {
          title: () => V(Ct, {
            class: s.e("icon-more")
          }, {
            default: () => V(e.ellipsisIcon)
          }),
          default: () => te
        })));
      }
      const D = V$(e, 0), O = e.closeOnClickOutside ? [
        [
          Pr,
          () => {
            d.value.length && (K.value || (d.value.forEach((j) => t("close", j, k(j))), d.value = []));
          }
        ]
      ] : [], F = Bt(V("ul", {
        key: String(e.collapse),
        role: "menubar",
        ref: r,
        style: D.value,
        class: {
          [i.b()]: !0,
          [i.m(e.mode)]: !0,
          [i.m("collapse")]: e.collapse
        }
      }, [...A, ...$]), O);
      return e.collapseTransition && e.mode === "vertical" ? V(AG, () => F) : F;
    };
  }
});
const WG = it({
  index: {
    type: Ae([String, null]),
    default: null
  },
  route: {
    type: Ae([String, Object])
  },
  disabled: Boolean
}), KG = {
  click: (e) => on(e.index) && Array.isArray(e.indexPath)
}, im = "ElMenuItem", UG = Q({
  name: im,
  components: {
    ElTooltip: hl
  },
  props: WG,
  emits: KG,
  setup(e, { emit: t }) {
    const n = Pt(), o = ot("rootMenu"), l = nt("menu"), a = nt("menu-item");
    o || lo(im, "can not inject root menu");
    const { parentMenu: r, indexPath: i } = F$(n, Pn(e, "index")), s = ot(`subMenu:${r.value.uid}`);
    s || lo(im, "can not inject sub menu");
    const u = x(() => e.index === o.activeIndex), d = en({
      index: e.index,
      indexPath: i,
      active: u
    }), f = () => {
      e.disabled || (o.handleMenuItemClick({
        index: e.index,
        indexPath: i.value,
        route: e.route
      }), t("click", d));
    };
    return Nt(() => {
      s.addSubMenu(d), o.addMenuItem(d);
    }), zn(() => {
      s.removeSubMenu(d), o.removeMenuItem(d);
    }), {
      parentMenu: r,
      rootMenu: o,
      active: u,
      nsMenu: l,
      nsMenuItem: a,
      handleClick: f
    };
  }
});
function jG(e, t, n, o, l, a) {
  const r = Dt("el-tooltip");
  return M(), G("li", {
    class: z([
      e.nsMenuItem.b(),
      e.nsMenuItem.is("active", e.active),
      e.nsMenuItem.is("disabled", e.disabled)
    ]),
    role: "menuitem",
    tabindex: "-1",
    onClick: t[0] || (t[0] = (...i) => e.handleClick && e.handleClick(...i))
  }, [
    e.parentMenu.type.name === "ElMenu" && e.rootMenu.props.collapse && e.$slots.title ? (M(), We(r, {
      key: 0,
      effect: e.rootMenu.props.popperEffect,
      placement: "right",
      "fallback-placements": ["left"],
      persistent: ""
    }, {
      content: fe(() => [
        Ie(e.$slots, "title")
      ]),
      default: fe(() => [
        X("div", {
          class: z(e.nsMenu.be("tooltip", "trigger"))
        }, [
          Ie(e.$slots, "default")
        ], 2)
      ]),
      _: 3
    }, 8, ["effect"])) : (M(), G(kt, { key: 1 }, [
      Ie(e.$slots, "default"),
      Ie(e.$slots, "title")
    ], 64))
  ], 2);
}
var B$ = /* @__PURE__ */ ut(UG, [["render", jG], ["__file", "menu-item.vue"]]);
const qG = {
  title: String
}, YG = "ElMenuItemGroup", GG = Q({
  name: YG,
  props: qG,
  setup() {
    return {
      ns: nt("menu-item-group")
    };
  }
});
function XG(e, t, n, o, l, a) {
  return M(), G("li", {
    class: z(e.ns.b())
  }, [
    X("div", {
      class: z(e.ns.e("title"))
    }, [
      e.$slots.title ? Ie(e.$slots, "title", { key: 1 }) : (M(), G(kt, { key: 0 }, [
        Ut(Qe(e.title), 1)
      ], 64))
    ], 2),
    X("ul", null, [
      Ie(e.$slots, "default")
    ])
  ], 2);
}
var H$ = /* @__PURE__ */ ut(GG, [["render", XG], ["__file", "menu-item-group.vue"]]);
const ZG = Yt(zG, {
  MenuItem: B$,
  MenuItemGroup: H$,
  SubMenu: r0
}), JG = Jn(B$), QG = Jn(H$), eX = Jn(r0), tX = it({
  icon: {
    type: Dn,
    default: () => o8
  },
  title: String,
  content: {
    type: String,
    default: ""
  }
}), nX = {
  back: () => !0
}, oX = ["aria-label"], lX = Q({
  name: "ElPageHeader"
}), aX = /* @__PURE__ */ Q({
  ...lX,
  props: tX,
  emits: nX,
  setup(e, { emit: t }) {
    const n = Yn(), { t: o } = bn(), l = nt("page-header"), a = x(() => [
      l.b(),
      {
        [l.m("has-breadcrumb")]: !!n.breadcrumb,
        [l.m("has-extra")]: !!n.extra,
        [l.is("contentful")]: !!n.default
      }
    ]);
    function r() {
      t("back");
    }
    return (i, s) => (M(), G("div", {
      class: z(c(a))
    }, [
      i.$slots.breadcrumb ? (M(), G("div", {
        key: 0,
        class: z(c(l).e("breadcrumb"))
      }, [
        Ie(i.$slots, "breadcrumb")
      ], 2)) : _e("v-if", !0),
      X("div", {
        class: z(c(l).e("header"))
      }, [
        X("div", {
          class: z(c(l).e("left"))
        }, [
          X("div", {
            class: z(c(l).e("back")),
            role: "button",
            tabindex: "0",
            onClick: r
          }, [
            i.icon || i.$slots.icon ? (M(), G("div", {
              key: 0,
              "aria-label": i.title || c(o)("el.pageHeader.title"),
              class: z(c(l).e("icon"))
            }, [
              Ie(i.$slots, "icon", {}, () => [
                i.icon ? (M(), We(c(Ct), { key: 0 }, {
                  default: fe(() => [
                    (M(), We(Qt(i.icon)))
                  ]),
                  _: 1
                })) : _e("v-if", !0)
              ])
            ], 10, oX)) : _e("v-if", !0),
            X("div", {
              class: z(c(l).e("title"))
            }, [
              Ie(i.$slots, "title", {}, () => [
                Ut(Qe(i.title || c(o)("el.pageHeader.title")), 1)
              ])
            ], 2)
          ], 2),
          oe(c(k$), { direction: "vertical" }),
          X("div", {
            class: z(c(l).e("content"))
          }, [
            Ie(i.$slots, "content", {}, () => [
              Ut(Qe(i.content), 1)
            ])
          ], 2)
        ], 2),
        i.$slots.extra ? (M(), G("div", {
          key: 0,
          class: z(c(l).e("extra"))
        }, [
          Ie(i.$slots, "extra")
        ], 2)) : _e("v-if", !0)
      ], 2),
      i.$slots.default ? (M(), G("div", {
        key: 1,
        class: z(c(l).e("main"))
      }, [
        Ie(i.$slots, "default")
      ], 2)) : _e("v-if", !0)
    ], 2));
  }
});
var rX = /* @__PURE__ */ ut(aX, [["__file", "page-header.vue"]]);
const sX = Yt(rX), z$ = Symbol("elPaginationKey"), iX = it({
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  prevText: {
    type: String
  },
  prevIcon: {
    type: Dn
  }
}), cX = {
  click: (e) => e instanceof MouseEvent
}, uX = ["disabled", "aria-label", "aria-disabled"], dX = { key: 0 }, fX = Q({
  name: "ElPaginationPrev"
}), pX = /* @__PURE__ */ Q({
  ...fX,
  props: iX,
  emits: cX,
  setup(e) {
    const t = e, { t: n } = bn(), o = x(() => t.disabled || t.currentPage <= 1);
    return (l, a) => (M(), G("button", {
      type: "button",
      class: "btn-prev",
      disabled: c(o),
      "aria-label": l.prevText || c(n)("el.pagination.prev"),
      "aria-disabled": c(o),
      onClick: a[0] || (a[0] = (r) => l.$emit("click", r))
    }, [
      l.prevText ? (M(), G("span", dX, Qe(l.prevText), 1)) : (M(), We(c(Ct), { key: 1 }, {
        default: fe(() => [
          (M(), We(Qt(l.prevIcon)))
        ]),
        _: 1
      }))
    ], 8, uX));
  }
});
var vX = /* @__PURE__ */ ut(pX, [["__file", "prev.vue"]]);
const hX = it({
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    default: 50
  },
  nextText: {
    type: String
  },
  nextIcon: {
    type: Dn
  }
}), mX = ["disabled", "aria-label", "aria-disabled"], gX = { key: 0 }, bX = Q({
  name: "ElPaginationNext"
}), yX = /* @__PURE__ */ Q({
  ...bX,
  props: hX,
  emits: ["click"],
  setup(e) {
    const t = e, { t: n } = bn(), o = x(() => t.disabled || t.currentPage === t.pageCount || t.pageCount === 0);
    return (l, a) => (M(), G("button", {
      type: "button",
      class: "btn-next",
      disabled: c(o),
      "aria-label": l.nextText || c(n)("el.pagination.next"),
      "aria-disabled": c(o),
      onClick: a[0] || (a[0] = (r) => l.$emit("click", r))
    }, [
      l.nextText ? (M(), G("span", gX, Qe(l.nextText), 1)) : (M(), We(c(Ct), { key: 1 }, {
        default: fe(() => [
          (M(), We(Qt(l.nextIcon)))
        ]),
        _: 1
      }))
    ], 8, mX));
  }
});
var CX = /* @__PURE__ */ ut(yX, [["__file", "next.vue"]]);
const W$ = Symbol("ElSelectGroup"), vf = Symbol("ElSelect");
function wX(e, t) {
  const n = ot(vf), o = ot(W$, { disabled: !1 }), l = x(() => n.props.multiple ? d(n.props.modelValue, e.value) : d([n.props.modelValue], e.value)), a = x(() => {
    if (n.props.multiple) {
      const h = n.props.modelValue || [];
      return !l.value && h.length >= n.props.multipleLimit && n.props.multipleLimit > 0;
    } else
      return !1;
  }), r = x(() => e.label || (Mn(e.value) ? "" : e.value)), i = x(() => e.value || e.label || ""), s = x(() => e.disabled || t.groupDisabled || a.value), u = Pt(), d = (h = [], m) => {
    if (Mn(e.value)) {
      const p = n.props.valueKey;
      return h && h.some((C) => Sd(bo(C, p)) === bo(m, p));
    } else
      return h && h.includes(m);
  }, f = () => {
    !e.disabled && !o.disabled && (n.states.hoveringIndex = n.optionsArray.indexOf(u.proxy));
  }, v = (h) => {
    const m = new RegExp(ry(h), "i");
    t.visible = m.test(r.value) || e.created;
  };
  return Pe(() => r.value, () => {
    !e.created && !n.props.remote && n.setSelected();
  }), Pe(() => e.value, (h, m) => {
    const { remote: p, valueKey: C } = n.props;
    if (pl(h, m) || (n.onOptionDestroy(m, u.proxy), n.onOptionCreate(u.proxy)), !e.created && !p) {
      if (C && Mn(h) && Mn(m) && h[C] === m[C])
        return;
      n.setSelected();
    }
  }), Pe(() => o.disabled, () => {
    t.groupDisabled = o.disabled;
  }, { immediate: !0 }), {
    select: n,
    currentLabel: r,
    currentValue: i,
    itemSelected: l,
    isDisabled: s,
    hoverItem: f,
    updateOption: v
  };
}
const EX = Q({
  name: "ElOption",
  componentName: "ElOption",
  props: {
    value: {
      required: !0,
      type: [String, Number, Boolean, Object]
    },
    label: [String, Number],
    created: Boolean,
    disabled: Boolean
  },
  setup(e) {
    const t = nt("select"), n = il(), o = x(() => [
      t.be("dropdown", "item"),
      t.is("disabled", c(i)),
      t.is("selected", c(r)),
      t.is("hovering", c(v))
    ]), l = en({
      index: -1,
      groupDisabled: !1,
      visible: !0,
      hover: !1
    }), {
      currentLabel: a,
      itemSelected: r,
      isDisabled: i,
      select: s,
      hoverItem: u,
      updateOption: d
    } = wX(e, l), { visible: f, hover: v } = Xo(l), h = Pt().proxy;
    s.onOptionCreate(h), zn(() => {
      const p = h.value, { selected: C } = s.states, w = (s.props.multiple ? C : [C]).some((b) => b.value === h.value);
      xe(() => {
        s.states.cachedOptions.get(p) === h && !w && s.states.cachedOptions.delete(p);
      }), s.onOptionDestroy(p, h);
    });
    function m() {
      e.disabled !== !0 && l.groupDisabled !== !0 && s.handleOptionSelect(h);
    }
    return {
      ns: t,
      id: n,
      containerKls: o,
      currentLabel: a,
      itemSelected: r,
      isDisabled: i,
      select: s,
      hoverItem: u,
      updateOption: d,
      visible: f,
      hover: v,
      selectOptionClick: m,
      states: l
    };
  }
}), SX = ["id", "aria-disabled", "aria-selected"];
function _X(e, t, n, o, l, a) {
  return Bt((M(), G("li", {
    id: e.id,
    class: z(e.containerKls),
    role: "option",
    "aria-disabled": e.isDisabled || void 0,
    "aria-selected": e.itemSelected,
    onMouseenter: t[0] || (t[0] = (...r) => e.hoverItem && e.hoverItem(...r)),
    onClick: t[1] || (t[1] = It((...r) => e.selectOptionClick && e.selectOptionClick(...r), ["stop"]))
  }, [
    Ie(e.$slots, "default", {}, () => [
      X("span", null, Qe(e.currentLabel), 1)
    ])
  ], 42, SX)), [
    [pn, e.visible]
  ]);
}
var s0 = /* @__PURE__ */ ut(EX, [["render", _X], ["__file", "option.vue"]]);
const xX = Q({
  name: "ElSelectDropdown",
  componentName: "ElSelectDropdown",
  setup() {
    const e = ot(vf), t = nt("select"), n = x(() => e.props.popperClass), o = x(() => e.props.multiple), l = x(() => e.props.fitInputWidth), a = B("");
    function r() {
      var i;
      a.value = `${(i = e.selectRef) == null ? void 0 : i.offsetWidth}px`;
    }
    return Nt(() => {
      r(), Xn(e.selectRef, r);
    }), {
      ns: t,
      minWidth: a,
      popperClass: n,
      isMultiple: o,
      isFitInputWidth: l
    };
  }
});
function kX(e, t, n, o, l, a) {
  return M(), G("div", {
    class: z([e.ns.b("dropdown"), e.ns.is("multiple", e.isMultiple), e.popperClass]),
    style: bt({ [e.isFitInputWidth ? "width" : "minWidth"]: e.minWidth })
  }, [
    e.$slots.header ? (M(), G("div", {
      key: 0,
      class: z(e.ns.be("dropdown", "header"))
    }, [
      Ie(e.$slots, "header")
    ], 2)) : _e("v-if", !0),
    Ie(e.$slots, "default"),
    e.$slots.footer ? (M(), G("div", {
      key: 1,
      class: z(e.ns.be("dropdown", "footer"))
    }, [
      Ie(e.$slots, "footer")
    ], 2)) : _e("v-if", !0)
  ], 6);
}
var TX = /* @__PURE__ */ ut(xX, [["render", kX], ["__file", "select-dropdown.vue"]]);
function K$(e) {
  const t = B(!1);
  return {
    handleCompositionStart: () => {
      t.value = !0;
    },
    handleCompositionUpdate: (a) => {
      const r = a.target.value, i = r[r.length - 1] || "";
      t.value = !hy(i);
    },
    handleCompositionEnd: (a) => {
      t.value && (t.value = !1, vn(e) && e(a));
    }
  };
}
const $X = 11, OX = (e, t) => {
  const { t: n } = bn(), o = il(), l = nt("select"), a = nt("input"), r = en({
    inputValue: "",
    options: /* @__PURE__ */ new Map(),
    cachedOptions: /* @__PURE__ */ new Map(),
    disabledOptions: /* @__PURE__ */ new Map(),
    optionValues: [],
    selected: e.multiple ? [] : {},
    selectionWidth: 0,
    calculatorWidth: 0,
    collapseItemWidth: 0,
    selectedLabel: "",
    hoveringIndex: -1,
    previousQuery: null,
    inputHovering: !1,
    menuVisibleOnFocus: !1,
    isBeforeHide: !1
  }), i = B(null), s = B(null), u = B(null), d = B(null), f = B(null), v = B(null), h = B(null), m = B(null), p = B(null), C = B(null), g = B(null), w = B(null), { wrapperRef: b, isFocused: y, handleFocus: E, handleBlur: S } = Bv(f, {
    afterFocus() {
      e.automaticDropdown && !_.value && (_.value = !0, r.menuVisibleOnFocus = !0);
    },
    beforeBlur(st) {
      var St, rn;
      return ((St = u.value) == null ? void 0 : St.isFocusInsideContent(st)) || ((rn = d.value) == null ? void 0 : rn.isFocusInsideContent(st));
    },
    afterBlur() {
      _.value = !1, r.menuVisibleOnFocus = !1;
    }
  }), _ = B(!1), k = B(), { form: N, formItem: L } = ml(), { inputId: R } = Wa(e, {
    formItemContext: L
  }), { valueOnClear: H, isEmptyValue: K } = Hv(e), U = x(() => e.disabled || (N == null ? void 0 : N.disabled)), W = x(() => e.multiple ? Kt(e.modelValue) && e.modelValue.length > 0 : !K(e.modelValue)), A = x(() => e.clearable && !U.value && r.inputHovering && W.value), $ = x(() => e.remote && e.filterable && !e.remoteShowSuffix ? "" : e.suffixIcon), D = x(() => l.is("reverse", $.value && _.value)), O = x(() => (L == null ? void 0 : L.validateState) || ""), F = x(() => vy[O.value]), j = x(() => e.remote ? 300 : 0), Z = x(() => e.loading ? e.loadingText || n("el.select.loading") : e.remote && !r.inputValue && r.options.size === 0 ? !1 : e.filterable && r.inputValue && r.options.size > 0 && te.value === 0 ? e.noMatchText || n("el.select.noMatch") : r.options.size === 0 ? e.noDataText || n("el.select.noData") : null), te = x(() => de.value.filter((st) => st.visible).length), de = x(() => {
    const st = Array.from(r.options.values()), St = [];
    return r.optionValues.forEach((rn) => {
      const Tn = st.findIndex((mo) => mo.value === rn);
      Tn > -1 && St.push(st[Tn]);
    }), St.length >= st.length ? St : st;
  }), Oe = x(() => Array.from(r.cachedOptions.values())), ce = x(() => {
    const st = de.value.filter((St) => !St.created).some((St) => St.currentLabel === r.inputValue);
    return e.filterable && e.allowCreate && r.inputValue !== "" && !st;
  }), ne = () => {
    e.filterable && vn(e.filterMethod) || e.filterable && e.remote && vn(e.remoteMethod) || de.value.forEach((st) => {
      var St;
      (St = st.updateOption) == null || St.call(st, r.inputValue);
    });
  }, Y = Mo(), ve = x(() => ["small"].includes(Y.value) ? "small" : "default"), ie = x({
    get() {
      return _.value && Z.value !== !1;
    },
    set(st) {
      _.value = st;
    }
  }), he = x(() => Kt(e.modelValue) ? e.modelValue.length === 0 && !r.inputValue : e.filterable ? !r.inputValue : !0), De = x(() => {
    var st;
    const St = (st = e.placeholder) != null ? st : n("el.select.placeholder");
    return e.multiple || !W.value ? St : r.selectedLabel;
  });
  Pe(() => e.modelValue, (st, St) => {
    e.multiple && e.filterable && !e.reserveKeyword && (r.inputValue = "", $e("")), Ne(), !pl(st, St) && e.validateEvent && (L == null || L.validate("change").catch((rn) => dn(rn)));
  }, {
    flush: "post",
    deep: !0
  }), Pe(() => _.value, (st) => {
    st ? $e(r.inputValue) : (r.inputValue = "", r.previousQuery = null, r.isBeforeHide = !0), t("visible-change", st);
  }), Pe(() => r.options.entries(), () => {
    var st;
    if (!fn)
      return;
    const St = ((st = i.value) == null ? void 0 : st.querySelectorAll("input")) || [];
    (!e.filterable && !e.defaultFirstOption && !To(e.modelValue) || !Array.from(St).includes(document.activeElement)) && Ne(), e.defaultFirstOption && (e.filterable || e.remote) && te.value && ue();
  }, {
    flush: "post"
  }), Pe(() => r.hoveringIndex, (st) => {
    Ot(st) && st > -1 ? k.value = de.value[st] || {} : k.value = {}, de.value.forEach((St) => {
      St.hover = k.value === St;
    });
  }), ol(() => {
    r.isBeforeHide || ne();
  });
  const $e = (st) => {
    r.previousQuery !== st && (r.previousQuery = st, e.filterable && vn(e.filterMethod) ? e.filterMethod(st) : e.filterable && e.remote && vn(e.remoteMethod) && e.remoteMethod(st), e.defaultFirstOption && (e.filterable || e.remote) && te.value ? xe(ue) : xe(Fe));
  }, ue = () => {
    const st = de.value.filter((Tn) => Tn.visible && !Tn.disabled && !Tn.states.groupDisabled), St = st.find((Tn) => Tn.created), rn = st[0];
    r.hoveringIndex = Ke(de.value, St || rn);
  }, Ne = () => {
    if (e.multiple)
      r.selectedLabel = "";
    else {
      const St = je(e.modelValue);
      r.selectedLabel = St.currentLabel, r.selected = St;
      return;
    }
    const st = [];
    Kt(e.modelValue) && e.modelValue.forEach((St) => {
      st.push(je(St));
    }), r.selected = st;
  }, je = (st) => {
    let St;
    const rn = Bh(st).toLowerCase() === "object", Tn = Bh(st).toLowerCase() === "null", mo = Bh(st).toLowerCase() === "undefined";
    for (let Oo = r.cachedOptions.size - 1; Oo >= 0; Oo--) {
      const so = Oe.value[Oo];
      if (rn ? bo(so.value, e.valueKey) === bo(st, e.valueKey) : so.value === st) {
        St = {
          value: st,
          currentLabel: so.currentLabel,
          get isDisabled() {
            return so.isDisabled;
          }
        };
        break;
      }
    }
    if (St)
      return St;
    const ro = rn ? st.label : !Tn && !mo ? st : "";
    return {
      value: st,
      currentLabel: ro
    };
  }, Fe = () => {
    e.multiple ? r.hoveringIndex = de.value.findIndex((st) => r.selected.some((St) => xn(St) === xn(st))) : r.hoveringIndex = de.value.findIndex((st) => xn(st) === xn(r.selected));
  }, Ve = () => {
    r.selectionWidth = s.value.getBoundingClientRect().width;
  }, Ze = () => {
    r.calculatorWidth = v.value.getBoundingClientRect().width;
  }, ae = () => {
    r.collapseItemWidth = g.value.getBoundingClientRect().width;
  }, pe = () => {
    var st, St;
    (St = (st = u.value) == null ? void 0 : st.updatePopper) == null || St.call(st);
  }, ke = () => {
    var st, St;
    (St = (st = d.value) == null ? void 0 : st.updatePopper) == null || St.call(st);
  }, Ue = () => {
    r.inputValue.length > 0 && !_.value && (_.value = !0), $e(r.inputValue);
  }, Xe = (st) => {
    if (r.inputValue = st.target.value, e.remote)
      re();
    else
      return Ue();
  }, re = Hl(() => {
    Ue();
  }, j.value), Te = (st) => {
    pl(e.modelValue, st) || t(qn, st);
  }, Ce = (st) => Bx(st, (St) => !r.disabledOptions.has(St)), Le = (st) => {
    if (e.multiple && st.code !== xt.delete && st.target.value.length <= 0) {
      const St = e.modelValue.slice(), rn = Ce(St);
      if (rn < 0)
        return;
      St.splice(rn, 1), t(Jt, St), Te(St);
    }
  }, ge = (st, St) => {
    const rn = r.selected.indexOf(St);
    if (rn > -1 && !U.value) {
      const Tn = e.modelValue.slice();
      Tn.splice(rn, 1), t(Jt, Tn), Te(Tn), t("remove-tag", St.value);
    }
    st.stopPropagation(), be();
  }, Ee = (st) => {
    st.stopPropagation();
    const St = e.multiple ? [] : H.value;
    if (e.multiple)
      for (const rn of r.selected)
        rn.isDisabled && St.push(rn.value);
    t(Jt, St), Te(St), r.hoveringIndex = -1, _.value = !1, t("clear"), be();
  }, me = (st) => {
    if (e.multiple) {
      const St = (e.modelValue || []).slice(), rn = Ke(St, st.value);
      rn > -1 ? St.splice(rn, 1) : (e.multipleLimit <= 0 || St.length < e.multipleLimit) && St.push(st.value), t(Jt, St), Te(St), st.created && $e(""), e.filterable && !e.reserveKeyword && (r.inputValue = "");
    } else
      t(Jt, st.value), Te(st.value), _.value = !1;
    be(), !_.value && xe(() => {
      Re(st);
    });
  }, Ke = (st = [], St) => {
    if (!Mn(St))
      return st.indexOf(St);
    const rn = e.valueKey;
    let Tn = -1;
    return st.some((mo, ro) => Sd(bo(mo, rn)) === bo(St, rn) ? (Tn = ro, !0) : !1), Tn;
  }, Re = (st) => {
    var St, rn, Tn, mo, ro;
    const Io = Kt(st) ? st[0] : st;
    let Oo = null;
    if (Io != null && Io.value) {
      const so = de.value.filter((la) => la.value === Io.value);
      so.length > 0 && (Oo = so[0].$el);
    }
    if (u.value && Oo) {
      const so = (mo = (Tn = (rn = (St = u.value) == null ? void 0 : St.popperRef) == null ? void 0 : rn.contentRef) == null ? void 0 : Tn.querySelector) == null ? void 0 : mo.call(Tn, `.${l.be("dropdown", "wrap")}`);
      so && jx(so, Oo);
    }
    (ro = w.value) == null || ro.handleScroll();
  }, we = (st) => {
    r.options.set(st.value, st), r.cachedOptions.set(st.value, st), st.disabled && r.disabledOptions.set(st.value, st);
  }, ze = (st, St) => {
    r.options.get(st) === St && r.options.delete(st);
  }, {
    handleCompositionStart: Je,
    handleCompositionUpdate: Me,
    handleCompositionEnd: et
  } = K$((st) => Xe(st)), mt = x(() => {
    var st, St;
    return (St = (st = u.value) == null ? void 0 : st.popperRef) == null ? void 0 : St.contentRef;
  }), Lt = () => {
    r.isBeforeHide = !1, xe(() => Re(r.selected));
  }, be = () => {
    var st;
    (st = f.value) == null || st.focus();
  }, an = () => {
    zt();
  }, _t = (st) => {
    Ee(st);
  }, zt = (st) => {
    if (_.value = !1, y.value) {
      const St = new FocusEvent("focus", st);
      xe(() => S(St));
    }
  }, jt = () => {
    r.inputValue.length > 0 ? r.inputValue = "" : _.value = !1;
  }, Sn = () => {
    U.value || (r.menuVisibleOnFocus ? r.menuVisibleOnFocus = !1 : _.value = !_.value);
  }, hn = () => {
    _.value ? de.value[r.hoveringIndex] && me(de.value[r.hoveringIndex]) : Sn();
  }, xn = (st) => Mn(st.value) ? bo(st.value, e.valueKey) : st.value, yn = x(() => de.value.filter((st) => st.visible).every((st) => st.disabled)), kn = x(() => e.multiple ? e.collapseTags ? r.selected.slice(0, e.maxCollapseTags) : r.selected : []), Wn = x(() => e.multiple ? e.collapseTags ? r.selected.slice(e.maxCollapseTags) : [] : []), Vn = (st) => {
    if (!_.value) {
      _.value = !0;
      return;
    }
    if (!(r.options.size === 0 || te.value === 0) && !yn.value) {
      st === "next" ? (r.hoveringIndex++, r.hoveringIndex === r.options.size && (r.hoveringIndex = 0)) : st === "prev" && (r.hoveringIndex--, r.hoveringIndex < 0 && (r.hoveringIndex = r.options.size - 1));
      const St = de.value[r.hoveringIndex];
      (St.disabled === !0 || St.states.groupDisabled === !0 || !St.visible) && Vn(st), xe(() => Re(k.value));
    }
  }, ho = () => {
    if (!s.value)
      return 0;
    const st = window.getComputedStyle(s.value);
    return Number.parseFloat(st.gap || "6px");
  }, Qn = x(() => {
    const st = ho();
    return { maxWidth: `${g.value && e.maxCollapseTags === 1 ? r.selectionWidth - r.collapseItemWidth - st : r.selectionWidth}px` };
  }), eo = x(() => ({ maxWidth: `${r.selectionWidth}px` })), So = x(() => ({
    width: `${Math.max(r.calculatorWidth, $X)}px`
  }));
  return e.multiple && !Kt(e.modelValue) && t(Jt, []), !e.multiple && Kt(e.modelValue) && t(Jt, ""), Xn(s, Ve), Xn(v, Ze), Xn(p, pe), Xn(b, pe), Xn(C, ke), Xn(g, ae), Nt(() => {
    Ne();
  }), {
    inputId: R,
    contentId: o,
    nsSelect: l,
    nsInput: a,
    states: r,
    isFocused: y,
    expanded: _,
    optionsArray: de,
    hoverOption: k,
    selectSize: Y,
    filteredOptionsCount: te,
    resetCalculatorWidth: Ze,
    updateTooltip: pe,
    updateTagTooltip: ke,
    debouncedOnInputChange: re,
    onInput: Xe,
    deletePrevTag: Le,
    deleteTag: ge,
    deleteSelected: Ee,
    handleOptionSelect: me,
    scrollToOption: Re,
    hasModelValue: W,
    shouldShowPlaceholder: he,
    currentPlaceholder: De,
    showClose: A,
    iconComponent: $,
    iconReverse: D,
    validateState: O,
    validateIcon: F,
    showNewOption: ce,
    updateOptions: ne,
    collapseTagSize: ve,
    setSelected: Ne,
    selectDisabled: U,
    emptyText: Z,
    handleCompositionStart: Je,
    handleCompositionUpdate: Me,
    handleCompositionEnd: et,
    onOptionCreate: we,
    onOptionDestroy: ze,
    handleMenuEnter: Lt,
    handleFocus: E,
    focus: be,
    blur: an,
    handleBlur: S,
    handleClearClick: _t,
    handleClickOutside: zt,
    handleEsc: jt,
    toggleMenu: Sn,
    selectOption: hn,
    getValueKey: xn,
    navigateOptions: Vn,
    dropdownMenuVisible: ie,
    showTagList: kn,
    collapseTagList: Wn,
    tagStyle: Qn,
    collapseTagStyle: eo,
    inputStyle: So,
    popperRef: mt,
    inputRef: f,
    tooltipRef: u,
    tagTooltipRef: d,
    calculatorRef: v,
    prefixRef: h,
    suffixRef: m,
    selectRef: i,
    wrapperRef: b,
    selectionRef: s,
    scrollbarRef: w,
    menuRef: p,
    tagMenuRef: C,
    collapseItemRef: g
  };
};
var NX = Q({
  name: "ElOptions",
  setup(e, { slots: t }) {
    const n = ot(vf);
    let o = [];
    return () => {
      var l, a;
      const r = (l = t.default) == null ? void 0 : l.call(t), i = [];
      function s(u) {
        Kt(u) && u.forEach((d) => {
          var f, v, h, m;
          const p = (f = (d == null ? void 0 : d.type) || {}) == null ? void 0 : f.name;
          p === "ElOptionGroup" ? s(!on(d.children) && !Kt(d.children) && vn((v = d.children) == null ? void 0 : v.default) ? (h = d.children) == null ? void 0 : h.default() : d.children) : p === "ElOption" ? i.push((m = d.props) == null ? void 0 : m.value) : Kt(d.children) && s(d.children);
        });
      }
      return r.length && s((a = r[0]) == null ? void 0 : a.children), pl(i, o) || (o = i, n && (n.states.optionValues = i)), r;
    };
  }
});
const MX = it({
  name: String,
  id: String,
  modelValue: {
    type: [Array, String, Number, Boolean, Object],
    default: void 0
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  automaticDropdown: Boolean,
  size: Lo,
  effect: {
    type: Ae(String),
    default: "light"
  },
  disabled: Boolean,
  clearable: Boolean,
  filterable: Boolean,
  allowCreate: Boolean,
  loading: Boolean,
  popperClass: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: Ae(Object),
    default: () => ({})
  },
  remote: Boolean,
  loadingText: String,
  noMatchText: String,
  noDataText: String,
  remoteMethod: Function,
  filterMethod: Function,
  multiple: Boolean,
  multipleLimit: {
    type: Number,
    default: 0
  },
  placeholder: {
    type: String
  },
  defaultFirstOption: Boolean,
  reserveKeyword: {
    type: Boolean,
    default: !0
  },
  valueKey: {
    type: String,
    default: "value"
  },
  collapseTags: Boolean,
  collapseTagsTooltip: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  teleported: Fo.teleported,
  persistent: {
    type: Boolean,
    default: !0
  },
  clearIcon: {
    type: Dn,
    default: Ls
  },
  fitInputWidth: Boolean,
  suffixIcon: {
    type: Dn,
    default: Br
  },
  tagType: { ...Uv.type, default: "info" },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  remoteShowSuffix: Boolean,
  placement: {
    type: Ae(String),
    values: Hi,
    default: "bottom-start"
  },
  fallbackPlacements: {
    type: Ae(Array),
    default: ["bottom-start", "top-start", "right", "left"]
  },
  ...ru,
  ...Zo(["ariaLabel"])
}), cE = "ElSelect", IX = Q({
  name: cE,
  componentName: cE,
  components: {
    ElInput: nl,
    ElSelectMenu: TX,
    ElOption: s0,
    ElOptions: NX,
    ElTag: Uc,
    ElScrollbar: zr,
    ElTooltip: hl,
    ElIcon: Ct
  },
  directives: { ClickOutside: Pr },
  props: MX,
  emits: [
    Jt,
    qn,
    "remove-tag",
    "clear",
    "visible-change",
    "focus",
    "blur"
  ],
  setup(e, { emit: t }) {
    const n = OX(e, t);
    return Mt(vf, en({
      props: e,
      states: n.states,
      optionsArray: n.optionsArray,
      handleOptionSelect: n.handleOptionSelect,
      onOptionCreate: n.onOptionCreate,
      onOptionDestroy: n.onOptionDestroy,
      selectRef: n.selectRef,
      setSelected: n.setSelected
    })), {
      ...n
    };
  }
}), RX = ["id", "disabled", "autocomplete", "readonly", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"], DX = ["textContent"];
function LX(e, t, n, o, l, a) {
  const r = Dt("el-tag"), i = Dt("el-tooltip"), s = Dt("el-icon"), u = Dt("el-option"), d = Dt("el-options"), f = Dt("el-scrollbar"), v = Dt("el-select-menu"), h = _v("click-outside");
  return Bt((M(), G("div", {
    ref: "selectRef",
    class: z([e.nsSelect.b(), e.nsSelect.m(e.selectSize)]),
    onMouseenter: t[16] || (t[16] = (m) => e.states.inputHovering = !0),
    onMouseleave: t[17] || (t[17] = (m) => e.states.inputHovering = !1),
    onClick: t[18] || (t[18] = It((...m) => e.toggleMenu && e.toggleMenu(...m), ["prevent", "stop"]))
  }, [
    oe(i, {
      ref: "tooltipRef",
      visible: e.dropdownMenuVisible,
      placement: e.placement,
      teleported: e.teleported,
      "popper-class": [e.nsSelect.e("popper"), e.popperClass],
      "popper-options": e.popperOptions,
      "fallback-placements": e.fallbackPlacements,
      effect: e.effect,
      pure: "",
      trigger: "click",
      transition: `${e.nsSelect.namespace.value}-zoom-in-top`,
      "stop-popper-mouse-event": !1,
      "gpu-acceleration": !1,
      persistent: e.persistent,
      onBeforeShow: e.handleMenuEnter,
      onHide: t[15] || (t[15] = (m) => e.states.isBeforeHide = !1)
    }, {
      default: fe(() => {
        var m;
        return [
          X("div", {
            ref: "wrapperRef",
            class: z([
              e.nsSelect.e("wrapper"),
              e.nsSelect.is("focused", e.isFocused),
              e.nsSelect.is("hovering", e.states.inputHovering),
              e.nsSelect.is("filterable", e.filterable),
              e.nsSelect.is("disabled", e.selectDisabled)
            ])
          }, [
            e.$slots.prefix ? (M(), G("div", {
              key: 0,
              ref: "prefixRef",
              class: z(e.nsSelect.e("prefix"))
            }, [
              Ie(e.$slots, "prefix")
            ], 2)) : _e("v-if", !0),
            X("div", {
              ref: "selectionRef",
              class: z([
                e.nsSelect.e("selection"),
                e.nsSelect.is("near", e.multiple && !e.$slots.prefix && !!e.states.selected.length)
              ])
            }, [
              e.multiple ? Ie(e.$slots, "tag", { key: 0 }, () => [
                (M(!0), G(kt, null, ln(e.showTagList, (p) => (M(), G("div", {
                  key: e.getValueKey(p),
                  class: z(e.nsSelect.e("selected-item"))
                }, [
                  oe(r, {
                    closable: !e.selectDisabled && !p.isDisabled,
                    size: e.collapseTagSize,
                    type: e.tagType,
                    "disable-transitions": "",
                    style: bt(e.tagStyle),
                    onClose: (C) => e.deleteTag(C, p)
                  }, {
                    default: fe(() => [
                      X("span", {
                        class: z(e.nsSelect.e("tags-text"))
                      }, Qe(p.currentLabel), 3)
                    ]),
                    _: 2
                  }, 1032, ["closable", "size", "type", "style", "onClose"])
                ], 2))), 128)),
                e.collapseTags && e.states.selected.length > e.maxCollapseTags ? (M(), We(i, {
                  key: 0,
                  ref: "tagTooltipRef",
                  disabled: e.dropdownMenuVisible || !e.collapseTagsTooltip,
                  "fallback-placements": ["bottom", "top", "right", "left"],
                  effect: e.effect,
                  placement: "bottom",
                  teleported: e.teleported
                }, {
                  default: fe(() => [
                    X("div", {
                      ref: "collapseItemRef",
                      class: z(e.nsSelect.e("selected-item"))
                    }, [
                      oe(r, {
                        closable: !1,
                        size: e.collapseTagSize,
                        type: e.tagType,
                        "disable-transitions": "",
                        style: bt(e.collapseTagStyle)
                      }, {
                        default: fe(() => [
                          X("span", {
                            class: z(e.nsSelect.e("tags-text"))
                          }, " + " + Qe(e.states.selected.length - e.maxCollapseTags), 3)
                        ]),
                        _: 1
                      }, 8, ["size", "type", "style"])
                    ], 2)
                  ]),
                  content: fe(() => [
                    X("div", {
                      ref: "tagMenuRef",
                      class: z(e.nsSelect.e("selection"))
                    }, [
                      (M(!0), G(kt, null, ln(e.collapseTagList, (p) => (M(), G("div", {
                        key: e.getValueKey(p),
                        class: z(e.nsSelect.e("selected-item"))
                      }, [
                        oe(r, {
                          class: "in-tooltip",
                          closable: !e.selectDisabled && !p.isDisabled,
                          size: e.collapseTagSize,
                          type: e.tagType,
                          "disable-transitions": "",
                          onClose: (C) => e.deleteTag(C, p)
                        }, {
                          default: fe(() => [
                            X("span", {
                              class: z(e.nsSelect.e("tags-text"))
                            }, Qe(p.currentLabel), 3)
                          ]),
                          _: 2
                        }, 1032, ["closable", "size", "type", "onClose"])
                      ], 2))), 128))
                    ], 2)
                  ]),
                  _: 1
                }, 8, ["disabled", "effect", "teleported"])) : _e("v-if", !0)
              ]) : _e("v-if", !0),
              e.selectDisabled ? _e("v-if", !0) : (M(), G("div", {
                key: 1,
                class: z([
                  e.nsSelect.e("selected-item"),
                  e.nsSelect.e("input-wrapper"),
                  e.nsSelect.is("hidden", !e.filterable)
                ])
              }, [
                Bt(X("input", {
                  id: e.inputId,
                  ref: "inputRef",
                  "onUpdate:modelValue": t[0] || (t[0] = (p) => e.states.inputValue = p),
                  type: "text",
                  class: z([e.nsSelect.e("input"), e.nsSelect.is(e.selectSize)]),
                  disabled: e.selectDisabled,
                  autocomplete: e.autocomplete,
                  style: bt(e.inputStyle),
                  role: "combobox",
                  readonly: !e.filterable,
                  spellcheck: "false",
                  "aria-activedescendant": ((m = e.hoverOption) == null ? void 0 : m.id) || "",
                  "aria-controls": e.contentId,
                  "aria-expanded": e.dropdownMenuVisible,
                  "aria-label": e.ariaLabel,
                  "aria-autocomplete": "none",
                  "aria-haspopup": "listbox",
                  onFocus: t[1] || (t[1] = (...p) => e.handleFocus && e.handleFocus(...p)),
                  onBlur: t[2] || (t[2] = (...p) => e.handleBlur && e.handleBlur(...p)),
                  onKeydown: [
                    t[3] || (t[3] = Rn(It((p) => e.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                    t[4] || (t[4] = Rn(It((p) => e.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                    t[5] || (t[5] = Rn(It((...p) => e.handleEsc && e.handleEsc(...p), ["stop", "prevent"]), ["esc"])),
                    t[6] || (t[6] = Rn(It((...p) => e.selectOption && e.selectOption(...p), ["stop", "prevent"]), ["enter"])),
                    t[7] || (t[7] = Rn(It((...p) => e.deletePrevTag && e.deletePrevTag(...p), ["stop"]), ["delete"]))
                  ],
                  onCompositionstart: t[8] || (t[8] = (...p) => e.handleCompositionStart && e.handleCompositionStart(...p)),
                  onCompositionupdate: t[9] || (t[9] = (...p) => e.handleCompositionUpdate && e.handleCompositionUpdate(...p)),
                  onCompositionend: t[10] || (t[10] = (...p) => e.handleCompositionEnd && e.handleCompositionEnd(...p)),
                  onInput: t[11] || (t[11] = (...p) => e.onInput && e.onInput(...p)),
                  onClick: t[12] || (t[12] = It((...p) => e.toggleMenu && e.toggleMenu(...p), ["stop"]))
                }, null, 46, RX), [
                  [Vb, e.states.inputValue]
                ]),
                e.filterable ? (M(), G("span", {
                  key: 0,
                  ref: "calculatorRef",
                  "aria-hidden": "true",
                  class: z(e.nsSelect.e("input-calculator")),
                  textContent: Qe(e.states.inputValue)
                }, null, 10, DX)) : _e("v-if", !0)
              ], 2)),
              e.shouldShowPlaceholder ? (M(), G("div", {
                key: 2,
                class: z([
                  e.nsSelect.e("selected-item"),
                  e.nsSelect.e("placeholder"),
                  e.nsSelect.is("transparent", !e.hasModelValue || e.expanded && !e.states.inputValue)
                ])
              }, [
                X("span", null, Qe(e.currentPlaceholder), 1)
              ], 2)) : _e("v-if", !0)
            ], 2),
            X("div", {
              ref: "suffixRef",
              class: z(e.nsSelect.e("suffix"))
            }, [
              e.iconComponent && !e.showClose ? (M(), We(s, {
                key: 0,
                class: z([e.nsSelect.e("caret"), e.nsSelect.e("icon"), e.iconReverse])
              }, {
                default: fe(() => [
                  (M(), We(Qt(e.iconComponent)))
                ]),
                _: 1
              }, 8, ["class"])) : _e("v-if", !0),
              e.showClose && e.clearIcon ? (M(), We(s, {
                key: 1,
                class: z([e.nsSelect.e("caret"), e.nsSelect.e("icon")]),
                onClick: e.handleClearClick
              }, {
                default: fe(() => [
                  (M(), We(Qt(e.clearIcon)))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : _e("v-if", !0),
              e.validateState && e.validateIcon ? (M(), We(s, {
                key: 2,
                class: z([e.nsInput.e("icon"), e.nsInput.e("validateIcon")])
              }, {
                default: fe(() => [
                  (M(), We(Qt(e.validateIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : _e("v-if", !0)
            ], 2)
          ], 2)
        ];
      }),
      content: fe(() => [
        oe(v, { ref: "menuRef" }, {
          default: fe(() => [
            e.$slots.header ? (M(), G("div", {
              key: 0,
              class: z(e.nsSelect.be("dropdown", "header")),
              onClick: t[13] || (t[13] = It(() => {
              }, ["stop"]))
            }, [
              Ie(e.$slots, "header")
            ], 2)) : _e("v-if", !0),
            Bt(oe(f, {
              id: e.contentId,
              ref: "scrollbarRef",
              tag: "ul",
              "wrap-class": e.nsSelect.be("dropdown", "wrap"),
              "view-class": e.nsSelect.be("dropdown", "list"),
              class: z([e.nsSelect.is("empty", e.filteredOptionsCount === 0)]),
              role: "listbox",
              "aria-label": e.ariaLabel,
              "aria-orientation": "vertical"
            }, {
              default: fe(() => [
                e.showNewOption ? (M(), We(u, {
                  key: 0,
                  value: e.states.inputValue,
                  created: !0
                }, null, 8, ["value"])) : _e("v-if", !0),
                oe(d, null, {
                  default: fe(() => [
                    Ie(e.$slots, "default")
                  ]),
                  _: 3
                })
              ]),
              _: 3
            }, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [
              [pn, e.states.options.size > 0 && !e.loading]
            ]),
            e.$slots.loading && e.loading ? (M(), G("div", {
              key: 1,
              class: z(e.nsSelect.be("dropdown", "loading"))
            }, [
              Ie(e.$slots, "loading")
            ], 2)) : e.loading || e.filteredOptionsCount === 0 ? (M(), G("div", {
              key: 2,
              class: z(e.nsSelect.be("dropdown", "empty"))
            }, [
              Ie(e.$slots, "empty", {}, () => [
                X("span", null, Qe(e.emptyText), 1)
              ])
            ], 2)) : _e("v-if", !0),
            e.$slots.footer ? (M(), G("div", {
              key: 3,
              class: z(e.nsSelect.be("dropdown", "footer")),
              onClick: t[14] || (t[14] = It(() => {
              }, ["stop"]))
            }, [
              Ie(e.$slots, "footer")
            ], 2)) : _e("v-if", !0)
          ]),
          _: 3
        }, 512)
      ]),
      _: 3
    }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "fallback-placements", "effect", "transition", "persistent", "onBeforeShow"])
  ], 34)), [
    [h, e.handleClickOutside, e.popperRef]
  ]);
}
var PX = /* @__PURE__ */ ut(IX, [["render", LX], ["__file", "select.vue"]]);
const AX = Q({
  name: "ElOptionGroup",
  componentName: "ElOptionGroup",
  props: {
    label: String,
    disabled: Boolean
  },
  setup(e) {
    const t = nt("select"), n = B(null), o = Pt(), l = B([]);
    Mt(W$, en({
      ...Xo(e)
    }));
    const a = x(() => l.value.some((u) => u.visible === !0)), r = (u) => {
      var d, f;
      return ((d = u.type) == null ? void 0 : d.name) === "ElOption" && !!((f = u.component) != null && f.proxy);
    }, i = (u) => {
      const d = _s(u), f = [];
      return d.forEach((v) => {
        var h, m;
        r(v) ? f.push(v.component.proxy) : (h = v.children) != null && h.length ? f.push(...i(v.children)) : (m = v.component) != null && m.subTree && f.push(...i(v.component.subTree));
      }), f;
    }, s = () => {
      l.value = i(o.subTree);
    };
    return Nt(() => {
      s();
    }), J2(n, s, {
      attributes: !0,
      subtree: !0,
      childList: !0
    }), {
      groupRef: n,
      visible: a,
      ns: t
    };
  }
});
function FX(e, t, n, o, l, a) {
  return Bt((M(), G("ul", {
    ref: "groupRef",
    class: z(e.ns.be("group", "wrap"))
  }, [
    X("li", {
      class: z(e.ns.be("group", "title"))
    }, Qe(e.label), 3),
    X("li", null, [
      X("ul", {
        class: z(e.ns.b("group"))
      }, [
        Ie(e.$slots, "default")
      ], 2)
    ])
  ], 2)), [
    [pn, e.visible]
  ]);
}
var U$ = /* @__PURE__ */ ut(AX, [["render", FX], ["__file", "option-group.vue"]]);
const Ns = Yt(PX, {
  Option: s0,
  OptionGroup: U$
}), Ad = Jn(s0), j$ = Jn(U$), i0 = () => ot(z$, {}), VX = it({
  pageSize: {
    type: Number,
    required: !0
  },
  pageSizes: {
    type: Ae(Array),
    default: () => Zn([10, 20, 30, 40, 50, 100])
  },
  popperClass: {
    type: String
  },
  disabled: Boolean,
  teleported: Boolean,
  size: {
    type: String,
    values: fr
  }
}), BX = Q({
  name: "ElPaginationSizes"
}), HX = /* @__PURE__ */ Q({
  ...BX,
  props: VX,
  emits: ["page-size-change"],
  setup(e, { emit: t }) {
    const n = e, { t: o } = bn(), l = nt("pagination"), a = i0(), r = B(n.pageSize);
    Pe(() => n.pageSizes, (u, d) => {
      if (!pl(u, d) && Array.isArray(u)) {
        const f = u.includes(n.pageSize) ? n.pageSize : n.pageSizes[0];
        t("page-size-change", f);
      }
    }), Pe(() => n.pageSize, (u) => {
      r.value = u;
    });
    const i = x(() => n.pageSizes);
    function s(u) {
      var d;
      u !== r.value && (r.value = u, (d = a.handleSizeChange) == null || d.call(a, Number(u)));
    }
    return (u, d) => (M(), G("span", {
      class: z(c(l).e("sizes"))
    }, [
      oe(c(Ns), {
        "model-value": r.value,
        disabled: u.disabled,
        "popper-class": u.popperClass,
        size: u.size,
        teleported: u.teleported,
        "validate-event": !1,
        onChange: s
      }, {
        default: fe(() => [
          (M(!0), G(kt, null, ln(c(i), (f) => (M(), We(c(Ad), {
            key: f,
            value: f,
            label: f + c(o)("el.pagination.pagesize")
          }, null, 8, ["value", "label"]))), 128))
        ]),
        _: 1
      }, 8, ["model-value", "disabled", "popper-class", "size", "teleported"])
    ], 2));
  }
});
var zX = /* @__PURE__ */ ut(HX, [["__file", "sizes.vue"]]);
const WX = it({
  size: {
    type: String,
    values: fr
  }
}), KX = ["disabled"], UX = Q({
  name: "ElPaginationJumper"
}), jX = /* @__PURE__ */ Q({
  ...UX,
  props: WX,
  setup(e) {
    const { t } = bn(), n = nt("pagination"), { pageCount: o, disabled: l, currentPage: a, changeEvent: r } = i0(), i = B(), s = x(() => {
      var f;
      return (f = i.value) != null ? f : a == null ? void 0 : a.value;
    });
    function u(f) {
      i.value = f ? +f : "";
    }
    function d(f) {
      f = Math.trunc(+f), r == null || r(f), i.value = void 0;
    }
    return (f, v) => (M(), G("span", {
      class: z(c(n).e("jump")),
      disabled: c(l)
    }, [
      X("span", {
        class: z([c(n).e("goto")])
      }, Qe(c(t)("el.pagination.goto")), 3),
      oe(c(nl), {
        size: f.size,
        class: z([c(n).e("editor"), c(n).is("in-pagination")]),
        min: 1,
        max: c(o),
        disabled: c(l),
        "model-value": c(s),
        "validate-event": !1,
        "aria-label": c(t)("el.pagination.page"),
        type: "number",
        "onUpdate:modelValue": u,
        onChange: d
      }, null, 8, ["size", "class", "max", "disabled", "model-value", "aria-label"]),
      X("span", {
        class: z([c(n).e("classifier")])
      }, Qe(c(t)("el.pagination.pageClassifier")), 3)
    ], 10, KX));
  }
});
var qX = /* @__PURE__ */ ut(jX, [["__file", "jumper.vue"]]);
const YX = it({
  total: {
    type: Number,
    default: 1e3
  }
}), GX = ["disabled"], XX = Q({
  name: "ElPaginationTotal"
}), ZX = /* @__PURE__ */ Q({
  ...XX,
  props: YX,
  setup(e) {
    const { t } = bn(), n = nt("pagination"), { disabled: o } = i0();
    return (l, a) => (M(), G("span", {
      class: z(c(n).e("total")),
      disabled: c(o)
    }, Qe(c(t)("el.pagination.total", {
      total: l.total
    })), 11, GX));
  }
});
var JX = /* @__PURE__ */ ut(ZX, [["__file", "total.vue"]]);
const QX = it({
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    required: !0
  },
  pagerCount: {
    type: Number,
    default: 7
  },
  disabled: Boolean
}), eZ = ["onKeyup"], tZ = ["aria-current", "aria-label", "tabindex"], nZ = ["tabindex", "aria-label"], oZ = ["aria-current", "aria-label", "tabindex"], lZ = ["tabindex", "aria-label"], aZ = ["aria-current", "aria-label", "tabindex"], rZ = Q({
  name: "ElPaginationPager"
}), sZ = /* @__PURE__ */ Q({
  ...rZ,
  props: QX,
  emits: ["change"],
  setup(e, { emit: t }) {
    const n = e, o = nt("pager"), l = nt("icon"), { t: a } = bn(), r = B(!1), i = B(!1), s = B(!1), u = B(!1), d = B(!1), f = B(!1), v = x(() => {
      const y = n.pagerCount, E = (y - 1) / 2, S = Number(n.currentPage), _ = Number(n.pageCount);
      let k = !1, N = !1;
      _ > y && (S > y - E && (k = !0), S < _ - E && (N = !0));
      const L = [];
      if (k && !N) {
        const R = _ - (y - 2);
        for (let H = R; H < _; H++)
          L.push(H);
      } else if (!k && N)
        for (let R = 2; R < y; R++)
          L.push(R);
      else if (k && N) {
        const R = Math.floor(y / 2) - 1;
        for (let H = S - R; H <= S + R; H++)
          L.push(H);
      } else
        for (let R = 2; R < _; R++)
          L.push(R);
      return L;
    }), h = x(() => [
      "more",
      "btn-quickprev",
      l.b(),
      o.is("disabled", n.disabled)
    ]), m = x(() => [
      "more",
      "btn-quicknext",
      l.b(),
      o.is("disabled", n.disabled)
    ]), p = x(() => n.disabled ? -1 : 0);
    ol(() => {
      const y = (n.pagerCount - 1) / 2;
      r.value = !1, i.value = !1, n.pageCount > n.pagerCount && (n.currentPage > n.pagerCount - y && (r.value = !0), n.currentPage < n.pageCount - y && (i.value = !0));
    });
    function C(y = !1) {
      n.disabled || (y ? s.value = !0 : u.value = !0);
    }
    function g(y = !1) {
      y ? d.value = !0 : f.value = !0;
    }
    function w(y) {
      const E = y.target;
      if (E.tagName.toLowerCase() === "li" && Array.from(E.classList).includes("number")) {
        const S = Number(E.textContent);
        S !== n.currentPage && t("change", S);
      } else
        E.tagName.toLowerCase() === "li" && Array.from(E.classList).includes("more") && b(y);
    }
    function b(y) {
      const E = y.target;
      if (E.tagName.toLowerCase() === "ul" || n.disabled)
        return;
      let S = Number(E.textContent);
      const _ = n.pageCount, k = n.currentPage, N = n.pagerCount - 2;
      E.className.includes("more") && (E.className.includes("quickprev") ? S = k - N : E.className.includes("quicknext") && (S = k + N)), Number.isNaN(+S) || (S < 1 && (S = 1), S > _ && (S = _)), S !== k && t("change", S);
    }
    return (y, E) => (M(), G("ul", {
      class: z(c(o).b()),
      onClick: b,
      onKeyup: Rn(w, ["enter"])
    }, [
      y.pageCount > 0 ? (M(), G("li", {
        key: 0,
        class: z([[
          c(o).is("active", y.currentPage === 1),
          c(o).is("disabled", y.disabled)
        ], "number"]),
        "aria-current": y.currentPage === 1,
        "aria-label": c(a)("el.pagination.currentPage", { pager: 1 }),
        tabindex: c(p)
      }, " 1 ", 10, tZ)) : _e("v-if", !0),
      r.value ? (M(), G("li", {
        key: 1,
        class: z(c(h)),
        tabindex: c(p),
        "aria-label": c(a)("el.pagination.prevPages", { pager: y.pagerCount - 2 }),
        onMouseenter: E[0] || (E[0] = (S) => C(!0)),
        onMouseleave: E[1] || (E[1] = (S) => s.value = !1),
        onFocus: E[2] || (E[2] = (S) => g(!0)),
        onBlur: E[3] || (E[3] = (S) => d.value = !1)
      }, [
        (s.value || d.value) && !y.disabled ? (M(), We(c(Pc), { key: 0 })) : (M(), We(c(XC), { key: 1 }))
      ], 42, nZ)) : _e("v-if", !0),
      (M(!0), G(kt, null, ln(c(v), (S) => (M(), G("li", {
        key: S,
        class: z([[
          c(o).is("active", y.currentPage === S),
          c(o).is("disabled", y.disabled)
        ], "number"]),
        "aria-current": y.currentPage === S,
        "aria-label": c(a)("el.pagination.currentPage", { pager: S }),
        tabindex: c(p)
      }, Qe(S), 11, oZ))), 128)),
      i.value ? (M(), G("li", {
        key: 2,
        class: z(c(m)),
        tabindex: c(p),
        "aria-label": c(a)("el.pagination.nextPages", { pager: y.pagerCount - 2 }),
        onMouseenter: E[4] || (E[4] = (S) => C()),
        onMouseleave: E[5] || (E[5] = (S) => u.value = !1),
        onFocus: E[6] || (E[6] = (S) => g()),
        onBlur: E[7] || (E[7] = (S) => f.value = !1)
      }, [
        (u.value || f.value) && !y.disabled ? (M(), We(c(Ac), { key: 0 })) : (M(), We(c(XC), { key: 1 }))
      ], 42, lZ)) : _e("v-if", !0),
      y.pageCount > 1 ? (M(), G("li", {
        key: 3,
        class: z([[
          c(o).is("active", y.currentPage === y.pageCount),
          c(o).is("disabled", y.disabled)
        ], "number"]),
        "aria-current": y.currentPage === y.pageCount,
        "aria-label": c(a)("el.pagination.currentPage", { pager: y.pageCount }),
        tabindex: c(p)
      }, Qe(y.pageCount), 11, aZ)) : _e("v-if", !0)
    ], 42, eZ));
  }
});
var iZ = /* @__PURE__ */ ut(sZ, [["__file", "pager.vue"]]);
const Cl = (e) => typeof e != "number", cZ = it({
  pageSize: Number,
  defaultPageSize: Number,
  total: Number,
  pageCount: Number,
  pagerCount: {
    type: Number,
    validator: (e) => Ot(e) && Math.trunc(e) === e && e > 4 && e < 22 && e % 2 === 1,
    default: 7
  },
  currentPage: Number,
  defaultCurrentPage: Number,
  layout: {
    type: String,
    default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
  },
  pageSizes: {
    type: Ae(Array),
    default: () => Zn([10, 20, 30, 40, 50, 100])
  },
  popperClass: {
    type: String,
    default: ""
  },
  prevText: {
    type: String,
    default: ""
  },
  prevIcon: {
    type: Dn,
    default: () => ks
  },
  nextText: {
    type: String,
    default: ""
  },
  nextIcon: {
    type: Dn,
    default: () => xl
  },
  teleported: {
    type: Boolean,
    default: !0
  },
  small: Boolean,
  background: Boolean,
  disabled: Boolean,
  hideOnSinglePage: Boolean
}), uZ = {
  "update:current-page": (e) => Ot(e),
  "update:page-size": (e) => Ot(e),
  "size-change": (e) => Ot(e),
  change: (e, t) => Ot(e) && Ot(t),
  "current-change": (e) => Ot(e),
  "prev-click": (e) => Ot(e),
  "next-click": (e) => Ot(e)
}, uE = "ElPagination";
var dZ = Q({
  name: uE,
  props: cZ,
  emits: uZ,
  setup(e, { emit: t, slots: n }) {
    const { t: o } = bn(), l = nt("pagination"), a = Pt().vnode.props || {}, r = "onUpdate:currentPage" in a || "onUpdate:current-page" in a || "onCurrentChange" in a, i = "onUpdate:pageSize" in a || "onUpdate:page-size" in a || "onSizeChange" in a, s = x(() => {
      if (Cl(e.total) && Cl(e.pageCount) || !Cl(e.currentPage) && !r)
        return !1;
      if (e.layout.includes("sizes")) {
        if (Cl(e.pageCount)) {
          if (!Cl(e.total) && !Cl(e.pageSize) && !i)
            return !1;
        } else if (!i)
          return !1;
      }
      return !0;
    }), u = B(Cl(e.defaultPageSize) ? 10 : e.defaultPageSize), d = B(Cl(e.defaultCurrentPage) ? 1 : e.defaultCurrentPage), f = x({
      get() {
        return Cl(e.pageSize) ? u.value : e.pageSize;
      },
      set(b) {
        Cl(e.pageSize) && (u.value = b), i && (t("update:page-size", b), t("size-change", b));
      }
    }), v = x(() => {
      let b = 0;
      return Cl(e.pageCount) ? Cl(e.total) || (b = Math.max(1, Math.ceil(e.total / f.value))) : b = e.pageCount, b;
    }), h = x({
      get() {
        return Cl(e.currentPage) ? d.value : e.currentPage;
      },
      set(b) {
        let y = b;
        b < 1 ? y = 1 : b > v.value && (y = v.value), Cl(e.currentPage) && (d.value = y), r && (t("update:current-page", y), t("current-change", y));
      }
    });
    Pe(v, (b) => {
      h.value > b && (h.value = b);
    }), Pe([h, f], (b) => {
      t("change", ...b);
    }, { flush: "post" });
    function m(b) {
      h.value = b;
    }
    function p(b) {
      f.value = b;
      const y = v.value;
      h.value > y && (h.value = y);
    }
    function C() {
      e.disabled || (h.value -= 1, t("prev-click", h.value));
    }
    function g() {
      e.disabled || (h.value += 1, t("next-click", h.value));
    }
    function w(b, y) {
      b && (b.props || (b.props = {}), b.props.class = [b.props.class, y].join(" "));
    }
    return Mt(z$, {
      pageCount: v,
      disabled: x(() => e.disabled),
      currentPage: h,
      changeEvent: m,
      handleSizeChange: p
    }), () => {
      var b, y;
      if (!s.value)
        return dn(uE, o("el.pagination.deprecationWarning")), null;
      if (!e.layout || e.hideOnSinglePage && v.value <= 1)
        return null;
      const E = [], S = [], _ = V("div", { class: l.e("rightwrapper") }, S), k = {
        prev: V(vX, {
          disabled: e.disabled,
          currentPage: h.value,
          prevText: e.prevText,
          prevIcon: e.prevIcon,
          onClick: C
        }),
        jumper: V(qX, {
          size: e.small ? "small" : "default"
        }),
        pager: V(iZ, {
          currentPage: h.value,
          pageCount: v.value,
          pagerCount: e.pagerCount,
          onChange: m,
          disabled: e.disabled
        }),
        next: V(CX, {
          disabled: e.disabled,
          currentPage: h.value,
          pageCount: v.value,
          nextText: e.nextText,
          nextIcon: e.nextIcon,
          onClick: g
        }),
        sizes: V(zX, {
          pageSize: f.value,
          pageSizes: e.pageSizes,
          popperClass: e.popperClass,
          disabled: e.disabled,
          teleported: e.teleported,
          size: e.small ? "small" : "default"
        }),
        slot: (y = (b = n == null ? void 0 : n.default) == null ? void 0 : b.call(n)) != null ? y : null,
        total: V(JX, { total: Cl(e.total) ? 0 : e.total })
      }, N = e.layout.split(",").map((R) => R.trim());
      let L = !1;
      return N.forEach((R) => {
        if (R === "->") {
          L = !0;
          return;
        }
        L ? S.push(k[R]) : E.push(k[R]);
      }), w(E[0], l.is("first")), w(E[E.length - 1], l.is("last")), L && S.length > 0 && (w(S[0], l.is("first")), w(S[S.length - 1], l.is("last")), E.push(_)), V("div", {
        class: [
          l.b(),
          l.is("background", e.background),
          {
            [l.m("small")]: e.small
          }
        ]
      }, E);
    };
  }
});
const q$ = Yt(dZ), fZ = it({
  title: String,
  confirmButtonText: String,
  cancelButtonText: String,
  confirmButtonType: {
    type: String,
    values: Eg,
    default: "primary"
  },
  cancelButtonType: {
    type: String,
    values: Eg,
    default: "text"
  },
  icon: {
    type: Dn,
    default: () => F8
  },
  iconColor: {
    type: String,
    default: "#f90"
  },
  hideIcon: {
    type: Boolean,
    default: !1
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  teleported: Fo.teleported,
  persistent: Fo.persistent,
  width: {
    type: [String, Number],
    default: 150
  }
}), pZ = {
  confirm: (e) => e instanceof MouseEvent,
  cancel: (e) => e instanceof MouseEvent
}, vZ = Q({
  name: "ElPopconfirm"
}), hZ = /* @__PURE__ */ Q({
  ...vZ,
  props: fZ,
  emits: pZ,
  setup(e, { emit: t }) {
    const n = e, { t: o } = bn(), l = nt("popconfirm"), a = B(), r = () => {
      var v, h;
      (h = (v = a.value) == null ? void 0 : v.onClose) == null || h.call(v);
    }, i = x(() => ({
      width: po(n.width)
    })), s = (v) => {
      t("confirm", v), r();
    }, u = (v) => {
      t("cancel", v), r();
    }, d = x(() => n.confirmButtonText || o("el.popconfirm.confirmButtonText")), f = x(() => n.cancelButtonText || o("el.popconfirm.cancelButtonText"));
    return (v, h) => (M(), We(c(hl), Et({
      ref_key: "tooltipRef",
      ref: a,
      trigger: "click",
      effect: "light"
    }, v.$attrs, {
      "popper-class": `${c(l).namespace.value}-popover`,
      "popper-style": c(i),
      teleported: v.teleported,
      "fallback-placements": ["bottom", "top", "right", "left"],
      "hide-after": v.hideAfter,
      persistent: v.persistent
    }), {
      content: fe(() => [
        X("div", {
          class: z(c(l).b())
        }, [
          X("div", {
            class: z(c(l).e("main"))
          }, [
            !v.hideIcon && v.icon ? (M(), We(c(Ct), {
              key: 0,
              class: z(c(l).e("icon")),
              style: bt({ color: v.iconColor })
            }, {
              default: fe(() => [
                (M(), We(Qt(v.icon)))
              ]),
              _: 1
            }, 8, ["class", "style"])) : _e("v-if", !0),
            Ut(" " + Qe(v.title), 1)
          ], 2),
          X("div", {
            class: z(c(l).e("action"))
          }, [
            oe(c(Do), {
              size: "small",
              type: v.cancelButtonType === "text" ? "" : v.cancelButtonType,
              text: v.cancelButtonType === "text",
              onClick: u
            }, {
              default: fe(() => [
                Ut(Qe(c(f)), 1)
              ]),
              _: 1
            }, 8, ["type", "text"]),
            oe(c(Do), {
              size: "small",
              type: v.confirmButtonType === "text" ? "" : v.confirmButtonType,
              text: v.confirmButtonType === "text",
              onClick: s
            }, {
              default: fe(() => [
                Ut(Qe(c(d)), 1)
              ]),
              _: 1
            }, 8, ["type", "text"])
          ], 2)
        ], 2)
      ]),
      default: fe(() => [
        v.$slots.reference ? Ie(v.$slots, "reference", { key: 0 }) : _e("v-if", !0)
      ]),
      _: 3
    }, 16, ["popper-class", "popper-style", "teleported", "hide-after", "persistent"]));
  }
});
var mZ = /* @__PURE__ */ ut(hZ, [["__file", "popconfirm.vue"]]);
const Y$ = Yt(mZ), gZ = it({
  trigger: Ld.trigger,
  placement: $p.placement,
  disabled: Ld.disabled,
  visible: Fo.visible,
  transition: Fo.transition,
  popperOptions: $p.popperOptions,
  tabindex: $p.tabindex,
  content: Fo.content,
  popperStyle: Fo.popperStyle,
  popperClass: Fo.popperClass,
  enterable: {
    ...Fo.enterable,
    default: !0
  },
  effect: {
    ...Fo.effect,
    default: "light"
  },
  teleported: Fo.teleported,
  title: String,
  width: {
    type: [String, Number],
    default: 150
  },
  offset: {
    type: Number,
    default: void 0
  },
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: !0
  },
  persistent: {
    type: Boolean,
    default: !0
  },
  "onUpdate:visible": {
    type: Function
  }
}), bZ = {
  "update:visible": (e) => $o(e),
  "before-enter": () => !0,
  "before-leave": () => !0,
  "after-enter": () => !0,
  "after-leave": () => !0
}, yZ = "onUpdate:visible", CZ = Q({
  name: "ElPopover"
}), wZ = /* @__PURE__ */ Q({
  ...CZ,
  props: gZ,
  emits: bZ,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = x(() => o[yZ]), a = nt("popover"), r = B(), i = x(() => {
      var C;
      return (C = c(r)) == null ? void 0 : C.popperRef;
    }), s = x(() => [
      {
        width: po(o.width)
      },
      o.popperStyle
    ]), u = x(() => [a.b(), o.popperClass, { [a.m("plain")]: !!o.content }]), d = x(() => o.transition === `${a.namespace.value}-fade-in-linear`), f = () => {
      var C;
      (C = r.value) == null || C.hide();
    }, v = () => {
      n("before-enter");
    }, h = () => {
      n("before-leave");
    }, m = () => {
      n("after-enter");
    }, p = () => {
      n("update:visible", !1), n("after-leave");
    };
    return t({
      popperRef: i,
      hide: f
    }), (C, g) => (M(), We(c(hl), Et({
      ref_key: "tooltipRef",
      ref: r
    }, C.$attrs, {
      trigger: C.trigger,
      placement: C.placement,
      disabled: C.disabled,
      visible: C.visible,
      transition: C.transition,
      "popper-options": C.popperOptions,
      tabindex: C.tabindex,
      content: C.content,
      offset: C.offset,
      "show-after": C.showAfter,
      "hide-after": C.hideAfter,
      "auto-close": C.autoClose,
      "show-arrow": C.showArrow,
      "aria-label": C.title,
      effect: C.effect,
      enterable: C.enterable,
      "popper-class": c(u),
      "popper-style": c(s),
      teleported: C.teleported,
      persistent: C.persistent,
      "gpu-acceleration": c(d),
      "onUpdate:visible": c(l),
      onBeforeShow: v,
      onBeforeHide: h,
      onShow: m,
      onHide: p
    }), {
      content: fe(() => [
        C.title ? (M(), G("div", {
          key: 0,
          class: z(c(a).e("title")),
          role: "title"
        }, Qe(C.title), 3)) : _e("v-if", !0),
        Ie(C.$slots, "default", {}, () => [
          Ut(Qe(C.content), 1)
        ])
      ]),
      default: fe(() => [
        C.$slots.reference ? Ie(C.$slots, "reference", { key: 0 }) : _e("v-if", !0)
      ]),
      _: 3
    }, 16, ["trigger", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "persistent", "gpu-acceleration", "onUpdate:visible"]));
  }
});
var EZ = /* @__PURE__ */ ut(wZ, [["__file", "popover.vue"]]);
const dE = (e, t) => {
  const n = t.arg || t.value, o = n == null ? void 0 : n.popperRef;
  o && (o.triggerRef = e);
};
var SZ = {
  mounted(e, t) {
    dE(e, t);
  },
  updated(e, t) {
    dE(e, t);
  }
};
const _Z = "popover", G$ = sV(SZ, _Z), X$ = Yt(EZ, {
  directive: G$
}), xZ = it({
  type: {
    type: String,
    default: "line",
    values: ["line", "circle", "dashboard"]
  },
  percentage: {
    type: Number,
    default: 0,
    validator: (e) => e >= 0 && e <= 100
  },
  status: {
    type: String,
    default: "",
    values: ["", "success", "exception", "warning"]
  },
  indeterminate: {
    type: Boolean,
    default: !1
  },
  duration: {
    type: Number,
    default: 3
  },
  strokeWidth: {
    type: Number,
    default: 6
  },
  strokeLinecap: {
    type: Ae(String),
    default: "round"
  },
  textInside: {
    type: Boolean,
    default: !1
  },
  width: {
    type: Number,
    default: 126
  },
  showText: {
    type: Boolean,
    default: !0
  },
  color: {
    type: Ae([
      String,
      Array,
      Function
    ]),
    default: ""
  },
  striped: Boolean,
  stripedFlow: Boolean,
  format: {
    type: Ae(Function),
    default: (e) => `${e}%`
  }
}), kZ = ["aria-valuenow"], TZ = { viewBox: "0 0 100 100" }, $Z = ["d", "stroke", "stroke-linecap", "stroke-width"], OZ = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"], NZ = { key: 0 }, MZ = Q({
  name: "ElProgress"
}), IZ = /* @__PURE__ */ Q({
  ...MZ,
  props: xZ,
  setup(e) {
    const t = e, n = {
      success: "#13ce66",
      exception: "#ff4949",
      warning: "#e6a23c",
      default: "#20a0ff"
    }, o = nt("progress"), l = x(() => ({
      width: `${t.percentage}%`,
      animationDuration: `${t.duration}s`,
      background: w(t.percentage)
    })), a = x(() => (t.strokeWidth / t.width * 100).toFixed(1)), r = x(() => ["circle", "dashboard"].includes(t.type) ? Number.parseInt(`${50 - Number.parseFloat(a.value) / 2}`, 10) : 0), i = x(() => {
      const b = r.value, y = t.type === "dashboard";
      return `
          M 50 50
          m 0 ${y ? "" : "-"}${b}
          a ${b} ${b} 0 1 1 0 ${y ? "-" : ""}${b * 2}
          a ${b} ${b} 0 1 1 0 ${y ? "" : "-"}${b * 2}
          `;
    }), s = x(() => 2 * Math.PI * r.value), u = x(() => t.type === "dashboard" ? 0.75 : 1), d = x(() => `${-1 * s.value * (1 - u.value) / 2}px`), f = x(() => ({
      strokeDasharray: `${s.value * u.value}px, ${s.value}px`,
      strokeDashoffset: d.value
    })), v = x(() => ({
      strokeDasharray: `${s.value * u.value * (t.percentage / 100)}px, ${s.value}px`,
      strokeDashoffset: d.value,
      transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
    })), h = x(() => {
      let b;
      return t.color ? b = w(t.percentage) : b = n[t.status] || n.default, b;
    }), m = x(() => t.status === "warning" ? Rv : t.type === "line" ? t.status === "success" ? cy : Ls : t.status === "success" ? lf : Fa), p = x(() => t.type === "line" ? 12 + t.strokeWidth * 0.4 : t.width * 0.111111 + 2), C = x(() => t.format(t.percentage));
    function g(b) {
      const y = 100 / b.length;
      return b.map((S, _) => on(S) ? {
        color: S,
        percentage: (_ + 1) * y
      } : S).sort((S, _) => S.percentage - _.percentage);
    }
    const w = (b) => {
      var y;
      const { color: E } = t;
      if (vn(E))
        return E(b);
      if (on(E))
        return E;
      {
        const S = g(E);
        for (const _ of S)
          if (_.percentage > b)
            return _.color;
        return (y = S[S.length - 1]) == null ? void 0 : y.color;
      }
    };
    return (b, y) => (M(), G("div", {
      class: z([
        c(o).b(),
        c(o).m(b.type),
        c(o).is(b.status),
        {
          [c(o).m("without-text")]: !b.showText,
          [c(o).m("text-inside")]: b.textInside
        }
      ]),
      role: "progressbar",
      "aria-valuenow": b.percentage,
      "aria-valuemin": "0",
      "aria-valuemax": "100"
    }, [
      b.type === "line" ? (M(), G("div", {
        key: 0,
        class: z(c(o).b("bar"))
      }, [
        X("div", {
          class: z(c(o).be("bar", "outer")),
          style: bt({ height: `${b.strokeWidth}px` })
        }, [
          X("div", {
            class: z([
              c(o).be("bar", "inner"),
              { [c(o).bem("bar", "inner", "indeterminate")]: b.indeterminate },
              { [c(o).bem("bar", "inner", "striped")]: b.striped },
              { [c(o).bem("bar", "inner", "striped-flow")]: b.stripedFlow }
            ]),
            style: bt(c(l))
          }, [
            (b.showText || b.$slots.default) && b.textInside ? (M(), G("div", {
              key: 0,
              class: z(c(o).be("bar", "innerText"))
            }, [
              Ie(b.$slots, "default", { percentage: b.percentage }, () => [
                X("span", null, Qe(c(C)), 1)
              ])
            ], 2)) : _e("v-if", !0)
          ], 6)
        ], 6)
      ], 2)) : (M(), G("div", {
        key: 1,
        class: z(c(o).b("circle")),
        style: bt({ height: `${b.width}px`, width: `${b.width}px` })
      }, [
        (M(), G("svg", TZ, [
          X("path", {
            class: z(c(o).be("circle", "track")),
            d: c(i),
            stroke: `var(${c(o).cssVarName("fill-color-light")}, #e5e9f2)`,
            "stroke-linecap": b.strokeLinecap,
            "stroke-width": c(a),
            fill: "none",
            style: bt(c(f))
          }, null, 14, $Z),
          X("path", {
            class: z(c(o).be("circle", "path")),
            d: c(i),
            stroke: c(h),
            fill: "none",
            opacity: b.percentage ? 1 : 0,
            "stroke-linecap": b.strokeLinecap,
            "stroke-width": c(a),
            style: bt(c(v))
          }, null, 14, OZ)
        ]))
      ], 6)),
      (b.showText || b.$slots.default) && !b.textInside ? (M(), G("div", {
        key: 2,
        class: z(c(o).e("text")),
        style: bt({ fontSize: `${c(p)}px` })
      }, [
        Ie(b.$slots, "default", { percentage: b.percentage }, () => [
          b.status ? (M(), We(c(Ct), { key: 1 }, {
            default: fe(() => [
              (M(), We(Qt(c(m))))
            ]),
            _: 1
          })) : (M(), G("span", NZ, Qe(c(C)), 1))
        ])
      ], 6)) : _e("v-if", !0)
    ], 10, kZ));
  }
});
var RZ = /* @__PURE__ */ ut(IZ, [["__file", "progress.vue"]]);
const c0 = Yt(RZ), DZ = it({
  modelValue: {
    type: Number,
    default: 0
  },
  id: {
    type: String,
    default: void 0
  },
  lowThreshold: {
    type: Number,
    default: 2
  },
  highThreshold: {
    type: Number,
    default: 4
  },
  max: {
    type: Number,
    default: 5
  },
  colors: {
    type: Ae([Array, Object]),
    default: () => Zn(["", "", ""])
  },
  voidColor: {
    type: String,
    default: ""
  },
  disabledVoidColor: {
    type: String,
    default: ""
  },
  icons: {
    type: Ae([Array, Object]),
    default: () => [Bf, Bf, Bf]
  },
  voidIcon: {
    type: Dn,
    default: () => J8
  },
  disabledVoidIcon: {
    type: Dn,
    default: () => Bf
  },
  disabled: Boolean,
  allowHalf: Boolean,
  showText: Boolean,
  showScore: Boolean,
  textColor: {
    type: String,
    default: ""
  },
  texts: {
    type: Ae(Array),
    default: () => Zn([
      "Extremely bad",
      "Disappointed",
      "Fair",
      "Satisfied",
      "Surprise"
    ])
  },
  scoreTemplate: {
    type: String,
    default: "{value}"
  },
  size: Lo,
  label: {
    type: String,
    default: void 0
  },
  clearable: {
    type: Boolean,
    default: !1
  },
  ...Zo(["ariaLabel"])
}), LZ = {
  [qn]: (e) => Ot(e),
  [Jt]: (e) => Ot(e)
}, PZ = ["id", "aria-label", "aria-labelledby", "aria-valuenow", "aria-valuetext", "aria-valuemax"], AZ = ["onMousemove", "onClick"], FZ = Q({
  name: "ElRate"
}), VZ = /* @__PURE__ */ Q({
  ...FZ,
  props: DZ,
  emits: LZ,
  setup(e, { expose: t, emit: n }) {
    const o = e;
    function l(A, $) {
      const D = (j) => Mn(j), O = Object.keys($).map((j) => +j).filter((j) => {
        const Z = $[j];
        return (D(Z) ? Z.excluded : !1) ? A < j : A <= j;
      }).sort((j, Z) => j - Z), F = $[O[0]];
      return D(F) && F.value || F;
    }
    const a = ot(zi, void 0), r = ot(ur, void 0), i = Mo(), s = nt("rate"), { inputId: u, isLabeledByFormItem: d } = Wa(o, {
      formItemContext: r
    }), f = B(o.modelValue), v = B(-1), h = B(!0), m = x(() => [s.b(), s.m(i.value)]), p = x(() => o.disabled || (a == null ? void 0 : a.disabled)), C = x(() => s.cssVarBlock({
      "void-color": o.voidColor,
      "disabled-void-color": o.disabledVoidColor,
      "fill-color": y.value
    })), g = x(() => {
      let A = "";
      return o.showScore ? A = o.scoreTemplate.replace(/\{\s*value\s*\}/, p.value ? `${o.modelValue}` : `${f.value}`) : o.showText && (A = o.texts[Math.ceil(f.value) - 1]), A;
    }), w = x(() => o.modelValue * 100 - Math.floor(o.modelValue) * 100), b = x(() => Kt(o.colors) ? {
      [o.lowThreshold]: o.colors[0],
      [o.highThreshold]: { value: o.colors[1], excluded: !0 },
      [o.max]: o.colors[2]
    } : o.colors), y = x(() => {
      const A = l(f.value, b.value);
      return Mn(A) ? "" : A;
    }), E = x(() => {
      let A = "";
      return p.value ? A = `${w.value}%` : o.allowHalf && (A = "50%"), {
        color: y.value,
        width: A
      };
    }), S = x(() => {
      let A = Kt(o.icons) ? [...o.icons] : { ...o.icons };
      return A = ju(A), Kt(A) ? {
        [o.lowThreshold]: A[0],
        [o.highThreshold]: {
          value: A[1],
          excluded: !0
        },
        [o.max]: A[2]
      } : A;
    }), _ = x(() => l(o.modelValue, S.value)), k = x(() => p.value ? on(o.disabledVoidIcon) ? o.disabledVoidIcon : ju(o.disabledVoidIcon) : on(o.voidIcon) ? o.voidIcon : ju(o.voidIcon)), N = x(() => l(f.value, S.value));
    function L(A) {
      const $ = p.value && w.value > 0 && A - 1 < o.modelValue && A > o.modelValue, D = o.allowHalf && h.value && A - 0.5 <= f.value && A > f.value;
      return $ || D;
    }
    function R(A) {
      o.clearable && A === o.modelValue && (A = 0), n(Jt, A), o.modelValue !== A && n("change", A);
    }
    function H(A) {
      p.value || (o.allowHalf && h.value ? R(f.value) : R(A));
    }
    function K(A) {
      if (p.value)
        return;
      let $ = f.value;
      const D = A.code;
      return D === xt.up || D === xt.right ? (o.allowHalf ? $ += 0.5 : $ += 1, A.stopPropagation(), A.preventDefault()) : (D === xt.left || D === xt.down) && (o.allowHalf ? $ -= 0.5 : $ -= 1, A.stopPropagation(), A.preventDefault()), $ = $ < 0 ? 0 : $, $ = $ > o.max ? o.max : $, n(Jt, $), n("change", $), $;
    }
    function U(A, $) {
      if (!p.value) {
        if (o.allowHalf && $) {
          let D = $.target;
          ba(D, s.e("item")) && (D = D.querySelector(`.${s.e("icon")}`)), (D.clientWidth === 0 || ba(D, s.e("decimal"))) && (D = D.parentNode), h.value = $.offsetX * 2 <= D.clientWidth, f.value = h.value ? A - 0.5 : A;
        } else
          f.value = A;
        v.value = A;
      }
    }
    function W() {
      p.value || (o.allowHalf && (h.value = o.modelValue !== Math.floor(o.modelValue)), f.value = o.modelValue, v.value = -1);
    }
    return Pe(() => o.modelValue, (A) => {
      f.value = A, h.value = o.modelValue !== Math.floor(o.modelValue);
    }), o.modelValue || n(Jt, 0), Ho({
      from: "label",
      replacement: "aria-label",
      version: "2.8.0",
      scope: "el-rate",
      ref: "https://element-plus.org/en-US/component/rate.html"
    }, x(() => !!o.label)), t({
      setCurrentValue: U,
      resetCurrentValue: W
    }), (A, $) => {
      var D;
      return M(), G("div", {
        id: c(u),
        class: z([c(m), c(s).is("disabled", c(p))]),
        role: "slider",
        "aria-label": c(d) ? void 0 : A.label || A.ariaLabel || "rating",
        "aria-labelledby": c(d) ? (D = c(r)) == null ? void 0 : D.labelId : void 0,
        "aria-valuenow": f.value,
        "aria-valuetext": c(g) || void 0,
        "aria-valuemin": "0",
        "aria-valuemax": A.max,
        tabindex: "0",
        style: bt(c(C)),
        onKeydown: K
      }, [
        (M(!0), G(kt, null, ln(A.max, (O, F) => (M(), G("span", {
          key: F,
          class: z(c(s).e("item")),
          onMousemove: (j) => U(O, j),
          onMouseleave: W,
          onClick: (j) => H(O)
        }, [
          oe(c(Ct), {
            class: z([
              c(s).e("icon"),
              { hover: v.value === O },
              c(s).is("active", O <= f.value)
            ])
          }, {
            default: fe(() => [
              L(O) ? _e("v-if", !0) : (M(), G(kt, { key: 0 }, [
                Bt((M(), We(Qt(c(N)), null, null, 512)), [
                  [pn, O <= f.value]
                ]),
                Bt((M(), We(Qt(c(k)), null, null, 512)), [
                  [pn, !(O <= f.value)]
                ])
              ], 64)),
              L(O) ? (M(), G(kt, { key: 1 }, [
                (M(), We(Qt(c(k)), {
                  class: z([c(s).em("decimal", "box")])
                }, null, 8, ["class"])),
                oe(c(Ct), {
                  style: bt(c(E)),
                  class: z([c(s).e("icon"), c(s).e("decimal")])
                }, {
                  default: fe(() => [
                    (M(), We(Qt(c(_))))
                  ]),
                  _: 1
                }, 8, ["style", "class"])
              ], 64)) : _e("v-if", !0)
            ]),
            _: 2
          }, 1032, ["class"])
        ], 42, AZ))), 128)),
        A.showText || A.showScore ? (M(), G("span", {
          key: 0,
          class: z(c(s).e("text")),
          style: bt({ color: A.textColor })
        }, Qe(c(g)), 7)) : _e("v-if", !0)
      ], 46, PZ);
    };
  }
});
var BZ = /* @__PURE__ */ ut(VZ, [["__file", "rate.vue"]]);
const HZ = Yt(BZ), bc = {
  success: "icon-success",
  warning: "icon-warning",
  error: "icon-error",
  info: "icon-info"
}, fE = {
  [bc.success]: d8,
  [bc.warning]: Rv,
  [bc.error]: uy,
  [bc.info]: dy
}, zZ = it({
  title: {
    type: String,
    default: ""
  },
  subTitle: {
    type: String,
    default: ""
  },
  icon: {
    type: String,
    values: ["success", "warning", "info", "error"],
    default: "info"
  }
}), WZ = Q({
  name: "ElResult"
}), KZ = /* @__PURE__ */ Q({
  ...WZ,
  props: zZ,
  setup(e) {
    const t = e, n = nt("result"), o = x(() => {
      const l = t.icon, a = l && bc[l] ? bc[l] : "icon-info", r = fE[a] || fE["icon-info"];
      return {
        class: a,
        component: r
      };
    });
    return (l, a) => (M(), G("div", {
      class: z(c(n).b())
    }, [
      X("div", {
        class: z(c(n).e("icon"))
      }, [
        Ie(l.$slots, "icon", {}, () => [
          c(o).component ? (M(), We(Qt(c(o).component), {
            key: 0,
            class: z(c(o).class)
          }, null, 8, ["class"])) : _e("v-if", !0)
        ])
      ], 2),
      l.title || l.$slots.title ? (M(), G("div", {
        key: 0,
        class: z(c(n).e("title"))
      }, [
        Ie(l.$slots, "title", {}, () => [
          X("p", null, Qe(l.title), 1)
        ])
      ], 2)) : _e("v-if", !0),
      l.subTitle || l.$slots["sub-title"] ? (M(), G("div", {
        key: 1,
        class: z(c(n).e("subtitle"))
      }, [
        Ie(l.$slots, "sub-title", {}, () => [
          X("p", null, Qe(l.subTitle), 1)
        ])
      ], 2)) : _e("v-if", !0),
      l.$slots.extra ? (M(), G("div", {
        key: 2,
        class: z(c(n).e("extra"))
      }, [
        Ie(l.$slots, "extra")
      ], 2)) : _e("v-if", !0)
    ], 2));
  }
});
var UZ = /* @__PURE__ */ ut(KZ, [["__file", "result.vue"]]);
const jZ = Yt(UZ);
var pE = Number.isNaN || function(t) {
  return typeof t == "number" && t !== t;
};
function qZ(e, t) {
  return !!(e === t || pE(e) && pE(t));
}
function YZ(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++)
    if (!qZ(e[n], t[n]))
      return !1;
  return !0;
}
function GZ(e, t) {
  t === void 0 && (t = YZ);
  var n = null;
  function o() {
    for (var l = [], a = 0; a < arguments.length; a++)
      l[a] = arguments[a];
    if (n && n.lastThis === this && t(l, n.lastArgs))
      return n.lastResult;
    var r = e.apply(this, l);
    return n = {
      lastResult: r,
      lastArgs: l,
      lastThis: this
    }, r;
  }
  return o.clear = function() {
    n = null;
  }, o;
}
const Z$ = () => {
  const t = Pt().proxy.$props;
  return x(() => {
    const n = (o, l, a) => ({});
    return t.perfMode ? Ov(n) : GZ(n);
  });
}, Wg = 50, tv = "itemRendered", nv = "scroll", yc = "forward", ov = "backward", ga = "auto", Yv = "smart", Fd = "start", tr = "center", Vd = "end", jc = "horizontal", u0 = "vertical", XZ = "ltr", $c = "rtl", Bd = "negative", d0 = "positive-ascending", f0 = "positive-descending", ZZ = {
  [jc]: "left",
  [u0]: "top"
}, JZ = 20, QZ = {
  [jc]: "deltaX",
  [u0]: "deltaY"
}, eJ = ({ atEndEdge: e, atStartEdge: t, layout: n }, o) => {
  let l, a = 0;
  const r = (s) => s < 0 && t.value || s > 0 && e.value;
  return {
    hasReachedEdge: r,
    onWheel: (s) => {
      Oi(l);
      const u = s[QZ[n.value]];
      r(a) && r(a + u) || (a += u, ex() || s.preventDefault(), l = xs(() => {
        o(a), a = 0;
      }));
    }
  };
}, Kg = Ha({
  type: Ae([Number, Function]),
  required: !0
}), Ug = Ha({
  type: Number
}), jg = Ha({
  type: Number,
  default: 2
}), tJ = Ha({
  type: String,
  values: ["ltr", "rtl"],
  default: "ltr"
}), qg = Ha({
  type: Number,
  default: 0
}), lv = Ha({
  type: Number,
  required: !0
}), J$ = Ha({
  type: String,
  values: ["horizontal", "vertical"],
  default: u0
}), Q$ = it({
  className: {
    type: String,
    default: ""
  },
  containerElement: {
    type: Ae([String, Object]),
    default: "div"
  },
  data: {
    type: Ae(Array),
    default: () => Zn([])
  },
  direction: tJ,
  height: {
    type: [String, Number],
    required: !0
  },
  innerElement: {
    type: [String, Object],
    default: "div"
  },
  style: {
    type: Ae([Object, String, Array])
  },
  useIsScrolling: {
    type: Boolean,
    default: !1
  },
  width: {
    type: [Number, String],
    required: !1
  },
  perfMode: {
    type: Boolean,
    default: !0
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: !1
  }
}), eO = it({
  cache: jg,
  estimatedItemSize: Ug,
  layout: J$,
  initScrollOffset: qg,
  total: lv,
  itemSize: Kg,
  ...Q$
}), Yg = {
  type: Number,
  default: 6
}, tO = { type: Number, default: 0 }, nO = { type: Number, default: 2 }, Ci = it({
  columnCache: jg,
  columnWidth: Kg,
  estimatedColumnWidth: Ug,
  estimatedRowHeight: Ug,
  initScrollLeft: qg,
  initScrollTop: qg,
  itemKey: {
    type: Ae(Function),
    default: ({
      columnIndex: e,
      rowIndex: t
    }) => `${t}:${e}`
  },
  rowCache: jg,
  rowHeight: Kg,
  totalColumn: lv,
  totalRow: lv,
  hScrollbarSize: Yg,
  vScrollbarSize: Yg,
  scrollbarStartGap: tO,
  scrollbarEndGap: nO,
  role: String,
  ...Q$
}), oO = it({
  alwaysOn: Boolean,
  class: String,
  layout: J$,
  total: lv,
  ratio: {
    type: Number,
    required: !0
  },
  clientSize: {
    type: Number,
    required: !0
  },
  scrollFrom: {
    type: Number,
    required: !0
  },
  scrollbarSize: Yg,
  startGap: tO,
  endGap: nO,
  visible: Boolean
}), ci = (e, t) => e < t ? yc : ov, Hd = (e) => e === XZ || e === $c || e === jc, vE = (e) => e === $c;
let Ji = null;
function av(e = !1) {
  if (Ji === null || e) {
    const t = document.createElement("div"), n = t.style;
    n.width = "50px", n.height = "50px", n.overflow = "scroll", n.direction = "rtl";
    const o = document.createElement("div"), l = o.style;
    return l.width = "100px", l.height = "100px", t.appendChild(o), document.body.appendChild(t), t.scrollLeft > 0 ? Ji = f0 : (t.scrollLeft = 1, t.scrollLeft === 0 ? Ji = Bd : Ji = d0), document.body.removeChild(t), Ji;
  }
  return Ji;
}
function nJ({ move: e, size: t, bar: n }, o) {
  const l = {}, a = `translate${n.axis}(${e}px)`;
  return l[n.size] = t, l.transform = a, l.msTransform = a, l.webkitTransform = a, o === "horizontal" ? l.height = "100%" : l.width = "100%", l;
}
const Gg = Q({
  name: "ElVirtualScrollBar",
  props: oO,
  emits: ["scroll", "start-move", "stop-move"],
  setup(e, { emit: t }) {
    const n = x(() => e.startGap + e.endGap), o = nt("virtual-scrollbar"), l = nt("scrollbar"), a = B(), r = B();
    let i = null, s = null;
    const u = en({
      isDragging: !1,
      traveled: 0
    }), d = x(() => Yk[e.layout]), f = x(() => e.clientSize - c(n)), v = x(() => ({
      position: "absolute",
      width: `${jc === e.layout ? f.value : e.scrollbarSize}px`,
      height: `${jc === e.layout ? e.scrollbarSize : f.value}px`,
      [ZZ[e.layout]]: "2px",
      right: "2px",
      bottom: "2px",
      borderRadius: "4px"
    })), h = x(() => {
      const S = e.ratio, _ = e.clientSize;
      if (S >= 100)
        return Number.POSITIVE_INFINITY;
      if (S >= 50)
        return S * _ / 100;
      const k = _ / 3;
      return Math.floor(Math.min(Math.max(S * _, JZ), k));
    }), m = x(() => {
      if (!Number.isFinite(h.value))
        return {
          display: "none"
        };
      const S = `${h.value}px`;
      return nJ({
        bar: d.value,
        size: S,
        move: u.traveled
      }, e.layout);
    }), p = x(() => Math.floor(e.clientSize - h.value - c(n))), C = () => {
      window.addEventListener("mousemove", y), window.addEventListener("mouseup", b);
      const S = c(r);
      S && (s = document.onselectstart, document.onselectstart = () => !1, S.addEventListener("touchmove", y), S.addEventListener("touchend", b));
    }, g = () => {
      window.removeEventListener("mousemove", y), window.removeEventListener("mouseup", b), document.onselectstart = s, s = null;
      const S = c(r);
      S && (S.removeEventListener("touchmove", y), S.removeEventListener("touchend", b));
    }, w = (S) => {
      S.stopImmediatePropagation(), !(S.ctrlKey || [1, 2].includes(S.button)) && (u.isDragging = !0, u[d.value.axis] = S.currentTarget[d.value.offset] - (S[d.value.client] - S.currentTarget.getBoundingClientRect()[d.value.direction]), t("start-move"), C());
    }, b = () => {
      u.isDragging = !1, u[d.value.axis] = 0, t("stop-move"), g();
    }, y = (S) => {
      const { isDragging: _ } = u;
      if (!_ || !r.value || !a.value)
        return;
      const k = u[d.value.axis];
      if (!k)
        return;
      Oi(i);
      const N = (a.value.getBoundingClientRect()[d.value.direction] - S[d.value.client]) * -1, L = r.value[d.value.offset] - k, R = N - L;
      i = xs(() => {
        u.traveled = Math.max(e.startGap, Math.min(R, p.value)), t("scroll", R, p.value);
      });
    }, E = (S) => {
      const _ = Math.abs(S.target.getBoundingClientRect()[d.value.direction] - S[d.value.client]), k = r.value[d.value.offset] / 2, N = _ - k;
      u.traveled = Math.max(0, Math.min(N, p.value)), t("scroll", N, p.value);
    };
    return Pe(() => e.scrollFrom, (S) => {
      u.isDragging || (u.traveled = Math.ceil(S * p.value));
    }), zn(() => {
      g();
    }), () => V("div", {
      role: "presentation",
      ref: a,
      class: [
        o.b(),
        e.class,
        (e.alwaysOn || u.isDragging) && "always-on"
      ],
      style: v.value,
      onMousedown: It(E, ["stop", "prevent"]),
      onTouchstartPrevent: w
    }, V("div", {
      ref: r,
      class: l.e("thumb"),
      style: m.value,
      onMousedown: w
    }, []));
  }
}), lO = ({
  name: e,
  getOffset: t,
  getItemSize: n,
  getItemOffset: o,
  getEstimatedTotalSize: l,
  getStartIndexForOffset: a,
  getStopIndexForStartIndex: r,
  initCache: i,
  clearCache: s,
  validateProps: u
}) => Q({
  name: e ?? "ElVirtualList",
  props: eO,
  emits: [tv, nv],
  setup(d, { emit: f, expose: v }) {
    u(d);
    const h = Pt(), m = nt("vl"), p = B(i(d, h)), C = Z$(), g = B(), w = B(), b = B(), y = B({
      isScrolling: !1,
      scrollDir: "forward",
      scrollOffset: Ot(d.initScrollOffset) ? d.initScrollOffset : 0,
      updateRequested: !1,
      isScrollbarDragging: !1,
      scrollbarAlwaysOn: d.scrollbarAlwaysOn
    }), E = x(() => {
      const { total: te, cache: de } = d, { isScrolling: Oe, scrollDir: ce, scrollOffset: ne } = c(y);
      if (te === 0)
        return [0, 0, 0, 0];
      const Y = a(d, ne, c(p)), ve = r(d, Y, ne, c(p)), ie = !Oe || ce === ov ? Math.max(1, de) : 1, he = !Oe || ce === yc ? Math.max(1, de) : 1;
      return [
        Math.max(0, Y - ie),
        Math.max(0, Math.min(te - 1, ve + he)),
        Y,
        ve
      ];
    }), S = x(() => l(d, c(p))), _ = x(() => Hd(d.layout)), k = x(() => [
      {
        position: "relative",
        [`overflow-${_.value ? "x" : "y"}`]: "scroll",
        WebkitOverflowScrolling: "touch",
        willChange: "transform"
      },
      {
        direction: d.direction,
        height: Ot(d.height) ? `${d.height}px` : d.height,
        width: Ot(d.width) ? `${d.width}px` : d.width
      },
      d.style
    ]), N = x(() => {
      const te = c(S), de = c(_);
      return {
        height: de ? "100%" : `${te}px`,
        pointerEvents: c(y).isScrolling ? "none" : void 0,
        width: de ? `${te}px` : "100%"
      };
    }), L = x(() => _.value ? d.width : d.height), { onWheel: R } = eJ({
      atStartEdge: x(() => y.value.scrollOffset <= 0),
      atEndEdge: x(() => y.value.scrollOffset >= S.value),
      layout: x(() => d.layout)
    }, (te) => {
      var de, Oe;
      (Oe = (de = b.value).onMouseUp) == null || Oe.call(de), $(Math.min(y.value.scrollOffset + te, S.value - L.value));
    }), H = () => {
      const { total: te } = d;
      if (te > 0) {
        const [ne, Y, ve, ie] = c(E);
        f(tv, ne, Y, ve, ie);
      }
      const { scrollDir: de, scrollOffset: Oe, updateRequested: ce } = c(y);
      f(nv, de, Oe, ce);
    }, K = (te) => {
      const { clientHeight: de, scrollHeight: Oe, scrollTop: ce } = te.currentTarget, ne = c(y);
      if (ne.scrollOffset === ce)
        return;
      const Y = Math.max(0, Math.min(ce, Oe - de));
      y.value = {
        ...ne,
        isScrolling: !0,
        scrollDir: ci(ne.scrollOffset, Y),
        scrollOffset: Y,
        updateRequested: !1
      }, xe(F);
    }, U = (te) => {
      const { clientWidth: de, scrollLeft: Oe, scrollWidth: ce } = te.currentTarget, ne = c(y);
      if (ne.scrollOffset === Oe)
        return;
      const { direction: Y } = d;
      let ve = Oe;
      if (Y === $c)
        switch (av()) {
          case Bd: {
            ve = -Oe;
            break;
          }
          case f0: {
            ve = ce - de - Oe;
            break;
          }
        }
      ve = Math.max(0, Math.min(ve, ce - de)), y.value = {
        ...ne,
        isScrolling: !0,
        scrollDir: ci(ne.scrollOffset, ve),
        scrollOffset: ve,
        updateRequested: !1
      }, xe(F);
    }, W = (te) => {
      c(_) ? U(te) : K(te), H();
    }, A = (te, de) => {
      const Oe = (S.value - L.value) / de * te;
      $(Math.min(S.value - L.value, Oe));
    }, $ = (te) => {
      te = Math.max(te, 0), te !== c(y).scrollOffset && (y.value = {
        ...c(y),
        scrollOffset: te,
        scrollDir: ci(c(y).scrollOffset, te),
        updateRequested: !0
      }, xe(F));
    }, D = (te, de = ga) => {
      const { scrollOffset: Oe } = c(y);
      te = Math.max(0, Math.min(te, d.total - 1)), $(t(d, te, de, Oe, c(p)));
    }, O = (te) => {
      const { direction: de, itemSize: Oe, layout: ce } = d, ne = C.value(s && Oe, s && ce, s && de);
      let Y;
      if (sl(ne, String(te)))
        Y = ne[te];
      else {
        const ve = o(d, te, c(p)), ie = n(d, te, c(p)), he = c(_), De = de === $c, $e = he ? ve : 0;
        ne[te] = Y = {
          position: "absolute",
          left: De ? void 0 : `${$e}px`,
          right: De ? `${$e}px` : void 0,
          top: he ? 0 : `${ve}px`,
          height: he ? "100%" : `${ie}px`,
          width: he ? `${ie}px` : "100%"
        };
      }
      return Y;
    }, F = () => {
      y.value.isScrolling = !1, xe(() => {
        C.value(-1, null, null);
      });
    }, j = () => {
      const te = g.value;
      te && (te.scrollTop = 0);
    };
    Nt(() => {
      if (!fn)
        return;
      const { initScrollOffset: te } = d, de = c(g);
      Ot(te) && de && (c(_) ? de.scrollLeft = te : de.scrollTop = te), H();
    }), Pi(() => {
      const { direction: te, layout: de } = d, { scrollOffset: Oe, updateRequested: ce } = c(y), ne = c(g);
      if (ce && ne)
        if (de === jc)
          if (te === $c)
            switch (av()) {
              case Bd: {
                ne.scrollLeft = -Oe;
                break;
              }
              case d0: {
                ne.scrollLeft = Oe;
                break;
              }
              default: {
                const { clientWidth: Y, scrollWidth: ve } = ne;
                ne.scrollLeft = ve - Y - Oe;
                break;
              }
            }
          else
            ne.scrollLeft = Oe;
        else
          ne.scrollTop = Oe;
    });
    const Z = {
      ns: m,
      clientSize: L,
      estimatedTotalSize: S,
      windowStyle: k,
      windowRef: g,
      innerRef: w,
      innerStyle: N,
      itemsToRender: E,
      scrollbarRef: b,
      states: y,
      getItemStyle: O,
      onScroll: W,
      onScrollbarScroll: A,
      onWheel: R,
      scrollTo: $,
      scrollToItem: D,
      resetScrollTop: j
    };
    return v({
      windowRef: g,
      innerRef: w,
      getItemStyleCache: C,
      scrollTo: $,
      scrollToItem: D,
      resetScrollTop: j,
      states: y
    }), Z;
  },
  render(d) {
    var f;
    const {
      $slots: v,
      className: h,
      clientSize: m,
      containerElement: p,
      data: C,
      getItemStyle: g,
      innerElement: w,
      itemsToRender: b,
      innerStyle: y,
      layout: E,
      total: S,
      onScroll: _,
      onScrollbarScroll: k,
      onWheel: N,
      states: L,
      useIsScrolling: R,
      windowStyle: H,
      ns: K
    } = d, [U, W] = b, A = Qt(p), $ = Qt(w), D = [];
    if (S > 0)
      for (let Z = U; Z <= W; Z++)
        D.push((f = v.default) == null ? void 0 : f.call(v, {
          data: C,
          key: Z,
          index: Z,
          isScrolling: R ? L.isScrolling : void 0,
          style: g(Z)
        }));
    const O = [
      V($, {
        style: y,
        ref: "innerRef"
      }, on($) ? D : {
        default: () => D
      })
    ], F = V(Gg, {
      ref: "scrollbarRef",
      clientSize: m,
      layout: E,
      onScroll: k,
      ratio: m * 100 / this.estimatedTotalSize,
      scrollFrom: L.scrollOffset / (this.estimatedTotalSize - m),
      total: S
    }), j = V(A, {
      class: [K.e("window"), h],
      style: H,
      onScroll: _,
      onWheel: N,
      ref: "windowRef",
      key: 0
    }, on(A) ? [O] : { default: () => [O] });
    return V("div", {
      key: 0,
      class: [K.e("wrapper"), L.scrollbarAlwaysOn ? "always-on" : ""]
    }, [j, F]);
  }
}), aO = lO({
  name: "ElFixedSizeList",
  getItemOffset: ({ itemSize: e }, t) => t * e,
  getItemSize: ({ itemSize: e }) => e,
  getEstimatedTotalSize: ({ total: e, itemSize: t }) => t * e,
  getOffset: ({ height: e, total: t, itemSize: n, layout: o, width: l }, a, r, i) => {
    const s = Hd(o) ? l : e;
    process.env.NODE_ENV !== "production" && on(s) && lo("[ElVirtualList]", `
        You should set
          width/height
        to number when your layout is
          horizontal/vertical
      `);
    const u = Math.max(0, t * n - s), d = Math.min(u, a * n), f = Math.max(0, (a + 1) * n - s);
    switch (r === Yv && (i >= f - s && i <= d + s ? r = ga : r = tr), r) {
      case Fd:
        return d;
      case Vd:
        return f;
      case tr: {
        const v = Math.round(f + (d - f) / 2);
        return v < Math.ceil(s / 2) ? 0 : v > u + Math.floor(s / 2) ? u : v;
      }
      case ga:
      default:
        return i >= f && i <= d ? i : i < f ? f : d;
    }
  },
  getStartIndexForOffset: ({ total: e, itemSize: t }, n) => Math.max(0, Math.min(e - 1, Math.floor(n / t))),
  getStopIndexForStartIndex: ({ height: e, total: t, itemSize: n, layout: o, width: l }, a, r) => {
    const i = a * n, s = Hd(o) ? l : e, u = Math.ceil((s + r - i) / n);
    return Math.max(0, Math.min(t - 1, a + u - 1));
  },
  initCache() {
  },
  clearCache: !0,
  validateProps() {
  }
}), oJ = "ElDynamicSizeList", Cc = (e, t, n) => {
  const { itemSize: o } = e, { items: l, lastVisitedIndex: a } = n;
  if (t > a) {
    let r = 0;
    if (a >= 0) {
      const i = l[a];
      r = i.offset + i.size;
    }
    for (let i = a + 1; i <= t; i++) {
      const s = o(i);
      l[i] = {
        offset: r,
        size: s
      }, r += s;
    }
    n.lastVisitedIndex = t;
  }
  return l[t];
}, lJ = (e, t, n) => {
  const { items: o, lastVisitedIndex: l } = t;
  return (l > 0 ? o[l].offset : 0) >= n ? rO(e, t, 0, l, n) : aJ(e, t, Math.max(0, l), n);
}, rO = (e, t, n, o, l) => {
  for (; n <= o; ) {
    const a = n + Math.floor((o - n) / 2), r = Cc(e, a, t).offset;
    if (r === l)
      return a;
    r < l ? n = a + 1 : r > l && (o = a - 1);
  }
  return Math.max(0, n - 1);
}, aJ = (e, t, n, o) => {
  const { total: l } = e;
  let a = 1;
  for (; n < l && Cc(e, n, t).offset < o; )
    n += a, a *= 2;
  return rO(e, t, Math.floor(n / 2), Math.min(n, l - 1), o);
}, hE = ({ total: e }, { items: t, estimatedItemSize: n, lastVisitedIndex: o }) => {
  let l = 0;
  if (o >= e && (o = e - 1), o >= 0) {
    const i = t[o];
    l = i.offset + i.size;
  }
  const r = (e - o - 1) * n;
  return l + r;
}, rJ = lO({
  name: "ElDynamicSizeList",
  getItemOffset: (e, t, n) => Cc(e, t, n).offset,
  getItemSize: (e, t, { items: n }) => n[t].size,
  getEstimatedTotalSize: hE,
  getOffset: (e, t, n, o, l) => {
    const { height: a, layout: r, width: i } = e, s = Hd(r) ? i : a, u = Cc(e, t, l), d = hE(e, l), f = Math.max(0, Math.min(d - s, u.offset)), v = Math.max(0, u.offset - s + u.size);
    switch (n === Yv && (o >= v - s && o <= f + s ? n = ga : n = tr), n) {
      case Fd:
        return f;
      case Vd:
        return v;
      case tr:
        return Math.round(v + (f - v) / 2);
      case ga:
      default:
        return o >= v && o <= f ? o : o < v ? v : f;
    }
  },
  getStartIndexForOffset: (e, t, n) => lJ(e, n, t),
  getStopIndexForStartIndex: (e, t, n, o) => {
    const { height: l, total: a, layout: r, width: i } = e, s = Hd(r) ? i : l, u = Cc(e, t, o), d = n + s;
    let f = u.offset + u.size, v = t;
    for (; v < a - 1 && f < d; )
      v++, f += Cc(e, v, o).size;
    return v;
  },
  initCache({ estimatedItemSize: e = Wg }, t) {
    const n = {
      items: {},
      estimatedItemSize: e,
      lastVisitedIndex: -1
    };
    return n.clearCacheAfterIndex = (o, l = !0) => {
      var a, r;
      n.lastVisitedIndex = Math.min(n.lastVisitedIndex, o - 1), (a = t.exposed) == null || a.getItemStyleCache(-1), l && ((r = t.proxy) == null || r.$forceUpdate());
    }, n;
  },
  clearCache: !1,
  validateProps: ({ itemSize: e }) => {
    process.env.NODE_ENV !== "production" && typeof e != "function" && lo(oJ, `
          itemSize is required as function, but the given value was ${typeof e}
        `);
  }
}), sJ = ({ atXEndEdge: e, atXStartEdge: t, atYEndEdge: n, atYStartEdge: o }, l) => {
  let a = null, r = 0, i = 0;
  const s = (d, f) => {
    const v = d <= 0 && t.value || d >= 0 && e.value, h = f <= 0 && o.value || f >= 0 && n.value;
    return v && h;
  };
  return {
    hasReachedEdge: s,
    onWheel: (d) => {
      Oi(a);
      let f = d.deltaX, v = d.deltaY;
      Math.abs(f) > Math.abs(v) ? v = 0 : f = 0, d.shiftKey && v !== 0 && (f = v, v = 0), !(s(r, i) && s(r + f, i + v)) && (r += f, i += v, d.preventDefault(), a = xs(() => {
        l(r, i), r = 0, i = 0;
      }));
    }
  };
}, sO = ({
  name: e,
  clearCache: t,
  getColumnPosition: n,
  getColumnStartIndexForOffset: o,
  getColumnStopIndexForStartIndex: l,
  getEstimatedTotalHeight: a,
  getEstimatedTotalWidth: r,
  getColumnOffset: i,
  getRowOffset: s,
  getRowPosition: u,
  getRowStartIndexForOffset: d,
  getRowStopIndexForStartIndex: f,
  initCache: v,
  injectToInstance: h,
  validateProps: m
}) => Q({
  name: e ?? "ElVirtualList",
  props: Ci,
  emits: [tv, nv],
  setup(p, { emit: C, expose: g, slots: w }) {
    const b = nt("vl");
    m(p);
    const y = Pt(), E = B(v(p, y));
    h == null || h(y, E);
    const S = B(), _ = B(), k = B(), N = B(null), L = B({
      isScrolling: !1,
      scrollLeft: Ot(p.initScrollLeft) ? p.initScrollLeft : 0,
      scrollTop: Ot(p.initScrollTop) ? p.initScrollTop : 0,
      updateRequested: !1,
      xAxisScrollDir: yc,
      yAxisScrollDir: yc
    }), R = Z$(), H = x(() => Number.parseInt(`${p.height}`, 10)), K = x(() => Number.parseInt(`${p.width}`, 10)), U = x(() => {
      const { totalColumn: Fe, totalRow: Ve, columnCache: Ze } = p, { isScrolling: ae, xAxisScrollDir: pe, scrollLeft: ke } = c(L);
      if (Fe === 0 || Ve === 0)
        return [0, 0, 0, 0];
      const Ue = o(p, ke, c(E)), Xe = l(p, Ue, ke, c(E)), re = !ae || pe === ov ? Math.max(1, Ze) : 1, Te = !ae || pe === yc ? Math.max(1, Ze) : 1;
      return [
        Math.max(0, Ue - re),
        Math.max(0, Math.min(Fe - 1, Xe + Te)),
        Ue,
        Xe
      ];
    }), W = x(() => {
      const { totalColumn: Fe, totalRow: Ve, rowCache: Ze } = p, { isScrolling: ae, yAxisScrollDir: pe, scrollTop: ke } = c(L);
      if (Fe === 0 || Ve === 0)
        return [0, 0, 0, 0];
      const Ue = d(p, ke, c(E)), Xe = f(p, Ue, ke, c(E)), re = !ae || pe === ov ? Math.max(1, Ze) : 1, Te = !ae || pe === yc ? Math.max(1, Ze) : 1;
      return [
        Math.max(0, Ue - re),
        Math.max(0, Math.min(Ve - 1, Xe + Te)),
        Ue,
        Xe
      ];
    }), A = x(() => a(p, c(E))), $ = x(() => r(p, c(E))), D = x(() => {
      var Fe;
      return [
        {
          position: "relative",
          overflow: "hidden",
          WebkitOverflowScrolling: "touch",
          willChange: "transform"
        },
        {
          direction: p.direction,
          height: Ot(p.height) ? `${p.height}px` : p.height,
          width: Ot(p.width) ? `${p.width}px` : p.width
        },
        (Fe = p.style) != null ? Fe : {}
      ];
    }), O = x(() => {
      const Fe = `${c($)}px`;
      return {
        height: `${c(A)}px`,
        pointerEvents: c(L).isScrolling ? "none" : void 0,
        width: Fe
      };
    }), F = () => {
      const { totalColumn: Fe, totalRow: Ve } = p;
      if (Fe > 0 && Ve > 0) {
        const [
          Xe,
          re,
          Te,
          Ce
        ] = c(U), [Le, ge, Ee, me] = c(W);
        C(tv, {
          columnCacheStart: Xe,
          columnCacheEnd: re,
          rowCacheStart: Le,
          rowCacheEnd: ge,
          columnVisibleStart: Te,
          columnVisibleEnd: Ce,
          rowVisibleStart: Ee,
          rowVisibleEnd: me
        });
      }
      const {
        scrollLeft: Ze,
        scrollTop: ae,
        updateRequested: pe,
        xAxisScrollDir: ke,
        yAxisScrollDir: Ue
      } = c(L);
      C(nv, {
        xAxisScrollDir: ke,
        scrollLeft: Ze,
        yAxisScrollDir: Ue,
        scrollTop: ae,
        updateRequested: pe
      });
    }, j = (Fe) => {
      const {
        clientHeight: Ve,
        clientWidth: Ze,
        scrollHeight: ae,
        scrollLeft: pe,
        scrollTop: ke,
        scrollWidth: Ue
      } = Fe.currentTarget, Xe = c(L);
      if (Xe.scrollTop === ke && Xe.scrollLeft === pe)
        return;
      let re = pe;
      if (vE(p.direction))
        switch (av()) {
          case Bd:
            re = -pe;
            break;
          case f0:
            re = Ue - Ze - pe;
            break;
        }
      L.value = {
        ...Xe,
        isScrolling: !0,
        scrollLeft: re,
        scrollTop: Math.max(0, Math.min(ke, ae - Ve)),
        updateRequested: !0,
        xAxisScrollDir: ci(Xe.scrollLeft, re),
        yAxisScrollDir: ci(Xe.scrollTop, ke)
      }, xe(() => Y()), ve(), F();
    }, Z = (Fe, Ve) => {
      const Ze = c(H), ae = (A.value - Ze) / Ve * Fe;
      Oe({
        scrollTop: Math.min(A.value - Ze, ae)
      });
    }, te = (Fe, Ve) => {
      const Ze = c(K), ae = ($.value - Ze) / Ve * Fe;
      Oe({
        scrollLeft: Math.min($.value - Ze, ae)
      });
    }, { onWheel: de } = sJ({
      atXStartEdge: x(() => L.value.scrollLeft <= 0),
      atXEndEdge: x(() => L.value.scrollLeft >= $.value - c(K)),
      atYStartEdge: x(() => L.value.scrollTop <= 0),
      atYEndEdge: x(() => L.value.scrollTop >= A.value - c(H))
    }, (Fe, Ve) => {
      var Ze, ae, pe, ke;
      (ae = (Ze = _.value) == null ? void 0 : Ze.onMouseUp) == null || ae.call(Ze), (ke = (pe = k.value) == null ? void 0 : pe.onMouseUp) == null || ke.call(pe);
      const Ue = c(K), Xe = c(H);
      Oe({
        scrollLeft: Math.min(L.value.scrollLeft + Fe, $.value - Ue),
        scrollTop: Math.min(L.value.scrollTop + Ve, A.value - Xe)
      });
    }), Oe = ({
      scrollLeft: Fe = L.value.scrollLeft,
      scrollTop: Ve = L.value.scrollTop
    }) => {
      Fe = Math.max(Fe, 0), Ve = Math.max(Ve, 0);
      const Ze = c(L);
      Ve === Ze.scrollTop && Fe === Ze.scrollLeft || (L.value = {
        ...Ze,
        xAxisScrollDir: ci(Ze.scrollLeft, Fe),
        yAxisScrollDir: ci(Ze.scrollTop, Ve),
        scrollLeft: Fe,
        scrollTop: Ve,
        updateRequested: !0
      }, xe(() => Y()), ve(), F());
    }, ce = (Fe = 0, Ve = 0, Ze = ga) => {
      const ae = c(L);
      Ve = Math.max(0, Math.min(Ve, p.totalColumn - 1)), Fe = Math.max(0, Math.min(Fe, p.totalRow - 1));
      const pe = Ux(b.namespace.value), ke = c(E), Ue = a(p, ke), Xe = r(p, ke);
      Oe({
        scrollLeft: i(p, Ve, Ze, ae.scrollLeft, ke, Xe > p.width ? pe : 0),
        scrollTop: s(p, Fe, Ze, ae.scrollTop, ke, Ue > p.height ? pe : 0)
      });
    }, ne = (Fe, Ve) => {
      const { columnWidth: Ze, direction: ae, rowHeight: pe } = p, ke = R.value(t && Ze, t && pe, t && ae), Ue = `${Fe},${Ve}`;
      if (sl(ke, Ue))
        return ke[Ue];
      {
        const [, Xe] = n(p, Ve, c(E)), re = c(E), Te = vE(ae), [Ce, Le] = u(p, Fe, re), [ge] = n(p, Ve, re);
        return ke[Ue] = {
          position: "absolute",
          left: Te ? void 0 : `${Xe}px`,
          right: Te ? `${Xe}px` : void 0,
          top: `${Le}px`,
          height: `${Ce}px`,
          width: `${ge}px`
        }, ke[Ue];
      }
    }, Y = () => {
      L.value.isScrolling = !1, xe(() => {
        R.value(-1, null, null);
      });
    };
    Nt(() => {
      if (!fn)
        return;
      const { initScrollLeft: Fe, initScrollTop: Ve } = p, Ze = c(S);
      Ze && (Ot(Fe) && (Ze.scrollLeft = Fe), Ot(Ve) && (Ze.scrollTop = Ve)), F();
    });
    const ve = () => {
      const { direction: Fe } = p, { scrollLeft: Ve, scrollTop: Ze, updateRequested: ae } = c(L), pe = c(S);
      if (ae && pe) {
        if (Fe === $c)
          switch (av()) {
            case Bd: {
              pe.scrollLeft = -Ve;
              break;
            }
            case d0: {
              pe.scrollLeft = Ve;
              break;
            }
            default: {
              const { clientWidth: ke, scrollWidth: Ue } = pe;
              pe.scrollLeft = Ue - ke - Ve;
              break;
            }
          }
        else
          pe.scrollLeft = Math.max(0, Ve);
        pe.scrollTop = Math.max(0, Ze);
      }
    }, { resetAfterColumnIndex: ie, resetAfterRowIndex: he, resetAfter: De } = y.proxy;
    g({
      windowRef: S,
      innerRef: N,
      getItemStyleCache: R,
      scrollTo: Oe,
      scrollToItem: ce,
      states: L,
      resetAfterColumnIndex: ie,
      resetAfterRowIndex: he,
      resetAfter: De
    });
    const $e = () => {
      const {
        scrollbarAlwaysOn: Fe,
        scrollbarStartGap: Ve,
        scrollbarEndGap: Ze,
        totalColumn: ae,
        totalRow: pe
      } = p, ke = c(K), Ue = c(H), Xe = c($), re = c(A), { scrollLeft: Te, scrollTop: Ce } = c(L), Le = V(Gg, {
        ref: _,
        alwaysOn: Fe,
        startGap: Ve,
        endGap: Ze,
        class: b.e("horizontal"),
        clientSize: ke,
        layout: "horizontal",
        onScroll: te,
        ratio: ke * 100 / Xe,
        scrollFrom: Te / (Xe - ke),
        total: pe,
        visible: !0
      }), ge = V(Gg, {
        ref: k,
        alwaysOn: Fe,
        startGap: Ve,
        endGap: Ze,
        class: b.e("vertical"),
        clientSize: Ue,
        layout: "vertical",
        onScroll: Z,
        ratio: Ue * 100 / re,
        scrollFrom: Ce / (re - Ue),
        total: ae,
        visible: !0
      });
      return {
        horizontalScrollbar: Le,
        verticalScrollbar: ge
      };
    }, ue = () => {
      var Fe;
      const [Ve, Ze] = c(U), [ae, pe] = c(W), { data: ke, totalColumn: Ue, totalRow: Xe, useIsScrolling: re, itemKey: Te } = p, Ce = [];
      if (Xe > 0 && Ue > 0)
        for (let Le = ae; Le <= pe; Le++)
          for (let ge = Ve; ge <= Ze; ge++)
            Ce.push((Fe = w.default) == null ? void 0 : Fe.call(w, {
              columnIndex: ge,
              data: ke,
              key: Te({ columnIndex: ge, data: ke, rowIndex: Le }),
              isScrolling: re ? c(L).isScrolling : void 0,
              style: ne(Le, ge),
              rowIndex: Le
            }));
      return Ce;
    }, Ne = () => {
      const Fe = Qt(p.innerElement), Ve = ue();
      return [
        V(Fe, {
          style: c(O),
          ref: N
        }, on(Fe) ? Ve : {
          default: () => Ve
        })
      ];
    };
    return () => {
      const Fe = Qt(p.containerElement), { horizontalScrollbar: Ve, verticalScrollbar: Ze } = $e(), ae = Ne();
      return V("div", {
        key: 0,
        class: b.e("wrapper"),
        role: p.role
      }, [
        V(Fe, {
          class: p.className,
          style: c(D),
          onScroll: j,
          onWheel: de,
          ref: S
        }, on(Fe) ? ae : { default: () => ae }),
        Ve,
        Ze
      ]);
    };
  }
}), mE = "ElFixedSizeGrid", iJ = sO({
  name: "ElFixedSizeGrid",
  getColumnPosition: ({ columnWidth: e }, t) => [
    e,
    t * e
  ],
  getRowPosition: ({ rowHeight: e }, t) => [
    e,
    t * e
  ],
  getEstimatedTotalHeight: ({ totalRow: e, rowHeight: t }) => t * e,
  getEstimatedTotalWidth: ({ totalColumn: e, columnWidth: t }) => t * e,
  getColumnOffset: ({ totalColumn: e, columnWidth: t, width: n }, o, l, a, r, i) => {
    n = Number(n);
    const s = Math.max(0, e * t - n), u = Math.min(s, o * t), d = Math.max(0, o * t - n + i + t);
    switch (l === "smart" && (a >= d - n && a <= u + n ? l = ga : l = tr), l) {
      case Fd:
        return u;
      case Vd:
        return d;
      case tr: {
        const f = Math.round(d + (u - d) / 2);
        return f < Math.ceil(n / 2) ? 0 : f > s + Math.floor(n / 2) ? s : f;
      }
      case ga:
      default:
        return a >= d && a <= u ? a : d > u || a < d ? d : u;
    }
  },
  getRowOffset: ({ rowHeight: e, height: t, totalRow: n }, o, l, a, r, i) => {
    t = Number(t);
    const s = Math.max(0, n * e - t), u = Math.min(s, o * e), d = Math.max(0, o * e - t + i + e);
    switch (l === Yv && (a >= d - t && a <= u + t ? l = ga : l = tr), l) {
      case Fd:
        return u;
      case Vd:
        return d;
      case tr: {
        const f = Math.round(d + (u - d) / 2);
        return f < Math.ceil(t / 2) ? 0 : f > s + Math.floor(t / 2) ? s : f;
      }
      case ga:
      default:
        return a >= d && a <= u ? a : d > u || a < d ? d : u;
    }
  },
  getColumnStartIndexForOffset: ({ columnWidth: e, totalColumn: t }, n) => Math.max(0, Math.min(t - 1, Math.floor(n / e))),
  getColumnStopIndexForStartIndex: ({ columnWidth: e, totalColumn: t, width: n }, o, l) => {
    const a = o * e, r = Math.ceil((n + l - a) / e);
    return Math.max(0, Math.min(t - 1, o + r - 1));
  },
  getRowStartIndexForOffset: ({ rowHeight: e, totalRow: t }, n) => Math.max(0, Math.min(t - 1, Math.floor(n / e))),
  getRowStopIndexForStartIndex: ({ rowHeight: e, totalRow: t, height: n }, o, l) => {
    const a = o * e, r = Math.ceil((n + l - a) / e);
    return Math.max(0, Math.min(t - 1, o + r - 1));
  },
  initCache: () => {
  },
  clearCache: !0,
  validateProps: ({ columnWidth: e, rowHeight: t }) => {
    process.env.NODE_ENV !== "production" && (Ot(e) || lo(mE, `
          "columnWidth" must be passed as number,
            instead ${typeof e} was given.
        `), Ot(t) || lo(mE, `
          "columnWidth" must be passed as number,
            instead ${typeof t} was given.
        `));
  }
}), { max: rv, min: iO, floor: cO } = Math, gE = "ElDynamicSizeGrid", cJ = {
  column: "columnWidth",
  row: "rowHeight"
}, Xg = {
  column: "lastVisitedColumnIndex",
  row: "lastVisitedRowIndex"
}, Tr = (e, t, n, o) => {
  const [l, a, r] = [
    n[o],
    e[cJ[o]],
    n[Xg[o]]
  ];
  if (t > r) {
    let i = 0;
    if (r >= 0) {
      const s = l[r];
      i = s.offset + s.size;
    }
    for (let s = r + 1; s <= t; s++) {
      const u = a(s);
      l[s] = {
        offset: i,
        size: u
      }, i += u;
    }
    n[Xg[o]] = t;
  }
  return l[t];
}, uO = (e, t, n, o, l, a) => {
  for (; n <= o; ) {
    const r = n + cO((o - n) / 2), i = Tr(e, r, t, a).offset;
    if (i === l)
      return r;
    i < l ? n = r + 1 : o = r - 1;
  }
  return rv(0, n - 1);
}, uJ = (e, t, n, o, l) => {
  const a = l === "column" ? e.totalColumn : e.totalRow;
  let r = 1;
  for (; n < a && Tr(e, n, t, l).offset < o; )
    n += r, r *= 2;
  return uO(e, t, cO(n / 2), iO(n, a - 1), o, l);
}, bE = (e, t, n, o) => {
  const [l, a] = [
    t[o],
    t[Xg[o]]
  ];
  return (a > 0 ? l[a].offset : 0) >= n ? uO(e, t, 0, a, n, o) : uJ(e, t, rv(0, a), n, o);
}, dO = ({ totalRow: e }, { estimatedRowHeight: t, lastVisitedRowIndex: n, row: o }) => {
  let l = 0;
  if (n >= e && (n = e - 1), n >= 0) {
    const i = o[n];
    l = i.offset + i.size;
  }
  const r = (e - n - 1) * t;
  return l + r;
}, fO = ({ totalColumn: e }, { column: t, estimatedColumnWidth: n, lastVisitedColumnIndex: o }) => {
  let l = 0;
  if (o > e && (o = e - 1), o >= 0) {
    const i = t[o];
    l = i.offset + i.size;
  }
  const r = (e - o - 1) * n;
  return l + r;
}, dJ = {
  column: fO,
  row: dO
}, yE = (e, t, n, o, l, a, r) => {
  const [i, s] = [
    a === "row" ? e.height : e.width,
    dJ[a]
  ], u = Tr(e, t, l, a), d = s(e, l), f = rv(0, iO(d - i, u.offset)), v = rv(0, u.offset - i + r + u.size);
  switch (n === Yv && (o >= v - i && o <= f + i ? n = ga : n = tr), n) {
    case Fd:
      return f;
    case Vd:
      return v;
    case tr:
      return Math.round(v + (f - v) / 2);
    case ga:
    default:
      return o >= v && o <= f ? o : v > f || o < v ? v : f;
  }
}, fJ = sO({
  name: "ElDynamicSizeGrid",
  getColumnPosition: (e, t, n) => {
    const o = Tr(e, t, n, "column");
    return [o.size, o.offset];
  },
  getRowPosition: (e, t, n) => {
    const o = Tr(e, t, n, "row");
    return [o.size, o.offset];
  },
  getColumnOffset: (e, t, n, o, l, a) => yE(e, t, n, o, l, "column", a),
  getRowOffset: (e, t, n, o, l, a) => yE(e, t, n, o, l, "row", a),
  getColumnStartIndexForOffset: (e, t, n) => bE(e, n, t, "column"),
  getColumnStopIndexForStartIndex: (e, t, n, o) => {
    const l = Tr(e, t, o, "column"), a = n + e.width;
    let r = l.offset + l.size, i = t;
    for (; i < e.totalColumn - 1 && r < a; )
      i++, r += Tr(e, t, o, "column").size;
    return i;
  },
  getEstimatedTotalHeight: dO,
  getEstimatedTotalWidth: fO,
  getRowStartIndexForOffset: (e, t, n) => bE(e, n, t, "row"),
  getRowStopIndexForStartIndex: (e, t, n, o) => {
    const { totalRow: l, height: a } = e, r = Tr(e, t, o, "row"), i = n + a;
    let s = r.size + r.offset, u = t;
    for (; u < l - 1 && s < i; )
      u++, s += Tr(e, u, o, "row").size;
    return u;
  },
  injectToInstance: (e, t) => {
    const n = ({ columnIndex: a, rowIndex: r }, i) => {
      var s, u;
      i = To(i) ? !0 : i, Ot(a) && (t.value.lastVisitedColumnIndex = Math.min(t.value.lastVisitedColumnIndex, a - 1)), Ot(r) && (t.value.lastVisitedRowIndex = Math.min(t.value.lastVisitedRowIndex, r - 1)), (s = e.exposed) == null || s.getItemStyleCache.value(-1, null, null), i && ((u = e.proxy) == null || u.$forceUpdate());
    }, o = (a, r) => {
      n({
        columnIndex: a
      }, r);
    }, l = (a, r) => {
      n({
        rowIndex: a
      }, r);
    };
    Object.assign(e.proxy, {
      resetAfterColumnIndex: o,
      resetAfterRowIndex: l,
      resetAfter: n
    });
  },
  initCache: ({
    estimatedColumnWidth: e = Wg,
    estimatedRowHeight: t = Wg
  }) => ({
    column: {},
    estimatedColumnWidth: e,
    estimatedRowHeight: t,
    lastVisitedColumnIndex: -1,
    lastVisitedRowIndex: -1,
    row: {}
  }),
  clearCache: !1,
  validateProps: ({ columnWidth: e, rowHeight: t }) => {
    process.env.NODE_ENV !== "production" && (vn(e) || lo(gE, `
          "columnWidth" must be passed as function,
            instead ${typeof e} was given.
        `), vn(t) || lo(gE, `
          "rowHeight" must be passed as function,
            instead ${typeof t} was given.
        `));
  }
}), pJ = Q({
  props: {
    item: {
      type: Object,
      required: !0
    },
    style: Object,
    height: Number
  },
  setup() {
    return {
      ns: nt("select")
    };
  }
});
function vJ(e, t, n, o, l, a) {
  return e.item.isTitle ? (M(), G("div", {
    key: 0,
    class: z(e.ns.be("group", "title")),
    style: bt([e.style, { lineHeight: `${e.height}px` }])
  }, Qe(e.item.label), 7)) : (M(), G("div", {
    key: 1,
    class: z(e.ns.be("group", "split")),
    style: bt(e.style)
  }, [
    X("span", {
      class: z(e.ns.be("group", "split-dash")),
      style: bt({ top: `${e.height / 2}px` })
    }, null, 6)
  ], 6));
}
var hJ = /* @__PURE__ */ ut(pJ, [["render", vJ], ["__file", "group-item.vue"]]);
function mJ(e, { emit: t }) {
  return {
    hoverItem: () => {
      e.disabled || t("hover", e.index);
    },
    selectOptionClick: () => {
      e.disabled || t("select", e.item, e.index);
    }
  };
}
const pO = {
  label: "label",
  value: "value",
  disabled: "disabled",
  options: "options"
};
function Gv(e) {
  const t = x(() => ({ ...pO, ...e.props }));
  return {
    aliasProps: t,
    getLabel: (r) => bo(r, t.value.label),
    getValue: (r) => bo(r, t.value.value),
    getDisabled: (r) => bo(r, t.value.disabled),
    getOptions: (r) => bo(r, t.value.options)
  };
}
const gJ = it({
  allowCreate: Boolean,
  autocomplete: {
    type: Ae(String),
    default: "none"
  },
  automaticDropdown: Boolean,
  clearable: Boolean,
  clearIcon: {
    type: Dn,
    default: Ls
  },
  effect: {
    type: Ae(String),
    default: "light"
  },
  collapseTags: Boolean,
  collapseTagsTooltip: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  defaultFirstOption: Boolean,
  disabled: Boolean,
  estimatedOptionHeight: {
    type: Number,
    default: void 0
  },
  filterable: Boolean,
  filterMethod: Function,
  height: {
    type: Number,
    default: 274
  },
  itemHeight: {
    type: Number,
    default: 34
  },
  id: String,
  loading: Boolean,
  loadingText: String,
  modelValue: {
    type: Ae([Array, String, Number, Boolean, Object])
  },
  multiple: Boolean,
  multipleLimit: {
    type: Number,
    default: 0
  },
  name: String,
  noDataText: String,
  noMatchText: String,
  remoteMethod: Function,
  reserveKeyword: {
    type: Boolean,
    default: !0
  },
  options: {
    type: Ae(Array),
    required: !0
  },
  placeholder: {
    type: String
  },
  teleported: Fo.teleported,
  persistent: {
    type: Boolean,
    default: !0
  },
  popperClass: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: Ae(Object),
    default: () => ({})
  },
  remote: Boolean,
  size: Lo,
  props: {
    type: Ae(Object),
    default: () => pO
  },
  valueKey: {
    type: String,
    default: "value"
  },
  scrollbarAlwaysOn: Boolean,
  validateEvent: {
    type: Boolean,
    default: !0
  },
  placement: {
    type: Ae(String),
    values: Hi,
    default: "bottom-start"
  },
  fallbackPlacements: {
    type: Ae(Array),
    default: ["bottom-start", "top-start", "right", "left"]
  },
  tagType: { ...Uv.type, default: "info" },
  ...ru,
  ...Zo(["ariaLabel"])
}), bJ = it({
  data: Array,
  disabled: Boolean,
  hovering: Boolean,
  item: {
    type: Ae(Object),
    required: !0
  },
  index: Number,
  style: Object,
  selected: Boolean,
  created: Boolean
}), p0 = Symbol("ElSelectV2Injection"), yJ = Q({
  props: bJ,
  emits: ["select", "hover"],
  setup(e, { emit: t }) {
    const n = ot(p0), o = nt("select"), { hoverItem: l, selectOptionClick: a } = mJ(e, { emit: t }), { getLabel: r } = Gv(n.props);
    return {
      ns: o,
      hoverItem: l,
      selectOptionClick: a,
      getLabel: r
    };
  }
}), CJ = ["aria-selected"];
function wJ(e, t, n, o, l, a) {
  return M(), G("li", {
    "aria-selected": e.selected,
    style: bt(e.style),
    class: z([
      e.ns.be("dropdown", "item"),
      e.ns.is("selected", e.selected),
      e.ns.is("disabled", e.disabled),
      e.ns.is("created", e.created),
      e.ns.is("hovering", e.hovering)
    ]),
    onMouseenter: t[0] || (t[0] = (...r) => e.hoverItem && e.hoverItem(...r)),
    onClick: t[1] || (t[1] = It((...r) => e.selectOptionClick && e.selectOptionClick(...r), ["stop"]))
  }, [
    Ie(e.$slots, "default", {
      item: e.item,
      index: e.index,
      disabled: e.disabled
    }, () => [
      X("span", null, Qe(e.getLabel(e.item)), 1)
    ])
  ], 46, CJ);
}
var EJ = /* @__PURE__ */ ut(yJ, [["render", wJ], ["__file", "option-item.vue"]]), SJ = Q({
  name: "ElSelectDropdown",
  props: {
    loading: Boolean,
    data: {
      type: Array,
      required: !0
    },
    hoveringIndex: Number,
    width: Number
  },
  setup(e, {
    slots: t,
    expose: n
  }) {
    const o = ot(p0), l = nt("select"), {
      getLabel: a,
      getValue: r,
      getDisabled: i
    } = Gv(o.props), s = B([]), u = B(), d = x(() => e.data.length);
    Pe(() => d.value, () => {
      var R, H;
      (H = (R = o.tooltipRef.value).updatePopper) == null || H.call(R);
    });
    const f = x(() => To(o.props.estimatedOptionHeight)), v = x(() => f.value ? {
      itemSize: o.props.itemHeight
    } : {
      estimatedSize: o.props.estimatedOptionHeight,
      itemSize: (R) => s.value[R]
    }), h = (R = [], H) => {
      const {
        props: {
          valueKey: K
        }
      } = o;
      return Mn(H) ? R && R.some((U) => Sd(bo(U, K)) === bo(H, K)) : R.includes(H);
    }, m = (R, H) => {
      if (Mn(H)) {
        const {
          valueKey: K
        } = o.props;
        return bo(R, K) === bo(H, K);
      } else
        return R === H;
    }, p = (R, H) => o.props.multiple ? h(R, r(H)) : m(R, r(H)), C = (R, H) => {
      const {
        disabled: K,
        multiple: U,
        multipleLimit: W
      } = o.props;
      return K || !H && (U ? W > 0 && R.length >= W : !1);
    }, g = (R) => e.hoveringIndex === R;
    n({
      listRef: u,
      isSized: f,
      isItemDisabled: C,
      isItemHovering: g,
      isItemSelected: p,
      scrollToItem: (R) => {
        const H = u.value;
        H && H.scrollToItem(R);
      },
      resetScrollTop: () => {
        const R = u.value;
        R && R.resetScrollTop();
      }
    });
    const y = (R) => {
      const {
        index: H,
        data: K,
        style: U
      } = R, W = c(f), {
        itemSize: A,
        estimatedSize: $
      } = c(v), {
        modelValue: D
      } = o.props, {
        onSelect: O,
        onHover: F
      } = o, j = K[H];
      if (j.type === "Group")
        return oe(hJ, {
          item: j,
          style: U,
          height: W ? A : $
        }, null);
      const Z = p(D, j), te = C(D, Z), de = g(H);
      return oe(EJ, Et(R, {
        selected: Z,
        disabled: i(j) || te,
        created: !!j.created,
        hovering: de,
        item: j,
        onSelect: O,
        onHover: F
      }), {
        default: (Oe) => {
          var ce;
          return ((ce = t.default) == null ? void 0 : ce.call(t, Oe)) || oe("span", null, [a(j)]);
        }
      });
    }, {
      onKeyboardNavigate: E,
      onKeyboardSelect: S
    } = o, _ = () => {
      E("forward");
    }, k = () => {
      E("backward");
    }, N = () => {
      o.expanded = !1;
    }, L = (R) => {
      const {
        code: H
      } = R, {
        tab: K,
        esc: U,
        down: W,
        up: A,
        enter: $
      } = xt;
      switch (H !== K && (R.preventDefault(), R.stopPropagation()), H) {
        case K:
        case U: {
          N();
          break;
        }
        case W: {
          _();
          break;
        }
        case A: {
          k();
          break;
        }
        case $: {
          S();
          break;
        }
      }
    };
    return () => {
      var R, H, K, U;
      const {
        data: W,
        width: A
      } = e, {
        height: $,
        multiple: D,
        scrollbarAlwaysOn: O
      } = o.props, F = c(f) ? aO : rJ;
      return oe("div", {
        class: [l.b("dropdown"), l.is("multiple", D)],
        style: {
          width: `${A}px`
        }
      }, [(R = t.header) == null ? void 0 : R.call(t), ((H = t.loading) == null ? void 0 : H.call(t)) || ((K = t.empty) == null ? void 0 : K.call(t)) || oe(F, Et({
        ref: u
      }, c(v), {
        className: l.be("dropdown", "list"),
        scrollbarAlwaysOn: O,
        data: W,
        height: $,
        width: A,
        total: W.length,
        onKeydown: L
      }), {
        default: (j) => oe(y, j, null)
      }), (U = t.footer) == null ? void 0 : U.call(t)]);
    };
  }
});
function _J(e, t) {
  const { aliasProps: n, getLabel: o, getValue: l } = Gv(e), a = B(0), r = B(null), i = x(() => e.allowCreate && e.filterable);
  function s(h) {
    const m = (p) => o(p) === h;
    return e.options && e.options.some(m) || t.createdOptions.some(m);
  }
  function u(h) {
    i.value && (e.multiple && h.created ? a.value++ : r.value = h);
  }
  function d(h) {
    if (i.value)
      if (h && h.length > 0) {
        if (s(h))
          return;
        const m = {
          [n.value.value]: h,
          [n.value.label]: h,
          created: !0,
          [n.value.disabled]: !1
        };
        t.createdOptions.length >= a.value ? t.createdOptions[a.value] = m : t.createdOptions.push(m);
      } else if (e.multiple)
        t.createdOptions.length = a.value;
      else {
        const m = r.value;
        t.createdOptions.length = 0, m && m.created && t.createdOptions.push(m);
      }
  }
  function f(h) {
    if (!i.value || !h || !h.created || h.created && e.reserveKeyword && t.inputValue === o(h))
      return;
    const m = t.createdOptions.findIndex((p) => l(p) === l(h));
    ~m && (t.createdOptions.splice(m, 1), a.value--);
  }
  function v() {
    i.value && (t.createdOptions.length = 0, a.value = 0);
  }
  return {
    createNewOption: d,
    removeNewOption: f,
    selectNewOption: u,
    clearAllNewOption: v
  };
}
const xJ = 11, kJ = (e, t) => {
  const { t: n } = bn(), o = nt("select"), l = nt("input"), { form: a, formItem: r } = ml(), { inputId: i } = Wa(e, {
    formItemContext: r
  }), { aliasProps: s, getLabel: u, getValue: d, getDisabled: f, getOptions: v } = Gv(e), { valueOnClear: h, isEmptyValue: m } = Hv(e), p = en({
    inputValue: "",
    cachedOptions: [],
    createdOptions: [],
    hoveringIndex: -1,
    inputHovering: !1,
    selectionWidth: 0,
    calculatorWidth: 0,
    collapseItemWidth: 0,
    previousQuery: null,
    previousValue: void 0,
    selectedLabel: "",
    menuVisibleOnFocus: !1,
    isBeforeHide: !1
  }), C = B(-1), g = B(null), w = B(null), b = B(null), y = B(null), E = B(null), S = B(null), _ = B(null), k = B(null), N = B(null), L = B(null), R = B(null), { wrapperRef: H, isFocused: K, handleFocus: U, handleBlur: W } = Bv(E, {
    afterFocus() {
      e.automaticDropdown && !D.value && (D.value = !0, p.menuVisibleOnFocus = !0);
    },
    beforeBlur(ft) {
      var At, Xt;
      return ((At = b.value) == null ? void 0 : At.isFocusInsideContent(ft)) || ((Xt = y.value) == null ? void 0 : Xt.isFocusInsideContent(ft));
    },
    afterBlur() {
      D.value = !1, p.menuVisibleOnFocus = !1;
    }
  }), A = B([]), $ = B([]), D = B(!1), O = x(() => e.disabled || (a == null ? void 0 : a.disabled)), F = x(() => {
    const ft = $.value.length * e.itemHeight;
    return ft > e.height ? e.height : ft;
  }), j = x(() => e.multiple ? Kt(e.modelValue) && e.modelValue.length > 0 : !m(e.modelValue)), Z = x(() => e.clearable && !O.value && p.inputHovering && j.value), te = x(() => e.remote && e.filterable ? "" : Br), de = x(() => te.value && o.is("reverse", D.value)), Oe = x(() => (r == null ? void 0 : r.validateState) || ""), ce = x(() => vy[Oe.value]), ne = x(() => e.remote ? 300 : 0), Y = x(() => e.loading ? e.loadingText || n("el.select.loading") : e.remote && !p.inputValue && A.value.length === 0 ? !1 : e.filterable && p.inputValue && A.value.length > 0 && $.value.length === 0 ? e.noMatchText || n("el.select.noMatch") : A.value.length === 0 ? e.noDataText || n("el.select.noData") : null), ve = (ft) => {
    const At = (Xt) => {
      if (e.filterable && vn(e.filterMethod) || e.filterable && e.remote && vn(e.remoteMethod))
        return !0;
      const sn = new RegExp(ry(ft), "i");
      return ft ? sn.test(u(Xt) || "") : !0;
    };
    return e.loading ? [] : [...p.createdOptions, ...e.options].reduce((Xt, sn) => {
      const _o = v(sn);
      if (Kt(_o)) {
        const No = _o.filter(At);
        No.length > 0 && Xt.push({
          label: u(sn),
          isTitle: !0,
          type: "Group"
        }, ...No, { type: "Group" });
      } else
        (e.remote || At(sn)) && Xt.push(sn);
      return Xt;
    }, []);
  }, ie = () => {
    A.value = ve(""), $.value = ve(p.inputValue);
  }, he = x(() => {
    const ft = /* @__PURE__ */ new Map();
    return A.value.forEach((At, Xt) => {
      ft.set(_t(d(At)), { option: At, index: Xt });
    }), ft;
  }), De = x(() => {
    const ft = /* @__PURE__ */ new Map();
    return $.value.forEach((At, Xt) => {
      ft.set(_t(d(At)), { option: At, index: Xt });
    }), ft;
  }), $e = x(() => $.value.every((ft) => f(ft))), ue = Mo(), Ne = x(() => ue.value === "small" ? "small" : "default"), je = () => {
    var ft;
    C.value = ((ft = g.value) == null ? void 0 : ft.offsetWidth) || 200;
  }, Fe = () => {
    if (!w.value)
      return 0;
    const ft = window.getComputedStyle(w.value);
    return Number.parseFloat(ft.gap || "6px");
  }, Ve = x(() => {
    const ft = Fe();
    return { maxWidth: `${R.value && e.maxCollapseTags === 1 ? p.selectionWidth - p.collapseItemWidth - ft : p.selectionWidth}px` };
  }), Ze = x(() => ({ maxWidth: `${p.selectionWidth}px` })), ae = x(() => ({
    width: `${Math.max(p.calculatorWidth, xJ)}px`
  })), pe = x(() => Kt(e.modelValue) ? e.modelValue.length === 0 && !p.inputValue : e.filterable ? !p.inputValue : !0), ke = x(() => {
    var ft;
    const At = (ft = e.placeholder) != null ? ft : n("el.select.placeholder");
    return e.multiple || !j.value ? At : p.selectedLabel;
  }), Ue = x(() => {
    var ft, At;
    return (At = (ft = b.value) == null ? void 0 : ft.popperRef) == null ? void 0 : At.contentRef;
  }), Xe = x(() => {
    if (e.multiple) {
      const ft = e.modelValue.length;
      if (e.modelValue.length > 0 && De.value.has(e.modelValue[ft - 1])) {
        const { index: At } = De.value.get(e.modelValue[ft - 1]);
        return At;
      }
    } else if (e.modelValue && De.value.has(e.modelValue)) {
      const { index: ft } = De.value.get(e.modelValue);
      return ft;
    }
    return -1;
  }), re = x({
    get() {
      return D.value && Y.value !== !1;
    },
    set(ft) {
      D.value = ft;
    }
  }), Te = x(() => e.multiple ? e.collapseTags ? p.cachedOptions.slice(0, e.maxCollapseTags) : p.cachedOptions : []), Ce = x(() => e.multiple ? e.collapseTags ? p.cachedOptions.slice(e.maxCollapseTags) : [] : []), {
    createNewOption: Le,
    removeNewOption: ge,
    selectNewOption: Ee,
    clearAllNewOption: me
  } = _J(e, p), {
    handleCompositionStart: Ke,
    handleCompositionUpdate: Re,
    handleCompositionEnd: we
  } = K$((ft) => ro(ft)), ze = () => {
    O.value || (p.menuVisibleOnFocus ? p.menuVisibleOnFocus = !1 : D.value = !D.value);
  }, Je = () => {
    p.inputValue.length > 0 && !D.value && (D.value = !0), Le(p.inputValue), et(p.inputValue);
  }, Me = Hl(Je, ne.value), et = (ft) => {
    p.previousQuery !== ft && (p.previousQuery = ft, e.filterable && vn(e.filterMethod) ? e.filterMethod(ft) : e.filterable && e.remote && vn(e.remoteMethod) && e.remoteMethod(ft), e.defaultFirstOption && (e.filterable || e.remote) && $.value.length ? xe(mt) : xe(mo));
  }, mt = () => {
    const ft = $.value.filter((sn) => !sn.disabled && sn.type !== "Group"), At = ft.find((sn) => sn.created), Xt = ft[0];
    p.hoveringIndex = an($.value, At || Xt);
  }, Lt = (ft) => {
    pl(e.modelValue, ft) || t(qn, ft);
  }, be = (ft) => {
    t(Jt, ft), Lt(ft), p.previousValue = e.multiple ? String(ft) : ft;
  }, an = (ft = [], At) => {
    if (!Mn(At))
      return ft.indexOf(At);
    const Xt = e.valueKey;
    let sn = -1;
    return ft.some((_o, No) => bo(_o, Xt) === bo(At, Xt) ? (sn = No, !0) : !1), sn;
  }, _t = (ft) => Mn(ft) ? bo(ft, e.valueKey) : ft, zt = () => {
    je();
  }, jt = () => {
    p.selectionWidth = w.value.getBoundingClientRect().width;
  }, Sn = () => {
    p.calculatorWidth = S.value.getBoundingClientRect().width;
  }, hn = () => {
    p.collapseItemWidth = R.value.getBoundingClientRect().width;
  }, xn = () => {
    var ft, At;
    (At = (ft = b.value) == null ? void 0 : ft.updatePopper) == null || At.call(ft);
  }, yn = () => {
    var ft, At;
    (At = (ft = y.value) == null ? void 0 : ft.updatePopper) == null || At.call(ft);
  }, kn = (ft) => {
    if (e.multiple) {
      let At = e.modelValue.slice();
      const Xt = an(At, d(ft));
      Xt > -1 ? (At = [
        ...At.slice(0, Xt),
        ...At.slice(Xt + 1)
      ], p.cachedOptions.splice(Xt, 1), ge(ft)) : (e.multipleLimit <= 0 || At.length < e.multipleLimit) && (At = [...At, d(ft)], p.cachedOptions.push(ft), Ee(ft)), be(At), ft.created && et(""), e.filterable && !e.reserveKeyword && (p.inputValue = "");
    } else
      p.selectedLabel = u(ft), be(d(ft)), D.value = !1, Ee(ft), ft.created || me();
    Vn();
  }, Wn = (ft, At) => {
    let Xt = e.modelValue.slice();
    const sn = an(Xt, d(At));
    sn > -1 && !O.value && (Xt = [
      ...e.modelValue.slice(0, sn),
      ...e.modelValue.slice(sn + 1)
    ], p.cachedOptions.splice(sn, 1), be(Xt), t("remove-tag", d(At)), ge(At)), ft.stopPropagation(), Vn();
  }, Vn = () => {
    var ft;
    (ft = E.value) == null || ft.focus();
  }, ho = () => {
    var ft;
    (ft = E.value) == null || ft.blur();
  }, Qn = () => {
    p.inputValue.length > 0 ? p.inputValue = "" : D.value = !1;
  }, eo = (ft) => Bx(ft, (At) => !p.cachedOptions.some((Xt) => d(Xt) === At && f(Xt))), So = (ft) => {
    if (e.multiple && ft.code !== xt.delete && p.inputValue.length === 0) {
      ft.preventDefault();
      const At = e.modelValue.slice(), Xt = eo(At);
      if (Xt < 0)
        return;
      At.splice(Xt, 1);
      const sn = p.cachedOptions[Xt];
      p.cachedOptions.splice(Xt, 1), ge(sn), be(At);
    }
  }, st = () => {
    let ft;
    Kt(e.modelValue) ? ft = [] : ft = h.value, e.multiple ? p.cachedOptions = [] : p.selectedLabel = "", D.value = !1, be(ft), t("clear"), me(), Vn();
  }, St = (ft, At = void 0) => {
    const Xt = $.value;
    if (!["forward", "backward"].includes(ft) || O.value || Xt.length <= 0 || $e.value)
      return;
    if (!D.value)
      return ze();
    At === void 0 && (At = p.hoveringIndex);
    let sn = -1;
    ft === "forward" ? (sn = At + 1, sn >= Xt.length && (sn = 0)) : ft === "backward" && (sn = At - 1, (sn < 0 || sn >= Xt.length) && (sn = Xt.length - 1));
    const _o = Xt[sn];
    if (f(_o) || _o.type === "Group")
      return St(ft, sn);
    p.hoveringIndex = sn, so(sn);
  }, rn = () => {
    if (D.value)
      ~p.hoveringIndex && $.value[p.hoveringIndex] && kn($.value[p.hoveringIndex]);
    else
      return ze();
  }, Tn = (ft) => {
    p.hoveringIndex = ft;
  }, mo = () => {
    e.multiple ? p.hoveringIndex = $.value.findIndex((ft) => e.modelValue.some((At) => _t(At) === _t(ft))) : p.hoveringIndex = $.value.findIndex((ft) => _t(ft) === _t(e.modelValue));
  }, ro = (ft) => {
    if (p.inputValue = ft.target.value, e.remote)
      Me();
    else
      return Je();
  }, Io = (ft) => {
    if (D.value = !1, K.value) {
      const At = new FocusEvent("focus", ft);
      W(At);
    }
  }, Oo = () => (p.isBeforeHide = !1, xe(() => {
    ~Xe.value && so(p.hoveringIndex);
  })), so = (ft) => {
    N.value.scrollToItem(ft);
  }, la = (ft) => {
    const At = _t(ft);
    if (he.value.has(At)) {
      const { option: Xt } = he.value.get(At);
      return Xt;
    }
    return {
      [s.value.value]: ft,
      [s.value.label]: ft
    };
  }, aa = () => {
    if (e.multiple)
      if (e.modelValue.length > 0) {
        p.cachedOptions.length = 0, p.previousValue = e.modelValue.toString();
        for (const ft of e.modelValue) {
          const At = la(ft);
          p.cachedOptions.push(At);
        }
      } else
        p.cachedOptions = [], p.previousValue = void 0;
    else if (j.value) {
      p.previousValue = e.modelValue;
      const ft = $.value, At = ft.findIndex((Xt) => _t(d(Xt)) === _t(e.modelValue));
      ~At ? p.selectedLabel = u(ft[At]) : p.selectedLabel = _t(e.modelValue);
    } else
      p.selectedLabel = "", p.previousValue = void 0;
    me(), je();
  };
  return Pe(D, (ft) => {
    ft ? et("") : (p.inputValue = "", p.previousQuery = null, p.isBeforeHide = !0, Le("")), t("visible-change", ft);
  }), Pe(() => e.modelValue, (ft, At) => {
    var Xt;
    (!ft || e.multiple && ft.toString() !== p.previousValue || !e.multiple && _t(ft) !== _t(p.previousValue)) && aa(), !pl(ft, At) && e.validateEvent && ((Xt = r == null ? void 0 : r.validate) == null || Xt.call(r, "change").catch((sn) => dn(sn)));
  }, {
    deep: !0
  }), Pe(() => e.options, () => {
    const ft = E.value;
    (!ft || ft && document.activeElement !== ft) && aa();
  }, {
    deep: !0,
    flush: "post"
  }), Pe(() => $.value, () => N.value && xe(N.value.resetScrollTop)), ol(() => {
    p.isBeforeHide || ie();
  }), ol(() => {
    const { valueKey: ft, options: At } = e, Xt = /* @__PURE__ */ new Map();
    for (const sn of At) {
      const _o = d(sn);
      let No = _o;
      if (Mn(No) && (No = bo(_o, ft)), Xt.get(No)) {
        dn("ElSelectV2", "The option values you provided seem to be duplicated, which may cause some problems, please check.");
        break;
      } else
        Xt.set(No, !0);
    }
  }), Nt(() => {
    aa();
  }), Xn(g, zt), Xn(w, jt), Xn(S, Sn), Xn(N, xn), Xn(H, xn), Xn(L, yn), Xn(R, hn), {
    inputId: i,
    collapseTagSize: Ne,
    currentPlaceholder: ke,
    expanded: D,
    emptyText: Y,
    popupHeight: F,
    debounce: ne,
    allOptions: A,
    filteredOptions: $,
    iconComponent: te,
    iconReverse: de,
    tagStyle: Ve,
    collapseTagStyle: Ze,
    inputStyle: ae,
    popperSize: C,
    dropdownMenuVisible: re,
    hasModelValue: j,
    shouldShowPlaceholder: pe,
    selectDisabled: O,
    selectSize: ue,
    showClearBtn: Z,
    states: p,
    isFocused: K,
    nsSelect: o,
    nsInput: l,
    calculatorRef: S,
    inputRef: E,
    menuRef: N,
    tagMenuRef: L,
    tooltipRef: b,
    tagTooltipRef: y,
    selectRef: g,
    wrapperRef: H,
    selectionRef: w,
    prefixRef: _,
    suffixRef: k,
    collapseItemRef: R,
    popperRef: Ue,
    validateState: Oe,
    validateIcon: ce,
    showTagList: Te,
    collapseTagList: Ce,
    debouncedOnInputChange: Me,
    deleteTag: Wn,
    getLabel: u,
    getValue: d,
    getDisabled: f,
    getValueKey: _t,
    handleBlur: W,
    handleClear: st,
    handleClickOutside: Io,
    handleDel: So,
    handleEsc: Qn,
    handleFocus: U,
    focus: Vn,
    blur: ho,
    handleMenuEnter: Oo,
    handleResize: zt,
    resetSelectionWidth: jt,
    resetCalculatorWidth: Sn,
    updateTooltip: xn,
    updateTagTooltip: yn,
    updateOptions: ie,
    toggleMenu: ze,
    scrollTo: so,
    onInput: ro,
    onKeyboardNavigate: St,
    onKeyboardSelect: rn,
    onSelect: kn,
    onHover: Tn,
    handleCompositionStart: Ke,
    handleCompositionEnd: we,
    handleCompositionUpdate: Re
  };
}, TJ = Q({
  name: "ElSelectV2",
  components: {
    ElSelectMenu: SJ,
    ElTag: Uc,
    ElTooltip: hl,
    ElIcon: Ct
  },
  directives: { ClickOutside: Pr },
  props: gJ,
  emits: [
    Jt,
    qn,
    "remove-tag",
    "clear",
    "visible-change",
    "focus",
    "blur"
  ],
  setup(e, { emit: t }) {
    const n = x(() => {
      const { modelValue: l, multiple: a } = e, r = a ? [] : void 0;
      return Kt(l) ? a ? l : r : a ? r : l;
    }), o = kJ(en({
      ...Xo(e),
      modelValue: n
    }), t);
    return Mt(p0, {
      props: en({
        ...Xo(e),
        height: o.popupHeight,
        modelValue: n
      }),
      tooltipRef: o.tooltipRef,
      onSelect: o.onSelect,
      onHover: o.onHover,
      onKeyboardNavigate: o.onKeyboardNavigate,
      onKeyboardSelect: o.onKeyboardSelect
    }), {
      ...o,
      modelValue: n
    };
  }
}), $J = ["id", "autocomplete", "aria-expanded", "aria-label", "disabled", "readonly", "name"], OJ = ["textContent"];
function NJ(e, t, n, o, l, a) {
  const r = Dt("el-tag"), i = Dt("el-tooltip"), s = Dt("el-icon"), u = Dt("el-select-menu"), d = _v("click-outside");
  return Bt((M(), G("div", {
    ref: "selectRef",
    class: z([e.nsSelect.b(), e.nsSelect.m(e.selectSize)]),
    onMouseenter: t[14] || (t[14] = (f) => e.states.inputHovering = !0),
    onMouseleave: t[15] || (t[15] = (f) => e.states.inputHovering = !1),
    onClick: t[16] || (t[16] = It((...f) => e.toggleMenu && e.toggleMenu(...f), ["prevent", "stop"]))
  }, [
    oe(i, {
      ref: "tooltipRef",
      visible: e.dropdownMenuVisible,
      teleported: e.teleported,
      "popper-class": [e.nsSelect.e("popper"), e.popperClass],
      "gpu-acceleration": !1,
      "stop-popper-mouse-event": !1,
      "popper-options": e.popperOptions,
      "fallback-placements": e.fallbackPlacements,
      effect: e.effect,
      placement: e.placement,
      pure: "",
      transition: `${e.nsSelect.namespace.value}-zoom-in-top`,
      trigger: "click",
      persistent: e.persistent,
      onBeforeShow: e.handleMenuEnter,
      onHide: t[13] || (t[13] = (f) => e.states.isBeforeHide = !1)
    }, {
      default: fe(() => [
        X("div", {
          ref: "wrapperRef",
          class: z([
            e.nsSelect.e("wrapper"),
            e.nsSelect.is("focused", e.isFocused),
            e.nsSelect.is("hovering", e.states.inputHovering),
            e.nsSelect.is("filterable", e.filterable),
            e.nsSelect.is("disabled", e.selectDisabled)
          ])
        }, [
          e.$slots.prefix ? (M(), G("div", {
            key: 0,
            ref: "prefixRef",
            class: z(e.nsSelect.e("prefix"))
          }, [
            Ie(e.$slots, "prefix")
          ], 2)) : _e("v-if", !0),
          X("div", {
            ref: "selectionRef",
            class: z([
              e.nsSelect.e("selection"),
              e.nsSelect.is("near", e.multiple && !e.$slots.prefix && !!e.modelValue.length)
            ])
          }, [
            e.multiple ? Ie(e.$slots, "tag", { key: 0 }, () => [
              (M(!0), G(kt, null, ln(e.showTagList, (f) => (M(), G("div", {
                key: e.getValueKey(e.getValue(f)),
                class: z(e.nsSelect.e("selected-item"))
              }, [
                oe(r, {
                  closable: !e.selectDisabled && !e.getDisabled(f),
                  size: e.collapseTagSize,
                  type: e.tagType,
                  "disable-transitions": "",
                  style: bt(e.tagStyle),
                  onClose: (v) => e.deleteTag(v, f)
                }, {
                  default: fe(() => [
                    X("span", {
                      class: z(e.nsSelect.e("tags-text"))
                    }, Qe(e.getLabel(f)), 3)
                  ]),
                  _: 2
                }, 1032, ["closable", "size", "type", "style", "onClose"])
              ], 2))), 128)),
              e.collapseTags && e.modelValue.length > e.maxCollapseTags ? (M(), We(i, {
                key: 0,
                ref: "tagTooltipRef",
                disabled: e.dropdownMenuVisible || !e.collapseTagsTooltip,
                "fallback-placements": ["bottom", "top", "right", "left"],
                effect: e.effect,
                placement: "bottom",
                teleported: e.teleported
              }, {
                default: fe(() => [
                  X("div", {
                    ref: "collapseItemRef",
                    class: z(e.nsSelect.e("selected-item"))
                  }, [
                    oe(r, {
                      closable: !1,
                      size: e.collapseTagSize,
                      type: e.tagType,
                      style: bt(e.collapseTagStyle),
                      "disable-transitions": ""
                    }, {
                      default: fe(() => [
                        X("span", {
                          class: z(e.nsSelect.e("tags-text"))
                        }, " + " + Qe(e.modelValue.length - e.maxCollapseTags), 3)
                      ]),
                      _: 1
                    }, 8, ["size", "type", "style"])
                  ], 2)
                ]),
                content: fe(() => [
                  X("div", {
                    ref: "tagMenuRef",
                    class: z(e.nsSelect.e("selection"))
                  }, [
                    (M(!0), G(kt, null, ln(e.collapseTagList, (f) => (M(), G("div", {
                      key: e.getValueKey(e.getValue(f)),
                      class: z(e.nsSelect.e("selected-item"))
                    }, [
                      oe(r, {
                        class: "in-tooltip",
                        closable: !e.selectDisabled && !e.getDisabled(f),
                        size: e.collapseTagSize,
                        type: e.tagType,
                        "disable-transitions": "",
                        onClose: (v) => e.deleteTag(v, f)
                      }, {
                        default: fe(() => [
                          X("span", {
                            class: z(e.nsSelect.e("tags-text"))
                          }, Qe(e.getLabel(f)), 3)
                        ]),
                        _: 2
                      }, 1032, ["closable", "size", "type", "onClose"])
                    ], 2))), 128))
                  ], 2)
                ]),
                _: 1
              }, 8, ["disabled", "effect", "teleported"])) : _e("v-if", !0)
            ]) : _e("v-if", !0),
            e.selectDisabled ? _e("v-if", !0) : (M(), G("div", {
              key: 1,
              class: z([
                e.nsSelect.e("selected-item"),
                e.nsSelect.e("input-wrapper"),
                e.nsSelect.is("hidden", !e.filterable)
              ])
            }, [
              Bt(X("input", {
                id: e.inputId,
                ref: "inputRef",
                "onUpdate:modelValue": t[0] || (t[0] = (f) => e.states.inputValue = f),
                style: bt(e.inputStyle),
                autocomplete: e.autocomplete,
                "aria-autocomplete": "list",
                "aria-haspopup": "listbox",
                autocapitalize: "off",
                "aria-expanded": e.expanded,
                "aria-label": e.ariaLabel,
                class: z([e.nsSelect.e("input"), e.nsSelect.is(e.selectSize)]),
                disabled: e.selectDisabled,
                role: "combobox",
                readonly: !e.filterable,
                spellcheck: "false",
                type: "text",
                name: e.name,
                onFocus: t[1] || (t[1] = (...f) => e.handleFocus && e.handleFocus(...f)),
                onBlur: t[2] || (t[2] = (...f) => e.handleBlur && e.handleBlur(...f)),
                onInput: t[3] || (t[3] = (...f) => e.onInput && e.onInput(...f)),
                onCompositionstart: t[4] || (t[4] = (...f) => e.handleCompositionStart && e.handleCompositionStart(...f)),
                onCompositionupdate: t[5] || (t[5] = (...f) => e.handleCompositionUpdate && e.handleCompositionUpdate(...f)),
                onCompositionend: t[6] || (t[6] = (...f) => e.handleCompositionEnd && e.handleCompositionEnd(...f)),
                onKeydown: [
                  t[7] || (t[7] = Rn(It((f) => e.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                  t[8] || (t[8] = Rn(It((f) => e.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                  t[9] || (t[9] = Rn(It((...f) => e.onKeyboardSelect && e.onKeyboardSelect(...f), ["stop", "prevent"]), ["enter"])),
                  t[10] || (t[10] = Rn(It((...f) => e.handleEsc && e.handleEsc(...f), ["stop", "prevent"]), ["esc"])),
                  t[11] || (t[11] = Rn(It((...f) => e.handleDel && e.handleDel(...f), ["stop"]), ["delete"]))
                ],
                onClick: t[12] || (t[12] = It((...f) => e.toggleMenu && e.toggleMenu(...f), ["stop"]))
              }, null, 46, $J), [
                [Vb, e.states.inputValue]
              ]),
              e.filterable ? (M(), G("span", {
                key: 0,
                ref: "calculatorRef",
                "aria-hidden": "true",
                class: z(e.nsSelect.e("input-calculator")),
                textContent: Qe(e.states.inputValue)
              }, null, 10, OJ)) : _e("v-if", !0)
            ], 2)),
            e.shouldShowPlaceholder ? (M(), G("div", {
              key: 2,
              class: z([
                e.nsSelect.e("selected-item"),
                e.nsSelect.e("placeholder"),
                e.nsSelect.is("transparent", !e.hasModelValue || e.expanded && !e.states.inputValue)
              ])
            }, [
              X("span", null, Qe(e.currentPlaceholder), 1)
            ], 2)) : _e("v-if", !0)
          ], 2),
          X("div", {
            ref: "suffixRef",
            class: z(e.nsSelect.e("suffix"))
          }, [
            e.iconComponent ? Bt((M(), We(s, {
              key: 0,
              class: z([e.nsSelect.e("caret"), e.nsInput.e("icon"), e.iconReverse])
            }, {
              default: fe(() => [
                (M(), We(Qt(e.iconComponent)))
              ]),
              _: 1
            }, 8, ["class"])), [
              [pn, !e.showClearBtn]
            ]) : _e("v-if", !0),
            e.showClearBtn && e.clearIcon ? (M(), We(s, {
              key: 1,
              class: z([e.nsSelect.e("caret"), e.nsInput.e("icon")]),
              onClick: It(e.handleClear, ["prevent", "stop"])
            }, {
              default: fe(() => [
                (M(), We(Qt(e.clearIcon)))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : _e("v-if", !0),
            e.validateState && e.validateIcon ? (M(), We(s, {
              key: 2,
              class: z([e.nsInput.e("icon"), e.nsInput.e("validateIcon")])
            }, {
              default: fe(() => [
                (M(), We(Qt(e.validateIcon)))
              ]),
              _: 1
            }, 8, ["class"])) : _e("v-if", !0)
          ], 2)
        ], 2)
      ]),
      content: fe(() => [
        oe(u, {
          ref: "menuRef",
          data: e.filteredOptions,
          width: e.popperSize,
          "hovering-index": e.states.hoveringIndex,
          "scrollbar-always-on": e.scrollbarAlwaysOn
        }, rl({
          default: fe((f) => [
            Ie(e.$slots, "default", xo(Ao(f)))
          ]),
          _: 2
        }, [
          e.$slots.header ? {
            name: "header",
            fn: fe(() => [
              X("div", {
                class: z(e.nsSelect.be("dropdown", "header"))
              }, [
                Ie(e.$slots, "header")
              ], 2)
            ])
          } : void 0,
          e.$slots.loading && e.loading ? {
            name: "loading",
            fn: fe(() => [
              X("div", {
                class: z(e.nsSelect.be("dropdown", "loading"))
              }, [
                Ie(e.$slots, "loading")
              ], 2)
            ])
          } : e.loading || e.filteredOptions.length === 0 ? {
            name: "empty",
            fn: fe(() => [
              X("div", {
                class: z(e.nsSelect.be("dropdown", "empty"))
              }, [
                Ie(e.$slots, "empty", {}, () => [
                  X("span", null, Qe(e.emptyText), 1)
                ])
              ], 2)
            ])
          } : void 0,
          e.$slots.footer ? {
            name: "footer",
            fn: fe(() => [
              X("div", {
                class: z(e.nsSelect.be("dropdown", "footer"))
              }, [
                Ie(e.$slots, "footer")
              ], 2)
            ])
          } : void 0
        ]), 1032, ["data", "width", "hovering-index", "scrollbar-always-on"])
      ]),
      _: 3
    }, 8, ["visible", "teleported", "popper-class", "popper-options", "fallback-placements", "effect", "placement", "transition", "persistent", "onBeforeShow"])
  ], 34)), [
    [d, e.handleClickOutside, e.popperRef]
  ]);
}
var Op = /* @__PURE__ */ ut(TJ, [["render", NJ], ["__file", "select.vue"]]);
Op.install = (e) => {
  e.component(Op.name, Op);
};
const MJ = Op, IJ = MJ, RJ = it({
  animated: {
    type: Boolean,
    default: !1
  },
  count: {
    type: Number,
    default: 1
  },
  rows: {
    type: Number,
    default: 3
  },
  loading: {
    type: Boolean,
    default: !0
  },
  throttle: {
    type: Number
  }
}), DJ = it({
  variant: {
    type: String,
    values: [
      "circle",
      "rect",
      "h1",
      "h3",
      "text",
      "caption",
      "p",
      "image",
      "button"
    ],
    default: "text"
  }
}), LJ = Q({
  name: "ElSkeletonItem"
}), PJ = /* @__PURE__ */ Q({
  ...LJ,
  props: DJ,
  setup(e) {
    const t = nt("skeleton");
    return (n, o) => (M(), G("div", {
      class: z([c(t).e("item"), c(t).e(n.variant)])
    }, [
      n.variant === "image" ? (M(), We(c(L8), { key: 0 })) : _e("v-if", !0)
    ], 2));
  }
});
var sv = /* @__PURE__ */ ut(PJ, [["__file", "skeleton-item.vue"]]);
const AJ = Q({
  name: "ElSkeleton"
}), FJ = /* @__PURE__ */ Q({
  ...AJ,
  props: RJ,
  setup(e, { expose: t }) {
    const n = e, o = nt("skeleton"), l = H6(Pn(n, "loading"), n.throttle);
    return t({
      uiLoading: l
    }), (a, r) => c(l) ? (M(), G("div", Et({
      key: 0,
      class: [c(o).b(), c(o).is("animated", a.animated)]
    }, a.$attrs), [
      (M(!0), G(kt, null, ln(a.count, (i) => (M(), G(kt, { key: i }, [
        a.loading ? Ie(a.$slots, "template", { key: i }, () => [
          oe(sv, {
            class: z(c(o).is("first")),
            variant: "p"
          }, null, 8, ["class"]),
          (M(!0), G(kt, null, ln(a.rows, (s) => (M(), We(sv, {
            key: s,
            class: z([
              c(o).e("paragraph"),
              c(o).is("last", s === a.rows && a.rows > 1)
            ]),
            variant: "p"
          }, null, 8, ["class"]))), 128))
        ]) : _e("v-if", !0)
      ], 64))), 128))
    ], 16)) : Ie(a.$slots, "default", xo(Et({ key: 1 }, a.$attrs)));
  }
});
var VJ = /* @__PURE__ */ ut(FJ, [["__file", "skeleton.vue"]]);
const BJ = Yt(VJ, {
  SkeletonItem: sv
}), HJ = Jn(sv), vO = Symbol("sliderContextKey"), zJ = it({
  modelValue: {
    type: Ae([Number, Array]),
    default: 0
  },
  id: {
    type: String,
    default: void 0
  },
  min: {
    type: Number,
    default: 0
  },
  max: {
    type: Number,
    default: 100
  },
  step: {
    type: Number,
    default: 1
  },
  showInput: Boolean,
  showInputControls: {
    type: Boolean,
    default: !0
  },
  size: Lo,
  inputSize: Lo,
  showStops: Boolean,
  showTooltip: {
    type: Boolean,
    default: !0
  },
  formatTooltip: {
    type: Ae(Function),
    default: void 0
  },
  disabled: Boolean,
  range: Boolean,
  vertical: Boolean,
  height: String,
  debounce: {
    type: Number,
    default: 300
  },
  label: {
    type: String,
    default: void 0
  },
  rangeStartLabel: {
    type: String,
    default: void 0
  },
  rangeEndLabel: {
    type: String,
    default: void 0
  },
  formatValueText: {
    type: Ae(Function),
    default: void 0
  },
  tooltipClass: {
    type: String,
    default: void 0
  },
  placement: {
    type: String,
    values: Hi,
    default: "top"
  },
  marks: {
    type: Ae(Object)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  ...Zo(["ariaLabel"])
}), cm = (e) => Ot(e) || Kt(e) && e.every(Ot), WJ = {
  [Jt]: cm,
  [kl]: cm,
  [qn]: cm
}, KJ = (e, t, n) => {
  const o = B();
  return Nt(async () => {
    e.range ? (Array.isArray(e.modelValue) ? (t.firstValue = Math.max(e.min, e.modelValue[0]), t.secondValue = Math.min(e.max, e.modelValue[1])) : (t.firstValue = e.min, t.secondValue = e.max), t.oldValue = [t.firstValue, t.secondValue]) : (typeof e.modelValue != "number" || Number.isNaN(e.modelValue) ? t.firstValue = e.min : t.firstValue = Math.min(e.max, Math.max(e.min, e.modelValue)), t.oldValue = t.firstValue), jn(window, "resize", n), await xe(), n();
  }), {
    sliderWrapper: o
  };
}, UJ = (e) => x(() => e.marks ? Object.keys(e.marks).map(Number.parseFloat).sort((n, o) => n - o).filter((n) => n <= e.max && n >= e.min).map((n) => ({
  point: n,
  position: (n - e.min) * 100 / (e.max - e.min),
  mark: e.marks[n]
})) : []), jJ = (e, t, n) => {
  const { form: o, formItem: l } = ml(), a = An(), r = B(), i = B(), s = {
    firstButton: r,
    secondButton: i
  }, u = x(() => e.disabled || (o == null ? void 0 : o.disabled) || !1), d = x(() => Math.min(t.firstValue, t.secondValue)), f = x(() => Math.max(t.firstValue, t.secondValue)), v = x(() => e.range ? `${100 * (f.value - d.value) / (e.max - e.min)}%` : `${100 * (t.firstValue - e.min) / (e.max - e.min)}%`), h = x(() => e.range ? `${100 * (d.value - e.min) / (e.max - e.min)}%` : "0%"), m = x(() => e.vertical ? { height: e.height } : {}), p = x(() => e.vertical ? {
    height: v.value,
    bottom: h.value
  } : {
    width: v.value,
    left: h.value
  }), C = () => {
    a.value && (t.sliderSize = a.value[`client${e.vertical ? "Height" : "Width"}`]);
  }, g = (R) => {
    const H = e.min + R * (e.max - e.min) / 100;
    if (!e.range)
      return r;
    let K;
    return Math.abs(d.value - H) < Math.abs(f.value - H) ? K = t.firstValue < t.secondValue ? "firstButton" : "secondButton" : K = t.firstValue > t.secondValue ? "firstButton" : "secondButton", s[K];
  }, w = (R) => {
    const H = g(R);
    return H.value.setPosition(R), H;
  }, b = (R) => {
    t.firstValue = R, E(e.range ? [d.value, f.value] : R);
  }, y = (R) => {
    t.secondValue = R, e.range && E([d.value, f.value]);
  }, E = (R) => {
    n(Jt, R), n(kl, R);
  }, S = async () => {
    await xe(), n(qn, e.range ? [d.value, f.value] : e.modelValue);
  }, _ = (R) => {
    var H, K, U, W, A, $;
    if (u.value || t.dragging)
      return;
    C();
    let D = 0;
    if (e.vertical) {
      const O = (U = (K = (H = R.touches) == null ? void 0 : H.item(0)) == null ? void 0 : K.clientY) != null ? U : R.clientY;
      D = (a.value.getBoundingClientRect().bottom - O) / t.sliderSize * 100;
    } else {
      const O = ($ = (A = (W = R.touches) == null ? void 0 : W.item(0)) == null ? void 0 : A.clientX) != null ? $ : R.clientX, F = a.value.getBoundingClientRect().left;
      D = (O - F) / t.sliderSize * 100;
    }
    if (!(D < 0 || D > 100))
      return w(D);
  };
  return {
    elFormItem: l,
    slider: a,
    firstButton: r,
    secondButton: i,
    sliderDisabled: u,
    minValue: d,
    maxValue: f,
    runwayStyle: m,
    barStyle: p,
    resetSize: C,
    setPosition: w,
    emitChange: S,
    onSliderWrapperPrevent: (R) => {
      var H, K;
      ((H = s.firstButton.value) != null && H.dragging || (K = s.secondButton.value) != null && K.dragging) && R.preventDefault();
    },
    onSliderClick: (R) => {
      _(R) && S();
    },
    onSliderDown: async (R) => {
      const H = _(R);
      H && (await xe(), H.value.onButtonDown(R));
    },
    setFirstValue: b,
    setSecondValue: y
  };
}, { left: qJ, down: YJ, right: GJ, up: XJ, home: ZJ, end: JJ, pageUp: QJ, pageDown: eQ } = xt, tQ = (e, t, n) => {
  const o = B(), l = B(!1), a = x(() => t.value instanceof Function), r = x(() => a.value && t.value(e.modelValue) || e.modelValue), i = Hl(() => {
    n.value && (l.value = !0);
  }, 50), s = Hl(() => {
    n.value && (l.value = !1);
  }, 50);
  return {
    tooltip: o,
    tooltipVisible: l,
    formatValue: r,
    displayTooltip: i,
    hideTooltip: s
  };
}, nQ = (e, t, n) => {
  const {
    disabled: o,
    min: l,
    max: a,
    step: r,
    showTooltip: i,
    precision: s,
    sliderSize: u,
    formatTooltip: d,
    emitChange: f,
    resetSize: v,
    updateDragging: h
  } = ot(vO), { tooltip: m, tooltipVisible: p, formatValue: C, displayTooltip: g, hideTooltip: w } = tQ(e, d, i), b = B(), y = x(() => `${(e.modelValue - l.value) / (a.value - l.value) * 100}%`), E = x(() => e.vertical ? { bottom: y.value } : { left: y.value }), S = () => {
    t.hovering = !0, g();
  }, _ = () => {
    t.hovering = !1, t.dragging || w();
  }, k = (Z) => {
    o.value || (Z.preventDefault(), D(Z), window.addEventListener("mousemove", O), window.addEventListener("touchmove", O), window.addEventListener("mouseup", F), window.addEventListener("touchend", F), window.addEventListener("contextmenu", F), b.value.focus());
  }, N = (Z) => {
    o.value || (t.newPosition = Number.parseFloat(y.value) + Z / (a.value - l.value) * 100, j(t.newPosition), f());
  }, L = () => {
    N(-r.value);
  }, R = () => {
    N(r.value);
  }, H = () => {
    N(-r.value * 4);
  }, K = () => {
    N(r.value * 4);
  }, U = () => {
    o.value || (j(0), f());
  }, W = () => {
    o.value || (j(100), f());
  }, A = (Z) => {
    let te = !0;
    [qJ, YJ].includes(Z.key) ? L() : [GJ, XJ].includes(Z.key) ? R() : Z.key === ZJ ? U() : Z.key === JJ ? W() : Z.key === eQ ? H() : Z.key === QJ ? K() : te = !1, te && Z.preventDefault();
  }, $ = (Z) => {
    let te, de;
    return Z.type.startsWith("touch") ? (de = Z.touches[0].clientY, te = Z.touches[0].clientX) : (de = Z.clientY, te = Z.clientX), {
      clientX: te,
      clientY: de
    };
  }, D = (Z) => {
    t.dragging = !0, t.isClick = !0;
    const { clientX: te, clientY: de } = $(Z);
    e.vertical ? t.startY = de : t.startX = te, t.startPosition = Number.parseFloat(y.value), t.newPosition = t.startPosition;
  }, O = (Z) => {
    if (t.dragging) {
      t.isClick = !1, g(), v();
      let te;
      const { clientX: de, clientY: Oe } = $(Z);
      e.vertical ? (t.currentY = Oe, te = (t.startY - t.currentY) / u.value * 100) : (t.currentX = de, te = (t.currentX - t.startX) / u.value * 100), t.newPosition = t.startPosition + te, j(t.newPosition);
    }
  }, F = () => {
    t.dragging && (setTimeout(() => {
      t.dragging = !1, t.hovering || w(), t.isClick || j(t.newPosition), f();
    }, 0), window.removeEventListener("mousemove", O), window.removeEventListener("touchmove", O), window.removeEventListener("mouseup", F), window.removeEventListener("touchend", F), window.removeEventListener("contextmenu", F));
  }, j = async (Z) => {
    if (Z === null || Number.isNaN(+Z))
      return;
    Z < 0 ? Z = 0 : Z > 100 && (Z = 100);
    const te = 100 / ((a.value - l.value) / r.value);
    let Oe = Math.round(Z / te) * te * (a.value - l.value) * 0.01 + l.value;
    Oe = Number.parseFloat(Oe.toFixed(s.value)), Oe !== e.modelValue && n(Jt, Oe), !t.dragging && e.modelValue !== t.oldValue && (t.oldValue = e.modelValue), await xe(), t.dragging && g(), m.value.updatePopper();
  };
  return Pe(() => t.dragging, (Z) => {
    h(Z);
  }), {
    disabled: o,
    button: b,
    tooltip: m,
    tooltipVisible: p,
    showTooltip: i,
    wrapperStyle: E,
    formatValue: C,
    handleMouseEnter: S,
    handleMouseLeave: _,
    onButtonDown: k,
    onKeyDown: A,
    setPosition: j
  };
}, oQ = (e, t, n, o) => ({
  stops: x(() => {
    if (!e.showStops || e.min > e.max)
      return [];
    if (e.step === 0)
      return dn("ElSlider", "step should not be 0."), [];
    const r = (e.max - e.min) / e.step, i = 100 * e.step / (e.max - e.min), s = Array.from({ length: r - 1 }).map((u, d) => (d + 1) * i);
    return e.range ? s.filter((u) => u < 100 * (n.value - e.min) / (e.max - e.min) || u > 100 * (o.value - e.min) / (e.max - e.min)) : s.filter((u) => u > 100 * (t.firstValue - e.min) / (e.max - e.min));
  }),
  getStopStyle: (r) => e.vertical ? { bottom: `${r}%` } : { left: `${r}%` }
}), lQ = (e, t, n, o, l, a) => {
  const r = (u) => {
    l(Jt, u), l(kl, u);
  }, i = () => e.range ? ![n.value, o.value].every((u, d) => u === t.oldValue[d]) : e.modelValue !== t.oldValue, s = () => {
    var u, d;
    e.min > e.max && lo("Slider", "min should not be greater than max.");
    const f = e.modelValue;
    e.range && Array.isArray(f) ? f[1] < e.min ? r([e.min, e.min]) : f[0] > e.max ? r([e.max, e.max]) : f[0] < e.min ? r([e.min, f[1]]) : f[1] > e.max ? r([f[0], e.max]) : (t.firstValue = f[0], t.secondValue = f[1], i() && (e.validateEvent && ((u = a == null ? void 0 : a.validate) == null || u.call(a, "change").catch((v) => dn(v))), t.oldValue = f.slice())) : !e.range && typeof f == "number" && !Number.isNaN(f) && (f < e.min ? r(e.min) : f > e.max ? r(e.max) : (t.firstValue = f, i() && (e.validateEvent && ((d = a == null ? void 0 : a.validate) == null || d.call(a, "change").catch((v) => dn(v))), t.oldValue = f)));
  };
  s(), Pe(() => t.dragging, (u) => {
    u || s();
  }), Pe(() => e.modelValue, (u, d) => {
    t.dragging || Array.isArray(u) && Array.isArray(d) && u.every((f, v) => f === d[v]) && t.firstValue === u[0] && t.secondValue === u[1] || s();
  }, {
    deep: !0
  }), Pe(() => [e.min, e.max], () => {
    s();
  });
}, aQ = it({
  modelValue: {
    type: Number,
    default: 0
  },
  vertical: Boolean,
  tooltipClass: String,
  placement: {
    type: String,
    values: Hi,
    default: "top"
  }
}), rQ = {
  [Jt]: (e) => Ot(e)
}, sQ = ["tabindex"], iQ = Q({
  name: "ElSliderButton"
}), cQ = /* @__PURE__ */ Q({
  ...iQ,
  props: aQ,
  emits: rQ,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = nt("slider"), a = en({
      hovering: !1,
      dragging: !1,
      isClick: !1,
      startX: 0,
      currentX: 0,
      startY: 0,
      currentY: 0,
      startPosition: 0,
      newPosition: 0,
      oldValue: o.modelValue
    }), {
      disabled: r,
      button: i,
      tooltip: s,
      showTooltip: u,
      tooltipVisible: d,
      wrapperStyle: f,
      formatValue: v,
      handleMouseEnter: h,
      handleMouseLeave: m,
      onButtonDown: p,
      onKeyDown: C,
      setPosition: g
    } = nQ(o, a, n), { hovering: w, dragging: b } = Xo(a);
    return t({
      onButtonDown: p,
      onKeyDown: C,
      setPosition: g,
      hovering: w,
      dragging: b
    }), (y, E) => (M(), G("div", {
      ref_key: "button",
      ref: i,
      class: z([c(l).e("button-wrapper"), { hover: c(w), dragging: c(b) }]),
      style: bt(c(f)),
      tabindex: c(r) ? -1 : 0,
      onMouseenter: E[0] || (E[0] = (...S) => c(h) && c(h)(...S)),
      onMouseleave: E[1] || (E[1] = (...S) => c(m) && c(m)(...S)),
      onMousedown: E[2] || (E[2] = (...S) => c(p) && c(p)(...S)),
      onTouchstart: E[3] || (E[3] = (...S) => c(p) && c(p)(...S)),
      onFocus: E[4] || (E[4] = (...S) => c(h) && c(h)(...S)),
      onBlur: E[5] || (E[5] = (...S) => c(m) && c(m)(...S)),
      onKeydown: E[6] || (E[6] = (...S) => c(C) && c(C)(...S))
    }, [
      oe(c(hl), {
        ref_key: "tooltip",
        ref: s,
        visible: c(d),
        placement: y.placement,
        "fallback-placements": ["top", "bottom", "right", "left"],
        "stop-popper-mouse-event": !1,
        "popper-class": y.tooltipClass,
        disabled: !c(u),
        persistent: ""
      }, {
        content: fe(() => [
          X("span", null, Qe(c(v)), 1)
        ]),
        default: fe(() => [
          X("div", {
            class: z([c(l).e("button"), { hover: c(w), dragging: c(b) }])
          }, null, 2)
        ]),
        _: 1
      }, 8, ["visible", "placement", "popper-class", "disabled"])
    ], 46, sQ));
  }
});
var CE = /* @__PURE__ */ ut(cQ, [["__file", "button.vue"]]);
const uQ = it({
  mark: {
    type: Ae([String, Object]),
    default: void 0
  }
});
var dQ = Q({
  name: "ElSliderMarker",
  props: uQ,
  setup(e) {
    const t = nt("slider"), n = x(() => on(e.mark) ? e.mark : e.mark.label), o = x(() => on(e.mark) ? void 0 : e.mark.style);
    return () => V("div", {
      class: t.e("marks-text"),
      style: o.value
    }, n.value);
  }
});
const fQ = ["id", "role", "aria-label", "aria-labelledby"], pQ = { key: 1 }, vQ = Q({
  name: "ElSlider"
}), hQ = /* @__PURE__ */ Q({
  ...vQ,
  props: zJ,
  emits: WJ,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = nt("slider"), { t: a } = bn(), r = en({
      firstValue: 0,
      secondValue: 0,
      oldValue: 0,
      dragging: !1,
      sliderSize: 1
    }), {
      elFormItem: i,
      slider: s,
      firstButton: u,
      secondButton: d,
      sliderDisabled: f,
      minValue: v,
      maxValue: h,
      runwayStyle: m,
      barStyle: p,
      resetSize: C,
      emitChange: g,
      onSliderWrapperPrevent: w,
      onSliderClick: b,
      onSliderDown: y,
      setFirstValue: E,
      setSecondValue: S
    } = jJ(o, r, n), { stops: _, getStopStyle: k } = oQ(o, r, v, h), { inputId: N, isLabeledByFormItem: L } = Wa(o, {
      formItemContext: i
    }), R = Mo(), H = x(() => o.inputSize || R.value), K = x(() => o.label || o.ariaLabel || a("el.slider.defaultLabel", {
      min: o.min,
      max: o.max
    })), U = x(() => o.range ? o.rangeStartLabel || a("el.slider.defaultRangeStartLabel") : K.value), W = x(() => o.formatValueText ? o.formatValueText(Z.value) : `${Z.value}`), A = x(() => o.rangeEndLabel || a("el.slider.defaultRangeEndLabel")), $ = x(() => o.formatValueText ? o.formatValueText(te.value) : `${te.value}`), D = x(() => [
      l.b(),
      l.m(R.value),
      l.is("vertical", o.vertical),
      { [l.m("with-input")]: o.showInput }
    ]), O = UJ(o);
    lQ(o, r, v, h, n, i);
    const F = x(() => {
      const ce = [o.min, o.max, o.step].map((ne) => {
        const Y = `${ne}`.split(".")[1];
        return Y ? Y.length : 0;
      });
      return Math.max.apply(null, ce);
    }), { sliderWrapper: j } = KJ(o, r, C), { firstValue: Z, secondValue: te, sliderSize: de } = Xo(r), Oe = (ce) => {
      r.dragging = ce;
    };
    return Mt(vO, {
      ...Xo(o),
      sliderSize: de,
      disabled: f,
      precision: F,
      emitChange: g,
      resetSize: C,
      updateDragging: Oe
    }), Ho({
      from: "label",
      replacement: "aria-label",
      version: "2.8.0",
      scope: "el-slider",
      ref: "https://element-plus.org/en-US/component/slider.html"
    }, x(() => !!o.label)), t({
      onSliderClick: b
    }), (ce, ne) => {
      var Y, ve;
      return M(), G("div", {
        id: ce.range ? c(N) : void 0,
        ref_key: "sliderWrapper",
        ref: j,
        class: z(c(D)),
        role: ce.range ? "group" : void 0,
        "aria-label": ce.range && !c(L) ? c(K) : void 0,
        "aria-labelledby": ce.range && c(L) ? (Y = c(i)) == null ? void 0 : Y.labelId : void 0,
        onTouchstart: ne[2] || (ne[2] = (...ie) => c(w) && c(w)(...ie)),
        onTouchmove: ne[3] || (ne[3] = (...ie) => c(w) && c(w)(...ie))
      }, [
        X("div", {
          ref_key: "slider",
          ref: s,
          class: z([
            c(l).e("runway"),
            { "show-input": ce.showInput && !ce.range },
            c(l).is("disabled", c(f))
          ]),
          style: bt(c(m)),
          onMousedown: ne[0] || (ne[0] = (...ie) => c(y) && c(y)(...ie)),
          onTouchstart: ne[1] || (ne[1] = (...ie) => c(y) && c(y)(...ie))
        }, [
          X("div", {
            class: z(c(l).e("bar")),
            style: bt(c(p))
          }, null, 6),
          oe(CE, {
            id: ce.range ? void 0 : c(N),
            ref_key: "firstButton",
            ref: u,
            "model-value": c(Z),
            vertical: ce.vertical,
            "tooltip-class": ce.tooltipClass,
            placement: ce.placement,
            role: "slider",
            "aria-label": ce.range || !c(L) ? c(U) : void 0,
            "aria-labelledby": !ce.range && c(L) ? (ve = c(i)) == null ? void 0 : ve.labelId : void 0,
            "aria-valuemin": ce.min,
            "aria-valuemax": ce.range ? c(te) : ce.max,
            "aria-valuenow": c(Z),
            "aria-valuetext": c(W),
            "aria-orientation": ce.vertical ? "vertical" : "horizontal",
            "aria-disabled": c(f),
            "onUpdate:modelValue": c(E)
          }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]),
          ce.range ? (M(), We(CE, {
            key: 0,
            ref_key: "secondButton",
            ref: d,
            "model-value": c(te),
            vertical: ce.vertical,
            "tooltip-class": ce.tooltipClass,
            placement: ce.placement,
            role: "slider",
            "aria-label": c(A),
            "aria-valuemin": c(Z),
            "aria-valuemax": ce.max,
            "aria-valuenow": c(te),
            "aria-valuetext": c($),
            "aria-orientation": ce.vertical ? "vertical" : "horizontal",
            "aria-disabled": c(f),
            "onUpdate:modelValue": c(S)
          }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : _e("v-if", !0),
          ce.showStops ? (M(), G("div", pQ, [
            (M(!0), G(kt, null, ln(c(_), (ie, he) => (M(), G("div", {
              key: he,
              class: z(c(l).e("stop")),
              style: bt(c(k)(ie))
            }, null, 6))), 128))
          ])) : _e("v-if", !0),
          c(O).length > 0 ? (M(), G(kt, { key: 2 }, [
            X("div", null, [
              (M(!0), G(kt, null, ln(c(O), (ie, he) => (M(), G("div", {
                key: he,
                style: bt(c(k)(ie.position)),
                class: z([c(l).e("stop"), c(l).e("marks-stop")])
              }, null, 6))), 128))
            ]),
            X("div", {
              class: z(c(l).e("marks"))
            }, [
              (M(!0), G(kt, null, ln(c(O), (ie, he) => (M(), We(c(dQ), {
                key: he,
                mark: ie.mark,
                style: bt(c(k)(ie.position))
              }, null, 8, ["mark", "style"]))), 128))
            ], 2)
          ], 64)) : _e("v-if", !0)
        ], 38),
        ce.showInput && !ce.range ? (M(), We(c(a0), {
          key: 0,
          ref: "input",
          "model-value": c(Z),
          class: z(c(l).e("input")),
          step: ce.step,
          disabled: c(f),
          controls: ce.showInputControls,
          min: ce.min,
          max: ce.max,
          debounce: ce.debounce,
          size: c(H),
          "onUpdate:modelValue": c(E),
          onChange: c(g)
        }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"])) : _e("v-if", !0)
      ], 42, fQ);
    };
  }
});
var mQ = /* @__PURE__ */ ut(hQ, [["__file", "slider.vue"]]);
const gQ = Yt(mQ), bQ = it({
  prefixCls: {
    type: String
  }
}), wE = Q({
  name: "ElSpaceItem",
  props: bQ,
  setup(e, { slots: t }) {
    const n = nt("space"), o = x(() => `${e.prefixCls || n.b()}__item`);
    return () => V("div", { class: o.value }, Ie(t, "default"));
  }
}), EE = {
  small: 8,
  default: 12,
  large: 16
};
function yQ(e) {
  const t = nt("space"), n = x(() => [t.b(), t.m(e.direction), e.class]), o = B(0), l = B(0), a = x(() => {
    const i = e.wrap || e.fill ? { flexWrap: "wrap" } : {}, s = {
      alignItems: e.alignment
    }, u = {
      rowGap: `${l.value}px`,
      columnGap: `${o.value}px`
    };
    return [i, s, u, e.style];
  }), r = x(() => e.fill ? { flexGrow: 1, minWidth: `${e.fillRatio}%` } : {});
  return ol(() => {
    const { size: i = "small", wrap: s, direction: u, fill: d } = e;
    if (Kt(i)) {
      const [f = 0, v = 0] = i;
      o.value = f, l.value = v;
    } else {
      let f;
      Ot(i) ? f = i : f = EE[i || "small"] || EE.small, (s || d) && u === "horizontal" ? o.value = l.value = f : u === "horizontal" ? (o.value = f, l.value = 0) : (l.value = f, o.value = 0);
    }
  }), {
    classes: n,
    containerStyle: a,
    itemStyle: r
  };
}
const CQ = it({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  class: {
    type: Ae([
      String,
      Object,
      Array
    ]),
    default: ""
  },
  style: {
    type: Ae([String, Array, Object]),
    default: ""
  },
  alignment: {
    type: Ae(String),
    default: "center"
  },
  prefixCls: {
    type: String
  },
  spacer: {
    type: Ae([Object, String, Number, Array]),
    default: null,
    validator: (e) => yo(e) || Ot(e) || on(e)
  },
  wrap: Boolean,
  fill: Boolean,
  fillRatio: {
    type: Number,
    default: 100
  },
  size: {
    type: [String, Array, Number],
    values: fr,
    validator: (e) => Ot(e) || Kt(e) && e.length === 2 && e.every(Ot)
  }
}), wQ = Q({
  name: "ElSpace",
  props: CQ,
  setup(e, { slots: t }) {
    const { classes: n, containerStyle: o, itemStyle: l } = yQ(e);
    function a(r, i = "", s = []) {
      const { prefixCls: u } = e;
      return r.forEach((d, f) => {
        ig(d) ? Kt(d.children) && d.children.forEach((v, h) => {
          ig(v) && Kt(v.children) ? a(v.children, `${i + h}-`, s) : s.push(oe(wE, {
            style: l.value,
            prefixCls: u,
            key: `nested-${i + h}`
          }, {
            default: () => [v]
          }, fa.PROPS | fa.STYLE, ["style", "prefixCls"]));
        }) : dV(d) && s.push(oe(wE, {
          style: l.value,
          prefixCls: u,
          key: `LoopKey${i + f}`
        }, {
          default: () => [d]
        }, fa.PROPS | fa.STYLE, ["style", "prefixCls"]));
      }), s;
    }
    return () => {
      var r;
      const { spacer: i, direction: s } = e, u = Ie(t, "default", { key: 0 }, () => []);
      if (((r = u.children) != null ? r : []).length === 0)
        return null;
      if (Kt(u.children)) {
        let d = a(u.children);
        if (i) {
          const f = d.length - 1;
          d = d.reduce((v, h, m) => {
            const p = [...v, h];
            return m !== f && p.push(oe("span", {
              style: [
                l.value,
                s === "vertical" ? "width: 100%" : null
              ],
              key: m
            }, [
              yo(i) ? i : Ut(i, fa.TEXT)
            ], fa.STYLE)), p;
          }, []);
        }
        return oe("div", {
          class: n.value,
          style: o.value
        }, d, fa.STYLE | fa.CLASS);
      }
      return u.children;
    };
  }
}), EQ = Yt(wQ), SQ = it({
  decimalSeparator: {
    type: String,
    default: "."
  },
  groupSeparator: {
    type: String,
    default: ","
  },
  precision: {
    type: Number,
    default: 0
  },
  formatter: Function,
  value: {
    type: Ae([Number, Object]),
    default: 0
  },
  prefix: String,
  suffix: String,
  title: String,
  valueStyle: {
    type: Ae([String, Object, Array])
  }
}), _Q = Q({
  name: "ElStatistic"
}), xQ = /* @__PURE__ */ Q({
  ..._Q,
  props: SQ,
  setup(e, { expose: t }) {
    const n = e, o = nt("statistic"), l = x(() => {
      const { value: a, formatter: r, precision: i, decimalSeparator: s, groupSeparator: u } = n;
      if (vn(r))
        return r(a);
      if (!Ot(a))
        return a;
      let [d, f = ""] = String(a).split(".");
      return f = f.padEnd(i, "0").slice(0, i > 0 ? i : 0), d = d.replace(/\B(?=(\d{3})+(?!\d))/g, u), [d, f].join(f ? s : "");
    });
    return t({
      displayValue: l
    }), (a, r) => (M(), G("div", {
      class: z(c(o).b())
    }, [
      a.$slots.title || a.title ? (M(), G("div", {
        key: 0,
        class: z(c(o).e("head"))
      }, [
        Ie(a.$slots, "title", {}, () => [
          Ut(Qe(a.title), 1)
        ])
      ], 2)) : _e("v-if", !0),
      X("div", {
        class: z(c(o).e("content"))
      }, [
        a.$slots.prefix || a.prefix ? (M(), G("div", {
          key: 0,
          class: z(c(o).e("prefix"))
        }, [
          Ie(a.$slots, "prefix", {}, () => [
            X("span", null, Qe(a.prefix), 1)
          ])
        ], 2)) : _e("v-if", !0),
        X("span", {
          class: z(c(o).e("number")),
          style: bt(a.valueStyle)
        }, Qe(c(l)), 7),
        a.$slots.suffix || a.suffix ? (M(), G("div", {
          key: 1,
          class: z(c(o).e("suffix"))
        }, [
          Ie(a.$slots, "suffix", {}, () => [
            X("span", null, Qe(a.suffix), 1)
          ])
        ], 2)) : _e("v-if", !0)
      ], 2)
    ], 2));
  }
});
var kQ = /* @__PURE__ */ ut(xQ, [["__file", "statistic.vue"]]);
const hO = Yt(kQ), TQ = it({
  format: {
    type: String,
    default: "HH:mm:ss"
  },
  prefix: String,
  suffix: String,
  title: String,
  value: {
    type: Ae([Number, Object]),
    default: 0
  },
  valueStyle: {
    type: Ae([String, Object, Array])
  }
}), $Q = {
  finish: () => !0,
  [qn]: (e) => Ot(e)
}, OQ = [
  ["Y", 1e3 * 60 * 60 * 24 * 365],
  ["M", 1e3 * 60 * 60 * 24 * 30],
  ["D", 1e3 * 60 * 60 * 24],
  ["H", 1e3 * 60 * 60],
  ["m", 1e3 * 60],
  ["s", 1e3],
  ["S", 1]
], SE = (e) => Ot(e) ? new Date(e).getTime() : e.valueOf(), _E = (e, t) => {
  let n = e;
  const o = /\[([^\]]*)]/g;
  return OQ.reduce((a, [r, i]) => {
    const s = new RegExp(`${r}+(?![^\\[\\]]*\\])`, "g");
    if (s.test(a)) {
      const u = Math.floor(n / i);
      return n -= u * i, a.replace(s, (d) => String(u).padStart(d.length, "0"));
    }
    return a;
  }, t).replace(o, "$1");
}, NQ = Q({
  name: "ElCountdown"
}), MQ = /* @__PURE__ */ Q({
  ...NQ,
  props: TQ,
  emits: $Q,
  setup(e, { expose: t, emit: n }) {
    const o = e;
    let l;
    const a = B(SE(o.value) - Date.now()), r = x(() => _E(a.value, o.format)), i = (d) => _E(d, o.format), s = () => {
      l && (Oi(l), l = void 0);
    }, u = () => {
      const d = SE(o.value), f = () => {
        let v = d - Date.now();
        n("change", v), v <= 0 ? (v = 0, s(), n("finish")) : l = xs(f), a.value = v;
      };
      l = xs(f);
    };
    return Pe(() => [o.value, o.format], () => {
      s(), u();
    }, {
      immediate: !0
    }), zn(() => {
      s();
    }), t({
      displayValue: r
    }), (d, f) => (M(), We(c(hO), {
      value: a.value,
      title: d.title,
      prefix: d.prefix,
      suffix: d.suffix,
      "value-style": d.valueStyle,
      formatter: i
    }, rl({ _: 2 }, [
      ln(d.$slots, (v, h) => ({
        name: h,
        fn: fe(() => [
          Ie(d.$slots, h)
        ])
      }))
    ]), 1032, ["value", "title", "prefix", "suffix", "value-style"]));
  }
});
var IQ = /* @__PURE__ */ ut(MQ, [["__file", "countdown.vue"]]);
const RQ = Yt(IQ), DQ = it({
  space: {
    type: [Number, String],
    default: ""
  },
  active: {
    type: Number,
    default: 0
  },
  direction: {
    type: String,
    default: "horizontal",
    values: ["horizontal", "vertical"]
  },
  alignCenter: {
    type: Boolean
  },
  simple: {
    type: Boolean
  },
  finishStatus: {
    type: String,
    values: ["wait", "process", "finish", "error", "success"],
    default: "finish"
  },
  processStatus: {
    type: String,
    values: ["wait", "process", "finish", "error", "success"],
    default: "process"
  }
}), LQ = {
  [qn]: (e, t) => [e, t].every(Ot)
}, PQ = Q({
  name: "ElSteps"
}), AQ = /* @__PURE__ */ Q({
  ...PQ,
  props: DQ,
  emits: LQ,
  setup(e, { emit: t }) {
    const n = e, o = nt("steps"), {
      children: l,
      addChild: a,
      removeChild: r
    } = Ly(Pt(), "ElStep");
    return Pe(l, () => {
      l.value.forEach((i, s) => {
        i.setIndex(s);
      });
    }), Mt("ElSteps", { props: n, steps: l, addStep: a, removeStep: r }), Pe(() => n.active, (i, s) => {
      t(qn, i, s);
    }), (i, s) => (M(), G("div", {
      class: z([c(o).b(), c(o).m(i.simple ? "simple" : i.direction)])
    }, [
      Ie(i.$slots, "default")
    ], 2));
  }
});
var FQ = /* @__PURE__ */ ut(AQ, [["__file", "steps.vue"]]);
const VQ = it({
  title: {
    type: String,
    default: ""
  },
  icon: {
    type: Dn
  },
  description: {
    type: String,
    default: ""
  },
  status: {
    type: String,
    values: ["", "wait", "process", "finish", "error", "success"],
    default: ""
  }
}), BQ = Q({
  name: "ElStep"
}), HQ = Q({
  ...BQ,
  props: VQ,
  setup(e) {
    const t = e, n = nt("step"), o = B(-1), l = B({}), a = B(""), r = ot("ElSteps"), i = Pt();
    Nt(() => {
      Pe([
        () => r.props.active,
        () => r.props.processStatus,
        () => r.props.finishStatus
      ], ([S]) => {
        y(S);
      }, { immediate: !0 });
    }), zn(() => {
      r.removeStep(E.uid);
    });
    const s = x(() => t.status || a.value), u = x(() => {
      const S = r.steps.value[o.value - 1];
      return S ? S.currentStatus : "wait";
    }), d = x(() => r.props.alignCenter), f = x(() => r.props.direction === "vertical"), v = x(() => r.props.simple), h = x(() => r.steps.value.length), m = x(() => {
      var S;
      return ((S = r.steps.value[h.value - 1]) == null ? void 0 : S.uid) === (i == null ? void 0 : i.uid);
    }), p = x(() => v.value ? "" : r.props.space), C = x(() => [
      n.b(),
      n.is(v.value ? "simple" : r.props.direction),
      n.is("flex", m.value && !p.value && !d.value),
      n.is("center", d.value && !f.value && !v.value)
    ]), g = x(() => {
      const S = {
        flexBasis: Ot(p.value) ? `${p.value}px` : p.value ? p.value : `${100 / (h.value - (d.value ? 0 : 1))}%`
      };
      return f.value || m.value && (S.maxWidth = `${100 / h.value}%`), S;
    }), w = (S) => {
      o.value = S;
    }, b = (S) => {
      const _ = S === "wait", k = {
        transitionDelay: `${_ ? "-" : ""}${150 * o.value}ms`
      }, N = S === r.props.processStatus || _ ? 0 : 100;
      k.borderWidth = N && !v.value ? "1px" : 0, k[r.props.direction === "vertical" ? "height" : "width"] = `${N}%`, l.value = k;
    }, y = (S) => {
      S > o.value ? a.value = r.props.finishStatus : S === o.value && u.value !== "error" ? a.value = r.props.processStatus : a.value = "wait";
      const _ = r.steps.value[o.value - 1];
      _ && _.calcProgress(a.value);
    }, E = en({
      uid: i.uid,
      currentStatus: s,
      setIndex: w,
      calcProgress: b
    });
    return r.addStep(E), (S, _) => (M(), G("div", {
      style: bt(c(g)),
      class: z(c(C))
    }, [
      _e(" icon & line "),
      X("div", {
        class: z([c(n).e("head"), c(n).is(c(s))])
      }, [
        c(v) ? _e("v-if", !0) : (M(), G("div", {
          key: 0,
          class: z(c(n).e("line"))
        }, [
          X("i", {
            class: z(c(n).e("line-inner")),
            style: bt(l.value)
          }, null, 6)
        ], 2)),
        X("div", {
          class: z([c(n).e("icon"), c(n).is(S.icon || S.$slots.icon ? "icon" : "text")])
        }, [
          Ie(S.$slots, "icon", {}, () => [
            S.icon ? (M(), We(c(Ct), {
              key: 0,
              class: z(c(n).e("icon-inner"))
            }, {
              default: fe(() => [
                (M(), We(Qt(S.icon)))
              ]),
              _: 1
            }, 8, ["class"])) : c(s) === "success" ? (M(), We(c(Ct), {
              key: 1,
              class: z([c(n).e("icon-inner"), c(n).is("status")])
            }, {
              default: fe(() => [
                oe(c(lf))
              ]),
              _: 1
            }, 8, ["class"])) : c(s) === "error" ? (M(), We(c(Ct), {
              key: 2,
              class: z([c(n).e("icon-inner"), c(n).is("status")])
            }, {
              default: fe(() => [
                oe(c(Fa))
              ]),
              _: 1
            }, 8, ["class"])) : c(v) ? _e("v-if", !0) : (M(), G("div", {
              key: 3,
              class: z(c(n).e("icon-inner"))
            }, Qe(o.value + 1), 3))
          ])
        ], 2)
      ], 2),
      _e(" title & description "),
      X("div", {
        class: z(c(n).e("main"))
      }, [
        X("div", {
          class: z([c(n).e("title"), c(n).is(c(s))])
        }, [
          Ie(S.$slots, "title", {}, () => [
            Ut(Qe(S.title), 1)
          ])
        ], 2),
        c(v) ? (M(), G("div", {
          key: 0,
          class: z(c(n).e("arrow"))
        }, null, 2)) : (M(), G("div", {
          key: 1,
          class: z([c(n).e("description"), c(n).is(c(s))])
        }, [
          Ie(S.$slots, "description", {}, () => [
            Ut(Qe(S.description), 1)
          ])
        ], 2))
      ], 2)
    ], 6));
  }
});
var mO = /* @__PURE__ */ ut(HQ, [["__file", "item.vue"]]);
const gO = Yt(FQ, {
  Step: mO
}), bO = Jn(mO), zQ = it({
  modelValue: {
    type: [Boolean, String, Number],
    default: !1
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  loading: {
    type: Boolean,
    default: !1
  },
  size: {
    type: String,
    validator: tk
  },
  width: {
    type: [String, Number],
    default: ""
  },
  inlinePrompt: {
    type: Boolean,
    default: !1
  },
  inactiveActionIcon: {
    type: Dn
  },
  activeActionIcon: {
    type: Dn
  },
  activeIcon: {
    type: Dn
  },
  inactiveIcon: {
    type: Dn
  },
  activeText: {
    type: String,
    default: ""
  },
  inactiveText: {
    type: String,
    default: ""
  },
  activeValue: {
    type: [Boolean, String, Number],
    default: !0
  },
  inactiveValue: {
    type: [Boolean, String, Number],
    default: !1
  },
  name: {
    type: String,
    default: ""
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  beforeChange: {
    type: Ae(Function)
  },
  id: String,
  tabindex: {
    type: [String, Number]
  },
  label: {
    type: String,
    default: void 0
  },
  ...Zo(["ariaLabel"])
}), WQ = {
  [Jt]: (e) => $o(e) || on(e) || Ot(e),
  [qn]: (e) => $o(e) || on(e) || Ot(e),
  [kl]: (e) => $o(e) || on(e) || Ot(e)
}, KQ = ["onClick"], UQ = ["id", "aria-checked", "aria-disabled", "aria-label", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"], jQ = ["aria-hidden"], qQ = ["aria-hidden"], YQ = ["aria-hidden"], Zg = "ElSwitch", GQ = Q({
  name: Zg
}), XQ = /* @__PURE__ */ Q({
  ...GQ,
  props: zQ,
  emits: WQ,
  setup(e, { expose: t, emit: n }) {
    const o = e, { formItem: l } = ml(), a = Mo(), r = nt("switch"), { inputId: i } = Wa(o, {
      formItemContext: l
    }), s = Nl(x(() => o.loading)), u = B(o.modelValue !== !1), d = B(), f = B(), v = x(() => [
      r.b(),
      r.m(a.value),
      r.is("disabled", s.value),
      r.is("checked", g.value)
    ]), h = x(() => [
      r.e("label"),
      r.em("label", "left"),
      r.is("active", !g.value)
    ]), m = x(() => [
      r.e("label"),
      r.em("label", "right"),
      r.is("active", g.value)
    ]), p = x(() => ({
      width: po(o.width)
    }));
    Pe(() => o.modelValue, () => {
      u.value = !0;
    });
    const C = x(() => u.value ? o.modelValue : !1), g = x(() => C.value === o.activeValue);
    [o.activeValue, o.inactiveValue].includes(C.value) || (n(Jt, o.inactiveValue), n(qn, o.inactiveValue), n(kl, o.inactiveValue)), Pe(g, (E) => {
      var S;
      d.value.checked = E, o.validateEvent && ((S = l == null ? void 0 : l.validate) == null || S.call(l, "change").catch((_) => dn(_)));
    });
    const w = () => {
      const E = g.value ? o.inactiveValue : o.activeValue;
      n(Jt, E), n(qn, E), n(kl, E), xe(() => {
        d.value.checked = g.value;
      });
    }, b = () => {
      if (s.value)
        return;
      const { beforeChange: E } = o;
      if (!E) {
        w();
        return;
      }
      const S = E();
      [
        eg(S),
        $o(S)
      ].includes(!0) || lo(Zg, "beforeChange must return type `Promise<boolean>` or `boolean`"), eg(S) ? S.then((k) => {
        k && w();
      }).catch((k) => {
        dn(Zg, `some error occurred: ${k}`);
      }) : S && w();
    }, y = () => {
      var E, S;
      (S = (E = d.value) == null ? void 0 : E.focus) == null || S.call(E);
    };
    return Nt(() => {
      d.value.checked = g.value;
    }), Ho({
      from: "label",
      replacement: "aria-label",
      version: "2.8.0",
      scope: "el-switch",
      ref: "https://element-plus.org/en-US/component/switch.html"
    }, x(() => !!o.label)), t({
      focus: y,
      checked: g
    }), (E, S) => (M(), G("div", {
      class: z(c(v)),
      onClick: It(b, ["prevent"])
    }, [
      X("input", {
        id: c(i),
        ref_key: "input",
        ref: d,
        class: z(c(r).e("input")),
        type: "checkbox",
        role: "switch",
        "aria-checked": c(g),
        "aria-disabled": c(s),
        "aria-label": E.label || E.ariaLabel,
        name: E.name,
        "true-value": E.activeValue,
        "false-value": E.inactiveValue,
        disabled: c(s),
        tabindex: E.tabindex,
        onChange: w,
        onKeydown: Rn(b, ["enter"])
      }, null, 42, UQ),
      !E.inlinePrompt && (E.inactiveIcon || E.inactiveText) ? (M(), G("span", {
        key: 0,
        class: z(c(h))
      }, [
        E.inactiveIcon ? (M(), We(c(Ct), { key: 0 }, {
          default: fe(() => [
            (M(), We(Qt(E.inactiveIcon)))
          ]),
          _: 1
        })) : _e("v-if", !0),
        !E.inactiveIcon && E.inactiveText ? (M(), G("span", {
          key: 1,
          "aria-hidden": c(g)
        }, Qe(E.inactiveText), 9, jQ)) : _e("v-if", !0)
      ], 2)) : _e("v-if", !0),
      X("span", {
        ref_key: "core",
        ref: f,
        class: z(c(r).e("core")),
        style: bt(c(p))
      }, [
        E.inlinePrompt ? (M(), G("div", {
          key: 0,
          class: z(c(r).e("inner"))
        }, [
          E.activeIcon || E.inactiveIcon ? (M(), We(c(Ct), {
            key: 0,
            class: z(c(r).is("icon"))
          }, {
            default: fe(() => [
              (M(), We(Qt(c(g) ? E.activeIcon : E.inactiveIcon)))
            ]),
            _: 1
          }, 8, ["class"])) : E.activeText || E.inactiveText ? (M(), G("span", {
            key: 1,
            class: z(c(r).is("text")),
            "aria-hidden": !c(g)
          }, Qe(c(g) ? E.activeText : E.inactiveText), 11, qQ)) : _e("v-if", !0)
        ], 2)) : _e("v-if", !0),
        X("div", {
          class: z(c(r).e("action"))
        }, [
          E.loading ? (M(), We(c(Ct), {
            key: 0,
            class: z(c(r).is("loading"))
          }, {
            default: fe(() => [
              oe(c(Ps))
            ]),
            _: 1
          }, 8, ["class"])) : c(g) ? Ie(E.$slots, "active-action", { key: 1 }, () => [
            E.activeActionIcon ? (M(), We(c(Ct), { key: 0 }, {
              default: fe(() => [
                (M(), We(Qt(E.activeActionIcon)))
              ]),
              _: 1
            })) : _e("v-if", !0)
          ]) : c(g) ? _e("v-if", !0) : Ie(E.$slots, "inactive-action", { key: 2 }, () => [
            E.inactiveActionIcon ? (M(), We(c(Ct), { key: 0 }, {
              default: fe(() => [
                (M(), We(Qt(E.inactiveActionIcon)))
              ]),
              _: 1
            })) : _e("v-if", !0)
          ])
        ], 2)
      ], 6),
      !E.inlinePrompt && (E.activeIcon || E.activeText) ? (M(), G("span", {
        key: 1,
        class: z(c(m))
      }, [
        E.activeIcon ? (M(), We(c(Ct), { key: 0 }, {
          default: fe(() => [
            (M(), We(Qt(E.activeIcon)))
          ]),
          _: 1
        })) : _e("v-if", !0),
        !E.activeIcon && E.activeText ? (M(), G("span", {
          key: 1,
          "aria-hidden": !c(g)
        }, Qe(E.activeText), 9, YQ)) : _e("v-if", !0)
      ], 2)) : _e("v-if", !0)
    ], 10, KQ));
  }
});
var ZQ = /* @__PURE__ */ ut(XQ, [["__file", "switch.vue"]]);
const yO = Yt(ZQ), um = function(e) {
  var t;
  return (t = e.target) == null ? void 0 : t.closest("td");
}, JQ = function(e, t, n, o, l) {
  if (!t && !o && (!l || Array.isArray(l) && !l.length))
    return e;
  typeof n == "string" ? n = n === "descending" ? -1 : 1 : n = n && n < 0 ? -1 : 1;
  const a = o ? null : function(i, s) {
    return l ? (Array.isArray(l) || (l = [l]), l.map((u) => typeof u == "string" ? bo(i, u) : u(i, s, e))) : (t !== "$key" && Mn(i) && "$value" in i && (i = i.$value), [Mn(i) ? bo(i, t) : i]);
  }, r = function(i, s) {
    if (o)
      return o(i.value, s.value);
    for (let u = 0, d = i.key.length; u < d; u++) {
      if (i.key[u] < s.key[u])
        return -1;
      if (i.key[u] > s.key[u])
        return 1;
    }
    return 0;
  };
  return e.map((i, s) => ({
    value: i,
    index: s,
    key: a ? a(i, s) : null
  })).sort((i, s) => {
    let u = r(i, s);
    return u || (u = i.index - s.index), u * +n;
  }).map((i) => i.value);
}, CO = function(e, t) {
  let n = null;
  return e.columns.forEach((o) => {
    o.id === t && (n = o);
  }), n;
}, QQ = function(e, t) {
  let n = null;
  for (let o = 0; o < e.columns.length; o++) {
    const l = e.columns[o];
    if (l.columnKey === t) {
      n = l;
      break;
    }
  }
  return n || lo("ElTable", `No column matching with column-key: ${t}`), n;
}, xE = function(e, t, n) {
  const o = (t.className || "").match(new RegExp(`${n}-table_[^\\s]+`, "gm"));
  return o ? CO(e, o[0]) : null;
}, tl = (e, t) => {
  if (!e)
    throw new Error("Row is required when get row identity");
  if (typeof t == "string") {
    if (!t.includes("."))
      return `${e[t]}`;
    const n = t.split(".");
    let o = e;
    for (const l of n)
      o = o[l];
    return `${o}`;
  } else if (typeof t == "function")
    return t.call(null, e);
}, ui = function(e, t) {
  const n = {};
  return (e || []).forEach((o, l) => {
    n[tl(o, t)] = { row: o, index: l };
  }), n;
};
function eee(e, t) {
  const n = {};
  let o;
  for (o in e)
    n[o] = e[o];
  for (o in t)
    if (sl(t, o)) {
      const l = t[o];
      typeof l < "u" && (n[o] = l);
    }
  return n;
}
function v0(e) {
  return e === "" || e !== void 0 && (e = Number.parseInt(e, 10), Number.isNaN(e) && (e = "")), e;
}
function wO(e) {
  return e === "" || e !== void 0 && (e = v0(e), Number.isNaN(e) && (e = 80)), e;
}
function tee(e) {
  return typeof e == "number" ? e : typeof e == "string" ? /^\d+(?:px)?$/.test(e) ? Number.parseInt(e, 10) : e : null;
}
function nee(...e) {
  return e.length === 0 ? (t) => t : e.length === 1 ? e[0] : e.reduce((t, n) => (...o) => t(n(...o)));
}
function ed(e, t, n) {
  let o = !1;
  const l = e.indexOf(t), a = l !== -1, r = (i) => {
    i === "add" ? e.push(t) : e.splice(l, 1), o = !0, Kt(t.children) && t.children.forEach((s) => {
      ed(e, s, n ?? !a);
    });
  };
  return $o(n) ? n && !a ? r("add") : !n && a && r("remove") : r(a ? "remove" : "add"), o;
}
function oee(e, t, n = "children", o = "hasChildren") {
  const l = (r) => !(Array.isArray(r) && r.length);
  function a(r, i, s) {
    t(r, i, s), i.forEach((u) => {
      if (u[o]) {
        t(u, null, s + 1);
        return;
      }
      const d = u[n];
      l(d) || a(u, d, s + 1);
    });
  }
  e.forEach((r) => {
    if (r[o]) {
      t(r, null, 0);
      return;
    }
    const i = r[n];
    l(i) || a(r, i, 0);
  });
}
let ua = null;
function lee(e, t, n, o) {
  if ((ua == null ? void 0 : ua.trigger) === n)
    return;
  ua == null || ua();
  const l = o == null ? void 0 : o.refs.tableWrapper, a = l == null ? void 0 : l.dataset.prefix, r = {
    strategy: "fixed",
    ...e.popperOptions
  }, i = oe(hl, {
    content: t,
    virtualTriggering: !0,
    virtualRef: n,
    appendTo: l,
    placement: "top",
    transition: "none",
    offset: 0,
    hideAfter: 0,
    ...e,
    popperOptions: r,
    onHide: () => {
      ua == null || ua();
    }
  });
  i.appContext = { ...o.appContext, ...o };
  const s = document.createElement("div");
  Es(i, s), i.component.exposed.onOpen();
  const u = l == null ? void 0 : l.querySelector(`.${a}-scrollbar__wrap`);
  ua = () => {
    Es(null, s), u == null || u.removeEventListener("scroll", ua), ua = null;
  }, ua.trigger = n, u == null || u.addEventListener("scroll", ua);
}
function EO(e) {
  return e.children ? TF(e.children, EO) : [e];
}
function kE(e, t) {
  return e + t.colSpan;
}
const SO = (e, t, n, o) => {
  let l = 0, a = e;
  const r = n.states.columns.value;
  if (o) {
    const s = EO(o[e]);
    l = r.slice(0, r.indexOf(s[0])).reduce(kE, 0), a = l + s.reduce(kE, 0) - 1;
  } else
    l = e;
  let i;
  switch (t) {
    case "left":
      a < n.states.fixedLeafColumnsLength.value && (i = "left");
      break;
    case "right":
      l >= r.length - n.states.rightFixedLeafColumnsLength.value && (i = "right");
      break;
    default:
      a < n.states.fixedLeafColumnsLength.value ? i = "left" : l >= r.length - n.states.rightFixedLeafColumnsLength.value && (i = "right");
  }
  return i ? {
    direction: i,
    start: l,
    after: a
  } : {};
}, h0 = (e, t, n, o, l, a = 0) => {
  const r = [], { direction: i, start: s, after: u } = SO(t, n, o, l);
  if (i) {
    const d = i === "left";
    r.push(`${e}-fixed-column--${i}`), d && u + a === o.states.fixedLeafColumnsLength.value - 1 ? r.push("is-last-column") : !d && s - a === o.states.columns.value.length - o.states.rightFixedLeafColumnsLength.value && r.push("is-first-column");
  }
  return r;
};
function TE(e, t) {
  return e + (t.realWidth === null || Number.isNaN(t.realWidth) ? Number(t.width) : t.realWidth);
}
const m0 = (e, t, n, o) => {
  const {
    direction: l,
    start: a = 0,
    after: r = 0
  } = SO(e, t, n, o);
  if (!l)
    return;
  const i = {}, s = l === "left", u = n.states.columns.value;
  return s ? i.left = u.slice(0, a).reduce(TE, 0) : i.right = u.slice(r + 1).reverse().reduce(TE, 0), i;
}, qc = (e, t) => {
  e && (Number.isNaN(e[t]) || (e[t] = `${e[t]}px`));
};
function aee(e) {
  const t = Pt(), n = B(!1), o = B([]);
  return {
    updateExpandRows: () => {
      const s = e.data.value || [], u = e.rowKey.value;
      if (n.value)
        o.value = s.slice();
      else if (u) {
        const d = ui(o.value, u);
        o.value = s.reduce((f, v) => {
          const h = tl(v, u);
          return d[h] && f.push(v), f;
        }, []);
      } else
        o.value = [];
    },
    toggleRowExpansion: (s, u) => {
      ed(o.value, s, u) && t.emit("expand-change", s, o.value.slice());
    },
    setExpandRowKeys: (s) => {
      t.store.assertRowKey();
      const u = e.data.value || [], d = e.rowKey.value, f = ui(u, d);
      o.value = s.reduce((v, h) => {
        const m = f[h];
        return m && v.push(m.row), v;
      }, []);
    },
    isRowExpanded: (s) => {
      const u = e.rowKey.value;
      return u ? !!ui(o.value, u)[tl(s, u)] : o.value.includes(s);
    },
    states: {
      expandRows: o,
      defaultExpandAll: n
    }
  };
}
function ree(e) {
  const t = Pt(), n = B(null), o = B(null), l = (u) => {
    t.store.assertRowKey(), n.value = u, r(u);
  }, a = () => {
    n.value = null;
  }, r = (u) => {
    const { data: d, rowKey: f } = e;
    let v = null;
    f.value && (v = (c(d) || []).find((h) => tl(h, f.value) === u)), o.value = v, t.emit("current-change", o.value, null);
  };
  return {
    setCurrentRowKey: l,
    restoreCurrentRowKey: a,
    setCurrentRowByKey: r,
    updateCurrentRow: (u) => {
      const d = o.value;
      if (u && u !== d) {
        o.value = u, t.emit("current-change", o.value, d);
        return;
      }
      !u && d && (o.value = null, t.emit("current-change", null, d));
    },
    updateCurrentRowData: () => {
      const u = e.rowKey.value, d = e.data.value || [], f = o.value;
      if (!d.includes(f) && f) {
        if (u) {
          const v = tl(f, u);
          r(v);
        } else
          o.value = null;
        o.value === null && t.emit("current-change", null, f);
      } else
        n.value && (r(n.value), a());
    },
    states: {
      _currentRowKey: n,
      currentRow: o
    }
  };
}
function see(e) {
  const t = B([]), n = B({}), o = B(16), l = B(!1), a = B({}), r = B("hasChildren"), i = B("children"), s = Pt(), u = x(() => {
    if (!e.rowKey.value)
      return {};
    const g = e.data.value || [];
    return f(g);
  }), d = x(() => {
    const g = e.rowKey.value, w = Object.keys(a.value), b = {};
    return w.length && w.forEach((y) => {
      if (a.value[y].length) {
        const E = { children: [] };
        a.value[y].forEach((S) => {
          const _ = tl(S, g);
          E.children.push(_), S[r.value] && !b[_] && (b[_] = { children: [] });
        }), b[y] = E;
      }
    }), b;
  }), f = (g) => {
    const w = e.rowKey.value, b = {};
    return oee(g, (y, E, S) => {
      const _ = tl(y, w);
      Array.isArray(E) ? b[_] = {
        children: E.map((k) => tl(k, w)),
        level: S
      } : l.value && (b[_] = {
        children: [],
        lazy: !0,
        level: S
      });
    }, i.value, r.value), b;
  }, v = (g = !1, w = ((b) => (b = s.store) == null ? void 0 : b.states.defaultExpandAll.value)()) => {
    var b;
    const y = u.value, E = d.value, S = Object.keys(y), _ = {};
    if (S.length) {
      const k = c(n), N = [], L = (H, K) => {
        if (g)
          return t.value ? w || t.value.includes(K) : !!(w || H != null && H.expanded);
        {
          const U = w || t.value && t.value.includes(K);
          return !!(H != null && H.expanded || U);
        }
      };
      S.forEach((H) => {
        const K = k[H], U = { ...y[H] };
        if (U.expanded = L(K, H), U.lazy) {
          const { loaded: W = !1, loading: A = !1 } = K || {};
          U.loaded = !!W, U.loading = !!A, N.push(H);
        }
        _[H] = U;
      });
      const R = Object.keys(E);
      l.value && R.length && N.length && R.forEach((H) => {
        const K = k[H], U = E[H].children;
        if (N.includes(H)) {
          if (_[H].children.length !== 0)
            throw new Error("[ElTable]children must be an empty array.");
          _[H].children = U;
        } else {
          const { loaded: W = !1, loading: A = !1 } = K || {};
          _[H] = {
            lazy: !0,
            loaded: !!W,
            loading: !!A,
            expanded: L(K, H),
            children: U,
            level: ""
          };
        }
      });
    }
    n.value = _, (b = s.store) == null || b.updateTableScrollY();
  };
  Pe(() => t.value, () => {
    v(!0);
  }), Pe(() => u.value, () => {
    v();
  }), Pe(() => d.value, () => {
    v();
  });
  const h = (g) => {
    t.value = g, v();
  }, m = (g, w) => {
    s.store.assertRowKey();
    const b = e.rowKey.value, y = tl(g, b), E = y && n.value[y];
    if (y && E && "expanded" in E) {
      const S = E.expanded;
      w = typeof w > "u" ? !E.expanded : w, n.value[y].expanded = w, S !== w && s.emit("expand-change", g, w), s.store.updateTableScrollY();
    }
  }, p = (g) => {
    s.store.assertRowKey();
    const w = e.rowKey.value, b = tl(g, w), y = n.value[b];
    l.value && y && "loaded" in y && !y.loaded ? C(g, b, y) : m(g, void 0);
  }, C = (g, w, b) => {
    const { load: y } = s.props;
    y && !n.value[w].loaded && (n.value[w].loading = !0, y(g, b, (E) => {
      if (!Array.isArray(E))
        throw new TypeError("[ElTable] data must be an array");
      n.value[w].loading = !1, n.value[w].loaded = !0, n.value[w].expanded = !0, E.length && (a.value[w] = E), s.emit("expand-change", g, !0);
    }));
  };
  return {
    loadData: C,
    loadOrToggle: p,
    toggleTreeExpansion: m,
    updateTreeExpandKeys: h,
    updateTreeData: v,
    normalize: f,
    states: {
      expandRowKeys: t,
      treeData: n,
      indent: o,
      lazy: l,
      lazyTreeNodeMap: a,
      lazyColumnIdentifier: r,
      childrenColumnName: i
    }
  };
}
const iee = (e, t) => {
  const n = t.sortingColumn;
  return !n || typeof n.sortable == "string" ? e : JQ(e, t.sortProp, t.sortOrder, n.sortMethod, n.sortBy);
}, Np = (e) => {
  const t = [];
  return e.forEach((n) => {
    n.children && n.children.length > 0 ? t.push.apply(t, Np(n.children)) : t.push(n);
  }), t;
};
function cee() {
  var e;
  const t = Pt(), { size: n } = Xo((e = t.proxy) == null ? void 0 : e.$props), o = B(null), l = B([]), a = B([]), r = B(!1), i = B([]), s = B([]), u = B([]), d = B([]), f = B([]), v = B([]), h = B([]), m = B([]), p = [], C = B(0), g = B(0), w = B(0), b = B(!1), y = B([]), E = B(!1), S = B(!1), _ = B(null), k = B({}), N = B(null), L = B(null), R = B(null), H = B(null), K = B(null);
  Pe(l, () => t.state && $(!1), {
    deep: !0
  });
  const U = () => {
    if (!o.value)
      throw new Error("[ElTable] prop row-key is required");
  }, W = (Ee) => {
    var me;
    (me = Ee.children) == null || me.forEach((Ke) => {
      Ke.fixed = Ee.fixed, W(Ke);
    });
  }, A = () => {
    i.value.forEach((we) => {
      W(we);
    }), d.value = i.value.filter((we) => we.fixed === !0 || we.fixed === "left"), f.value = i.value.filter((we) => we.fixed === "right"), d.value.length > 0 && i.value[0] && i.value[0].type === "selection" && !i.value[0].fixed && (i.value[0].fixed = !0, d.value.unshift(i.value[0]));
    const Ee = i.value.filter((we) => !we.fixed);
    s.value = [].concat(d.value).concat(Ee).concat(f.value);
    const me = Np(Ee), Ke = Np(d.value), Re = Np(f.value);
    C.value = me.length, g.value = Ke.length, w.value = Re.length, u.value = [].concat(Ke).concat(me).concat(Re), r.value = d.value.length > 0 || f.value.length > 0;
  }, $ = (Ee, me = !1) => {
    Ee && A(), me ? t.state.doLayout() : t.state.debouncedUpdateLayout();
  }, D = (Ee) => y.value.includes(Ee), O = () => {
    b.value = !1;
    const Ee = y.value;
    y.value = [], Ee.length && t.emit("selection-change", []);
  }, F = () => {
    let Ee;
    if (o.value) {
      Ee = [];
      const me = ui(y.value, o.value), Ke = ui(l.value, o.value);
      for (const Re in me)
        sl(me, Re) && !Ke[Re] && Ee.push(me[Re].row);
    } else
      Ee = y.value.filter((me) => !l.value.includes(me));
    if (Ee.length) {
      const me = y.value.filter((Ke) => !Ee.includes(Ke));
      y.value = me, t.emit("selection-change", me.slice());
    }
  }, j = () => (y.value || []).slice(), Z = (Ee, me = void 0, Ke = !0) => {
    if (ed(y.value, Ee, me)) {
      const we = (y.value || []).slice();
      Ke && t.emit("select", we, Ee), t.emit("selection-change", we);
    }
  }, te = () => {
    var Ee, me;
    const Ke = S.value ? !b.value : !(b.value || y.value.length);
    b.value = Ke;
    let Re = !1, we = 0;
    const ze = (me = (Ee = t == null ? void 0 : t.store) == null ? void 0 : Ee.states) == null ? void 0 : me.rowKey.value;
    l.value.forEach((Je, Me) => {
      const et = Me + we;
      _.value ? _.value.call(null, Je, et) && ed(y.value, Je, Ke) && (Re = !0) : ed(y.value, Je, Ke) && (Re = !0), we += ce(tl(Je, ze));
    }), Re && t.emit("selection-change", y.value ? y.value.slice() : []), t.emit("select-all", (y.value || []).slice());
  }, de = () => {
    const Ee = ui(y.value, o.value);
    l.value.forEach((me) => {
      const Ke = tl(me, o.value), Re = Ee[Ke];
      Re && (y.value[Re.index] = me);
    });
  }, Oe = () => {
    var Ee, me, Ke;
    if (((Ee = l.value) == null ? void 0 : Ee.length) === 0) {
      b.value = !1;
      return;
    }
    let Re;
    o.value && (Re = ui(y.value, o.value));
    const we = function(et) {
      return Re ? !!Re[tl(et, o.value)] : y.value.includes(et);
    };
    let ze = !0, Je = 0, Me = 0;
    for (let et = 0, mt = (l.value || []).length; et < mt; et++) {
      const Lt = (Ke = (me = t == null ? void 0 : t.store) == null ? void 0 : me.states) == null ? void 0 : Ke.rowKey.value, be = et + Me, an = l.value[et], _t = _.value && _.value.call(null, an, be);
      if (we(an))
        Je++;
      else if (!_.value || _t) {
        ze = !1;
        break;
      }
      Me += ce(tl(an, Lt));
    }
    Je === 0 && (ze = !1), b.value = ze;
  }, ce = (Ee) => {
    var me;
    if (!t || !t.store)
      return 0;
    const { treeData: Ke } = t.store.states;
    let Re = 0;
    const we = (me = Ke.value[Ee]) == null ? void 0 : me.children;
    return we && (Re += we.length, we.forEach((ze) => {
      Re += ce(ze);
    })), Re;
  }, ne = (Ee, me) => {
    Array.isArray(Ee) || (Ee = [Ee]);
    const Ke = {};
    return Ee.forEach((Re) => {
      k.value[Re.id] = me, Ke[Re.columnKey || Re.id] = me;
    }), Ke;
  }, Y = (Ee, me, Ke) => {
    L.value && L.value !== Ee && (L.value.order = null), L.value = Ee, R.value = me, H.value = Ke;
  }, ve = () => {
    let Ee = c(a);
    Object.keys(k.value).forEach((me) => {
      const Ke = k.value[me];
      if (!Ke || Ke.length === 0)
        return;
      const Re = CO({
        columns: u.value
      }, me);
      Re && Re.filterMethod && (Ee = Ee.filter((we) => Ke.some((ze) => Re.filterMethod.call(null, ze, we, Re))));
    }), N.value = Ee;
  }, ie = () => {
    l.value = iee(N.value, {
      sortingColumn: L.value,
      sortProp: R.value,
      sortOrder: H.value
    });
  }, he = (Ee = void 0) => {
    Ee && Ee.filter || ve(), ie();
  }, De = (Ee) => {
    const { tableHeaderRef: me } = t.refs;
    if (!me)
      return;
    const Ke = Object.assign({}, me.filterPanels), Re = Object.keys(Ke);
    if (Re.length)
      if (typeof Ee == "string" && (Ee = [Ee]), Array.isArray(Ee)) {
        const we = Ee.map((ze) => QQ({
          columns: u.value
        }, ze));
        Re.forEach((ze) => {
          const Je = we.find((Me) => Me.id === ze);
          Je && (Je.filteredValue = []);
        }), t.store.commit("filterChange", {
          column: we,
          values: [],
          silent: !0,
          multi: !0
        });
      } else
        Re.forEach((we) => {
          const ze = u.value.find((Je) => Je.id === we);
          ze && (ze.filteredValue = []);
        }), k.value = {}, t.store.commit("filterChange", {
          column: {},
          values: [],
          silent: !0
        });
  }, $e = () => {
    L.value && (Y(null, null, null), t.store.commit("changeSortCondition", {
      silent: !0
    }));
  }, {
    setExpandRowKeys: ue,
    toggleRowExpansion: Ne,
    updateExpandRows: je,
    states: Fe,
    isRowExpanded: Ve
  } = aee({
    data: l,
    rowKey: o
  }), {
    updateTreeExpandKeys: Ze,
    toggleTreeExpansion: ae,
    updateTreeData: pe,
    loadOrToggle: ke,
    states: Ue
  } = see({
    data: l,
    rowKey: o
  }), {
    updateCurrentRowData: Xe,
    updateCurrentRow: re,
    setCurrentRowKey: Te,
    states: Ce
  } = ree({
    data: l,
    rowKey: o
  });
  return {
    assertRowKey: U,
    updateColumns: A,
    scheduleLayout: $,
    isSelected: D,
    clearSelection: O,
    cleanSelection: F,
    getSelectionRows: j,
    toggleRowSelection: Z,
    _toggleAllSelection: te,
    toggleAllSelection: null,
    updateSelectionByRowKey: de,
    updateAllSelected: Oe,
    updateFilters: ne,
    updateCurrentRow: re,
    updateSort: Y,
    execFilter: ve,
    execSort: ie,
    execQuery: he,
    clearFilter: De,
    clearSort: $e,
    toggleRowExpansion: Ne,
    setExpandRowKeysAdapter: (Ee) => {
      ue(Ee), Ze(Ee);
    },
    setCurrentRowKey: Te,
    toggleRowExpansionAdapter: (Ee, me) => {
      u.value.some(({ type: Re }) => Re === "expand") ? Ne(Ee, me) : ae(Ee, me);
    },
    isRowExpanded: Ve,
    updateExpandRows: je,
    updateCurrentRowData: Xe,
    loadOrToggle: ke,
    updateTreeData: pe,
    states: {
      tableSize: n,
      rowKey: o,
      data: l,
      _data: a,
      isComplex: r,
      _columns: i,
      originColumns: s,
      columns: u,
      fixedColumns: d,
      rightFixedColumns: f,
      leafColumns: v,
      fixedLeafColumns: h,
      rightFixedLeafColumns: m,
      updateOrderFns: p,
      leafColumnsLength: C,
      fixedLeafColumnsLength: g,
      rightFixedLeafColumnsLength: w,
      isAllSelected: b,
      selection: y,
      reserveSelection: E,
      selectOnIndeterminate: S,
      selectable: _,
      filters: k,
      filteredData: N,
      sortingColumn: L,
      sortProp: R,
      sortOrder: H,
      hoverRow: K,
      ...Fe,
      ...Ue,
      ...Ce
    }
  };
}
function Jg(e, t) {
  return e.map((n) => {
    var o;
    return n.id === t.id ? t : ((o = n.children) != null && o.length && (n.children = Jg(n.children, t)), n);
  });
}
function Qg(e) {
  e.forEach((t) => {
    var n, o;
    t.no = (n = t.getColumnIndex) == null ? void 0 : n.call(t), (o = t.children) != null && o.length && Qg(t.children);
  }), e.sort((t, n) => t.no - n.no);
}
function uee() {
  const e = Pt(), t = cee();
  return {
    ns: nt("table"),
    ...t,
    mutations: {
      setData(r, i) {
        const s = c(r._data) !== i;
        r.data.value = i, r._data.value = i, e.store.execQuery(), e.store.updateCurrentRowData(), e.store.updateExpandRows(), e.store.updateTreeData(e.store.states.defaultExpandAll.value), c(r.reserveSelection) ? (e.store.assertRowKey(), e.store.updateSelectionByRowKey()) : s ? e.store.clearSelection() : e.store.cleanSelection(), e.store.updateAllSelected(), e.$ready && e.store.scheduleLayout();
      },
      insertColumn(r, i, s, u) {
        const d = c(r._columns);
        let f = [];
        s ? (s && !s.children && (s.children = []), s.children.push(i), f = Jg(d, s)) : (d.push(i), f = d), Qg(f), r._columns.value = f, r.updateOrderFns.push(u), i.type === "selection" && (r.selectable.value = i.selectable, r.reserveSelection.value = i.reserveSelection), e.$ready && (e.store.updateColumns(), e.store.scheduleLayout());
      },
      updateColumnOrder(r, i) {
        var s;
        ((s = i.getColumnIndex) == null ? void 0 : s.call(i)) !== i.no && (Qg(r._columns.value), e.$ready && e.store.updateColumns());
      },
      removeColumn(r, i, s, u) {
        const d = c(r._columns) || [];
        if (s)
          s.children.splice(s.children.findIndex((v) => v.id === i.id), 1), xe(() => {
            var v;
            ((v = s.children) == null ? void 0 : v.length) === 0 && delete s.children;
          }), r._columns.value = Jg(d, s);
        else {
          const v = d.indexOf(i);
          v > -1 && (d.splice(v, 1), r._columns.value = d);
        }
        const f = r.updateOrderFns.indexOf(u);
        f > -1 && r.updateOrderFns.splice(f, 1), e.$ready && (e.store.updateColumns(), e.store.scheduleLayout());
      },
      sort(r, i) {
        const { prop: s, order: u, init: d } = i;
        if (s) {
          const f = c(r.columns).find((v) => v.property === s);
          f && (f.order = u, e.store.updateSort(f, s, u), e.store.commit("changeSortCondition", { init: d }));
        }
      },
      changeSortCondition(r, i) {
        const { sortingColumn: s, sortProp: u, sortOrder: d } = r, f = c(s), v = c(u), h = c(d);
        h === null && (r.sortingColumn.value = null, r.sortProp.value = null);
        const m = { filter: !0 };
        e.store.execQuery(m), (!i || !(i.silent || i.init)) && e.emit("sort-change", {
          column: f,
          prop: v,
          order: h
        }), e.store.updateTableScrollY();
      },
      filterChange(r, i) {
        const { column: s, values: u, silent: d } = i, f = e.store.updateFilters(s, u);
        e.store.execQuery(), d || e.emit("filter-change", f), e.store.updateTableScrollY();
      },
      toggleAllSelection() {
        e.store.toggleAllSelection();
      },
      rowSelectedChanged(r, i) {
        e.store.toggleRowSelection(i), e.store.updateAllSelected();
      },
      setHoverRow(r, i) {
        r.hoverRow.value = i;
      },
      setCurrentRow(r, i) {
        e.store.updateCurrentRow(i);
      }
    },
    commit: function(r, ...i) {
      const s = e.store.mutations;
      if (s[r])
        s[r].apply(e, [e.store.states].concat(i));
      else
        throw new Error(`Action not found: ${r}`);
    },
    updateTableScrollY: function() {
      xe(() => e.layout.updateScrollY.apply(e.layout));
    }
  };
}
const td = {
  rowKey: "rowKey",
  defaultExpandAll: "defaultExpandAll",
  selectOnIndeterminate: "selectOnIndeterminate",
  indent: "indent",
  lazy: "lazy",
  data: "data",
  "treeProps.hasChildren": {
    key: "lazyColumnIdentifier",
    default: "hasChildren"
  },
  "treeProps.children": {
    key: "childrenColumnName",
    default: "children"
  }
};
function dee(e, t) {
  if (!e)
    throw new Error("Table is required.");
  const n = uee();
  return n.toggleAllSelection = Hl(n._toggleAllSelection, 10), Object.keys(td).forEach((o) => {
    _O(xO(t, o), o, n);
  }), fee(n, t), n;
}
function fee(e, t) {
  Object.keys(td).forEach((n) => {
    Pe(() => xO(t, n), (o) => {
      _O(o, n, e);
    });
  });
}
function _O(e, t, n) {
  let o = e, l = td[t];
  typeof td[t] == "object" && (l = l.key, o = o || td[t].default), n.states[l].value = o;
}
function xO(e, t) {
  if (t.includes(".")) {
    const n = t.split(".");
    let o = e;
    return n.forEach((l) => {
      o = o[l];
    }), o;
  } else
    return e[t];
}
class pee {
  constructor(t) {
    this.observers = [], this.table = null, this.store = null, this.columns = [], this.fit = !0, this.showHeader = !0, this.height = B(null), this.scrollX = B(!1), this.scrollY = B(!1), this.bodyWidth = B(null), this.fixedWidth = B(null), this.rightFixedWidth = B(null), this.gutterWidth = 0;
    for (const n in t)
      sl(t, n) && (fl(this[n]) ? this[n].value = t[n] : this[n] = t[n]);
    if (!this.table)
      throw new Error("Table is required for Table Layout");
    if (!this.store)
      throw new Error("Store is required for Table Layout");
  }
  updateScrollY() {
    if (this.height.value === null)
      return !1;
    const n = this.table.refs.scrollBarRef;
    if (this.table.vnode.el && (n != null && n.wrapRef)) {
      let o = !0;
      const l = this.scrollY.value;
      return o = n.wrapRef.scrollHeight > n.wrapRef.clientHeight, this.scrollY.value = o, l !== o;
    }
    return !1;
  }
  setHeight(t, n = "height") {
    if (!fn)
      return;
    const o = this.table.vnode.el;
    if (t = tee(t), this.height.value = Number(t), !o && (t || t === 0))
      return xe(() => this.setHeight(t, n));
    typeof t == "number" ? (o.style[n] = `${t}px`, this.updateElsHeight()) : typeof t == "string" && (o.style[n] = t, this.updateElsHeight());
  }
  setMaxHeight(t) {
    this.setHeight(t, "max-height");
  }
  getFlattenColumns() {
    const t = [];
    return this.table.store.states.columns.value.forEach((o) => {
      o.isColumnGroup ? t.push.apply(t, o.columns) : t.push(o);
    }), t;
  }
  updateElsHeight() {
    this.updateScrollY(), this.notifyObservers("scrollable");
  }
  headerDisplayNone(t) {
    if (!t)
      return !0;
    let n = t;
    for (; n.tagName !== "DIV"; ) {
      if (getComputedStyle(n).display === "none")
        return !0;
      n = n.parentElement;
    }
    return !1;
  }
  updateColumnsWidth() {
    if (!fn)
      return;
    const t = this.fit, n = this.table.vnode.el.clientWidth;
    let o = 0;
    const l = this.getFlattenColumns(), a = l.filter((s) => typeof s.width != "number");
    if (l.forEach((s) => {
      typeof s.width == "number" && s.realWidth && (s.realWidth = null);
    }), a.length > 0 && t) {
      if (l.forEach((s) => {
        o += Number(s.width || s.minWidth || 80);
      }), o <= n) {
        this.scrollX.value = !1;
        const s = n - o;
        if (a.length === 1)
          a[0].realWidth = Number(a[0].minWidth || 80) + s;
        else {
          const u = a.reduce((v, h) => v + Number(h.minWidth || 80), 0), d = s / u;
          let f = 0;
          a.forEach((v, h) => {
            if (h === 0)
              return;
            const m = Math.floor(Number(v.minWidth || 80) * d);
            f += m, v.realWidth = Number(v.minWidth || 80) + m;
          }), a[0].realWidth = Number(a[0].minWidth || 80) + s - f;
        }
      } else
        this.scrollX.value = !0, a.forEach((s) => {
          s.realWidth = Number(s.minWidth);
        });
      this.bodyWidth.value = Math.max(o, n), this.table.state.resizeState.value.width = this.bodyWidth.value;
    } else
      l.forEach((s) => {
        !s.width && !s.minWidth ? s.realWidth = 80 : s.realWidth = Number(s.width || s.minWidth), o += s.realWidth;
      }), this.scrollX.value = o > n, this.bodyWidth.value = o;
    const r = this.store.states.fixedColumns.value;
    if (r.length > 0) {
      let s = 0;
      r.forEach((u) => {
        s += Number(u.realWidth || u.width);
      }), this.fixedWidth.value = s;
    }
    const i = this.store.states.rightFixedColumns.value;
    if (i.length > 0) {
      let s = 0;
      i.forEach((u) => {
        s += Number(u.realWidth || u.width);
      }), this.rightFixedWidth.value = s;
    }
    this.notifyObservers("columns");
  }
  addObserver(t) {
    this.observers.push(t);
  }
  removeObserver(t) {
    const n = this.observers.indexOf(t);
    n !== -1 && this.observers.splice(n, 1);
  }
  notifyObservers(t) {
    this.observers.forEach((o) => {
      var l, a;
      switch (t) {
        case "columns":
          (l = o.state) == null || l.onColumnsChange(this);
          break;
        case "scrollable":
          (a = o.state) == null || a.onScrollableChange(this);
          break;
        default:
          throw new Error(`Table Layout don't have event ${t}.`);
      }
    });
  }
}
const { CheckboxGroup: vee } = ta, hee = Q({
  name: "ElTableFilterPanel",
  components: {
    ElCheckbox: ta,
    ElCheckboxGroup: vee,
    ElScrollbar: zr,
    ElTooltip: hl,
    ElIcon: Ct,
    ArrowDown: Br,
    ArrowUp: iy
  },
  directives: { ClickOutside: Pr },
  props: {
    placement: {
      type: String,
      default: "bottom-start"
    },
    store: {
      type: Object
    },
    column: {
      type: Object
    },
    upDataColumn: {
      type: Function
    }
  },
  setup(e) {
    const t = Pt(), { t: n } = bn(), o = nt("table-filter"), l = t == null ? void 0 : t.parent;
    l.filterPanels.value[e.column.id] || (l.filterPanels.value[e.column.id] = t);
    const a = B(!1), r = B(null), i = x(() => e.column && e.column.filters), s = x(() => e.column.filterClassName ? `${o.b()} ${e.column.filterClassName}` : o.b()), u = x({
      get: () => {
        var E;
        return (((E = e.column) == null ? void 0 : E.filteredValue) || [])[0];
      },
      set: (E) => {
        d.value && (typeof E < "u" && E !== null ? d.value.splice(0, 1, E) : d.value.splice(0, 1));
      }
    }), d = x({
      get() {
        return e.column ? e.column.filteredValue || [] : [];
      },
      set(E) {
        e.column && e.upDataColumn("filteredValue", E);
      }
    }), f = x(() => e.column ? e.column.filterMultiple : !0), v = (E) => E.value === u.value, h = () => {
      a.value = !1;
    }, m = (E) => {
      E.stopPropagation(), a.value = !a.value;
    }, p = () => {
      a.value = !1;
    }, C = () => {
      b(d.value), h();
    }, g = () => {
      d.value = [], b(d.value), h();
    }, w = (E) => {
      u.value = E, b(typeof E < "u" && E !== null ? d.value : []), h();
    }, b = (E) => {
      e.store.commit("filterChange", {
        column: e.column,
        values: E
      }), e.store.updateAllSelected();
    };
    Pe(a, (E) => {
      e.column && e.upDataColumn("filterOpened", E);
    }, {
      immediate: !0
    });
    const y = x(() => {
      var E, S;
      return (S = (E = r.value) == null ? void 0 : E.popperRef) == null ? void 0 : S.contentRef;
    });
    return {
      tooltipVisible: a,
      multiple: f,
      filterClassName: s,
      filteredValue: d,
      filterValue: u,
      filters: i,
      handleConfirm: C,
      handleReset: g,
      handleSelect: w,
      isActive: v,
      t: n,
      ns: o,
      showFilterPanel: m,
      hideFilterPanel: p,
      popperPaneRef: y,
      tooltip: r
    };
  }
}), mee = { key: 0 }, gee = ["disabled"], bee = ["label", "onClick"];
function yee(e, t, n, o, l, a) {
  const r = Dt("el-checkbox"), i = Dt("el-checkbox-group"), s = Dt("el-scrollbar"), u = Dt("arrow-up"), d = Dt("arrow-down"), f = Dt("el-icon"), v = Dt("el-tooltip"), h = _v("click-outside");
  return M(), We(v, {
    ref: "tooltip",
    visible: e.tooltipVisible,
    offset: 0,
    placement: e.placement,
    "show-arrow": !1,
    "stop-popper-mouse-event": !1,
    teleported: "",
    effect: "light",
    pure: "",
    "popper-class": e.filterClassName,
    persistent: ""
  }, {
    content: fe(() => [
      e.multiple ? (M(), G("div", mee, [
        X("div", {
          class: z(e.ns.e("content"))
        }, [
          oe(s, {
            "wrap-class": e.ns.e("wrap")
          }, {
            default: fe(() => [
              oe(i, {
                modelValue: e.filteredValue,
                "onUpdate:modelValue": t[0] || (t[0] = (m) => e.filteredValue = m),
                class: z(e.ns.e("checkbox-group"))
              }, {
                default: fe(() => [
                  (M(!0), G(kt, null, ln(e.filters, (m) => (M(), We(r, {
                    key: m.value,
                    value: m.value
                  }, {
                    default: fe(() => [
                      Ut(Qe(m.text), 1)
                    ]),
                    _: 2
                  }, 1032, ["value"]))), 128))
                ]),
                _: 1
              }, 8, ["modelValue", "class"])
            ]),
            _: 1
          }, 8, ["wrap-class"])
        ], 2),
        X("div", {
          class: z(e.ns.e("bottom"))
        }, [
          X("button", {
            class: z({ [e.ns.is("disabled")]: e.filteredValue.length === 0 }),
            disabled: e.filteredValue.length === 0,
            type: "button",
            onClick: t[1] || (t[1] = (...m) => e.handleConfirm && e.handleConfirm(...m))
          }, Qe(e.t("el.table.confirmFilter")), 11, gee),
          X("button", {
            type: "button",
            onClick: t[2] || (t[2] = (...m) => e.handleReset && e.handleReset(...m))
          }, Qe(e.t("el.table.resetFilter")), 1)
        ], 2)
      ])) : (M(), G("ul", {
        key: 1,
        class: z(e.ns.e("list"))
      }, [
        X("li", {
          class: z([
            e.ns.e("list-item"),
            {
              [e.ns.is("active")]: e.filterValue === void 0 || e.filterValue === null
            }
          ]),
          onClick: t[3] || (t[3] = (m) => e.handleSelect(null))
        }, Qe(e.t("el.table.clearFilter")), 3),
        (M(!0), G(kt, null, ln(e.filters, (m) => (M(), G("li", {
          key: m.value,
          class: z([e.ns.e("list-item"), e.ns.is("active", e.isActive(m))]),
          label: m.value,
          onClick: (p) => e.handleSelect(m.value)
        }, Qe(m.text), 11, bee))), 128))
      ], 2))
    ]),
    default: fe(() => [
      Bt((M(), G("span", {
        class: z([
          `${e.ns.namespace.value}-table__column-filter-trigger`,
          `${e.ns.namespace.value}-none-outline`
        ]),
        onClick: t[4] || (t[4] = (...m) => e.showFilterPanel && e.showFilterPanel(...m))
      }, [
        oe(f, null, {
          default: fe(() => [
            e.column.filterOpened ? (M(), We(u, { key: 0 })) : (M(), We(d, { key: 1 }))
          ]),
          _: 1
        })
      ], 2)), [
        [h, e.hideFilterPanel, e.popperPaneRef]
      ])
    ]),
    _: 1
  }, 8, ["visible", "placement", "popper-class"]);
}
var Cee = /* @__PURE__ */ ut(hee, [["render", yee], ["__file", "filter-panel.vue"]]);
function kO(e) {
  const t = Pt();
  Sv(() => {
    n.value.addObserver(t);
  }), Nt(() => {
    o(n.value), l(n.value);
  }), Pi(() => {
    o(n.value), l(n.value);
  }), wo(() => {
    n.value.removeObserver(t);
  });
  const n = x(() => {
    const a = e.layout;
    if (!a)
      throw new Error("Can not find table layout.");
    return a;
  }), o = (a) => {
    var r;
    const i = ((r = e.vnode.el) == null ? void 0 : r.querySelectorAll("colgroup > col")) || [];
    if (!i.length)
      return;
    const s = a.getFlattenColumns(), u = {};
    s.forEach((d) => {
      u[d.id] = d;
    });
    for (let d = 0, f = i.length; d < f; d++) {
      const v = i[d], h = v.getAttribute("name"), m = u[h];
      m && v.setAttribute("width", m.realWidth || m.width);
    }
  }, l = (a) => {
    var r, i;
    const s = ((r = e.vnode.el) == null ? void 0 : r.querySelectorAll("colgroup > col[name=gutter]")) || [];
    for (let d = 0, f = s.length; d < f; d++)
      s[d].setAttribute("width", a.scrollY.value ? a.gutterWidth : "0");
    const u = ((i = e.vnode.el) == null ? void 0 : i.querySelectorAll("th.gutter")) || [];
    for (let d = 0, f = u.length; d < f; d++) {
      const v = u[d];
      v.style.width = a.scrollY.value ? `${a.gutterWidth}px` : "0", v.style.display = a.scrollY.value ? "" : "none";
    }
  };
  return {
    tableLayout: n.value,
    onColumnsChange: o,
    onScrollableChange: l
  };
}
const vr = Symbol("ElTable");
function wee(e, t) {
  const n = Pt(), o = ot(vr), l = (p) => {
    p.stopPropagation();
  }, a = (p, C) => {
    !C.filters && C.sortable ? m(p, C, !1) : C.filterable && !C.sortable && l(p), o == null || o.emit("header-click", C, p);
  }, r = (p, C) => {
    o == null || o.emit("header-contextmenu", C, p);
  }, i = B(null), s = B(!1), u = B({}), d = (p, C) => {
    if (fn && !(C.children && C.children.length > 0) && i.value && e.border) {
      s.value = !0;
      const g = o;
      t("set-drag-visible", !0);
      const b = (g == null ? void 0 : g.vnode.el).getBoundingClientRect().left, y = n.vnode.el.querySelector(`th.${C.id}`), E = y.getBoundingClientRect(), S = E.left - b + 30;
      ma(y, "noclick"), u.value = {
        startMouseLeft: p.clientX,
        startLeft: E.right - b,
        startColumnLeft: E.left - b,
        tableLeft: b
      };
      const _ = g == null ? void 0 : g.refs.resizeProxy;
      _.style.left = `${u.value.startLeft}px`, document.onselectstart = function() {
        return !1;
      }, document.ondragstart = function() {
        return !1;
      };
      const k = (L) => {
        const R = L.clientX - u.value.startMouseLeft, H = u.value.startLeft + R;
        _.style.left = `${Math.max(S, H)}px`;
      }, N = () => {
        if (s.value) {
          const { startColumnLeft: L, startLeft: R } = u.value, K = Number.parseInt(_.style.left, 10) - L;
          C.width = C.realWidth = K, g == null || g.emit("header-dragend", C.width, R - L, C, p), requestAnimationFrame(() => {
            e.store.scheduleLayout(!1, !0);
          }), document.body.style.cursor = "", s.value = !1, i.value = null, u.value = {}, t("set-drag-visible", !1);
        }
        document.removeEventListener("mousemove", k), document.removeEventListener("mouseup", N), document.onselectstart = null, document.ondragstart = null, setTimeout(() => {
          vl(y, "noclick");
        }, 0);
      };
      document.addEventListener("mousemove", k), document.addEventListener("mouseup", N);
    }
  }, f = (p, C) => {
    if (C.children && C.children.length > 0)
      return;
    const g = p.target;
    if (!wa(g))
      return;
    const w = g == null ? void 0 : g.closest("th");
    if (!(!C || !C.resizable) && !s.value && e.border) {
      const b = w.getBoundingClientRect(), y = document.body.style;
      b.width > 12 && b.right - p.pageX < 8 ? (y.cursor = "col-resize", ba(w, "is-sortable") && (w.style.cursor = "col-resize"), i.value = C) : s.value || (y.cursor = "", ba(w, "is-sortable") && (w.style.cursor = "pointer"), i.value = null);
    }
  }, v = () => {
    fn && (document.body.style.cursor = "");
  }, h = ({ order: p, sortOrders: C }) => {
    if (p === "")
      return C[0];
    const g = C.indexOf(p || null);
    return C[g > C.length - 2 ? 0 : g + 1];
  }, m = (p, C, g) => {
    var w;
    p.stopPropagation();
    const b = C.order === g ? null : g || h(C), y = (w = p.target) == null ? void 0 : w.closest("th");
    if (y && ba(y, "noclick")) {
      vl(y, "noclick");
      return;
    }
    if (!C.sortable)
      return;
    const E = e.store.states;
    let S = E.sortProp.value, _;
    const k = E.sortingColumn.value;
    (k !== C || k === C && k.order === null) && (k && (k.order = null), E.sortingColumn.value = C, S = C.property), b ? _ = C.order = b : _ = C.order = null, E.sortProp.value = S, E.sortOrder.value = _, o == null || o.store.commit("changeSortCondition");
  };
  return {
    handleHeaderClick: a,
    handleHeaderContextMenu: r,
    handleMouseDown: d,
    handleMouseMove: f,
    handleMouseOut: v,
    handleSortClick: m,
    handleFilterClick: l
  };
}
function Eee(e) {
  const t = ot(vr), n = nt("table");
  return {
    getHeaderRowStyle: (i) => {
      const s = t == null ? void 0 : t.props.headerRowStyle;
      return typeof s == "function" ? s.call(null, { rowIndex: i }) : s;
    },
    getHeaderRowClass: (i) => {
      const s = [], u = t == null ? void 0 : t.props.headerRowClassName;
      return typeof u == "string" ? s.push(u) : typeof u == "function" && s.push(u.call(null, { rowIndex: i })), s.join(" ");
    },
    getHeaderCellStyle: (i, s, u, d) => {
      var f;
      let v = (f = t == null ? void 0 : t.props.headerCellStyle) != null ? f : {};
      typeof v == "function" && (v = v.call(null, {
        rowIndex: i,
        columnIndex: s,
        row: u,
        column: d
      }));
      const h = m0(s, d.fixed, e.store, u);
      return qc(h, "left"), qc(h, "right"), Object.assign({}, v, h);
    },
    getHeaderCellClass: (i, s, u, d) => {
      const f = h0(n.b(), s, d.fixed, e.store, u), v = [
        d.id,
        d.order,
        d.headerAlign,
        d.className,
        d.labelClassName,
        ...f
      ];
      d.children || v.push("is-leaf"), d.sortable && v.push("is-sortable");
      const h = t == null ? void 0 : t.props.headerCellClassName;
      return typeof h == "string" ? v.push(h) : typeof h == "function" && v.push(h.call(null, {
        rowIndex: i,
        columnIndex: s,
        row: u,
        column: d
      })), v.push(n.e("cell")), v.filter((m) => !!m).join(" ");
    }
  };
}
const TO = (e) => {
  const t = [];
  return e.forEach((n) => {
    n.children ? (t.push(n), t.push.apply(t, TO(n.children))) : t.push(n);
  }), t;
}, See = (e) => {
  let t = 1;
  const n = (a, r) => {
    if (r && (a.level = r.level + 1, t < a.level && (t = a.level)), a.children) {
      let i = 0;
      a.children.forEach((s) => {
        n(s, a), i += s.colSpan;
      }), a.colSpan = i;
    } else
      a.colSpan = 1;
  };
  e.forEach((a) => {
    a.level = 1, n(a, void 0);
  });
  const o = [];
  for (let a = 0; a < t; a++)
    o.push([]);
  return TO(e).forEach((a) => {
    a.children ? (a.rowSpan = 1, a.children.forEach((r) => r.isSubColumn = !0)) : a.rowSpan = t - a.level + 1, o[a.level - 1].push(a);
  }), o;
};
function _ee(e) {
  const t = ot(vr), n = x(() => See(e.store.states.originColumns.value));
  return {
    isGroup: x(() => {
      const a = n.value.length > 1;
      return a && t && (t.state.isGroup.value = !0), a;
    }),
    toggleAllSelection: (a) => {
      a.stopPropagation(), t == null || t.store.commit("toggleAllSelection");
    },
    columnRows: n
  };
}
var xee = Q({
  name: "ElTableHeader",
  components: {
    ElCheckbox: ta
  },
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: !0,
      type: Object
    },
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => ({
        prop: "",
        order: ""
      })
    }
  },
  setup(e, { emit: t }) {
    const n = Pt(), o = ot(vr), l = nt("table"), a = B({}), { onColumnsChange: r, onScrollableChange: i } = kO(o);
    Nt(async () => {
      await xe(), await xe();
      const { prop: S, order: _ } = e.defaultSort;
      o == null || o.store.commit("sort", { prop: S, order: _, init: !0 });
    });
    const {
      handleHeaderClick: s,
      handleHeaderContextMenu: u,
      handleMouseDown: d,
      handleMouseMove: f,
      handleMouseOut: v,
      handleSortClick: h,
      handleFilterClick: m
    } = wee(e, t), {
      getHeaderRowStyle: p,
      getHeaderRowClass: C,
      getHeaderCellStyle: g,
      getHeaderCellClass: w
    } = Eee(e), { isGroup: b, toggleAllSelection: y, columnRows: E } = _ee(e);
    return n.state = {
      onColumnsChange: r,
      onScrollableChange: i
    }, n.filterPanels = a, {
      ns: l,
      filterPanels: a,
      onColumnsChange: r,
      onScrollableChange: i,
      columnRows: E,
      getHeaderRowClass: C,
      getHeaderRowStyle: p,
      getHeaderCellClass: w,
      getHeaderCellStyle: g,
      handleHeaderClick: s,
      handleHeaderContextMenu: u,
      handleMouseDown: d,
      handleMouseMove: f,
      handleMouseOut: v,
      handleSortClick: h,
      handleFilterClick: m,
      isGroup: b,
      toggleAllSelection: y
    };
  },
  render() {
    const {
      ns: e,
      isGroup: t,
      columnRows: n,
      getHeaderCellStyle: o,
      getHeaderCellClass: l,
      getHeaderRowClass: a,
      getHeaderRowStyle: r,
      handleHeaderClick: i,
      handleHeaderContextMenu: s,
      handleMouseDown: u,
      handleMouseMove: d,
      handleSortClick: f,
      handleMouseOut: v,
      store: h,
      $parent: m
    } = this;
    let p = 1;
    return V("thead", {
      class: { [e.is("group")]: t }
    }, n.map((C, g) => V("tr", {
      class: a(g),
      key: g,
      style: r(g)
    }, C.map((w, b) => (w.rowSpan > p && (p = w.rowSpan), V("th", {
      class: l(g, b, C, w),
      colspan: w.colSpan,
      key: `${w.id}-thead`,
      rowspan: w.rowSpan,
      style: o(g, b, C, w),
      onClick: (y) => i(y, w),
      onContextmenu: (y) => s(y, w),
      onMousedown: (y) => u(y, w),
      onMousemove: (y) => d(y, w),
      onMouseout: v
    }, [
      V("div", {
        class: [
          "cell",
          w.filteredValue && w.filteredValue.length > 0 ? "highlight" : ""
        ]
      }, [
        w.renderHeader ? w.renderHeader({
          column: w,
          $index: b,
          store: h,
          _self: m
        }) : w.label,
        w.sortable && V("span", {
          onClick: (y) => f(y, w),
          class: "caret-wrapper"
        }, [
          V("i", {
            onClick: (y) => f(y, w, "ascending"),
            class: "sort-caret ascending"
          }),
          V("i", {
            onClick: (y) => f(y, w, "descending"),
            class: "sort-caret descending"
          })
        ]),
        w.filterable && V(Cee, {
          store: h,
          placement: w.filterPlacement || "bottom-start",
          column: w,
          upDataColumn: (y, E) => {
            w[y] = E;
          }
        })
      ])
    ]))))));
  }
});
function kee(e) {
  const t = ot(vr), n = B(""), o = B(V("div")), l = (m, p, C) => {
    var g;
    const w = t, b = um(m);
    let y;
    const E = (g = w == null ? void 0 : w.vnode.el) == null ? void 0 : g.dataset.prefix;
    b && (y = xE({
      columns: e.store.states.columns.value
    }, b, E), y && (w == null || w.emit(`cell-${C}`, p, y, b, m))), w == null || w.emit(`row-${C}`, p, y, m);
  }, a = (m, p) => {
    l(m, p, "dblclick");
  }, r = (m, p) => {
    e.store.commit("setCurrentRow", p), l(m, p, "click");
  }, i = (m, p) => {
    l(m, p, "contextmenu");
  }, s = Hl((m) => {
    e.store.commit("setHoverRow", m);
  }, 30), u = Hl(() => {
    e.store.commit("setHoverRow", null);
  }, 30), d = (m) => {
    const p = window.getComputedStyle(m, null), C = Number.parseInt(p.paddingLeft, 10) || 0, g = Number.parseInt(p.paddingRight, 10) || 0, w = Number.parseInt(p.paddingTop, 10) || 0, b = Number.parseInt(p.paddingBottom, 10) || 0;
    return {
      left: C,
      right: g,
      top: w,
      bottom: b
    };
  }, f = (m, p, C) => {
    let g = p.target.parentNode;
    for (; m > 1 && (g = g == null ? void 0 : g.nextSibling, !(!g || g.nodeName !== "TR")); )
      C(g, "hover-row hover-fixed-row"), m--;
  };
  return {
    handleDoubleClick: a,
    handleClick: r,
    handleContextMenu: i,
    handleMouseEnter: s,
    handleMouseLeave: u,
    handleCellMouseEnter: (m, p, C) => {
      var g;
      const w = t, b = um(m), y = (g = w == null ? void 0 : w.vnode.el) == null ? void 0 : g.dataset.prefix;
      if (b) {
        const O = xE({
          columns: e.store.states.columns.value
        }, b, y);
        b.rowSpan > 1 && f(b.rowSpan, m, ma);
        const F = w.hoverState = { cell: b, column: O, row: p };
        w == null || w.emit("cell-mouse-enter", F.row, F.column, F.cell, m);
      }
      if (!C)
        return;
      const E = m.target.querySelector(".cell");
      if (!(ba(E, `${y}-tooltip`) && E.childNodes.length))
        return;
      const S = document.createRange();
      S.setStart(E, 0), S.setEnd(E, E.childNodes.length);
      let _ = S.getBoundingClientRect().width, k = S.getBoundingClientRect().height;
      const N = _ - Math.floor(_), { width: L, height: R } = E.getBoundingClientRect();
      N < 1e-3 && (_ = Math.floor(_)), k - Math.floor(k) < 1e-3 && (k = Math.floor(k));
      const { top: K, left: U, right: W, bottom: A } = d(E), $ = U + W, D = K + A;
      (_ + $ > L || k + D > R || E.scrollWidth > L) && lee(C, b.innerText || b.textContent, b, w);
    },
    handleCellMouseLeave: (m) => {
      const p = um(m);
      if (!p)
        return;
      p.rowSpan > 1 && f(p.rowSpan, m, vl);
      const C = t == null ? void 0 : t.hoverState;
      t == null || t.emit("cell-mouse-leave", C == null ? void 0 : C.row, C == null ? void 0 : C.column, C == null ? void 0 : C.cell, m);
    },
    tooltipContent: n,
    tooltipTrigger: o
  };
}
function Tee(e) {
  const t = ot(vr), n = nt("table");
  return {
    getRowStyle: (u, d) => {
      const f = t == null ? void 0 : t.props.rowStyle;
      return typeof f == "function" ? f.call(null, {
        row: u,
        rowIndex: d
      }) : f || null;
    },
    getRowClass: (u, d) => {
      const f = [n.e("row")];
      t != null && t.props.highlightCurrentRow && u === e.store.states.currentRow.value && f.push("current-row"), e.stripe && d % 2 === 1 && f.push(n.em("row", "striped"));
      const v = t == null ? void 0 : t.props.rowClassName;
      return typeof v == "string" ? f.push(v) : typeof v == "function" && f.push(v.call(null, {
        row: u,
        rowIndex: d
      })), f;
    },
    getCellStyle: (u, d, f, v) => {
      const h = t == null ? void 0 : t.props.cellStyle;
      let m = h ?? {};
      typeof h == "function" && (m = h.call(null, {
        rowIndex: u,
        columnIndex: d,
        row: f,
        column: v
      }));
      const p = m0(d, e == null ? void 0 : e.fixed, e.store);
      return qc(p, "left"), qc(p, "right"), Object.assign({}, m, p);
    },
    getCellClass: (u, d, f, v, h) => {
      const m = h0(n.b(), d, e == null ? void 0 : e.fixed, e.store, void 0, h), p = [v.id, v.align, v.className, ...m], C = t == null ? void 0 : t.props.cellClassName;
      return typeof C == "string" ? p.push(C) : typeof C == "function" && p.push(C.call(null, {
        rowIndex: u,
        columnIndex: d,
        row: f,
        column: v
      })), p.push(n.e("cell")), p.filter((g) => !!g).join(" ");
    },
    getSpan: (u, d, f, v) => {
      let h = 1, m = 1;
      const p = t == null ? void 0 : t.props.spanMethod;
      if (typeof p == "function") {
        const C = p({
          row: u,
          column: d,
          rowIndex: f,
          columnIndex: v
        });
        Array.isArray(C) ? (h = C[0], m = C[1]) : typeof C == "object" && (h = C.rowspan, m = C.colspan);
      }
      return { rowspan: h, colspan: m };
    },
    getColspanRealWidth: (u, d, f) => {
      if (d < 1)
        return u[f].realWidth;
      const v = u.map(({ realWidth: h, width: m }) => h || m).slice(f, f + d);
      return Number(v.reduce((h, m) => Number(h) + Number(m), -1));
    }
  };
}
function $ee(e) {
  const t = ot(vr), n = nt("table"), {
    handleDoubleClick: o,
    handleClick: l,
    handleContextMenu: a,
    handleMouseEnter: r,
    handleMouseLeave: i,
    handleCellMouseEnter: s,
    handleCellMouseLeave: u,
    tooltipContent: d,
    tooltipTrigger: f
  } = kee(e), {
    getRowStyle: v,
    getRowClass: h,
    getCellStyle: m,
    getCellClass: p,
    getSpan: C,
    getColspanRealWidth: g
  } = Tee(e), w = x(() => e.store.states.columns.value.findIndex(({ type: _ }) => _ === "default")), b = (_, k) => {
    const N = t.props.rowKey;
    return N ? tl(_, N) : k;
  }, y = (_, k, N, L = !1) => {
    const { tooltipEffect: R, tooltipOptions: H, store: K } = e, { indent: U, columns: W } = K.states, A = h(_, k);
    let $ = !0;
    return N && (A.push(n.em("row", `level-${N.level}`)), $ = N.display), V("tr", {
      style: [$ ? null : {
        display: "none"
      }, v(_, k)],
      class: A,
      key: b(_, k),
      onDblclick: (O) => o(O, _),
      onClick: (O) => l(O, _),
      onContextmenu: (O) => a(O, _),
      onMouseenter: () => r(k),
      onMouseleave: i
    }, W.value.map((O, F) => {
      const { rowspan: j, colspan: Z } = C(_, O, k, F);
      if (!j || !Z)
        return null;
      const te = Object.assign({}, O);
      te.realWidth = g(W.value, Z, F);
      const de = {
        store: e.store,
        _self: e.context || t,
        column: te,
        row: _,
        $index: k,
        cellIndex: F,
        expanded: L
      };
      F === w.value && N && (de.treeNode = {
        indent: N.level * U.value,
        level: N.level
      }, typeof N.expanded == "boolean" && (de.treeNode.expanded = N.expanded, "loading" in N && (de.treeNode.loading = N.loading), "noLazyChildren" in N && (de.treeNode.noLazyChildren = N.noLazyChildren)));
      const Oe = `${b(_, k)},${F}`, ce = te.columnKey || te.rawColumnKey || "", ne = E(F, O, de), Y = O.showOverflowTooltip && IF({
        effect: R
      }, H, O.showOverflowTooltip);
      return V("td", {
        style: m(k, F, _, O),
        class: p(k, F, _, O, Z - 1),
        key: `${ce}${Oe}`,
        rowspan: j,
        colspan: Z,
        onMouseenter: (ve) => s(ve, _, Y),
        onMouseleave: u
      }, [ne]);
    }));
  }, E = (_, k, N) => k.renderCell(N);
  return {
    wrappedRowRender: (_, k) => {
      const N = e.store, { isRowExpanded: L, assertRowKey: R } = N, { treeData: H, lazyTreeNodeMap: K, childrenColumnName: U, rowKey: W } = N.states, A = N.states.columns.value;
      if (A.some(({ type: D }) => D === "expand")) {
        const D = L(_), O = y(_, k, void 0, D), F = t.renderExpanded;
        return D ? F ? [
          [
            O,
            V("tr", {
              key: `expanded-row__${O.key}`
            }, [
              V("td", {
                colspan: A.length,
                class: `${n.e("cell")} ${n.e("expanded-cell")}`
              }, [F({ row: _, $index: k, store: N, expanded: D })])
            ])
          ]
        ] : (console.error("[Element Error]renderExpanded is required."), O) : [[O]];
      } else if (Object.keys(H.value).length) {
        R();
        const D = tl(_, W.value);
        let O = H.value[D], F = null;
        O && (F = {
          expanded: O.expanded,
          level: O.level,
          display: !0
        }, typeof O.lazy == "boolean" && (typeof O.loaded == "boolean" && O.loaded && (F.noLazyChildren = !(O.children && O.children.length)), F.loading = O.loading));
        const j = [y(_, k, F)];
        if (O) {
          let Z = 0;
          const te = (Oe, ce) => {
            Oe && Oe.length && ce && Oe.forEach((ne) => {
              const Y = {
                display: ce.display && ce.expanded,
                level: ce.level + 1,
                expanded: !1,
                noLazyChildren: !1,
                loading: !1
              }, ve = tl(ne, W.value);
              if (ve == null)
                throw new Error("For nested data item, row-key is required.");
              if (O = { ...H.value[ve] }, O && (Y.expanded = O.expanded, O.level = O.level || Y.level, O.display = !!(O.expanded && Y.display), typeof O.lazy == "boolean" && (typeof O.loaded == "boolean" && O.loaded && (Y.noLazyChildren = !(O.children && O.children.length)), Y.loading = O.loading)), Z++, j.push(y(ne, k + Z, Y)), O) {
                const ie = K.value[ve] || ne[U.value];
                te(ie, O);
              }
            });
          };
          O.display = !0;
          const de = K.value[D] || _[U.value];
          te(de, O);
        }
        return j;
      } else
        return y(_, k, void 0);
    },
    tooltipContent: d,
    tooltipTrigger: f
  };
}
const Oee = {
  store: {
    required: !0,
    type: Object
  },
  stripe: Boolean,
  tooltipEffect: String,
  tooltipOptions: {
    type: Object
  },
  context: {
    default: () => ({}),
    type: Object
  },
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  fixed: {
    type: String,
    default: ""
  },
  highlight: Boolean
};
var Nee = Q({
  name: "ElTableBody",
  props: Oee,
  setup(e) {
    const t = Pt(), n = ot(vr), o = nt("table"), { wrappedRowRender: l, tooltipContent: a, tooltipTrigger: r } = $ee(e), { onColumnsChange: i, onScrollableChange: s } = kO(n), u = [];
    return Pe(e.store.states.hoverRow, (d, f) => {
      var v;
      const h = t == null ? void 0 : t.vnode.el, m = Array.from((h == null ? void 0 : h.children) || []).filter((g) => g == null ? void 0 : g.classList.contains(`${o.e("row")}`));
      let p = d;
      const C = (v = m[p]) == null ? void 0 : v.childNodes;
      if (C != null && C.length) {
        let g = 0;
        Array.from(C).reduce((b, y, E) => {
          var S, _;
          return ((S = C[E]) == null ? void 0 : S.colSpan) > 1 && (g = (_ = C[E]) == null ? void 0 : _.colSpan), y.nodeName !== "TD" && g === 0 && b.push(E), g > 0 && g--, b;
        }, []).forEach((b) => {
          var y;
          for (p = d; p > 0; ) {
            const E = (y = m[p - 1]) == null ? void 0 : y.childNodes;
            if (E[b] && E[b].nodeName === "TD" && E[b].rowSpan > 1) {
              ma(E[b], "hover-cell"), u.push(E[b]);
              break;
            }
            p--;
          }
        });
      } else
        u.forEach((g) => vl(g, "hover-cell")), u.length = 0;
      !e.store.states.isComplex.value || !fn || xs(() => {
        const g = m[f], w = m[d];
        g && !g.classList.contains("hover-fixed-row") && vl(g, "hover-row"), w && ma(w, "hover-row");
      });
    }), wo(() => {
      var d;
      (d = ua) == null || d();
    }), {
      ns: o,
      onColumnsChange: i,
      onScrollableChange: s,
      wrappedRowRender: l,
      tooltipContent: a,
      tooltipTrigger: r
    };
  },
  render() {
    const { wrappedRowRender: e, store: t } = this, n = t.states.data.value || [];
    return V("tbody", { tabIndex: -1 }, [
      n.reduce((o, l) => o.concat(e(l, o.length)), [])
    ]);
  }
});
function Mee() {
  const e = ot(vr), t = e == null ? void 0 : e.store, n = x(() => t.states.fixedLeafColumnsLength.value), o = x(() => t.states.rightFixedColumns.value.length), l = x(() => t.states.columns.value.length), a = x(() => t.states.fixedColumns.value.length), r = x(() => t.states.rightFixedColumns.value.length);
  return {
    leftFixedLeafCount: n,
    rightFixedLeafCount: o,
    columnsCount: l,
    leftFixedCount: a,
    rightFixedCount: r,
    columns: t.states.columns
  };
}
function Iee(e) {
  const { columns: t } = Mee(), n = nt("table");
  return {
    getCellClasses: (a, r) => {
      const i = a[r], s = [
        n.e("cell"),
        i.id,
        i.align,
        i.labelClassName,
        ...h0(n.b(), r, i.fixed, e.store)
      ];
      return i.className && s.push(i.className), i.children || s.push(n.is("leaf")), s;
    },
    getCellStyles: (a, r) => {
      const i = m0(r, a.fixed, e.store);
      return qc(i, "left"), qc(i, "right"), i;
    },
    columns: t
  };
}
var Ree = Q({
  name: "ElTableFooter",
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: !0,
      type: Object
    },
    summaryMethod: Function,
    sumText: String,
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => ({
        prop: "",
        order: ""
      })
    }
  },
  setup(e) {
    const { getCellClasses: t, getCellStyles: n, columns: o } = Iee(e);
    return {
      ns: nt("table"),
      getCellClasses: t,
      getCellStyles: n,
      columns: o
    };
  },
  render() {
    const { columns: e, getCellStyles: t, getCellClasses: n, summaryMethod: o, sumText: l } = this, a = this.store.states.data.value;
    let r = [];
    return o ? r = o({
      columns: e,
      data: a
    }) : e.forEach((i, s) => {
      if (s === 0) {
        r[s] = l;
        return;
      }
      const u = a.map((h) => Number(h[i.property])), d = [];
      let f = !0;
      u.forEach((h) => {
        if (!Number.isNaN(+h)) {
          f = !1;
          const m = `${h}`.split(".")[1];
          d.push(m ? m.length : 0);
        }
      });
      const v = Math.max.apply(null, d);
      f ? r[s] = "" : r[s] = u.reduce((h, m) => {
        const p = Number(m);
        return Number.isNaN(+p) ? h : Number.parseFloat((h + m).toFixed(Math.min(v, 20)));
      }, 0);
    }), V(V("tfoot", [
      V("tr", {}, [
        ...e.map((i, s) => V("td", {
          key: s,
          colspan: i.colSpan,
          rowspan: i.rowSpan,
          class: n(e, s),
          style: t(i, s)
        }, [
          V("div", {
            class: ["cell", i.labelClassName]
          }, [r[s]])
        ]))
      ])
    ]));
  }
});
function Dee(e) {
  return {
    setCurrentRow: (d) => {
      e.commit("setCurrentRow", d);
    },
    getSelectionRows: () => e.getSelectionRows(),
    toggleRowSelection: (d, f) => {
      e.toggleRowSelection(d, f, !1), e.updateAllSelected();
    },
    clearSelection: () => {
      e.clearSelection();
    },
    clearFilter: (d) => {
      e.clearFilter(d);
    },
    toggleAllSelection: () => {
      e.commit("toggleAllSelection");
    },
    toggleRowExpansion: (d, f) => {
      e.toggleRowExpansionAdapter(d, f);
    },
    clearSort: () => {
      e.clearSort();
    },
    sort: (d, f) => {
      e.commit("sort", { prop: d, order: f });
    }
  };
}
function Lee(e, t, n, o) {
  const l = B(!1), a = B(null), r = B(!1), i = (O) => {
    r.value = O;
  }, s = B({
    width: null,
    height: null,
    headerHeight: null
  }), u = B(!1), d = {
    display: "inline-block",
    verticalAlign: "middle"
  }, f = B(), v = B(0), h = B(0), m = B(0), p = B(0), C = B(0);
  ol(() => {
    t.setHeight(e.height);
  }), ol(() => {
    t.setMaxHeight(e.maxHeight);
  }), Pe(() => [e.currentRowKey, n.states.rowKey], ([O, F]) => {
    !c(F) || !c(O) || n.setCurrentRowKey(`${O}`);
  }, {
    immediate: !0
  }), Pe(() => e.data, (O) => {
    o.store.commit("setData", O);
  }, {
    immediate: !0,
    deep: !0
  }), ol(() => {
    e.expandRowKeys && n.setExpandRowKeysAdapter(e.expandRowKeys);
  });
  const g = () => {
    o.store.commit("setHoverRow", null), o.hoverState && (o.hoverState = null);
  }, w = (O, F) => {
    const { pixelX: j, pixelY: Z } = F;
    Math.abs(j) >= Math.abs(Z) && (o.refs.bodyWrapper.scrollLeft += F.pixelX / 5);
  }, b = x(() => e.height || e.maxHeight || n.states.fixedColumns.value.length > 0 || n.states.rightFixedColumns.value.length > 0), y = x(() => ({
    width: t.bodyWidth.value ? `${t.bodyWidth.value}px` : ""
  })), E = () => {
    b.value && t.updateElsHeight(), t.updateColumnsWidth(), requestAnimationFrame(N);
  };
  Nt(async () => {
    await xe(), n.updateColumns(), L(), requestAnimationFrame(E);
    const O = o.vnode.el, F = o.refs.headerWrapper;
    e.flexible && O && O.parentElement && (O.parentElement.style.minWidth = "0"), s.value = {
      width: f.value = O.offsetWidth,
      height: O.offsetHeight,
      headerHeight: e.showHeader && F ? F.offsetHeight : null
    }, n.states.columns.value.forEach((j) => {
      j.filteredValue && j.filteredValue.length && o.store.commit("filterChange", {
        column: j,
        values: j.filteredValue,
        silent: !0
      });
    }), o.$ready = !0;
  });
  const S = (O, F) => {
    if (!O)
      return;
    const j = Array.from(O.classList).filter((Z) => !Z.startsWith("is-scrolling-"));
    j.push(t.scrollX.value ? F : "is-scrolling-none"), O.className = j.join(" ");
  }, _ = (O) => {
    const { tableWrapper: F } = o.refs;
    S(F, O);
  }, k = (O) => {
    const { tableWrapper: F } = o.refs;
    return !!(F && F.classList.contains(O));
  }, N = function() {
    if (!o.refs.scrollBarRef)
      return;
    if (!t.scrollX.value) {
      const ce = "is-scrolling-none";
      k(ce) || _(ce);
      return;
    }
    const O = o.refs.scrollBarRef.wrapRef;
    if (!O)
      return;
    const { scrollLeft: F, offsetWidth: j, scrollWidth: Z } = O, { headerWrapper: te, footerWrapper: de } = o.refs;
    te && (te.scrollLeft = F), de && (de.scrollLeft = F);
    const Oe = Z - j - 1;
    F >= Oe ? _("is-scrolling-right") : _(F === 0 ? "is-scrolling-left" : "is-scrolling-middle");
  }, L = () => {
    o.refs.scrollBarRef && (o.refs.scrollBarRef.wrapRef && jn(o.refs.scrollBarRef.wrapRef, "scroll", N, {
      passive: !0
    }), e.fit ? Xn(o.vnode.el, R) : jn(window, "resize", R), Xn(o.refs.bodyWrapper, () => {
      var O, F;
      R(), (F = (O = o.refs) == null ? void 0 : O.scrollBarRef) == null || F.update();
    }));
  }, R = () => {
    var O, F, j, Z;
    const te = o.vnode.el;
    if (!o.$ready || !te)
      return;
    let de = !1;
    const {
      width: Oe,
      height: ce,
      headerHeight: ne
    } = s.value, Y = f.value = te.offsetWidth;
    Oe !== Y && (de = !0);
    const ve = te.offsetHeight;
    (e.height || b.value) && ce !== ve && (de = !0);
    const ie = e.tableLayout === "fixed" ? o.refs.headerWrapper : (O = o.refs.tableHeaderRef) == null ? void 0 : O.$el;
    e.showHeader && (ie == null ? void 0 : ie.offsetHeight) !== ne && (de = !0), v.value = ((F = o.refs.tableWrapper) == null ? void 0 : F.scrollHeight) || 0, m.value = (ie == null ? void 0 : ie.scrollHeight) || 0, p.value = ((j = o.refs.footerWrapper) == null ? void 0 : j.offsetHeight) || 0, C.value = ((Z = o.refs.appendWrapper) == null ? void 0 : Z.offsetHeight) || 0, h.value = v.value - m.value - p.value - C.value, de && (s.value = {
      width: Y,
      height: ve,
      headerHeight: e.showHeader && (ie == null ? void 0 : ie.offsetHeight) || 0
    }, E());
  }, H = Mo(), K = x(() => {
    const { bodyWidth: O, scrollY: F, gutterWidth: j } = t;
    return O.value ? `${O.value - (F.value ? j : 0)}px` : "";
  }), U = x(() => e.maxHeight ? "fixed" : e.tableLayout), W = x(() => {
    if (e.data && e.data.length)
      return null;
    let O = "100%";
    e.height && h.value && (O = `${h.value}px`);
    const F = f.value;
    return {
      width: F ? `${F}px` : "",
      height: O
    };
  }), A = x(() => e.height ? {
    height: Number.isNaN(Number(e.height)) ? e.height : `${e.height}px`
  } : e.maxHeight ? {
    maxHeight: Number.isNaN(Number(e.maxHeight)) ? e.maxHeight : `${e.maxHeight}px`
  } : {}), $ = x(() => e.height ? {
    height: "100%"
  } : e.maxHeight ? Number.isNaN(Number(e.maxHeight)) ? {
    maxHeight: `calc(${e.maxHeight} - ${m.value + p.value}px)`
  } : {
    maxHeight: `${e.maxHeight - m.value - p.value}px`
  } : {});
  return {
    isHidden: l,
    renderExpanded: a,
    setDragVisible: i,
    isGroup: u,
    handleMouseLeave: g,
    handleHeaderFooterMousewheel: w,
    tableSize: H,
    emptyBlockStyle: W,
    handleFixedMousewheel: (O, F) => {
      const j = o.refs.bodyWrapper;
      if (Math.abs(F.spinY) > 0) {
        const Z = j.scrollTop;
        F.pixelY < 0 && Z !== 0 && O.preventDefault(), F.pixelY > 0 && j.scrollHeight - j.clientHeight > Z && O.preventDefault(), j.scrollTop += Math.ceil(F.pixelY / 5);
      } else
        j.scrollLeft += Math.ceil(F.pixelX / 5);
    },
    resizeProxyVisible: r,
    bodyWidth: K,
    resizeState: s,
    doLayout: E,
    tableBodyStyles: y,
    tableLayout: U,
    scrollbarViewStyle: d,
    tableInnerStyle: A,
    scrollbarStyle: $
  };
}
function Pee(e) {
  const t = B(), n = () => {
    const l = e.vnode.el.querySelector(".hidden-columns"), a = { childList: !0, subtree: !0 }, r = e.store.states.updateOrderFns;
    t.value = new MutationObserver(() => {
      r.forEach((i) => i());
    }), t.value.observe(l, a);
  };
  Nt(() => {
    n();
  }), wo(() => {
    var o;
    (o = t.value) == null || o.disconnect();
  });
}
var Aee = {
  data: {
    type: Array,
    default: () => []
  },
  size: Lo,
  width: [String, Number],
  height: [String, Number],
  maxHeight: [String, Number],
  fit: {
    type: Boolean,
    default: !0
  },
  stripe: Boolean,
  border: Boolean,
  rowKey: [String, Function],
  showHeader: {
    type: Boolean,
    default: !0
  },
  showSummary: Boolean,
  sumText: String,
  summaryMethod: Function,
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  cellClassName: [String, Function],
  cellStyle: [Object, Function],
  headerRowClassName: [String, Function],
  headerRowStyle: [Object, Function],
  headerCellClassName: [String, Function],
  headerCellStyle: [Object, Function],
  highlightCurrentRow: Boolean,
  currentRowKey: [String, Number],
  emptyText: String,
  expandRowKeys: Array,
  defaultExpandAll: Boolean,
  defaultSort: Object,
  tooltipEffect: String,
  tooltipOptions: Object,
  spanMethod: Function,
  selectOnIndeterminate: {
    type: Boolean,
    default: !0
  },
  indent: {
    type: Number,
    default: 16
  },
  treeProps: {
    type: Object,
    default: () => ({
      hasChildren: "hasChildren",
      children: "children"
    })
  },
  lazy: Boolean,
  load: Function,
  style: {
    type: Object,
    default: () => ({})
  },
  className: {
    type: String,
    default: ""
  },
  tableLayout: {
    type: String,
    default: "fixed"
  },
  scrollbarAlwaysOn: Boolean,
  flexible: Boolean,
  showOverflowTooltip: [Boolean, Object]
};
function $O(e) {
  const t = e.tableLayout === "auto";
  let n = e.columns || [];
  t && n.every((l) => l.width === void 0) && (n = []);
  const o = (l) => {
    const a = {
      key: `${e.tableLayout}_${l.id}`,
      style: {},
      name: void 0
    };
    return t ? a.style = {
      width: `${l.width}px`
    } : a.name = l.id, a;
  };
  return V("colgroup", {}, n.map((l) => V("col", o(l))));
}
$O.props = ["columns", "tableLayout"];
const Fee = () => {
  const e = B(), t = (a, r) => {
    const i = e.value;
    i && i.scrollTo(a, r);
  }, n = (a, r) => {
    const i = e.value;
    i && Ot(r) && ["Top", "Left"].includes(a) && i[`setScroll${a}`](r);
  };
  return {
    scrollBarRef: e,
    scrollTo: t,
    setScrollTop: (a) => n("Top", a),
    setScrollLeft: (a) => n("Left", a)
  };
};
let Vee = 1;
const Bee = Q({
  name: "ElTable",
  directives: {
    Mousewheel: Wz
  },
  components: {
    TableHeader: xee,
    TableBody: Nee,
    TableFooter: Ree,
    ElScrollbar: zr,
    hColgroup: $O
  },
  props: Aee,
  emits: [
    "select",
    "select-all",
    "selection-change",
    "cell-mouse-enter",
    "cell-mouse-leave",
    "cell-contextmenu",
    "cell-click",
    "cell-dblclick",
    "row-click",
    "row-contextmenu",
    "row-dblclick",
    "header-click",
    "header-contextmenu",
    "sort-change",
    "filter-change",
    "current-change",
    "header-dragend",
    "expand-change"
  ],
  setup(e) {
    const { t } = bn(), n = nt("table"), o = Pt();
    Mt(vr, o);
    const l = dee(o, e);
    o.store = l;
    const a = new pee({
      store: o.store,
      table: o,
      fit: e.fit,
      showHeader: e.showHeader
    });
    o.layout = a;
    const r = x(() => (l.states.data.value || []).length === 0), {
      setCurrentRow: i,
      getSelectionRows: s,
      toggleRowSelection: u,
      clearSelection: d,
      clearFilter: f,
      toggleAllSelection: v,
      toggleRowExpansion: h,
      clearSort: m,
      sort: p
    } = Dee(l), {
      isHidden: C,
      renderExpanded: g,
      setDragVisible: w,
      isGroup: b,
      handleMouseLeave: y,
      handleHeaderFooterMousewheel: E,
      tableSize: S,
      emptyBlockStyle: _,
      handleFixedMousewheel: k,
      resizeProxyVisible: N,
      bodyWidth: L,
      resizeState: R,
      doLayout: H,
      tableBodyStyles: K,
      tableLayout: U,
      scrollbarViewStyle: W,
      tableInnerStyle: A,
      scrollbarStyle: $
    } = Lee(e, a, l, o), { scrollBarRef: D, scrollTo: O, setScrollLeft: F, setScrollTop: j } = Fee(), Z = Hl(H, 50), te = `${n.namespace.value}-table_${Vee++}`;
    o.tableId = te, o.state = {
      isGroup: b,
      resizeState: R,
      doLayout: H,
      debouncedUpdateLayout: Z
    };
    const de = x(() => e.sumText || t("el.table.sumText")), Oe = x(() => e.emptyText || t("el.table.emptyText"));
    return Pee(o), {
      ns: n,
      layout: a,
      store: l,
      handleHeaderFooterMousewheel: E,
      handleMouseLeave: y,
      tableId: te,
      tableSize: S,
      isHidden: C,
      isEmpty: r,
      renderExpanded: g,
      resizeProxyVisible: N,
      resizeState: R,
      isGroup: b,
      bodyWidth: L,
      tableBodyStyles: K,
      emptyBlockStyle: _,
      debouncedUpdateLayout: Z,
      handleFixedMousewheel: k,
      setCurrentRow: i,
      getSelectionRows: s,
      toggleRowSelection: u,
      clearSelection: d,
      clearFilter: f,
      toggleAllSelection: v,
      toggleRowExpansion: h,
      clearSort: m,
      doLayout: H,
      sort: p,
      t,
      setDragVisible: w,
      context: o,
      computedSumText: de,
      computedEmptyText: Oe,
      tableLayout: U,
      scrollbarViewStyle: W,
      tableInnerStyle: A,
      scrollbarStyle: $,
      scrollBarRef: D,
      scrollTo: O,
      setScrollLeft: F,
      setScrollTop: j
    };
  }
}), Hee = ["data-prefix"], zee = {
  ref: "hiddenColumns",
  class: "hidden-columns"
};
function Wee(e, t, n, o, l, a) {
  const r = Dt("hColgroup"), i = Dt("table-header"), s = Dt("table-body"), u = Dt("table-footer"), d = Dt("el-scrollbar"), f = _v("mousewheel");
  return M(), G("div", {
    ref: "tableWrapper",
    class: z([
      {
        [e.ns.m("fit")]: e.fit,
        [e.ns.m("striped")]: e.stripe,
        [e.ns.m("border")]: e.border || e.isGroup,
        [e.ns.m("hidden")]: e.isHidden,
        [e.ns.m("group")]: e.isGroup,
        [e.ns.m("fluid-height")]: e.maxHeight,
        [e.ns.m("scrollable-x")]: e.layout.scrollX.value,
        [e.ns.m("scrollable-y")]: e.layout.scrollY.value,
        [e.ns.m("enable-row-hover")]: !e.store.states.isComplex.value,
        [e.ns.m("enable-row-transition")]: (e.store.states.data.value || []).length !== 0 && (e.store.states.data.value || []).length < 100,
        "has-footer": e.showSummary
      },
      e.ns.m(e.tableSize),
      e.className,
      e.ns.b(),
      e.ns.m(`layout-${e.tableLayout}`)
    ]),
    style: bt(e.style),
    "data-prefix": e.ns.namespace.value,
    onMouseleave: t[0] || (t[0] = (...v) => e.handleMouseLeave && e.handleMouseLeave(...v))
  }, [
    X("div", {
      class: z(e.ns.e("inner-wrapper")),
      style: bt(e.tableInnerStyle)
    }, [
      X("div", zee, [
        Ie(e.$slots, "default")
      ], 512),
      e.showHeader && e.tableLayout === "fixed" ? Bt((M(), G("div", {
        key: 0,
        ref: "headerWrapper",
        class: z(e.ns.e("header-wrapper"))
      }, [
        X("table", {
          ref: "tableHeader",
          class: z(e.ns.e("header")),
          style: bt(e.tableBodyStyles),
          border: "0",
          cellpadding: "0",
          cellspacing: "0"
        }, [
          oe(r, {
            columns: e.store.states.columns.value,
            "table-layout": e.tableLayout
          }, null, 8, ["columns", "table-layout"]),
          oe(i, {
            ref: "tableHeaderRef",
            border: e.border,
            "default-sort": e.defaultSort,
            store: e.store,
            onSetDragVisible: e.setDragVisible
          }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])
        ], 6)
      ], 2)), [
        [f, e.handleHeaderFooterMousewheel]
      ]) : _e("v-if", !0),
      X("div", {
        ref: "bodyWrapper",
        class: z(e.ns.e("body-wrapper"))
      }, [
        oe(d, {
          ref: "scrollBarRef",
          "view-style": e.scrollbarViewStyle,
          "wrap-style": e.scrollbarStyle,
          always: e.scrollbarAlwaysOn
        }, {
          default: fe(() => [
            X("table", {
              ref: "tableBody",
              class: z(e.ns.e("body")),
              cellspacing: "0",
              cellpadding: "0",
              border: "0",
              style: bt({
                width: e.bodyWidth,
                tableLayout: e.tableLayout
              })
            }, [
              oe(r, {
                columns: e.store.states.columns.value,
                "table-layout": e.tableLayout
              }, null, 8, ["columns", "table-layout"]),
              e.showHeader && e.tableLayout === "auto" ? (M(), We(i, {
                key: 0,
                ref: "tableHeaderRef",
                class: z(e.ns.e("body-header")),
                border: e.border,
                "default-sort": e.defaultSort,
                store: e.store,
                onSetDragVisible: e.setDragVisible
              }, null, 8, ["class", "border", "default-sort", "store", "onSetDragVisible"])) : _e("v-if", !0),
              oe(s, {
                context: e.context,
                highlight: e.highlightCurrentRow,
                "row-class-name": e.rowClassName,
                "tooltip-effect": e.tooltipEffect,
                "tooltip-options": e.tooltipOptions,
                "row-style": e.rowStyle,
                store: e.store,
                stripe: e.stripe
              }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"]),
              e.showSummary && e.tableLayout === "auto" ? (M(), We(u, {
                key: 1,
                class: z(e.ns.e("body-footer")),
                border: e.border,
                "default-sort": e.defaultSort,
                store: e.store,
                "sum-text": e.computedSumText,
                "summary-method": e.summaryMethod
              }, null, 8, ["class", "border", "default-sort", "store", "sum-text", "summary-method"])) : _e("v-if", !0)
            ], 6),
            e.isEmpty ? (M(), G("div", {
              key: 0,
              ref: "emptyBlock",
              style: bt(e.emptyBlockStyle),
              class: z(e.ns.e("empty-block"))
            }, [
              X("span", {
                class: z(e.ns.e("empty-text"))
              }, [
                Ie(e.$slots, "empty", {}, () => [
                  Ut(Qe(e.computedEmptyText), 1)
                ])
              ], 2)
            ], 6)) : _e("v-if", !0),
            e.$slots.append ? (M(), G("div", {
              key: 1,
              ref: "appendWrapper",
              class: z(e.ns.e("append-wrapper"))
            }, [
              Ie(e.$slots, "append")
            ], 2)) : _e("v-if", !0)
          ]),
          _: 3
        }, 8, ["view-style", "wrap-style", "always"])
      ], 2),
      e.showSummary && e.tableLayout === "fixed" ? Bt((M(), G("div", {
        key: 1,
        ref: "footerWrapper",
        class: z(e.ns.e("footer-wrapper"))
      }, [
        X("table", {
          class: z(e.ns.e("footer")),
          cellspacing: "0",
          cellpadding: "0",
          border: "0",
          style: bt(e.tableBodyStyles)
        }, [
          oe(r, {
            columns: e.store.states.columns.value,
            "table-layout": e.tableLayout
          }, null, 8, ["columns", "table-layout"]),
          oe(u, {
            border: e.border,
            "default-sort": e.defaultSort,
            store: e.store,
            "sum-text": e.computedSumText,
            "summary-method": e.summaryMethod
          }, null, 8, ["border", "default-sort", "store", "sum-text", "summary-method"])
        ], 6)
      ], 2)), [
        [pn, !e.isEmpty],
        [f, e.handleHeaderFooterMousewheel]
      ]) : _e("v-if", !0),
      e.border || e.isGroup ? (M(), G("div", {
        key: 2,
        class: z(e.ns.e("border-left-patch"))
      }, null, 2)) : _e("v-if", !0)
    ], 6),
    Bt(X("div", {
      ref: "resizeProxy",
      class: z(e.ns.e("column-resize-proxy"))
    }, null, 2), [
      [pn, e.resizeProxyVisible]
    ])
  ], 46, Hee);
}
var Kee = /* @__PURE__ */ ut(Bee, [["render", Wee], ["__file", "table.vue"]]);
const Uee = {
  selection: "table-column--selection",
  expand: "table__expand-column"
}, jee = {
  default: {
    order: ""
  },
  selection: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  }
}, qee = (e) => Uee[e] || "", Yee = {
  selection: {
    renderHeader({ store: e, column: t }) {
      function n() {
        return e.states.data.value && e.states.data.value.length === 0;
      }
      return V(ta, {
        disabled: n(),
        size: e.states.tableSize.value,
        indeterminate: e.states.selection.value.length > 0 && !e.states.isAllSelected.value,
        "onUpdate:modelValue": e.toggleAllSelection,
        modelValue: e.states.isAllSelected.value,
        ariaLabel: t.label
      });
    },
    renderCell({
      row: e,
      column: t,
      store: n,
      $index: o
    }) {
      return V(ta, {
        disabled: t.selectable ? !t.selectable.call(null, e, o) : !1,
        size: n.states.tableSize.value,
        onChange: () => {
          n.commit("rowSelectedChanged", e);
        },
        onClick: (l) => l.stopPropagation(),
        modelValue: n.isSelected(e),
        ariaLabel: t.label
      });
    },
    sortable: !1,
    resizable: !1
  },
  index: {
    renderHeader({ column: e }) {
      return e.label || "#";
    },
    renderCell({
      column: e,
      $index: t
    }) {
      let n = t + 1;
      const o = e.index;
      return typeof o == "number" ? n = t + o : typeof o == "function" && (n = o(t)), V("div", {}, [n]);
    },
    sortable: !1
  },
  expand: {
    renderHeader({ column: e }) {
      return e.label || "";
    },
    renderCell({
      row: e,
      store: t,
      expanded: n
    }) {
      const { ns: o } = t, l = [o.e("expand-icon")];
      return n && l.push(o.em("expand-icon", "expanded")), V("div", {
        class: l,
        onClick: function(r) {
          r.stopPropagation(), t.toggleRowExpansion(e);
        }
      }, {
        default: () => [
          V(Ct, null, {
            default: () => [V(xl)]
          })
        ]
      });
    },
    sortable: !1,
    resizable: !1
  }
};
function Gee({
  row: e,
  column: t,
  $index: n
}) {
  var o;
  const l = t.property, a = l && hp(e, l).value;
  return t && t.formatter ? t.formatter(e, t, a, n) : ((o = a == null ? void 0 : a.toString) == null ? void 0 : o.call(a)) || "";
}
function Xee({
  row: e,
  treeNode: t,
  store: n
}, o = !1) {
  const { ns: l } = n;
  if (!t)
    return o ? [
      V("span", {
        class: l.e("placeholder")
      })
    ] : null;
  const a = [], r = function(i) {
    i.stopPropagation(), !t.loading && n.loadOrToggle(e);
  };
  if (t.indent && a.push(V("span", {
    class: l.e("indent"),
    style: { "padding-left": `${t.indent}px` }
  })), typeof t.expanded == "boolean" && !t.noLazyChildren) {
    const i = [
      l.e("expand-icon"),
      t.expanded ? l.em("expand-icon", "expanded") : ""
    ];
    let s = xl;
    t.loading && (s = Ps), a.push(V("div", {
      class: i,
      onClick: r
    }, {
      default: () => [
        V(Ct, { class: { [l.is("loading")]: t.loading } }, {
          default: () => [V(s)]
        })
      ]
    }));
  } else
    a.push(V("span", {
      class: l.e("placeholder")
    }));
  return a;
}
function $E(e, t) {
  return e.reduce((n, o) => (n[o] = o, n), t);
}
function Zee(e, t) {
  const n = Pt();
  return {
    registerComplexWatchers: () => {
      const a = ["fixed"], r = {
        realWidth: "width",
        realMinWidth: "minWidth"
      }, i = $E(a, r);
      Object.keys(i).forEach((s) => {
        const u = r[s];
        sl(t, u) && Pe(() => t[u], (d) => {
          let f = d;
          u === "width" && s === "realWidth" && (f = v0(d)), u === "minWidth" && s === "realMinWidth" && (f = wO(d)), n.columnConfig.value[u] = f, n.columnConfig.value[s] = f;
          const v = u === "fixed";
          e.value.store.scheduleLayout(v);
        });
      });
    },
    registerNormalWatchers: () => {
      const a = [
        "label",
        "filters",
        "filterMultiple",
        "filteredValue",
        "sortable",
        "index",
        "formatter",
        "className",
        "labelClassName",
        "filterClassName",
        "showOverflowTooltip"
      ], r = {
        property: "prop",
        align: "realAlign",
        headerAlign: "realHeaderAlign"
      }, i = $E(a, r);
      Object.keys(i).forEach((s) => {
        const u = r[s];
        sl(t, u) && Pe(() => t[u], (d) => {
          n.columnConfig.value[s] = d;
        });
      });
    }
  };
}
function Jee(e, t, n) {
  const o = Pt(), l = B(""), a = B(!1), r = B(), i = B(), s = nt("table");
  ol(() => {
    r.value = e.align ? `is-${e.align}` : null, r.value;
  }), ol(() => {
    i.value = e.headerAlign ? `is-${e.headerAlign}` : r.value, i.value;
  });
  const u = x(() => {
    let y = o.vnode.vParent || o.parent;
    for (; y && !y.tableId && !y.columnId; )
      y = y.vnode.vParent || y.parent;
    return y;
  }), d = x(() => {
    const { store: y } = o.parent;
    if (!y)
      return !1;
    const { treeData: E } = y.states, S = E.value;
    return S && Object.keys(S).length > 0;
  }), f = B(v0(e.width)), v = B(wO(e.minWidth)), h = (y) => (f.value && (y.width = f.value), v.value && (y.minWidth = v.value), !f.value && v.value && (y.width = void 0), y.minWidth || (y.minWidth = 80), y.realWidth = Number(y.width === void 0 ? y.minWidth : y.width), y), m = (y) => {
    const E = y.type, S = Yee[E] || {};
    Object.keys(S).forEach((k) => {
      const N = S[k];
      k !== "className" && N !== void 0 && (y[k] = N);
    });
    const _ = qee(E);
    if (_) {
      const k = `${c(s.namespace)}-${_}`;
      y.className = y.className ? `${y.className} ${k}` : k;
    }
    return y;
  }, p = (y) => {
    Array.isArray(y) ? y.forEach((S) => E(S)) : E(y);
    function E(S) {
      var _;
      ((_ = S == null ? void 0 : S.type) == null ? void 0 : _.name) === "ElTableColumn" && (S.vParent = o);
    }
  };
  return {
    columnId: l,
    realAlign: r,
    isSubColumn: a,
    realHeaderAlign: i,
    columnOrTableParent: u,
    setColumnWidth: h,
    setColumnForcedProps: m,
    setColumnRenders: (y) => {
      e.renderHeader ? dn("TableColumn", "Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.") : y.type !== "selection" && (y.renderHeader = (S) => (o.columnConfig.value.label, Ie(t, "header", S, () => [y.label])));
      let E = y.renderCell;
      return y.type === "expand" ? (y.renderCell = (S) => V("div", {
        class: "cell"
      }, [E(S)]), n.value.renderExpanded = (S) => t.default ? t.default(S) : t.default) : (E = E || Gee, y.renderCell = (S) => {
        let _ = null;
        if (t.default) {
          const K = t.default(S);
          _ = K.some((U) => U.type !== Pb) ? K : E(S);
        } else
          _ = E(S);
        const { columns: k } = n.value.store.states, N = k.value.findIndex((K) => K.type === "default"), L = d.value && S.cellIndex === N, R = Xee(S, L), H = {
          class: "cell",
          style: {}
        };
        return y.showOverflowTooltip && (H.class = `${H.class} ${c(s.namespace)}-tooltip`, H.style = {
          width: `${(S.column.realWidth || Number(S.column.width)) - 1}px`
        }), p(_), V("div", H, [R, _]);
      }), y;
    },
    getPropsData: (...y) => y.reduce((E, S) => (Array.isArray(S) && S.forEach((_) => {
      E[_] = e[_];
    }), E), {}),
    getColumnElIndex: (y, E) => Array.prototype.indexOf.call(y, E),
    updateColumnOrder: () => {
      n.value.store.commit("updateColumnOrder", o.columnConfig.value);
    }
  };
}
var Qee = {
  type: {
    type: String,
    default: "default"
  },
  label: String,
  className: String,
  labelClassName: String,
  property: String,
  prop: String,
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  renderHeader: Function,
  sortable: {
    type: [Boolean, String],
    default: !1
  },
  sortMethod: Function,
  sortBy: [String, Function, Array],
  resizable: {
    type: Boolean,
    default: !0
  },
  columnKey: String,
  align: String,
  headerAlign: String,
  showOverflowTooltip: {
    type: [Boolean, Object],
    default: void 0
  },
  fixed: [Boolean, String],
  formatter: Function,
  selectable: Function,
  reserveSelection: Boolean,
  filterMethod: Function,
  filteredValue: Array,
  filters: Array,
  filterPlacement: String,
  filterMultiple: {
    type: Boolean,
    default: !0
  },
  filterClassName: String,
  index: [Number, Function],
  sortOrders: {
    type: Array,
    default: () => ["ascending", "descending", null],
    validator: (e) => e.every((t) => ["ascending", "descending", null].includes(t))
  }
};
let ete = 1;
var OO = Q({
  name: "ElTableColumn",
  components: {
    ElCheckbox: ta
  },
  props: Qee,
  setup(e, { slots: t }) {
    const n = Pt(), o = B({}), l = x(() => {
      let b = n.parent;
      for (; b && !b.tableId; )
        b = b.parent;
      return b;
    }), { registerNormalWatchers: a, registerComplexWatchers: r } = Zee(l, e), {
      columnId: i,
      isSubColumn: s,
      realHeaderAlign: u,
      columnOrTableParent: d,
      setColumnWidth: f,
      setColumnForcedProps: v,
      setColumnRenders: h,
      getPropsData: m,
      getColumnElIndex: p,
      realAlign: C,
      updateColumnOrder: g
    } = Jee(e, t, l), w = d.value;
    i.value = `${w.tableId || w.columnId}_column_${ete++}`, Sv(() => {
      s.value = l.value !== w;
      const b = e.type || "default", y = e.sortable === "" ? !0 : e.sortable, E = To(e.showOverflowTooltip) ? w.props.showOverflowTooltip : e.showOverflowTooltip, S = {
        ...jee[b],
        id: i.value,
        type: b,
        property: e.prop || e.property,
        align: C,
        headerAlign: u,
        showOverflowTooltip: E,
        filterable: e.filters || e.filterMethod,
        filteredValue: [],
        filterPlacement: "",
        filterClassName: "",
        isColumnGroup: !1,
        isSubColumn: !1,
        filterOpened: !1,
        sortable: y,
        index: e.index,
        rawColumnKey: n.vnode.key
      };
      let R = m([
        "columnKey",
        "label",
        "className",
        "labelClassName",
        "type",
        "renderHeader",
        "formatter",
        "fixed",
        "resizable"
      ], ["sortMethod", "sortBy", "sortOrders"], ["selectable", "reserveSelection"], [
        "filterMethod",
        "filters",
        "filterMultiple",
        "filterOpened",
        "filteredValue",
        "filterPlacement",
        "filterClassName"
      ]);
      R = eee(S, R), R = nee(h, f, v)(R), o.value = R, a(), r();
    }), Nt(() => {
      var b;
      const y = d.value, E = s.value ? y.vnode.el.children : (b = y.refs.hiddenColumns) == null ? void 0 : b.children, S = () => p(E || [], n.vnode.el);
      o.value.getColumnIndex = S, S() > -1 && l.value.store.commit("insertColumn", o.value, s.value ? y.columnConfig.value : null, g);
    }), zn(() => {
      o.value.getColumnIndex() > -1 && l.value.store.commit("removeColumn", o.value, s.value ? w.columnConfig.value : null, g);
    }), n.columnId = i.value, n.columnConfig = o;
  },
  render() {
    var e, t, n;
    try {
      const o = (t = (e = this.$slots).default) == null ? void 0 : t.call(e, {
        row: {},
        column: {},
        $index: -1
      }), l = [];
      if (Array.isArray(o))
        for (const r of o)
          ((n = r.type) == null ? void 0 : n.name) === "ElTableColumn" || r.shapeFlag & 2 ? l.push(r) : r.type === kt && Array.isArray(r.children) && r.children.forEach((i) => {
            (i == null ? void 0 : i.patchFlag) !== 1024 && !on(i == null ? void 0 : i.children) && l.push(i);
          });
      return V("div", l);
    } catch {
      return V("div", []);
    }
  }
});
const tte = Yt(Kee, {
  TableColumn: OO
}), nte = Jn(OO);
var zd = /* @__PURE__ */ ((e) => (e.ASC = "asc", e.DESC = "desc", e))(zd || {}), Wd = /* @__PURE__ */ ((e) => (e.CENTER = "center", e.RIGHT = "right", e))(Wd || {}), NO = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.RIGHT = "right", e))(NO || {});
const eb = {
  asc: "desc",
  desc: "asc"
  /* ASC */
}, Kd = Symbol("placeholder"), ote = (e, t, n) => {
  var o;
  const l = {
    flexGrow: 0,
    flexShrink: 0,
    ...n ? {} : {
      flexGrow: e.flexGrow || 0,
      flexShrink: e.flexShrink || 1
    }
  };
  n || (l.flexShrink = 1);
  const a = {
    ...(o = e.style) != null ? o : {},
    ...l,
    flexBasis: "auto",
    width: e.width
  };
  return t || (e.maxWidth && (a.maxWidth = e.maxWidth), e.minWidth && (a.minWidth = e.minWidth)), a;
};
function lte(e, t, n) {
  const o = x(() => c(t).filter((p) => !p.hidden)), l = x(() => c(o).filter((p) => p.fixed === "left" || p.fixed === !0)), a = x(() => c(o).filter((p) => p.fixed === "right")), r = x(() => c(o).filter((p) => !p.fixed)), i = x(() => {
    const p = [];
    return c(l).forEach((C) => {
      p.push({
        ...C,
        placeholderSign: Kd
      });
    }), c(r).forEach((C) => {
      p.push(C);
    }), c(a).forEach((C) => {
      p.push({
        ...C,
        placeholderSign: Kd
      });
    }), p;
  }), s = x(() => c(l).length || c(a).length), u = x(() => c(t).reduce((C, g) => (C[g.key] = ote(g, c(n), e.fixed), C), {})), d = x(() => c(o).reduce((p, C) => p + C.width, 0)), f = (p) => c(t).find((C) => C.key === p), v = (p) => c(u)[p], h = (p, C) => {
    p.width = C;
  };
  function m(p) {
    var C;
    const { key: g } = p.currentTarget.dataset;
    if (!g)
      return;
    const { sortState: w, sortBy: b } = e;
    let y = zd.ASC;
    Mn(w) ? y = eb[w[g]] : y = eb[b.order], (C = e.onColumnSort) == null || C.call(e, { column: f(g), key: g, order: y });
  }
  return {
    columns: t,
    columnsStyles: u,
    columnsTotalWidth: d,
    fixedColumnsOnLeft: l,
    fixedColumnsOnRight: a,
    hasFixedColumns: s,
    mainColumns: i,
    normalColumns: r,
    visibleColumns: o,
    getColumn: f,
    getColumnStyle: v,
    updateColumnWidth: h,
    onColumnSorted: m
  };
}
const ate = (e, {
  mainTableRef: t,
  leftTableRef: n,
  rightTableRef: o,
  onMaybeEndReached: l
}) => {
  const a = B({ scrollLeft: 0, scrollTop: 0 });
  function r(h) {
    var m, p, C;
    const { scrollTop: g } = h;
    (m = t.value) == null || m.scrollTo(h), (p = n.value) == null || p.scrollToTop(g), (C = o.value) == null || C.scrollToTop(g);
  }
  function i(h) {
    a.value = h, r(h);
  }
  function s(h) {
    a.value.scrollTop = h, r(c(a));
  }
  function u(h) {
    var m, p;
    a.value.scrollLeft = h, (p = (m = t.value) == null ? void 0 : m.scrollTo) == null || p.call(m, c(a));
  }
  function d(h) {
    var m;
    i(h), (m = e.onScroll) == null || m.call(e, h);
  }
  function f({ scrollTop: h }) {
    const { scrollTop: m } = c(a);
    h !== m && s(h);
  }
  function v(h, m = "auto") {
    var p;
    (p = t.value) == null || p.scrollToRow(h, m);
  }
  return Pe(() => c(a).scrollTop, (h, m) => {
    h > m && l();
  }), {
    scrollPos: a,
    scrollTo: i,
    scrollToLeft: u,
    scrollToTop: s,
    scrollToRow: v,
    onScroll: d,
    onVerticalScroll: f
  };
}, rte = (e, {
  mainTableRef: t,
  leftTableRef: n,
  rightTableRef: o,
  tableInstance: l,
  ns: a,
  isScrolling: r
}) => {
  const i = Pt(), { emit: s } = i, u = An(!1), d = B(e.defaultExpandedRowKeys || []), f = B(-1), v = An(null), h = B({}), m = B({}), p = An({}), C = An({}), g = An({}), w = x(() => Ot(e.estimatedRowHeight));
  function b(L) {
    var R;
    (R = e.onRowsRendered) == null || R.call(e, L), L.rowCacheEnd > c(f) && (f.value = L.rowCacheEnd);
  }
  function y({ hovered: L, rowKey: R }) {
    if (r.value)
      return;
    l.vnode.el.querySelectorAll(`[rowkey=${R}]`).forEach((U) => {
      L ? U.classList.add(a.is("hovered")) : U.classList.remove(a.is("hovered"));
    });
  }
  function E({
    expanded: L,
    rowData: R,
    rowIndex: H,
    rowKey: K
  }) {
    var U, W;
    const A = [...c(d)], $ = A.indexOf(K);
    L ? $ === -1 && A.push(K) : $ > -1 && A.splice($, 1), d.value = A, s("update:expandedRowKeys", A), (U = e.onRowExpand) == null || U.call(e, {
      expanded: L,
      rowData: R,
      rowIndex: H,
      rowKey: K
    }), (W = e.onExpandedRowsChange) == null || W.call(e, A);
  }
  const S = Hl(() => {
    var L, R, H, K;
    u.value = !0, h.value = { ...c(h), ...c(m) }, _(c(v), !1), m.value = {}, v.value = null, (L = t.value) == null || L.forceUpdate(), (R = n.value) == null || R.forceUpdate(), (H = o.value) == null || H.forceUpdate(), (K = i.proxy) == null || K.$forceUpdate(), u.value = !1;
  }, 0);
  function _(L, R = !1) {
    c(w) && [t, n, o].forEach((H) => {
      const K = c(H);
      K && K.resetAfterRowIndex(L, R);
    });
  }
  function k(L, R, H) {
    const K = c(v);
    (K === null || K > H) && (v.value = H), m.value[L] = R;
  }
  function N({ rowKey: L, height: R, rowIndex: H }, K) {
    K ? K === NO.RIGHT ? g.value[L] = R : p.value[L] = R : C.value[L] = R;
    const U = Math.max(...[p, g, C].map((W) => W.value[L] || 0));
    c(h)[L] !== U && (k(L, U, H), S());
  }
  return {
    expandedRowKeys: d,
    lastRenderedRowIndex: f,
    isDynamic: w,
    isResetting: u,
    rowHeights: h,
    resetAfterIndex: _,
    onRowExpanded: E,
    onRowHovered: y,
    onRowsRendered: b,
    onRowHeightChange: N
  };
}, ste = (e, { expandedRowKeys: t, lastRenderedRowIndex: n, resetAfterIndex: o }) => {
  const l = B({}), a = x(() => {
    const i = {}, { data: s, rowKey: u } = e, d = c(t);
    if (!d || !d.length)
      return s;
    const f = [], v = /* @__PURE__ */ new Set();
    d.forEach((m) => v.add(m));
    let h = s.slice();
    for (h.forEach((m) => i[m[u]] = 0); h.length > 0; ) {
      const m = h.shift();
      f.push(m), v.has(m[u]) && Array.isArray(m.children) && m.children.length > 0 && (h = [...m.children, ...h], m.children.forEach((p) => i[p[u]] = i[m[u]] + 1));
    }
    return l.value = i, f;
  }), r = x(() => {
    const { data: i, expandColumnKey: s } = e;
    return s ? c(a) : i;
  });
  return Pe(r, (i, s) => {
    i !== s && (n.value = -1, o(0, !0));
  }), {
    data: r,
    depthMap: l
  };
}, ite = (e, t) => e + t, Mp = (e) => Kt(e) ? e.reduce(ite, 0) : e, Ii = (e, t, n = {}) => vn(e) ? e(t) : e ?? n, ms = (e) => (["width", "maxWidth", "minWidth", "height"].forEach((t) => {
  e[t] = po(e[t]);
}), e), MO = (e) => yo(e) ? (t) => V(e, t) : e, cte = (e, {
  columnsTotalWidth: t,
  data: n,
  fixedColumnsOnLeft: o,
  fixedColumnsOnRight: l
}) => {
  const a = x(() => {
    const { fixed: b, width: y, vScrollbarSize: E } = e, S = y - E;
    return b ? Math.max(Math.round(c(t)), S) : S;
  }), r = x(() => c(a) + e.vScrollbarSize), i = x(() => {
    const { height: b = 0, maxHeight: y = 0, footerHeight: E, hScrollbarSize: S } = e;
    if (y > 0) {
      const _ = c(m), k = c(s), L = c(h) + _ + k + S;
      return Math.min(L, y - E);
    }
    return b - E;
  }), s = x(() => {
    const { rowHeight: b, estimatedRowHeight: y } = e, E = c(n);
    return Ot(y) ? E.length * y : E.length * b;
  }), u = x(() => {
    const { maxHeight: b } = e, y = c(i);
    if (Ot(b) && b > 0)
      return y;
    const E = c(s) + c(h) + c(m);
    return Math.min(y, E);
  }), d = (b) => b.width, f = x(() => Mp(c(o).map(d))), v = x(() => Mp(c(l).map(d))), h = x(() => Mp(e.headerHeight)), m = x(() => {
    var b;
    return (((b = e.fixedData) == null ? void 0 : b.length) || 0) * e.rowHeight;
  }), p = x(() => c(i) - c(h) - c(m)), C = x(() => {
    const { style: b = {}, height: y, width: E } = e;
    return ms({
      ...b,
      height: y,
      width: E
    });
  }), g = x(() => ms({ height: e.footerHeight })), w = x(() => ({
    top: po(c(h)),
    bottom: po(e.footerHeight),
    width: po(e.width)
  }));
  return {
    bodyWidth: a,
    fixedTableHeight: u,
    mainTableHeight: i,
    leftTableWidth: f,
    rightTableWidth: v,
    headerWidth: r,
    rowsHeight: s,
    windowHeight: p,
    footerHeight: g,
    emptyStyle: w,
    rootStyle: C,
    headerHeight: h
  };
}, ute = (e) => {
  const t = B(), n = B(0), o = B(0);
  let l;
  return Nt(() => {
    l = Xn(t, ([a]) => {
      const { width: r, height: i } = a.contentRect, { paddingLeft: s, paddingRight: u, paddingTop: d, paddingBottom: f } = getComputedStyle(a.target), v = Number.parseInt(s) || 0, h = Number.parseInt(u) || 0, m = Number.parseInt(d) || 0, p = Number.parseInt(f) || 0;
      n.value = r - v - h, o.value = i - m - p;
    }).stop;
  }), zn(() => {
    l == null || l();
  }), Pe([n, o], ([a, r]) => {
    var i;
    (i = e.onResize) == null || i.call(e, {
      width: a,
      height: r
    });
  }), {
    sizer: t,
    width: n,
    height: o
  };
};
function dte(e) {
  const t = B(), n = B(), o = B(), {
    columns: l,
    columnsStyles: a,
    columnsTotalWidth: r,
    fixedColumnsOnLeft: i,
    fixedColumnsOnRight: s,
    hasFixedColumns: u,
    mainColumns: d,
    onColumnSorted: f
  } = lte(e, Pn(e, "columns"), Pn(e, "fixed")), {
    scrollTo: v,
    scrollToLeft: h,
    scrollToTop: m,
    scrollToRow: p,
    onScroll: C,
    onVerticalScroll: g,
    scrollPos: w
  } = ate(e, {
    mainTableRef: t,
    leftTableRef: n,
    rightTableRef: o,
    onMaybeEndReached: $e
  }), b = nt("table-v2"), y = Pt(), E = An(!1), {
    expandedRowKeys: S,
    lastRenderedRowIndex: _,
    isDynamic: k,
    isResetting: N,
    rowHeights: L,
    resetAfterIndex: R,
    onRowExpanded: H,
    onRowHeightChange: K,
    onRowHovered: U,
    onRowsRendered: W
  } = rte(e, {
    mainTableRef: t,
    leftTableRef: n,
    rightTableRef: o,
    tableInstance: y,
    ns: b,
    isScrolling: E
  }), { data: A, depthMap: $ } = ste(e, {
    expandedRowKeys: S,
    lastRenderedRowIndex: _,
    resetAfterIndex: R
  }), {
    bodyWidth: D,
    fixedTableHeight: O,
    mainTableHeight: F,
    leftTableWidth: j,
    rightTableWidth: Z,
    headerWidth: te,
    rowsHeight: de,
    windowHeight: Oe,
    footerHeight: ce,
    emptyStyle: ne,
    rootStyle: Y,
    headerHeight: ve
  } = cte(e, {
    columnsTotalWidth: r,
    data: A,
    fixedColumnsOnLeft: i,
    fixedColumnsOnRight: s
  }), ie = B(), he = x(() => {
    const ue = c(A).length === 0;
    return Kt(e.fixedData) ? e.fixedData.length === 0 && ue : ue;
  });
  function De(ue) {
    const { estimatedRowHeight: Ne, rowHeight: je, rowKey: Fe } = e;
    return Ne ? c(L)[c(A)[ue][Fe]] || Ne : je;
  }
  function $e() {
    const { onEndReached: ue } = e;
    if (!ue)
      return;
    const { scrollTop: Ne } = c(w), je = c(de), Fe = c(Oe), Ve = je - (Ne + Fe) + e.hScrollbarSize;
    c(_) >= 0 && je === Ne + c(F) - c(ve) && ue(Ve);
  }
  return Pe(() => e.expandedRowKeys, (ue) => S.value = ue, {
    deep: !0
  }), {
    columns: l,
    containerRef: ie,
    mainTableRef: t,
    leftTableRef: n,
    rightTableRef: o,
    isDynamic: k,
    isResetting: N,
    isScrolling: E,
    hasFixedColumns: u,
    columnsStyles: a,
    columnsTotalWidth: r,
    data: A,
    expandedRowKeys: S,
    depthMap: $,
    fixedColumnsOnLeft: i,
    fixedColumnsOnRight: s,
    mainColumns: d,
    bodyWidth: D,
    emptyStyle: ne,
    rootStyle: Y,
    headerWidth: te,
    footerHeight: ce,
    mainTableHeight: F,
    fixedTableHeight: O,
    leftTableWidth: j,
    rightTableWidth: Z,
    showEmpty: he,
    getRowHeight: De,
    onColumnSorted: f,
    onRowHovered: U,
    onRowExpanded: H,
    onRowsRendered: W,
    onRowHeightChange: K,
    scrollTo: v,
    scrollToLeft: h,
    scrollToTop: m,
    scrollToRow: p,
    onScroll: C,
    onVerticalScroll: g
  };
}
const g0 = Symbol("tableV2"), IO = String, hf = {
  type: Ae(Array),
  required: !0
}, b0 = {
  type: Ae(Array)
}, RO = {
  ...b0,
  required: !0
}, fte = String, OE = {
  type: Ae(Array),
  default: () => Zn([])
}, li = {
  type: Number,
  required: !0
}, DO = {
  type: Ae([String, Number, Symbol]),
  default: "id"
}, NE = {
  type: Ae(Object)
}, di = it({
  class: String,
  columns: hf,
  columnsStyles: {
    type: Ae(Object),
    required: !0
  },
  depth: Number,
  expandColumnKey: fte,
  estimatedRowHeight: {
    ...Ci.estimatedRowHeight,
    default: void 0
  },
  isScrolling: Boolean,
  onRowExpand: {
    type: Ae(Function)
  },
  onRowHover: {
    type: Ae(Function)
  },
  onRowHeightChange: {
    type: Ae(Function)
  },
  rowData: {
    type: Ae(Object),
    required: !0
  },
  rowEventHandlers: {
    type: Ae(Object)
  },
  rowIndex: {
    type: Number,
    required: !0
  },
  rowKey: DO,
  style: {
    type: Ae(Object)
  }
}), dm = {
  type: Number,
  required: !0
}, y0 = it({
  class: String,
  columns: hf,
  fixedHeaderData: {
    type: Ae(Array)
  },
  headerData: {
    type: Ae(Array),
    required: !0
  },
  headerHeight: {
    type: Ae([Number, Array]),
    default: 50
  },
  rowWidth: dm,
  rowHeight: {
    type: Number,
    default: 50
  },
  height: dm,
  width: dm
}), Ip = it({
  columns: hf,
  data: RO,
  fixedData: b0,
  estimatedRowHeight: di.estimatedRowHeight,
  width: li,
  height: li,
  headerWidth: li,
  headerHeight: y0.headerHeight,
  bodyWidth: li,
  rowHeight: li,
  cache: eO.cache,
  useIsScrolling: Boolean,
  scrollbarAlwaysOn: Ci.scrollbarAlwaysOn,
  scrollbarStartGap: Ci.scrollbarStartGap,
  scrollbarEndGap: Ci.scrollbarEndGap,
  class: IO,
  style: NE,
  containerStyle: NE,
  getRowHeight: {
    type: Ae(Function),
    required: !0
  },
  rowKey: di.rowKey,
  onRowsRendered: {
    type: Ae(Function)
  },
  onScroll: {
    type: Ae(Function)
  }
}), pte = it({
  cache: Ip.cache,
  estimatedRowHeight: di.estimatedRowHeight,
  rowKey: DO,
  headerClass: {
    type: Ae([
      String,
      Function
    ])
  },
  headerProps: {
    type: Ae([
      Object,
      Function
    ])
  },
  headerCellProps: {
    type: Ae([
      Object,
      Function
    ])
  },
  headerHeight: y0.headerHeight,
  footerHeight: {
    type: Number,
    default: 0
  },
  rowClass: {
    type: Ae([String, Function])
  },
  rowProps: {
    type: Ae([Object, Function])
  },
  rowHeight: {
    type: Number,
    default: 50
  },
  cellProps: {
    type: Ae([
      Object,
      Function
    ])
  },
  columns: hf,
  data: RO,
  dataGetter: {
    type: Ae(Function)
  },
  fixedData: b0,
  expandColumnKey: di.expandColumnKey,
  expandedRowKeys: OE,
  defaultExpandedRowKeys: OE,
  class: IO,
  fixed: Boolean,
  style: {
    type: Ae(Object)
  },
  width: li,
  height: li,
  maxHeight: Number,
  useIsScrolling: Boolean,
  indentSize: {
    type: Number,
    default: 12
  },
  iconSize: {
    type: Number,
    default: 12
  },
  hScrollbarSize: Ci.hScrollbarSize,
  vScrollbarSize: Ci.vScrollbarSize,
  scrollbarAlwaysOn: oO.alwaysOn,
  sortBy: {
    type: Ae(Object),
    default: () => ({})
  },
  sortState: {
    type: Ae(Object),
    default: void 0
  },
  onColumnSort: {
    type: Ae(Function)
  },
  onExpandedRowsChange: {
    type: Ae(Function)
  },
  onEndReached: {
    type: Ae(Function)
  },
  onRowExpand: di.onRowExpand,
  onScroll: Ip.onScroll,
  onRowsRendered: Ip.onRowsRendered,
  rowEventHandlers: di.rowEventHandlers
}), C0 = (e, {
  slots: t
}) => {
  var n;
  const {
    cellData: o,
    style: l
  } = e, a = ((n = o == null ? void 0 : o.toString) == null ? void 0 : n.call(o)) || "", r = Ie(t, "default", e, () => [a]);
  return oe("div", {
    class: e.class,
    title: a,
    style: l
  }, [r]);
};
C0.displayName = "ElTableV2Cell";
C0.inheritAttrs = !1;
const w0 = (e, {
  slots: t
}) => Ie(t, "default", e, () => {
  var n, o;
  return [oe("div", {
    class: e.class,
    title: (n = e.column) == null ? void 0 : n.title
  }, [(o = e.column) == null ? void 0 : o.title])];
});
w0.displayName = "ElTableV2HeaderCell";
w0.inheritAttrs = !1;
const vte = it({
  class: String,
  columns: hf,
  columnsStyles: {
    type: Ae(Object),
    required: !0
  },
  headerIndex: Number,
  style: { type: Ae(Object) }
}), hte = Q({
  name: "ElTableV2HeaderRow",
  props: vte,
  setup(e, {
    slots: t
  }) {
    return () => {
      const {
        columns: n,
        columnsStyles: o,
        headerIndex: l,
        style: a
      } = e;
      let r = n.map((i, s) => t.cell({
        columns: n,
        column: i,
        columnIndex: s,
        headerIndex: l,
        style: o[i.key]
      }));
      return t.header && (r = t.header({
        cells: r.map((i) => Kt(i) && i.length === 1 ? i[0] : i),
        columns: n,
        headerIndex: l
      })), oe("div", {
        class: e.class,
        style: a,
        role: "row"
      }, [r]);
    };
  }
}), mte = "ElTableV2Header", gte = Q({
  name: mte,
  props: y0,
  setup(e, {
    slots: t,
    expose: n
  }) {
    const o = nt("table-v2"), l = B(), a = x(() => ms({
      width: e.width,
      height: e.height
    })), r = x(() => ms({
      width: e.rowWidth,
      height: e.height
    })), i = x(() => _s(c(e.headerHeight))), s = (f) => {
      const v = c(l);
      xe(() => {
        v != null && v.scroll && v.scroll({
          left: f
        });
      });
    }, u = () => {
      const f = o.e("fixed-header-row"), {
        columns: v,
        fixedHeaderData: h,
        rowHeight: m
      } = e;
      return h == null ? void 0 : h.map((p, C) => {
        var g;
        const w = ms({
          height: m,
          width: "100%"
        });
        return (g = t.fixed) == null ? void 0 : g.call(t, {
          class: f,
          columns: v,
          rowData: p,
          rowIndex: -(C + 1),
          style: w
        });
      });
    }, d = () => {
      const f = o.e("dynamic-header-row"), {
        columns: v
      } = e;
      return c(i).map((h, m) => {
        var p;
        const C = ms({
          width: "100%",
          height: h
        });
        return (p = t.dynamic) == null ? void 0 : p.call(t, {
          class: f,
          columns: v,
          headerIndex: m,
          style: C
        });
      });
    };
    return n({
      scrollToLeft: s
    }), () => {
      if (!(e.height <= 0))
        return oe("div", {
          ref: l,
          class: e.class,
          style: c(a),
          role: "rowgroup"
        }, [oe("div", {
          style: c(r),
          class: o.e("header")
        }, [d(), u()])]);
    };
  }
}), bte = (e) => {
  const {
    isScrolling: t
  } = ot(g0), n = B(!1), o = B(), l = x(() => Ot(e.estimatedRowHeight) && e.rowIndex >= 0), a = (s = !1) => {
    const u = c(o);
    if (!u)
      return;
    const {
      columns: d,
      onRowHeightChange: f,
      rowKey: v,
      rowIndex: h,
      style: m
    } = e, {
      height: p
    } = u.getBoundingClientRect();
    n.value = !0, xe(() => {
      if (s || p !== Number.parseInt(m.height)) {
        const C = d[0], g = (C == null ? void 0 : C.placeholderSign) === Kd;
        f == null || f({
          rowKey: v,
          height: p,
          rowIndex: h
        }, C && !g && C.fixed);
      }
    });
  }, r = x(() => {
    const {
      rowData: s,
      rowIndex: u,
      rowKey: d,
      onRowHover: f
    } = e, v = e.rowEventHandlers || {}, h = {};
    return Object.entries(v).forEach(([m, p]) => {
      vn(p) && (h[m] = (C) => {
        p({
          event: C,
          rowData: s,
          rowIndex: u,
          rowKey: d
        });
      });
    }), f && [{
      name: "onMouseleave",
      hovered: !1
    }, {
      name: "onMouseenter",
      hovered: !0
    }].forEach(({
      name: m,
      hovered: p
    }) => {
      const C = h[m];
      h[m] = (g) => {
        f({
          event: g,
          hovered: p,
          rowData: s,
          rowIndex: u,
          rowKey: d
        }), C == null || C(g);
      };
    }), h;
  }), i = (s) => {
    const {
      onRowExpand: u,
      rowData: d,
      rowIndex: f,
      rowKey: v
    } = e;
    u == null || u({
      expanded: s,
      rowData: d,
      rowIndex: f,
      rowKey: v
    });
  };
  return Nt(() => {
    c(l) && a(!0);
  }), {
    isScrolling: t,
    measurable: l,
    measured: n,
    rowRef: o,
    eventHandlers: r,
    onExpand: i
  };
}, yte = "ElTableV2TableRow", Cte = Q({
  name: yte,
  props: di,
  setup(e, {
    expose: t,
    slots: n,
    attrs: o
  }) {
    const {
      eventHandlers: l,
      isScrolling: a,
      measurable: r,
      measured: i,
      rowRef: s,
      onExpand: u
    } = bte(e);
    return t({
      onExpand: u
    }), () => {
      const {
        columns: d,
        columnsStyles: f,
        expandColumnKey: v,
        depth: h,
        rowData: m,
        rowIndex: p,
        style: C
      } = e;
      let g = d.map((w, b) => {
        const y = Kt(m.children) && m.children.length > 0 && w.key === v;
        return n.cell({
          column: w,
          columns: d,
          columnIndex: b,
          depth: h,
          style: f[w.key],
          rowData: m,
          rowIndex: p,
          isScrolling: c(a),
          expandIconProps: y ? {
            rowData: m,
            rowIndex: p,
            onExpand: u
          } : void 0
        });
      });
      if (n.row && (g = n.row({
        cells: g.map((w) => Kt(w) && w.length === 1 ? w[0] : w),
        style: C,
        columns: d,
        depth: h,
        rowData: m,
        rowIndex: p,
        isScrolling: c(a)
      })), c(r)) {
        const {
          height: w,
          ...b
        } = C || {}, y = c(i);
        return oe("div", Et({
          ref: s,
          class: e.class,
          style: y ? C : b,
          role: "row"
        }, o, c(l)), [g]);
      }
      return oe("div", Et(o, {
        ref: s,
        class: e.class,
        style: C,
        role: "row"
      }, c(l)), [g]);
    };
  }
}), wte = (e) => {
  const {
    sortOrder: t
  } = e;
  return oe(Ct, {
    size: 14,
    class: e.class
  }, {
    default: () => [t === zd.ASC ? oe(G8, null, null) : oe(q8, null, null)]
  });
}, Ete = (e) => {
  const {
    expanded: t,
    expandable: n,
    onExpand: o,
    style: l,
    size: a
  } = e, r = {
    onClick: n ? () => o(!t) : void 0,
    class: e.class
  };
  return oe(Ct, Et(r, {
    size: a,
    style: l
  }), {
    default: () => [oe(xl, null, null)]
  });
}, Ste = "ElTableV2Grid", _te = (e) => {
  const t = B(), n = B(), o = x(() => {
    const {
      data: p,
      rowHeight: C,
      estimatedRowHeight: g
    } = e;
    if (!g)
      return p.length * C;
  }), l = x(() => {
    const {
      fixedData: p,
      rowHeight: C
    } = e;
    return ((p == null ? void 0 : p.length) || 0) * C;
  }), a = x(() => Mp(e.headerHeight)), r = x(() => {
    const {
      height: p
    } = e;
    return Math.max(0, p - c(a) - c(l));
  }), i = x(() => c(a) + c(l) > 0), s = ({
    data: p,
    rowIndex: C
  }) => p[C][e.rowKey];
  function u({
    rowCacheStart: p,
    rowCacheEnd: C,
    rowVisibleStart: g,
    rowVisibleEnd: w
  }) {
    var b;
    (b = e.onRowsRendered) == null || b.call(e, {
      rowCacheStart: p,
      rowCacheEnd: C,
      rowVisibleStart: g,
      rowVisibleEnd: w
    });
  }
  function d(p, C) {
    var g;
    (g = n.value) == null || g.resetAfterRowIndex(p, C);
  }
  function f(p, C) {
    const g = c(t), w = c(n);
    Mn(p) ? (g == null || g.scrollToLeft(p.scrollLeft), w == null || w.scrollTo(p)) : (g == null || g.scrollToLeft(p), w == null || w.scrollTo({
      scrollLeft: p,
      scrollTop: C
    }));
  }
  function v(p) {
    var C;
    (C = c(n)) == null || C.scrollTo({
      scrollTop: p
    });
  }
  function h(p, C) {
    var g;
    (g = c(n)) == null || g.scrollToItem(p, 1, C);
  }
  function m() {
    var p, C;
    (p = c(n)) == null || p.$forceUpdate(), (C = c(t)) == null || C.$forceUpdate();
  }
  return {
    bodyRef: n,
    forceUpdate: m,
    fixedRowHeight: l,
    gridHeight: r,
    hasHeader: i,
    headerHeight: a,
    headerRef: t,
    totalHeight: o,
    itemKey: s,
    onItemRendered: u,
    resetAfterRowIndex: d,
    scrollTo: f,
    scrollToTop: v,
    scrollToRow: h
  };
}, E0 = Q({
  name: Ste,
  props: Ip,
  setup(e, {
    slots: t,
    expose: n
  }) {
    const {
      ns: o
    } = ot(g0), {
      bodyRef: l,
      fixedRowHeight: a,
      gridHeight: r,
      hasHeader: i,
      headerRef: s,
      headerHeight: u,
      totalHeight: d,
      forceUpdate: f,
      itemKey: v,
      onItemRendered: h,
      resetAfterRowIndex: m,
      scrollTo: p,
      scrollToTop: C,
      scrollToRow: g
    } = _te(e);
    n({
      forceUpdate: f,
      totalHeight: d,
      scrollTo: p,
      scrollToTop: C,
      scrollToRow: g,
      resetAfterRowIndex: m
    });
    const w = () => e.bodyWidth;
    return () => {
      const {
        cache: b,
        columns: y,
        data: E,
        fixedData: S,
        useIsScrolling: _,
        scrollbarAlwaysOn: k,
        scrollbarEndGap: N,
        scrollbarStartGap: L,
        style: R,
        rowHeight: H,
        bodyWidth: K,
        estimatedRowHeight: U,
        headerWidth: W,
        height: A,
        width: $,
        getRowHeight: D,
        onScroll: O
      } = e, F = Ot(U), j = F ? fJ : iJ, Z = c(u);
      return oe("div", {
        role: "table",
        class: [o.e("table"), e.class],
        style: R
      }, [oe(j, {
        ref: l,
        data: E,
        useIsScrolling: _,
        itemKey: v,
        columnCache: 0,
        columnWidth: F ? w : K,
        totalColumn: 1,
        totalRow: E.length,
        rowCache: b,
        rowHeight: F ? D : H,
        width: $,
        height: c(r),
        class: o.e("body"),
        role: "rowgroup",
        scrollbarStartGap: L,
        scrollbarEndGap: N,
        scrollbarAlwaysOn: k,
        onScroll: O,
        onItemRendered: h,
        perfMode: !1
      }, {
        default: (te) => {
          var de;
          const Oe = E[te.rowIndex];
          return (de = t.row) == null ? void 0 : de.call(t, {
            ...te,
            columns: y,
            rowData: Oe
          });
        }
      }), c(i) && oe(gte, {
        ref: s,
        class: o.e("header-wrapper"),
        columns: y,
        headerData: E,
        headerHeight: e.headerHeight,
        fixedHeaderData: S,
        rowWidth: W,
        rowHeight: H,
        width: $,
        height: Math.min(Z + c(a), A)
      }, {
        dynamic: t.header,
        fixed: t.row
      })]);
    };
  }
});
function xte(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !yo(e);
}
const kte = (e, {
  slots: t
}) => {
  const {
    mainTableRef: n,
    ...o
  } = e;
  return oe(E0, Et({
    ref: n
  }, o), xte(t) ? t : {
    default: () => [t]
  });
};
function Tte(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !yo(e);
}
const $te = (e, {
  slots: t
}) => {
  if (!e.columns.length)
    return;
  const {
    leftTableRef: n,
    ...o
  } = e;
  return oe(E0, Et({
    ref: n
  }, o), Tte(t) ? t : {
    default: () => [t]
  });
};
function Ote(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !yo(e);
}
const Nte = (e, {
  slots: t
}) => {
  if (!e.columns.length)
    return;
  const {
    rightTableRef: n,
    ...o
  } = e;
  return oe(E0, Et({
    ref: n
  }, o), Ote(t) ? t : {
    default: () => [t]
  });
};
function Mte(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !yo(e);
}
const Ite = (e, {
  slots: t
}) => {
  const {
    columns: n,
    columnsStyles: o,
    depthMap: l,
    expandColumnKey: a,
    expandedRowKeys: r,
    estimatedRowHeight: i,
    hasFixedColumns: s,
    rowData: u,
    rowIndex: d,
    style: f,
    isScrolling: v,
    rowProps: h,
    rowClass: m,
    rowKey: p,
    rowEventHandlers: C,
    ns: g,
    onRowHovered: w,
    onRowExpanded: b
  } = e, y = Ii(m, {
    columns: n,
    rowData: u,
    rowIndex: d
  }, ""), E = Ii(h, {
    columns: n,
    rowData: u,
    rowIndex: d
  }), S = u[p], _ = l[S] || 0, k = !!a, N = d < 0, L = [g.e("row"), y, {
    [g.e(`row-depth-${_}`)]: k && d >= 0,
    [g.is("expanded")]: k && r.includes(S),
    [g.is("fixed")]: !_ && N,
    [g.is("customized")]: !!t.row
  }], R = s ? w : void 0, H = {
    ...E,
    columns: n,
    columnsStyles: o,
    class: L,
    depth: _,
    expandColumnKey: a,
    estimatedRowHeight: N ? void 0 : i,
    isScrolling: v,
    rowIndex: d,
    rowData: u,
    rowKey: S,
    rowEventHandlers: C,
    style: f
  };
  return oe(Cte, Et(H, {
    onRowExpand: b,
    onMouseenter: (W) => {
      R == null || R({
        hovered: !0,
        rowKey: S,
        event: W,
        rowData: u,
        rowIndex: d
      });
    },
    onMouseleave: (W) => {
      R == null || R({
        hovered: !1,
        rowKey: S,
        event: W,
        rowData: u,
        rowIndex: d
      });
    },
    rowkey: S
  }), Mte(t) ? t : {
    default: () => [t]
  });
}, tb = ({
  columns: e,
  column: t,
  columnIndex: n,
  depth: o,
  expandIconProps: l,
  isScrolling: a,
  rowData: r,
  rowIndex: i,
  style: s,
  expandedRowKeys: u,
  ns: d,
  cellProps: f,
  expandColumnKey: v,
  indentSize: h,
  iconSize: m,
  rowKey: p
}, {
  slots: C
}) => {
  const g = ms(s);
  if (t.placeholderSign === Kd)
    return oe("div", {
      class: d.em("row-cell", "placeholder"),
      style: g
    }, null);
  const {
    cellRenderer: w,
    dataKey: b,
    dataGetter: y
  } = t, E = vn(y) ? y({
    columns: e,
    column: t,
    columnIndex: n,
    rowData: r,
    rowIndex: i
  }) : bo(r, b ?? ""), S = Ii(f, {
    cellData: E,
    columns: e,
    column: t,
    columnIndex: n,
    rowIndex: i,
    rowData: r
  }), _ = {
    class: d.e("cell-text"),
    columns: e,
    column: t,
    columnIndex: n,
    cellData: E,
    isScrolling: a,
    rowData: r,
    rowIndex: i
  }, k = MO(w), N = k ? k(_) : Ie(C, "default", _, () => [oe(C0, _, null)]), L = [d.e("row-cell"), t.class, t.align === Wd.CENTER && d.is("align-center"), t.align === Wd.RIGHT && d.is("align-right")], R = i >= 0 && v && t.key === v, H = i >= 0 && u.includes(r[p]);
  let K;
  const U = `margin-inline-start: ${o * h}px;`;
  return R && (Mn(l) ? K = oe(Ete, Et(l, {
    class: [d.e("expand-icon"), d.is("expanded", H)],
    size: m,
    expanded: H,
    style: U,
    expandable: !0
  }), null) : K = oe("div", {
    style: [U, `width: ${m}px; height: ${m}px;`].join(" ")
  }, null)), oe("div", Et({
    class: L,
    style: g
  }, S, {
    role: "cell"
  }), [K, N]);
};
tb.inheritAttrs = !1;
function Rte(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !yo(e);
}
const Dte = ({
  columns: e,
  columnsStyles: t,
  headerIndex: n,
  style: o,
  headerClass: l,
  headerProps: a,
  ns: r
}, {
  slots: i
}) => {
  const s = {
    columns: e,
    headerIndex: n
  }, u = [r.e("header-row"), Ii(l, s, ""), {
    [r.is("customized")]: !!i.header
  }], d = {
    ...Ii(a, s),
    columnsStyles: t,
    class: u,
    columns: e,
    headerIndex: n,
    style: o
  };
  return oe(hte, d, Rte(i) ? i : {
    default: () => [i]
  });
}, ME = (e, {
  slots: t
}) => {
  const {
    column: n,
    ns: o,
    style: l,
    onColumnSorted: a
  } = e, r = ms(l);
  if (n.placeholderSign === Kd)
    return oe("div", {
      class: o.em("header-row-cell", "placeholder"),
      style: r
    }, null);
  const {
    headerCellRenderer: i,
    headerClass: s,
    sortable: u
  } = n, d = {
    ...e,
    class: o.e("header-cell-text")
  }, f = MO(i), v = f ? f(d) : Ie(t, "default", d, () => [oe(w0, d, null)]), {
    sortBy: h,
    sortState: m,
    headerCellProps: p
  } = e;
  let C, g;
  if (m) {
    const y = m[n.key];
    C = !!eb[y], g = C ? y : zd.ASC;
  } else
    C = n.key === h.key, g = C ? h.order : zd.ASC;
  const w = [o.e("header-cell"), Ii(s, e, ""), n.align === Wd.CENTER && o.is("align-center"), n.align === Wd.RIGHT && o.is("align-right"), u && o.is("sortable")], b = {
    ...Ii(p, e),
    onClick: n.sortable ? a : void 0,
    class: w,
    style: r,
    "data-key": n.key
  };
  return oe("div", Et(b, {
    role: "columnheader"
  }), [v, u && oe(wte, {
    class: [o.e("sort-icon"), C && o.is("sorting")],
    sortOrder: g
  }, null)]);
}, LO = (e, {
  slots: t
}) => {
  var n;
  return oe("div", {
    class: e.class,
    style: e.style
  }, [(n = t.default) == null ? void 0 : n.call(t)]);
};
LO.displayName = "ElTableV2Footer";
const PO = (e, {
  slots: t
}) => {
  const n = Ie(t, "default", {}, () => [oe(P$, null, null)]);
  return oe("div", {
    class: e.class,
    style: e.style
  }, [n]);
};
PO.displayName = "ElTableV2Empty";
const AO = (e, {
  slots: t
}) => {
  var n;
  return oe("div", {
    class: e.class,
    style: e.style
  }, [(n = t.default) == null ? void 0 : n.call(t)]);
};
AO.displayName = "ElTableV2Overlay";
function Ou(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !yo(e);
}
const Lte = "ElTableV2", Pte = Q({
  name: Lte,
  props: pte,
  setup(e, {
    slots: t,
    expose: n
  }) {
    const o = nt("table-v2"), {
      columnsStyles: l,
      fixedColumnsOnLeft: a,
      fixedColumnsOnRight: r,
      mainColumns: i,
      mainTableHeight: s,
      fixedTableHeight: u,
      leftTableWidth: d,
      rightTableWidth: f,
      data: v,
      depthMap: h,
      expandedRowKeys: m,
      hasFixedColumns: p,
      mainTableRef: C,
      leftTableRef: g,
      rightTableRef: w,
      isDynamic: b,
      isResetting: y,
      isScrolling: E,
      bodyWidth: S,
      emptyStyle: _,
      rootStyle: k,
      headerWidth: N,
      footerHeight: L,
      showEmpty: R,
      scrollTo: H,
      scrollToLeft: K,
      scrollToTop: U,
      scrollToRow: W,
      getRowHeight: A,
      onColumnSorted: $,
      onRowHeightChange: D,
      onRowHovered: O,
      onRowExpanded: F,
      onRowsRendered: j,
      onScroll: Z,
      onVerticalScroll: te
    } = dte(e);
    return n({
      scrollTo: H,
      scrollToLeft: K,
      scrollToTop: U,
      scrollToRow: W
    }), Mt(g0, {
      ns: o,
      isResetting: y,
      isScrolling: E
    }), () => {
      const {
        cache: de,
        cellProps: Oe,
        estimatedRowHeight: ce,
        expandColumnKey: ne,
        fixedData: Y,
        headerHeight: ve,
        headerClass: ie,
        headerProps: he,
        headerCellProps: De,
        sortBy: $e,
        sortState: ue,
        rowHeight: Ne,
        rowClass: je,
        rowEventHandlers: Fe,
        rowKey: Ve,
        rowProps: Ze,
        scrollbarAlwaysOn: ae,
        indentSize: pe,
        iconSize: ke,
        useIsScrolling: Ue,
        vScrollbarSize: Xe,
        width: re
      } = e, Te = c(v), Ce = {
        cache: de,
        class: o.e("main"),
        columns: c(i),
        data: Te,
        fixedData: Y,
        estimatedRowHeight: ce,
        bodyWidth: c(S) + Xe,
        headerHeight: ve,
        headerWidth: c(N),
        height: c(s),
        mainTableRef: C,
        rowKey: Ve,
        rowHeight: Ne,
        scrollbarAlwaysOn: ae,
        scrollbarStartGap: 2,
        scrollbarEndGap: Xe,
        useIsScrolling: Ue,
        width: re,
        getRowHeight: A,
        onRowsRendered: j,
        onScroll: Z
      }, Le = c(d), ge = c(u), Ee = {
        cache: de,
        class: o.e("left"),
        columns: c(a),
        data: Te,
        estimatedRowHeight: ce,
        leftTableRef: g,
        rowHeight: Ne,
        bodyWidth: Le,
        headerWidth: Le,
        headerHeight: ve,
        height: ge,
        rowKey: Ve,
        scrollbarAlwaysOn: ae,
        scrollbarStartGap: 2,
        scrollbarEndGap: Xe,
        useIsScrolling: Ue,
        width: Le,
        getRowHeight: A,
        onScroll: te
      }, Ke = c(f) + Xe, Re = {
        cache: de,
        class: o.e("right"),
        columns: c(r),
        data: Te,
        estimatedRowHeight: ce,
        rightTableRef: w,
        rowHeight: Ne,
        bodyWidth: Ke,
        headerWidth: Ke,
        headerHeight: ve,
        height: ge,
        rowKey: Ve,
        scrollbarAlwaysOn: ae,
        scrollbarStartGap: 2,
        scrollbarEndGap: Xe,
        width: Ke,
        style: `--${c(o.namespace)}-table-scrollbar-size: ${Xe}px`,
        useIsScrolling: Ue,
        getRowHeight: A,
        onScroll: te
      }, we = c(l), ze = {
        ns: o,
        depthMap: c(h),
        columnsStyles: we,
        expandColumnKey: ne,
        expandedRowKeys: c(m),
        estimatedRowHeight: ce,
        hasFixedColumns: c(p),
        rowProps: Ze,
        rowClass: je,
        rowKey: Ve,
        rowEventHandlers: Fe,
        onRowHovered: O,
        onRowExpanded: F,
        onRowHeightChange: D
      }, Je = {
        cellProps: Oe,
        expandColumnKey: ne,
        indentSize: pe,
        iconSize: ke,
        rowKey: Ve,
        expandedRowKeys: c(m),
        ns: o
      }, Me = {
        ns: o,
        headerClass: ie,
        headerProps: he,
        columnsStyles: we
      }, et = {
        ns: o,
        sortBy: $e,
        sortState: ue,
        headerCellProps: De,
        onColumnSorted: $
      }, mt = {
        row: (an) => oe(Ite, Et(an, ze), {
          row: t.row,
          cell: (_t) => {
            let zt;
            return t.cell ? oe(tb, Et(_t, Je, {
              style: we[_t.column.key]
            }), Ou(zt = t.cell(_t)) ? zt : {
              default: () => [zt]
            }) : oe(tb, Et(_t, Je, {
              style: we[_t.column.key]
            }), null);
          }
        }),
        header: (an) => oe(Dte, Et(an, Me), {
          header: t.header,
          cell: (_t) => {
            let zt;
            return t["header-cell"] ? oe(ME, Et(_t, et, {
              style: we[_t.column.key]
            }), Ou(zt = t["header-cell"](_t)) ? zt : {
              default: () => [zt]
            }) : oe(ME, Et(_t, et, {
              style: we[_t.column.key]
            }), null);
          }
        })
      }, Lt = [e.class, o.b(), o.e("root"), {
        [o.is("dynamic")]: c(b)
      }], be = {
        class: o.e("footer"),
        style: c(L)
      };
      return oe("div", {
        class: Lt,
        style: c(k)
      }, [oe(kte, Ce, Ou(mt) ? mt : {
        default: () => [mt]
      }), oe($te, Ee, Ou(mt) ? mt : {
        default: () => [mt]
      }), oe(Nte, Re, Ou(mt) ? mt : {
        default: () => [mt]
      }), t.footer && oe(LO, be, {
        default: t.footer
      }), c(R) && oe(PO, {
        class: o.e("empty"),
        style: c(_)
      }, {
        default: t.empty
      }), t.overlay && oe(AO, {
        class: o.e("overlay")
      }, {
        default: t.overlay
      })]);
    };
  }
}), Ate = it({
  disableWidth: Boolean,
  disableHeight: Boolean,
  onResize: {
    type: Ae(Function)
  }
}), Fte = Q({
  name: "ElAutoResizer",
  props: Ate,
  setup(e, {
    slots: t
  }) {
    const n = nt("auto-resizer"), {
      height: o,
      width: l,
      sizer: a
    } = ute(e), r = {
      width: "100%",
      height: "100%"
    };
    return () => {
      var i;
      return oe("div", {
        ref: a,
        class: n.b(),
        style: r
      }, [(i = t.default) == null ? void 0 : i.call(t, {
        height: o.value,
        width: l.value
      })]);
    };
  }
}), Vte = Yt(Pte), Bte = Yt(Fte), Xv = Symbol("tabsRootContextKey"), Hte = it({
  tabs: {
    type: Ae(Array),
    default: () => Zn([])
  }
}), FO = "ElTabBar", zte = Q({
  name: FO
}), Wte = /* @__PURE__ */ Q({
  ...zte,
  props: Hte,
  setup(e, { expose: t }) {
    const n = e, o = Pt(), l = ot(Xv);
    l || lo(FO, "<el-tabs><el-tab-bar /></el-tabs>");
    const a = nt("tabs"), r = B(), i = B(), s = () => {
      let d = 0, f = 0;
      const v = ["top", "bottom"].includes(l.props.tabPosition) ? "width" : "height", h = v === "width" ? "x" : "y", m = h === "x" ? "left" : "top";
      return n.tabs.every((p) => {
        var C, g;
        const w = (g = (C = o.parent) == null ? void 0 : C.refs) == null ? void 0 : g[`tab-${p.uid}`];
        if (!w)
          return !1;
        if (!p.active)
          return !0;
        d = w[`offset${Qa(m)}`], f = w[`client${Qa(v)}`];
        const b = window.getComputedStyle(w);
        return v === "width" && (n.tabs.length > 1 && (f -= Number.parseFloat(b.paddingLeft) + Number.parseFloat(b.paddingRight)), d += Number.parseFloat(b.paddingLeft)), !1;
      }), {
        [v]: `${f}px`,
        transform: `translate${Qa(h)}(${d}px)`
      };
    }, u = () => i.value = s();
    return Pe(() => n.tabs, async () => {
      await xe(), u();
    }, { immediate: !0 }), Xn(r, () => u()), t({
      ref: r,
      update: u
    }), (d, f) => (M(), G("div", {
      ref_key: "barRef",
      ref: r,
      class: z([c(a).e("active-bar"), c(a).is(c(l).props.tabPosition)]),
      style: bt(i.value)
    }, null, 6));
  }
});
var Kte = /* @__PURE__ */ ut(Wte, [["__file", "tab-bar.vue"]]);
const Ute = it({
  panes: {
    type: Ae(Array),
    default: () => Zn([])
  },
  currentName: {
    type: [String, Number],
    default: ""
  },
  editable: Boolean,
  type: {
    type: String,
    values: ["card", "border-card", ""],
    default: ""
  },
  stretch: Boolean
}), jte = {
  tabClick: (e, t, n) => n instanceof Event,
  tabRemove: (e, t) => t instanceof Event
}, IE = "ElTabNav", qte = Q({
  name: IE,
  props: Ute,
  emits: jte,
  setup(e, {
    expose: t,
    emit: n
  }) {
    const o = Pt(), l = ot(Xv);
    l || lo(IE, "<el-tabs><tab-nav /></el-tabs>");
    const a = nt("tabs"), r = z3(), i = eD(), s = B(), u = B(), d = B(), f = B(), v = B(!1), h = B(0), m = B(!1), p = B(!0), C = x(() => ["top", "bottom"].includes(l.props.tabPosition) ? "width" : "height"), g = x(() => ({
      transform: `translate${C.value === "width" ? "X" : "Y"}(-${h.value}px)`
    })), w = () => {
      if (!s.value)
        return;
      const N = s.value[`offset${Qa(C.value)}`], L = h.value;
      if (!L)
        return;
      const R = L > N ? L - N : 0;
      h.value = R;
    }, b = () => {
      if (!s.value || !u.value)
        return;
      const N = u.value[`offset${Qa(C.value)}`], L = s.value[`offset${Qa(C.value)}`], R = h.value;
      if (N - R <= L)
        return;
      const H = N - R > L * 2 ? R + L : N - L;
      h.value = H;
    }, y = async () => {
      const N = u.value;
      if (!v.value || !d.value || !s.value || !N)
        return;
      await xe();
      const L = d.value.querySelector(".is-active");
      if (!L)
        return;
      const R = s.value, H = ["top", "bottom"].includes(l.props.tabPosition), K = L.getBoundingClientRect(), U = R.getBoundingClientRect(), W = H ? N.offsetWidth - U.width : N.offsetHeight - U.height, A = h.value;
      let $ = A;
      H ? (K.left < U.left && ($ = A - (U.left - K.left)), K.right > U.right && ($ = A + K.right - U.right)) : (K.top < U.top && ($ = A - (U.top - K.top)), K.bottom > U.bottom && ($ = A + (K.bottom - U.bottom))), $ = Math.max($, 0), h.value = Math.min($, W);
    }, E = () => {
      var N;
      if (!u.value || !s.value)
        return;
      e.stretch && ((N = f.value) == null || N.update());
      const L = u.value[`offset${Qa(C.value)}`], R = s.value[`offset${Qa(C.value)}`], H = h.value;
      R < L ? (v.value = v.value || {}, v.value.prev = H, v.value.next = H + R < L, L - H < R && (h.value = L - R)) : (v.value = !1, H > 0 && (h.value = 0));
    }, S = (N) => {
      const L = N.code, {
        up: R,
        down: H,
        left: K,
        right: U
      } = xt;
      if (![R, H, K, U].includes(L))
        return;
      const W = Array.from(N.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)")), A = W.indexOf(N.target);
      let $;
      L === K || L === R ? A === 0 ? $ = W.length - 1 : $ = A - 1 : A < W.length - 1 ? $ = A + 1 : $ = 0, W[$].focus({
        preventScroll: !0
      }), W[$].click(), _();
    }, _ = () => {
      p.value && (m.value = !0);
    }, k = () => m.value = !1;
    return Pe(r, (N) => {
      N === "hidden" ? p.value = !1 : N === "visible" && setTimeout(() => p.value = !0, 50);
    }), Pe(i, (N) => {
      N ? setTimeout(() => p.value = !0, 50) : p.value = !1;
    }), Xn(d, E), Nt(() => setTimeout(() => y(), 0)), Pi(() => E()), t({
      scrollToActiveTab: y,
      removeFocus: k
    }), Pe(() => e.panes, () => o.update(), {
      flush: "post",
      deep: !0
    }), () => {
      const N = v.value ? [oe("span", {
        class: [a.e("nav-prev"), a.is("disabled", !v.value.prev)],
        onClick: w
      }, [oe(Ct, null, {
        default: () => [oe(ks, null, null)]
      })]), oe("span", {
        class: [a.e("nav-next"), a.is("disabled", !v.value.next)],
        onClick: b
      }, [oe(Ct, null, {
        default: () => [oe(xl, null, null)]
      })])] : null, L = e.panes.map((R, H) => {
        var K, U, W, A;
        const $ = R.uid, D = R.props.disabled, O = (U = (K = R.props.name) != null ? K : R.index) != null ? U : `${H}`, F = !D && (R.isClosable || e.editable);
        R.index = `${H}`;
        const j = F ? oe(Ct, {
          class: "is-icon-close",
          onClick: (de) => n("tabRemove", R, de)
        }, {
          default: () => [oe(Fa, null, null)]
        }) : null, Z = ((A = (W = R.slots).label) == null ? void 0 : A.call(W)) || R.props.label, te = !D && R.active ? 0 : -1;
        return oe("div", {
          ref: `tab-${$}`,
          class: [a.e("item"), a.is(l.props.tabPosition), a.is("active", R.active), a.is("disabled", D), a.is("closable", F), a.is("focus", m.value)],
          id: `tab-${O}`,
          key: `tab-${$}`,
          "aria-controls": `pane-${O}`,
          role: "tab",
          "aria-selected": R.active,
          tabindex: te,
          onFocus: () => _(),
          onBlur: () => k(),
          onClick: (de) => {
            k(), n("tabClick", R, O, de);
          },
          onKeydown: (de) => {
            F && (de.code === xt.delete || de.code === xt.backspace) && n("tabRemove", R, de);
          }
        }, [Z, j]);
      });
      return oe("div", {
        ref: d,
        class: [a.e("nav-wrap"), a.is("scrollable", !!v.value), a.is(l.props.tabPosition)]
      }, [N, oe("div", {
        class: a.e("nav-scroll"),
        ref: s
      }, [oe("div", {
        class: [a.e("nav"), a.is(l.props.tabPosition), a.is("stretch", e.stretch && ["top", "bottom"].includes(l.props.tabPosition))],
        ref: u,
        style: g.value,
        role: "tablist",
        onKeydown: S
      }, [e.type ? null : oe(Kte, {
        ref: f,
        tabs: [...e.panes]
      }, null), L])])]);
    };
  }
}), Yte = it({
  type: {
    type: String,
    values: ["card", "border-card", ""],
    default: ""
  },
  closable: Boolean,
  addable: Boolean,
  modelValue: {
    type: [String, Number]
  },
  editable: Boolean,
  tabPosition: {
    type: String,
    values: ["top", "right", "bottom", "left"],
    default: "top"
  },
  beforeLeave: {
    type: Ae(Function),
    default: () => !0
  },
  stretch: Boolean
}), fm = (e) => on(e) || Ot(e), Gte = {
  [Jt]: (e) => fm(e),
  tabClick: (e, t) => t instanceof Event,
  tabChange: (e) => fm(e),
  edit: (e, t) => ["remove", "add"].includes(t),
  tabRemove: (e) => fm(e),
  tabAdd: () => !0
}, Xte = Q({
  name: "ElTabs",
  props: Yte,
  emits: Gte,
  setup(e, {
    emit: t,
    slots: n,
    expose: o
  }) {
    var l;
    const a = nt("tabs"), {
      children: r,
      addChild: i,
      removeChild: s
    } = Ly(Pt(), "ElTabPane"), u = B(), d = B((l = e.modelValue) != null ? l : "0"), f = async (p, C = !1) => {
      var g, w, b;
      if (!(d.value === p || To(p)))
        try {
          await ((g = e.beforeLeave) == null ? void 0 : g.call(e, p, d.value)) !== !1 && (d.value = p, C && (t(Jt, p), t("tabChange", p)), (b = (w = u.value) == null ? void 0 : w.removeFocus) == null || b.call(w));
        } catch {
        }
    }, v = (p, C, g) => {
      p.props.disabled || (f(C, !0), t("tabClick", p, g));
    }, h = (p, C) => {
      p.props.disabled || To(p.props.name) || (C.stopPropagation(), t("edit", p.props.name, "remove"), t("tabRemove", p.props.name));
    }, m = () => {
      t("edit", void 0, "add"), t("tabAdd");
    };
    return Pe(() => e.modelValue, (p) => f(p)), Pe(d, async () => {
      var p;
      await xe(), (p = u.value) == null || p.scrollToActiveTab();
    }), Mt(Xv, {
      props: e,
      currentName: d,
      registerPane: i,
      unregisterPane: s
    }), o({
      currentName: d
    }), () => {
      const p = n["add-icon"], C = e.editable || e.addable ? oe("span", {
        class: a.e("new-tab"),
        tabindex: "0",
        onClick: m,
        onKeydown: (b) => {
          b.code === xt.enter && m();
        }
      }, [p ? Ie(n, "add-icon") : oe(Ct, {
        class: a.is("icon-plus")
      }, {
        default: () => [oe(Gx, null, null)]
      })]) : null, g = oe("div", {
        class: [a.e("header"), a.is(e.tabPosition)]
      }, [C, oe(qte, {
        ref: u,
        currentName: d.value,
        editable: e.editable,
        type: e.type,
        panes: r.value,
        stretch: e.stretch,
        onTabClick: v,
        onTabRemove: h
      }, null)]), w = oe("div", {
        class: a.e("content")
      }, [Ie(n, "default")]);
      return oe("div", {
        class: [a.b(), a.m(e.tabPosition), {
          [a.m("card")]: e.type === "card",
          [a.m("border-card")]: e.type === "border-card"
        }]
      }, [...e.tabPosition !== "bottom" ? [g, w] : [w, g]]);
    };
  }
}), Zte = it({
  label: {
    type: String,
    default: ""
  },
  name: {
    type: [String, Number]
  },
  closable: Boolean,
  disabled: Boolean,
  lazy: Boolean
}), Jte = ["id", "aria-hidden", "aria-labelledby"], VO = "ElTabPane", Qte = Q({
  name: VO
}), ene = /* @__PURE__ */ Q({
  ...Qte,
  props: Zte,
  setup(e) {
    const t = e, n = Pt(), o = Yn(), l = ot(Xv);
    l || lo(VO, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
    const a = nt("tab-pane"), r = B(), i = x(() => t.closable || l.props.closable), s = lC(() => {
      var h;
      return l.currentName.value === ((h = t.name) != null ? h : r.value);
    }), u = B(s.value), d = x(() => {
      var h;
      return (h = t.name) != null ? h : r.value;
    }), f = lC(() => !t.lazy || u.value || s.value);
    Pe(s, (h) => {
      h && (u.value = !0);
    });
    const v = en({
      uid: n.uid,
      slots: o,
      props: t,
      paneName: d,
      active: s,
      index: r,
      isClosable: i
    });
    return Nt(() => {
      l.registerPane(v);
    }), wo(() => {
      l.unregisterPane(v.uid);
    }), (h, m) => c(f) ? Bt((M(), G("div", {
      key: 0,
      id: `pane-${c(d)}`,
      class: z(c(a).b()),
      role: "tabpanel",
      "aria-hidden": !c(s),
      "aria-labelledby": `tab-${c(d)}`
    }, [
      Ie(h.$slots, "default")
    ], 10, Jte)), [
      [pn, c(s)]
    ]) : _e("v-if", !0);
  }
});
var BO = /* @__PURE__ */ ut(ene, [["__file", "tab-pane.vue"]]);
const HO = Yt(Xte, {
  TabPane: BO
}), zO = Jn(BO), tne = it({
  type: {
    type: String,
    values: ["primary", "success", "info", "warning", "danger", ""],
    default: ""
  },
  size: {
    type: String,
    values: fr,
    default: ""
  },
  truncated: {
    type: Boolean
  },
  lineClamp: {
    type: [String, Number]
  },
  tag: {
    type: String,
    default: "span"
  }
}), nne = Q({
  name: "ElText"
}), one = /* @__PURE__ */ Q({
  ...nne,
  props: tne,
  setup(e) {
    const t = e, n = Mo(), o = nt("text"), l = x(() => [
      o.b(),
      o.m(t.type),
      o.m(n.value),
      o.is("truncated", t.truncated),
      o.is("line-clamp", !To(t.lineClamp))
    ]);
    return (a, r) => (M(), We(Qt(a.tag), {
      class: z(c(l)),
      style: bt({ "-webkit-line-clamp": a.lineClamp })
    }, {
      default: fe(() => [
        Ie(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "style"]));
  }
});
var lne = /* @__PURE__ */ ut(one, [["__file", "text.vue"]]);
const ane = Yt(lne), rne = it({
  format: {
    type: String,
    default: "HH:mm"
  },
  modelValue: String,
  disabled: Boolean,
  editable: {
    type: Boolean,
    default: !0
  },
  effect: {
    type: String,
    default: "light"
  },
  clearable: {
    type: Boolean,
    default: !0
  },
  size: Lo,
  placeholder: String,
  start: {
    type: String,
    default: "09:00"
  },
  end: {
    type: String,
    default: "18:00"
  },
  step: {
    type: String,
    default: "00:30"
  },
  minTime: String,
  maxTime: String,
  name: String,
  prefixIcon: {
    type: Ae([String, Object]),
    default: () => Yx
  },
  clearIcon: {
    type: Ae([String, Object]),
    default: () => Ls
  },
  ...ru
}), $r = (e) => {
  const t = (e || "").split(":");
  if (t.length >= 2) {
    let n = Number.parseInt(t[0], 10);
    const o = Number.parseInt(t[1], 10), l = e.toUpperCase();
    return l.includes("AM") && n === 12 ? n = 0 : l.includes("PM") && n !== 12 && (n += 12), {
      hours: n,
      minutes: o
    };
  }
  return null;
}, pm = (e, t) => {
  const n = $r(e);
  if (!n)
    return -1;
  const o = $r(t);
  if (!o)
    return -1;
  const l = n.minutes + n.hours * 60, a = o.minutes + o.hours * 60;
  return l === a ? 0 : l > a ? 1 : -1;
}, RE = (e) => `${e}`.padStart(2, "0"), pc = (e) => `${RE(e.hours)}:${RE(e.minutes)}`, sne = (e, t) => {
  const n = $r(e);
  if (!n)
    return "";
  const o = $r(t);
  if (!o)
    return "";
  const l = {
    hours: n.hours,
    minutes: n.minutes
  };
  return l.minutes += o.minutes, l.hours += o.hours, l.hours += Math.floor(l.minutes / 60), l.minutes = l.minutes % 60, pc(l);
}, ine = Q({
  name: "ElTimeSelect"
}), cne = /* @__PURE__ */ Q({
  ...ine,
  props: rne,
  emits: ["change", "blur", "focus", "update:modelValue"],
  setup(e, { expose: t }) {
    const n = e;
    Gt.extend(Wy);
    const { Option: o } = Ns, l = nt("input"), a = B(), r = Nl(), { lang: i } = bn(), s = x(() => n.modelValue), u = x(() => {
      const g = $r(n.start);
      return g ? pc(g) : null;
    }), d = x(() => {
      const g = $r(n.end);
      return g ? pc(g) : null;
    }), f = x(() => {
      const g = $r(n.step);
      return g ? pc(g) : null;
    }), v = x(() => {
      const g = $r(n.minTime || "");
      return g ? pc(g) : null;
    }), h = x(() => {
      const g = $r(n.maxTime || "");
      return g ? pc(g) : null;
    }), m = x(() => {
      const g = [];
      if (n.start && n.end && n.step) {
        let w = u.value, b;
        for (; w && d.value && pm(w, d.value) <= 0; )
          b = Gt(w, "HH:mm").locale(i.value).format(n.format), g.push({
            value: b,
            disabled: pm(w, v.value || "-1:-1") <= 0 || pm(w, h.value || "100:100") >= 0
          }), w = sne(w, f.value);
      }
      return g;
    });
    return t({
      blur: () => {
        var g, w;
        (w = (g = a.value) == null ? void 0 : g.blur) == null || w.call(g);
      },
      focus: () => {
        var g, w;
        (w = (g = a.value) == null ? void 0 : g.focus) == null || w.call(g);
      }
    }), (g, w) => (M(), We(c(Ns), {
      ref_key: "select",
      ref: a,
      "model-value": c(s),
      disabled: c(r),
      clearable: g.clearable,
      "clear-icon": g.clearIcon,
      size: g.size,
      effect: g.effect,
      placeholder: g.placeholder,
      "default-first-option": "",
      filterable: g.editable,
      "empty-values": g.emptyValues,
      "value-on-clear": g.valueOnClear,
      "onUpdate:modelValue": w[0] || (w[0] = (b) => g.$emit("update:modelValue", b)),
      onChange: w[1] || (w[1] = (b) => g.$emit("change", b)),
      onBlur: w[2] || (w[2] = (b) => g.$emit("blur", b)),
      onFocus: w[3] || (w[3] = (b) => g.$emit("focus", b))
    }, {
      prefix: fe(() => [
        g.prefixIcon ? (M(), We(c(Ct), {
          key: 0,
          class: z(c(l).e("prefix-icon"))
        }, {
          default: fe(() => [
            (M(), We(Qt(g.prefixIcon)))
          ]),
          _: 1
        }, 8, ["class"])) : _e("v-if", !0)
      ]),
      default: fe(() => [
        (M(!0), G(kt, null, ln(c(m), (b) => (M(), We(c(o), {
          key: b.value,
          label: b.value,
          value: b.value,
          disabled: b.disabled
        }, null, 8, ["label", "value", "disabled"]))), 128))
      ]),
      _: 1
    }, 8, ["model-value", "disabled", "clearable", "clear-icon", "size", "effect", "placeholder", "filterable", "empty-values", "value-on-clear"]));
  }
});
var Rp = /* @__PURE__ */ ut(cne, [["__file", "time-select.vue"]]);
Rp.install = (e) => {
  e.component(Rp.name, Rp);
};
const une = Rp, dne = une, fne = Q({
  name: "ElTimeline",
  setup(e, { slots: t }) {
    const n = nt("timeline");
    return Mt("timeline", t), () => V("ul", { class: [n.b()] }, [Ie(t, "default")]);
  }
}), pne = it({
  timestamp: {
    type: String,
    default: ""
  },
  hideTimestamp: {
    type: Boolean,
    default: !1
  },
  center: {
    type: Boolean,
    default: !1
  },
  placement: {
    type: String,
    values: ["top", "bottom"],
    default: "bottom"
  },
  type: {
    type: String,
    values: ["primary", "success", "warning", "danger", "info"],
    default: ""
  },
  color: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    values: ["normal", "large"],
    default: "normal"
  },
  icon: {
    type: Dn
  },
  hollow: {
    type: Boolean,
    default: !1
  }
}), vne = Q({
  name: "ElTimelineItem"
}), hne = /* @__PURE__ */ Q({
  ...vne,
  props: pne,
  setup(e) {
    const t = e, n = nt("timeline-item"), o = x(() => [
      n.e("node"),
      n.em("node", t.size || ""),
      n.em("node", t.type || ""),
      n.is("hollow", t.hollow)
    ]);
    return (l, a) => (M(), G("li", {
      class: z([c(n).b(), { [c(n).e("center")]: l.center }])
    }, [
      X("div", {
        class: z(c(n).e("tail"))
      }, null, 2),
      l.$slots.dot ? _e("v-if", !0) : (M(), G("div", {
        key: 0,
        class: z(c(o)),
        style: bt({
          backgroundColor: l.color
        })
      }, [
        l.icon ? (M(), We(c(Ct), {
          key: 0,
          class: z(c(n).e("icon"))
        }, {
          default: fe(() => [
            (M(), We(Qt(l.icon)))
          ]),
          _: 1
        }, 8, ["class"])) : _e("v-if", !0)
      ], 6)),
      l.$slots.dot ? (M(), G("div", {
        key: 1,
        class: z(c(n).e("dot"))
      }, [
        Ie(l.$slots, "dot")
      ], 2)) : _e("v-if", !0),
      X("div", {
        class: z(c(n).e("wrapper"))
      }, [
        !l.hideTimestamp && l.placement === "top" ? (M(), G("div", {
          key: 0,
          class: z([c(n).e("timestamp"), c(n).is("top")])
        }, Qe(l.timestamp), 3)) : _e("v-if", !0),
        X("div", {
          class: z(c(n).e("content"))
        }, [
          Ie(l.$slots, "default")
        ], 2),
        !l.hideTimestamp && l.placement === "bottom" ? (M(), G("div", {
          key: 1,
          class: z([c(n).e("timestamp"), c(n).is("bottom")])
        }, Qe(l.timestamp), 3)) : _e("v-if", !0)
      ], 2)
    ], 2));
  }
});
var WO = /* @__PURE__ */ ut(hne, [["__file", "timeline-item.vue"]]);
const mne = Yt(fne, {
  TimelineItem: WO
}), gne = Jn(WO), KO = it({
  nowrap: Boolean
});
var UO = /* @__PURE__ */ ((e) => (e.top = "top", e.bottom = "bottom", e.left = "left", e.right = "right", e))(UO || {});
const bne = Object.values(UO), S0 = it({
  width: {
    type: Number,
    default: 10
  },
  height: {
    type: Number,
    default: 10
  },
  style: {
    type: Ae(Object),
    default: null
  }
}), yne = it({
  side: {
    type: Ae(String),
    values: bne,
    required: !0
  }
}), Cne = ["absolute", "fixed"], wne = [
  "top-start",
  "top-end",
  "top",
  "bottom-start",
  "bottom-end",
  "bottom",
  "left-start",
  "left-end",
  "left",
  "right-start",
  "right-end",
  "right"
], _0 = it({
  arrowPadding: {
    type: Ae(Number),
    default: 5
  },
  effect: {
    type: String,
    default: ""
  },
  contentClass: String,
  placement: {
    type: Ae(String),
    values: wne,
    default: "bottom"
  },
  reference: {
    type: Ae(Object),
    default: null
  },
  offset: {
    type: Number,
    default: 8
  },
  strategy: {
    type: Ae(String),
    values: Cne,
    default: "absolute"
  },
  showArrow: {
    type: Boolean,
    default: !1
  },
  ...Zo(["ariaLabel"])
}), x0 = it({
  delayDuration: {
    type: Number,
    default: 300
  },
  defaultOpen: Boolean,
  open: {
    type: Boolean,
    default: void 0
  },
  onOpenChange: {
    type: Ae(Function)
  },
  "onUpdate:open": {
    type: Ae(Function)
  }
}), Qi = {
  type: Ae(Function)
}, k0 = it({
  onBlur: Qi,
  onClick: Qi,
  onFocus: Qi,
  onMouseDown: Qi,
  onMouseEnter: Qi,
  onMouseLeave: Qi
}), Ene = it({
  ...x0,
  ...S0,
  ...k0,
  ..._0,
  alwaysOn: Boolean,
  fullTransition: Boolean,
  transitionProps: {
    type: Ae(Object),
    default: null
  },
  teleported: Boolean,
  to: {
    type: Ae(String),
    default: "body"
  }
}), Zv = Symbol("tooltipV2"), jO = Symbol("tooltipV2Content"), vm = "tooltip_v2.open", Sne = Q({
  name: "ElTooltipV2Root"
}), _ne = /* @__PURE__ */ Q({
  ...Sne,
  props: x0,
  setup(e, { expose: t }) {
    const n = e, o = B(n.defaultOpen), l = B(null), a = x({
      get: () => $i(n.open) ? o.value : n.open,
      set: (C) => {
        var g;
        o.value = C, (g = n["onUpdate:open"]) == null || g.call(n, C);
      }
    }), r = x(() => Ot(n.delayDuration) && n.delayDuration > 0), { start: i, stop: s } = ki(() => {
      a.value = !0;
    }, x(() => n.delayDuration), {
      immediate: !1
    }), u = nt("tooltip-v2"), d = il(), f = () => {
      s(), a.value = !0;
    }, v = () => {
      c(r) ? i() : f();
    }, h = f, m = () => {
      s(), a.value = !1;
    };
    return Pe(a, (C) => {
      var g;
      C && (document.dispatchEvent(new CustomEvent(vm)), h()), (g = n.onOpenChange) == null || g.call(n, C);
    }), Nt(() => {
      document.addEventListener(vm, m);
    }), zn(() => {
      s(), document.removeEventListener(vm, m);
    }), Mt(Zv, {
      contentId: d,
      triggerRef: l,
      ns: u,
      onClose: m,
      onDelayOpen: v,
      onOpen: h
    }), t({
      onOpen: h,
      onClose: m
    }), (C, g) => Ie(C.$slots, "default", { open: c(a) });
  }
});
var xne = /* @__PURE__ */ ut(_ne, [["__file", "root.vue"]]);
const kne = Q({
  name: "ElTooltipV2Arrow"
}), Tne = /* @__PURE__ */ Q({
  ...kne,
  props: {
    ...S0,
    ...yne
  },
  setup(e) {
    const t = e, { ns: n } = ot(Zv), { arrowRef: o } = ot(jO), l = x(() => {
      const { style: a, width: r, height: i } = t, s = n.namespace.value;
      return {
        [`--${s}-tooltip-v2-arrow-width`]: `${r}px`,
        [`--${s}-tooltip-v2-arrow-height`]: `${i}px`,
        [`--${s}-tooltip-v2-arrow-border-width`]: `${r / 2}px`,
        [`--${s}-tooltip-v2-arrow-cover-width`]: r / 2 - 1,
        ...a || {}
      };
    });
    return (a, r) => (M(), G("span", {
      ref_key: "arrowRef",
      ref: o,
      style: bt(c(l)),
      class: z(c(n).e("arrow"))
    }, null, 6));
  }
});
var DE = /* @__PURE__ */ ut(Tne, [["__file", "arrow.vue"]]);
const $ne = it({
  style: {
    type: Ae([String, Object, Array]),
    default: () => ({})
  }
}), One = Q({
  name: "ElVisuallyHidden"
}), Nne = /* @__PURE__ */ Q({
  ...One,
  props: $ne,
  setup(e) {
    const t = e, n = x(() => [
      t.style,
      {
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal"
      }
    ]);
    return (o, l) => (M(), G("span", Et(o.$attrs, { style: c(n) }), [
      Ie(o.$slots, "default")
    ], 16));
  }
});
var Mne = /* @__PURE__ */ ut(Nne, [["__file", "visual-hidden.vue"]]);
const Ine = ["data-side"], Rne = Q({
  name: "ElTooltipV2Content"
}), Dne = /* @__PURE__ */ Q({
  ...Rne,
  props: { ..._0, ...KO },
  setup(e) {
    const t = e, { triggerRef: n, contentId: o } = ot(Zv), l = B(t.placement), a = B(t.strategy), r = B(null), { referenceRef: i, contentRef: s, middlewareData: u, x: d, y: f, update: v } = N5({
      placement: l,
      strategy: a,
      middleware: x(() => {
        const b = [Ok(t.offset)];
        return t.showArrow && b.push(M5({
          arrowRef: r
        })), b;
      })
    }), h = au().nextZIndex(), m = nt("tooltip-v2"), p = x(() => l.value.split("-")[0]), C = x(() => ({
      position: c(a),
      top: `${c(f) || 0}px`,
      left: `${c(d) || 0}px`,
      zIndex: h
    })), g = x(() => {
      if (!t.showArrow)
        return {};
      const { arrow: b } = c(u);
      return {
        [`--${m.namespace.value}-tooltip-v2-arrow-x`]: `${b == null ? void 0 : b.x}px` || "",
        [`--${m.namespace.value}-tooltip-v2-arrow-y`]: `${b == null ? void 0 : b.y}px` || ""
      };
    }), w = x(() => [
      m.e("content"),
      m.is("dark", t.effect === "dark"),
      m.is(c(a)),
      t.contentClass
    ]);
    return Pe(r, () => v()), Pe(() => t.placement, (b) => l.value = b), Nt(() => {
      Pe(() => t.reference || n.value, (b) => {
        i.value = b || void 0;
      }, {
        immediate: !0
      });
    }), Mt(jO, { arrowRef: r }), (b, y) => (M(), G("div", {
      ref_key: "contentRef",
      ref: s,
      style: bt(c(C)),
      "data-tooltip-v2-root": ""
    }, [
      b.nowrap ? _e("v-if", !0) : (M(), G("div", {
        key: 0,
        "data-side": c(p),
        class: z(c(w))
      }, [
        Ie(b.$slots, "default", {
          contentStyle: c(C),
          contentClass: c(w)
        }),
        oe(c(Mne), {
          id: c(o),
          role: "tooltip"
        }, {
          default: fe(() => [
            b.ariaLabel ? (M(), G(kt, { key: 0 }, [
              Ut(Qe(b.ariaLabel), 1)
            ], 64)) : Ie(b.$slots, "default", { key: 1 })
          ]),
          _: 3
        }, 8, ["id"]),
        Ie(b.$slots, "arrow", {
          style: bt(c(g)),
          side: c(p)
        })
      ], 10, Ine))
    ], 4));
  }
});
var LE = /* @__PURE__ */ ut(Dne, [["__file", "content.vue"]]);
const Lne = it({
  setRef: {
    type: Ae(Function),
    required: !0
  },
  onlyChild: Boolean
});
var Pne = Q({
  props: Lne,
  setup(e, {
    slots: t
  }) {
    const n = B(), o = Dv(n, (l) => {
      l ? e.setRef(l.nextElementSibling) : e.setRef(null);
    });
    return () => {
      var l;
      const [a] = ((l = t.default) == null ? void 0 : l.call(t)) || [], r = e.onlyChild ? pV(a.children) : a.children;
      return oe(kt, {
        ref: o
      }, [r]);
    };
  }
});
const Ane = Q({
  name: "ElTooltipV2Trigger"
}), Fne = /* @__PURE__ */ Q({
  ...Ane,
  props: {
    ...KO,
    ...k0
  },
  setup(e) {
    const t = e, { onClose: n, onOpen: o, onDelayOpen: l, triggerRef: a, contentId: r } = ot(Zv);
    let i = !1;
    const s = (w) => {
      a.value = w;
    }, u = () => {
      i = !1;
    }, d = uo(t.onMouseEnter, l), f = uo(t.onMouseLeave, n), v = uo(t.onMouseDown, () => {
      n(), i = !0, document.addEventListener("mouseup", u, { once: !0 });
    }), h = uo(t.onFocus, () => {
      i || o();
    }), m = uo(t.onBlur, n), p = uo(t.onClick, (w) => {
      w.detail === 0 && n();
    }), C = {
      blur: m,
      click: p,
      focus: h,
      mousedown: v,
      mouseenter: d,
      mouseleave: f
    }, g = (w, b, y) => {
      w && Object.entries(b).forEach(([E, S]) => {
        w[y](E, S);
      });
    };
    return Pe(a, (w, b) => {
      g(w, C, "addEventListener"), g(b, C, "removeEventListener"), w && w.setAttribute("aria-describedby", r.value);
    }), zn(() => {
      g(a.value, C, "removeEventListener"), document.removeEventListener("mouseup", u);
    }), (w, b) => w.nowrap ? (M(), We(c(Pne), {
      key: 0,
      "set-ref": s,
      "only-child": ""
    }, {
      default: fe(() => [
        Ie(w.$slots, "default")
      ]),
      _: 3
    })) : (M(), G("button", Et({
      key: 1,
      ref_key: "triggerRef",
      ref: a
    }, w.$attrs), [
      Ie(w.$slots, "default")
    ], 16));
  }
});
var Vne = /* @__PURE__ */ ut(Fne, [["__file", "trigger.vue"]]);
const Bne = Q({
  name: "ElTooltipV2"
}), Hne = /* @__PURE__ */ Q({
  ...Bne,
  props: Ene,
  setup(e) {
    const n = Xo(e), o = en(er(n, Object.keys(S0))), l = en(er(n, Object.keys(_0))), a = en(er(n, Object.keys(x0))), r = en(er(n, Object.keys(k0)));
    return (i, s) => (M(), We(xne, xo(Ao(a)), {
      default: fe(({ open: u }) => [
        oe(Vne, Et(r, { nowrap: "" }), {
          default: fe(() => [
            Ie(i.$slots, "trigger")
          ]),
          _: 3
        }, 16),
        (M(), We(ka, {
          to: i.to,
          disabled: !i.teleported
        }, [
          i.fullTransition ? (M(), We(Ko, xo(Et({ key: 0 }, i.transitionProps)), {
            default: fe(() => [
              i.alwaysOn || u ? (M(), We(LE, xo(Et({ key: 0 }, l)), {
                arrow: fe(({ style: d, side: f }) => [
                  i.showArrow ? (M(), We(DE, Et({ key: 0 }, o, {
                    style: d,
                    side: f
                  }), null, 16, ["style", "side"])) : _e("v-if", !0)
                ]),
                default: fe(() => [
                  Ie(i.$slots, "default")
                ]),
                _: 3
              }, 16)) : _e("v-if", !0)
            ]),
            _: 2
          }, 1040)) : (M(), G(kt, { key: 1 }, [
            i.alwaysOn || u ? (M(), We(LE, xo(Et({ key: 0 }, l)), {
              arrow: fe(({ style: d, side: f }) => [
                i.showArrow ? (M(), We(DE, Et({ key: 0 }, o, {
                  style: d,
                  side: f
                }), null, 16, ["style", "side"])) : _e("v-if", !0)
              ]),
              default: fe(() => [
                Ie(i.$slots, "default")
              ]),
              _: 3
            }, 16)) : _e("v-if", !0)
          ], 64))
        ], 8, ["to", "disabled"]))
      ]),
      _: 3
    }, 16));
  }
});
var zne = /* @__PURE__ */ ut(Hne, [["__file", "tooltip.vue"]]);
const Wne = Yt(zne), qO = "left-check-change", YO = "right-check-change", vc = it({
  data: {
    type: Ae(Array),
    default: () => []
  },
  titles: {
    type: Ae(Array),
    default: () => []
  },
  buttonTexts: {
    type: Ae(Array),
    default: () => []
  },
  filterPlaceholder: String,
  filterMethod: {
    type: Ae(Function)
  },
  leftDefaultChecked: {
    type: Ae(Array),
    default: () => []
  },
  rightDefaultChecked: {
    type: Ae(Array),
    default: () => []
  },
  renderContent: {
    type: Ae(Function)
  },
  modelValue: {
    type: Ae(Array),
    default: () => []
  },
  format: {
    type: Ae(Object),
    default: () => ({})
  },
  filterable: Boolean,
  props: {
    type: Ae(Object),
    default: () => Zn({
      label: "label",
      key: "key",
      disabled: "disabled"
    })
  },
  targetOrder: {
    type: String,
    values: ["original", "push", "unshift"],
    default: "original"
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), nb = (e, t) => [e, t].every(Kt) || Kt(e) && zo(t), Kne = {
  [qn]: (e, t, n) => [e, n].every(Kt) && ["left", "right"].includes(t),
  [Jt]: (e) => Kt(e),
  [qO]: nb,
  [YO]: nb
}, ob = "checked-change", Une = it({
  data: vc.data,
  optionRender: {
    type: Ae(Function)
  },
  placeholder: String,
  title: String,
  filterable: Boolean,
  format: vc.format,
  filterMethod: vc.filterMethod,
  defaultChecked: vc.leftDefaultChecked,
  props: vc.props
}), jne = {
  [ob]: nb
}, mf = (e) => {
  const t = {
    label: "label",
    key: "key",
    disabled: "disabled"
  };
  return x(() => ({
    ...t,
    ...e.props
  }));
}, qne = (e, t, n) => {
  const o = mf(e), l = x(() => e.data.filter((d) => vn(e.filterMethod) ? e.filterMethod(t.query, d) : String(d[o.value.label] || d[o.value.key]).toLowerCase().includes(t.query.toLowerCase()))), a = x(() => l.value.filter((d) => !d[o.value.disabled])), r = x(() => {
    const d = t.checked.length, f = e.data.length, { noChecked: v, hasChecked: h } = e.format;
    return v && h ? d > 0 ? h.replace(/\${checked}/g, d.toString()).replace(/\${total}/g, f.toString()) : v.replace(/\${total}/g, f.toString()) : `${d}/${f}`;
  }), i = x(() => {
    const d = t.checked.length;
    return d > 0 && d < a.value.length;
  }), s = () => {
    const d = a.value.map((f) => f[o.value.key]);
    t.allChecked = d.length > 0 && d.every((f) => t.checked.includes(f));
  }, u = (d) => {
    t.checked = d ? a.value.map((f) => f[o.value.key]) : [];
  };
  return Pe(() => t.checked, (d, f) => {
    if (s(), t.checkChangeByUser) {
      const v = d.concat(f).filter((h) => !d.includes(h) || !f.includes(h));
      n(ob, d, v);
    } else
      n(ob, d), t.checkChangeByUser = !0;
  }), Pe(a, () => {
    s();
  }), Pe(() => e.data, () => {
    const d = [], f = l.value.map((v) => v[o.value.key]);
    t.checked.forEach((v) => {
      f.includes(v) && d.push(v);
    }), t.checkChangeByUser = !1, t.checked = d;
  }), Pe(() => e.defaultChecked, (d, f) => {
    if (f && d.length === f.length && d.every((m) => f.includes(m)))
      return;
    const v = [], h = a.value.map((m) => m[o.value.key]);
    d.forEach((m) => {
      h.includes(m) && v.push(m);
    }), t.checkChangeByUser = !1, t.checked = v;
  }, {
    immediate: !0
  }), {
    filteredData: l,
    checkableData: a,
    checkedSummary: r,
    isIndeterminate: i,
    updateAllChecked: s,
    handleAllCheckedChange: u
  };
}, Yne = (e, t) => ({
  onSourceCheckedChange: (l, a) => {
    e.leftChecked = l, a && t(qO, l, a);
  },
  onTargetCheckedChange: (l, a) => {
    e.rightChecked = l, a && t(YO, l, a);
  }
}), Gne = (e) => {
  const t = mf(e), n = x(() => e.data.reduce((a, r) => (a[r[t.value.key]] = r) && a, {})), o = x(() => e.data.filter((a) => !e.modelValue.includes(a[t.value.key]))), l = x(() => e.targetOrder === "original" ? e.data.filter((a) => e.modelValue.includes(a[t.value.key])) : e.modelValue.reduce((a, r) => {
    const i = n.value[r];
    return i && a.push(i), a;
  }, []));
  return {
    sourceData: o,
    targetData: l
  };
}, Xne = (e, t, n) => {
  const o = mf(e), l = (i, s, u) => {
    n(Jt, i), n(qn, i, s, u);
  };
  return {
    addToLeft: () => {
      const i = e.modelValue.slice();
      t.rightChecked.forEach((s) => {
        const u = i.indexOf(s);
        u > -1 && i.splice(u, 1);
      }), l(i, "left", t.rightChecked);
    },
    addToRight: () => {
      let i = e.modelValue.slice();
      const s = e.data.filter((u) => {
        const d = u[o.value.key];
        return t.leftChecked.includes(d) && !e.modelValue.includes(d);
      }).map((u) => u[o.value.key]);
      i = e.targetOrder === "unshift" ? s.concat(i) : i.concat(s), e.targetOrder === "original" && (i = e.data.filter((u) => i.includes(u[o.value.key])).map((u) => u[o.value.key])), l(i, "right", t.leftChecked);
    }
  };
}, Zne = Q({
  name: "ElTransferPanel"
}), Jne = /* @__PURE__ */ Q({
  ...Zne,
  props: Une,
  emits: jne,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = Yn(), a = ({ option: b }) => b, { t: r } = bn(), i = nt("transfer"), s = en({
      checked: [],
      allChecked: !1,
      query: "",
      checkChangeByUser: !0
    }), u = mf(o), {
      filteredData: d,
      checkedSummary: f,
      isIndeterminate: v,
      handleAllCheckedChange: h
    } = qne(o, s, n), m = x(() => !ha(s.query) && ha(d.value)), p = x(() => !ha(l.default()[0].children)), { checked: C, allChecked: g, query: w } = Xo(s);
    return t({
      query: w
    }), (b, y) => (M(), G("div", {
      class: z(c(i).b("panel"))
    }, [
      X("p", {
        class: z(c(i).be("panel", "header"))
      }, [
        oe(c(ta), {
          modelValue: c(g),
          "onUpdate:modelValue": y[0] || (y[0] = (E) => fl(g) ? g.value = E : null),
          indeterminate: c(v),
          "validate-event": !1,
          onChange: c(h)
        }, {
          default: fe(() => [
            Ut(Qe(b.title) + " ", 1),
            X("span", null, Qe(c(f)), 1)
          ]),
          _: 1
        }, 8, ["modelValue", "indeterminate", "onChange"])
      ], 2),
      X("div", {
        class: z([c(i).be("panel", "body"), c(i).is("with-footer", c(p))])
      }, [
        b.filterable ? (M(), We(c(nl), {
          key: 0,
          modelValue: c(w),
          "onUpdate:modelValue": y[1] || (y[1] = (E) => fl(w) ? w.value = E : null),
          class: z(c(i).be("panel", "filter")),
          size: "default",
          placeholder: b.placeholder,
          "prefix-icon": c(Xx),
          clearable: "",
          "validate-event": !1
        }, null, 8, ["modelValue", "class", "placeholder", "prefix-icon"])) : _e("v-if", !0),
        Bt(oe(c(Uy), {
          modelValue: c(C),
          "onUpdate:modelValue": y[2] || (y[2] = (E) => fl(C) ? C.value = E : null),
          "validate-event": !1,
          class: z([c(i).is("filterable", b.filterable), c(i).be("panel", "list")])
        }, {
          default: fe(() => [
            (M(!0), G(kt, null, ln(c(d), (E) => (M(), We(c(ta), {
              key: E[c(u).key],
              class: z(c(i).be("panel", "item")),
              value: E[c(u).key],
              disabled: E[c(u).disabled],
              "validate-event": !1
            }, {
              default: fe(() => {
                var S;
                return [
                  oe(a, {
                    option: (S = b.optionRender) == null ? void 0 : S.call(b, E)
                  }, null, 8, ["option"])
                ];
              }),
              _: 2
            }, 1032, ["class", "value", "disabled"]))), 128))
          ]),
          _: 1
        }, 8, ["modelValue", "class"]), [
          [pn, !c(m) && !c(ha)(b.data)]
        ]),
        Bt(X("p", {
          class: z(c(i).be("panel", "empty"))
        }, Qe(c(m) ? c(r)("el.transfer.noMatch") : c(r)("el.transfer.noData")), 3), [
          [pn, c(m) || c(ha)(b.data)]
        ])
      ], 2),
      c(p) ? (M(), G("p", {
        key: 0,
        class: z(c(i).be("panel", "footer"))
      }, [
        Ie(b.$slots, "default")
      ], 2)) : _e("v-if", !0)
    ], 2));
  }
});
var PE = /* @__PURE__ */ ut(Jne, [["__file", "transfer-panel.vue"]]);
const Qne = { key: 0 }, eoe = { key: 0 }, toe = Q({
  name: "ElTransfer"
}), noe = /* @__PURE__ */ Q({
  ...toe,
  props: vc,
  emits: Kne,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = Yn(), { t: a } = bn(), r = nt("transfer"), { formItem: i } = ml(), s = en({
      leftChecked: [],
      rightChecked: []
    }), u = mf(o), { sourceData: d, targetData: f } = Gne(o), { onSourceCheckedChange: v, onTargetCheckedChange: h } = Yne(s, n), { addToLeft: m, addToRight: p } = Xne(o, s, n), C = B(), g = B(), w = (k) => {
      switch (k) {
        case "left":
          C.value.query = "";
          break;
        case "right":
          g.value.query = "";
          break;
      }
    }, b = x(() => o.buttonTexts.length === 2), y = x(() => o.titles[0] || a("el.transfer.titles.0")), E = x(() => o.titles[1] || a("el.transfer.titles.1")), S = x(() => o.filterPlaceholder || a("el.transfer.filterPlaceholder"));
    Pe(() => o.modelValue, () => {
      var k;
      o.validateEvent && ((k = i == null ? void 0 : i.validate) == null || k.call(i, "change").catch((N) => dn(N)));
    });
    const _ = x(() => (k) => o.renderContent ? o.renderContent(V, k) : l.default ? l.default({ option: k }) : V("span", k[u.value.label] || k[u.value.key]));
    return t({
      clearQuery: w,
      leftPanel: C,
      rightPanel: g
    }), (k, N) => (M(), G("div", {
      class: z(c(r).b())
    }, [
      oe(PE, {
        ref_key: "leftPanel",
        ref: C,
        data: c(d),
        "option-render": c(_),
        placeholder: c(S),
        title: c(y),
        filterable: k.filterable,
        format: k.format,
        "filter-method": k.filterMethod,
        "default-checked": k.leftDefaultChecked,
        props: o.props,
        onCheckedChange: c(v)
      }, {
        default: fe(() => [
          Ie(k.$slots, "left-footer")
        ]),
        _: 3
      }, 8, ["data", "option-render", "placeholder", "title", "filterable", "format", "filter-method", "default-checked", "props", "onCheckedChange"]),
      X("div", {
        class: z(c(r).e("buttons"))
      }, [
        oe(c(Do), {
          type: "primary",
          class: z([c(r).e("button"), c(r).is("with-texts", c(b))]),
          disabled: c(ha)(s.rightChecked),
          onClick: c(m)
        }, {
          default: fe(() => [
            oe(c(Ct), null, {
              default: fe(() => [
                oe(c(ks))
              ]),
              _: 1
            }),
            c(To)(k.buttonTexts[0]) ? _e("v-if", !0) : (M(), G("span", Qne, Qe(k.buttonTexts[0]), 1))
          ]),
          _: 1
        }, 8, ["class", "disabled", "onClick"]),
        oe(c(Do), {
          type: "primary",
          class: z([c(r).e("button"), c(r).is("with-texts", c(b))]),
          disabled: c(ha)(s.leftChecked),
          onClick: c(p)
        }, {
          default: fe(() => [
            c(To)(k.buttonTexts[1]) ? _e("v-if", !0) : (M(), G("span", eoe, Qe(k.buttonTexts[1]), 1)),
            oe(c(Ct), null, {
              default: fe(() => [
                oe(c(xl))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["class", "disabled", "onClick"])
      ], 2),
      oe(PE, {
        ref_key: "rightPanel",
        ref: g,
        data: c(f),
        "option-render": c(_),
        placeholder: c(S),
        filterable: k.filterable,
        format: k.format,
        "filter-method": k.filterMethod,
        title: c(E),
        "default-checked": k.rightDefaultChecked,
        props: o.props,
        onCheckedChange: c(h)
      }, {
        default: fe(() => [
          Ie(k.$slots, "right-footer")
        ]),
        _: 3
      }, 8, ["data", "option-render", "placeholder", "filterable", "format", "filter-method", "title", "default-checked", "props", "onCheckedChange"])
    ], 2));
  }
});
var ooe = /* @__PURE__ */ ut(noe, [["__file", "transfer.vue"]]);
const GO = Yt(ooe), Oc = "$treeNodeId", AE = function(e, t) {
  !t || t[Oc] || Object.defineProperty(t, Oc, {
    value: e.id,
    enumerable: !1,
    configurable: !1,
    writable: !1
  });
}, T0 = function(e, t) {
  return e ? t[e] : t[Oc];
}, lb = (e, t, n) => {
  const o = e.value.currentNode;
  n();
  const l = e.value.currentNode;
  o !== l && t("current-change", l ? l.data : null, l);
}, ab = (e) => {
  let t = !0, n = !0, o = !0;
  for (let l = 0, a = e.length; l < a; l++) {
    const r = e[l];
    (r.checked !== !0 || r.indeterminate) && (t = !1, r.disabled || (o = !1)), (r.checked !== !1 || r.indeterminate) && (n = !1);
  }
  return { all: t, none: n, allWithoutDisable: o, half: !t && !n };
}, Wu = function(e) {
  if (e.childNodes.length === 0 || e.loading)
    return;
  const { all: t, none: n, half: o } = ab(e.childNodes);
  t ? (e.checked = !0, e.indeterminate = !1) : o ? (e.checked = !1, e.indeterminate = !0) : n && (e.checked = !1, e.indeterminate = !1);
  const l = e.parent;
  !l || l.level === 0 || e.store.checkStrictly || Wu(l);
}, Qf = function(e, t) {
  const n = e.store.props, o = e.data || {}, l = n[t];
  if (typeof l == "function")
    return l(o, e);
  if (typeof l == "string")
    return o[l];
  if (typeof l > "u") {
    const a = o[t];
    return a === void 0 ? "" : a;
  }
};
let loe = 0, rb = class Dp {
  constructor(t) {
    this.id = loe++, this.text = null, this.checked = !1, this.indeterminate = !1, this.data = null, this.expanded = !1, this.parent = null, this.visible = !0, this.isCurrent = !1, this.canFocus = !1;
    for (const n in t)
      sl(t, n) && (this[n] = t[n]);
    this.level = 0, this.loaded = !1, this.childNodes = [], this.loading = !1, this.parent && (this.level = this.parent.level + 1);
  }
  initialize() {
    const t = this.store;
    if (!t)
      throw new Error("[Node]store is required!");
    t.registerNode(this);
    const n = t.props;
    if (n && typeof n.isLeaf < "u") {
      const a = Qf(this, "isLeaf");
      typeof a == "boolean" && (this.isLeafByUser = a);
    }
    if (t.lazy !== !0 && this.data ? (this.setData(this.data), t.defaultExpandAll && (this.expanded = !0, this.canFocus = !0)) : this.level > 0 && t.lazy && t.defaultExpandAll && this.expand(), Array.isArray(this.data) || AE(this, this.data), !this.data)
      return;
    const o = t.defaultExpandedKeys, l = t.key;
    l && o && o.includes(this.key) && this.expand(null, t.autoExpandParent), l && t.currentNodeKey !== void 0 && this.key === t.currentNodeKey && (t.currentNode = this, t.currentNode.isCurrent = !0), t.lazy && t._initDefaultCheckedNode(this), this.updateLeafState(), this.parent && (this.level === 1 || this.parent.expanded === !0) && (this.canFocus = !0);
  }
  setData(t) {
    Array.isArray(t) || AE(this, t), this.data = t, this.childNodes = [];
    let n;
    this.level === 0 && Array.isArray(this.data) ? n = this.data : n = Qf(this, "children") || [];
    for (let o = 0, l = n.length; o < l; o++)
      this.insertChild({ data: n[o] });
  }
  get label() {
    return Qf(this, "label");
  }
  get key() {
    const t = this.store.key;
    return this.data ? this.data[t] : null;
  }
  get disabled() {
    return Qf(this, "disabled");
  }
  get nextSibling() {
    const t = this.parent;
    if (t) {
      const n = t.childNodes.indexOf(this);
      if (n > -1)
        return t.childNodes[n + 1];
    }
    return null;
  }
  get previousSibling() {
    const t = this.parent;
    if (t) {
      const n = t.childNodes.indexOf(this);
      if (n > -1)
        return n > 0 ? t.childNodes[n - 1] : null;
    }
    return null;
  }
  contains(t, n = !0) {
    return (this.childNodes || []).some((o) => o === t || n && o.contains(t));
  }
  remove() {
    const t = this.parent;
    t && t.removeChild(this);
  }
  insertChild(t, n, o) {
    if (!t)
      throw new Error("InsertChild error: child is required.");
    if (!(t instanceof Dp)) {
      if (!o) {
        const l = this.getChildren(!0);
        l.includes(t.data) || (typeof n > "u" || n < 0 ? l.push(t.data) : l.splice(n, 0, t.data));
      }
      Object.assign(t, {
        parent: this,
        store: this.store
      }), t = en(new Dp(t)), t instanceof Dp && t.initialize();
    }
    t.level = this.level + 1, typeof n > "u" || n < 0 ? this.childNodes.push(t) : this.childNodes.splice(n, 0, t), this.updateLeafState();
  }
  insertBefore(t, n) {
    let o;
    n && (o = this.childNodes.indexOf(n)), this.insertChild(t, o);
  }
  insertAfter(t, n) {
    let o;
    n && (o = this.childNodes.indexOf(n), o !== -1 && (o += 1)), this.insertChild(t, o);
  }
  removeChild(t) {
    const n = this.getChildren() || [], o = n.indexOf(t.data);
    o > -1 && n.splice(o, 1);
    const l = this.childNodes.indexOf(t);
    l > -1 && (this.store && this.store.deregisterNode(t), t.parent = null, this.childNodes.splice(l, 1)), this.updateLeafState();
  }
  removeChildByData(t) {
    let n = null;
    for (let o = 0; o < this.childNodes.length; o++)
      if (this.childNodes[o].data === t) {
        n = this.childNodes[o];
        break;
      }
    n && this.removeChild(n);
  }
  expand(t, n) {
    const o = () => {
      if (n) {
        let l = this.parent;
        for (; l.level > 0; )
          l.expanded = !0, l = l.parent;
      }
      this.expanded = !0, t && t(), this.childNodes.forEach((l) => {
        l.canFocus = !0;
      });
    };
    this.shouldLoadData() ? this.loadData((l) => {
      Array.isArray(l) && (this.checked ? this.setChecked(!0, !0) : this.store.checkStrictly || Wu(this), o());
    }) : o();
  }
  doCreateChildren(t, n = {}) {
    t.forEach((o) => {
      this.insertChild(Object.assign({ data: o }, n), void 0, !0);
    });
  }
  collapse() {
    this.expanded = !1, this.childNodes.forEach((t) => {
      t.canFocus = !1;
    });
  }
  shouldLoadData() {
    return this.store.lazy === !0 && this.store.load && !this.loaded;
  }
  updateLeafState() {
    if (this.store.lazy === !0 && this.loaded !== !0 && typeof this.isLeafByUser < "u") {
      this.isLeaf = this.isLeafByUser;
      return;
    }
    const t = this.childNodes;
    if (!this.store.lazy || this.store.lazy === !0 && this.loaded === !0) {
      this.isLeaf = !t || t.length === 0;
      return;
    }
    this.isLeaf = !1;
  }
  setChecked(t, n, o, l) {
    if (this.indeterminate = t === "half", this.checked = t === !0, this.store.checkStrictly)
      return;
    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
      const { all: r, allWithoutDisable: i } = ab(this.childNodes);
      !this.isLeaf && !r && i && (this.checked = !1, t = !1);
      const s = () => {
        if (n) {
          const u = this.childNodes;
          for (let v = 0, h = u.length; v < h; v++) {
            const m = u[v];
            l = l || t !== !1;
            const p = m.disabled ? m.checked : l;
            m.setChecked(p, n, !0, l);
          }
          const { half: d, all: f } = ab(u);
          f || (this.checked = f, this.indeterminate = d);
        }
      };
      if (this.shouldLoadData()) {
        this.loadData(() => {
          s(), Wu(this);
        }, {
          checked: t !== !1
        });
        return;
      } else
        s();
    }
    const a = this.parent;
    !a || a.level === 0 || o || Wu(a);
  }
  getChildren(t = !1) {
    if (this.level === 0)
      return this.data;
    const n = this.data;
    if (!n)
      return null;
    const o = this.store.props;
    let l = "children";
    return o && (l = o.children || "children"), n[l] === void 0 && (n[l] = null), t && !n[l] && (n[l] = []), n[l];
  }
  updateChildren() {
    const t = this.getChildren() || [], n = this.childNodes.map((a) => a.data), o = {}, l = [];
    t.forEach((a, r) => {
      const i = a[Oc];
      !!i && n.findIndex((u) => u[Oc] === i) >= 0 ? o[i] = { index: r, data: a } : l.push({ index: r, data: a });
    }), this.store.lazy || n.forEach((a) => {
      o[a[Oc]] || this.removeChildByData(a);
    }), l.forEach(({ index: a, data: r }) => {
      this.insertChild({ data: r }, a);
    }), this.updateLeafState();
  }
  loadData(t, n = {}) {
    if (this.store.lazy === !0 && this.store.load && !this.loaded && (!this.loading || Object.keys(n).length)) {
      this.loading = !0;
      const o = (a) => {
        this.childNodes = [], this.doCreateChildren(a, n), this.loaded = !0, this.loading = !1, this.updateLeafState(), t && t.call(this, a);
      }, l = () => {
        this.loading = !1;
      };
      this.store.load(this, o, l);
    } else
      t && t.call(this);
  }
  eachNode(t) {
    const n = [this];
    for (; n.length; ) {
      const o = n.shift();
      n.unshift(...o.childNodes), t(o);
    }
  }
  reInitChecked() {
    this.store.checkStrictly || Wu(this);
  }
};
class aoe {
  constructor(t) {
    this.currentNode = null, this.currentNodeKey = null;
    for (const n in t)
      sl(t, n) && (this[n] = t[n]);
    this.nodesMap = {};
  }
  initialize() {
    if (this.root = new rb({
      data: this.data,
      store: this
    }), this.root.initialize(), this.lazy && this.load) {
      const t = this.load;
      t(this.root, (n) => {
        this.root.doCreateChildren(n), this._initDefaultCheckedNodes();
      });
    } else
      this._initDefaultCheckedNodes();
  }
  filter(t) {
    const n = this.filterNodeMethod, o = this.lazy, l = function(a) {
      const r = a.root ? a.root.childNodes : a.childNodes;
      if (r.forEach((i) => {
        i.visible = n.call(i, t, i.data, i), l(i);
      }), !a.visible && r.length) {
        let i = !0;
        i = !r.some((s) => s.visible), a.root ? a.root.visible = i === !1 : a.visible = i === !1;
      }
      t && a.visible && !a.isLeaf && (!o || a.loaded) && a.expand();
    };
    l(this);
  }
  setData(t) {
    t !== this.root.data ? (this.root.setData(t), this._initDefaultCheckedNodes()) : this.root.updateChildren();
  }
  getNode(t) {
    if (t instanceof rb)
      return t;
    const n = Mn(t) ? T0(this.key, t) : t;
    return this.nodesMap[n] || null;
  }
  insertBefore(t, n) {
    const o = this.getNode(n);
    o.parent.insertBefore({ data: t }, o);
  }
  insertAfter(t, n) {
    const o = this.getNode(n);
    o.parent.insertAfter({ data: t }, o);
  }
  remove(t) {
    const n = this.getNode(t);
    n && n.parent && (n === this.currentNode && (this.currentNode = null), n.parent.removeChild(n));
  }
  append(t, n) {
    const o = $i(n) ? this.root : this.getNode(n);
    o && o.insertChild({ data: t });
  }
  _initDefaultCheckedNodes() {
    const t = this.defaultCheckedKeys || [], n = this.nodesMap;
    t.forEach((o) => {
      const l = n[o];
      l && l.setChecked(!0, !this.checkStrictly);
    });
  }
  _initDefaultCheckedNode(t) {
    (this.defaultCheckedKeys || []).includes(t.key) && t.setChecked(!0, !this.checkStrictly);
  }
  setDefaultCheckedKey(t) {
    t !== this.defaultCheckedKeys && (this.defaultCheckedKeys = t, this._initDefaultCheckedNodes());
  }
  registerNode(t) {
    const n = this.key;
    !t || !t.data || (n ? t.key !== void 0 && (this.nodesMap[t.key] = t) : this.nodesMap[t.id] = t);
  }
  deregisterNode(t) {
    !this.key || !t || !t.data || (t.childNodes.forEach((o) => {
      this.deregisterNode(o);
    }), delete this.nodesMap[t.key]);
  }
  getCheckedNodes(t = !1, n = !1) {
    const o = [], l = function(a) {
      (a.root ? a.root.childNodes : a.childNodes).forEach((i) => {
        (i.checked || n && i.indeterminate) && (!t || t && i.isLeaf) && o.push(i.data), l(i);
      });
    };
    return l(this), o;
  }
  getCheckedKeys(t = !1) {
    return this.getCheckedNodes(t).map((n) => (n || {})[this.key]);
  }
  getHalfCheckedNodes() {
    const t = [], n = function(o) {
      (o.root ? o.root.childNodes : o.childNodes).forEach((a) => {
        a.indeterminate && t.push(a.data), n(a);
      });
    };
    return n(this), t;
  }
  getHalfCheckedKeys() {
    return this.getHalfCheckedNodes().map((t) => (t || {})[this.key]);
  }
  _getAllNodes() {
    const t = [], n = this.nodesMap;
    for (const o in n)
      sl(n, o) && t.push(n[o]);
    return t;
  }
  updateChildren(t, n) {
    const o = this.nodesMap[t];
    if (!o)
      return;
    const l = o.childNodes;
    for (let a = l.length - 1; a >= 0; a--) {
      const r = l[a];
      this.remove(r.data);
    }
    for (let a = 0, r = n.length; a < r; a++) {
      const i = n[a];
      this.append(i, o.data);
    }
  }
  _setCheckedKeys(t, n = !1, o) {
    const l = this._getAllNodes().sort((s, u) => s.level - u.level), a = /* @__PURE__ */ Object.create(null), r = Object.keys(o);
    l.forEach((s) => s.setChecked(!1, !1));
    const i = (s) => {
      s.childNodes.forEach((u) => {
        var d;
        a[u.data[t]] = !0, (d = u.childNodes) != null && d.length && i(u);
      });
    };
    for (let s = 0, u = l.length; s < u; s++) {
      const d = l[s], f = d.data[t].toString();
      if (!r.includes(f)) {
        d.checked && !a[f] && d.setChecked(!1, !1);
        continue;
      }
      if (d.childNodes.length && i(d), d.isLeaf || this.checkStrictly) {
        d.setChecked(!0, !1);
        continue;
      }
      if (d.setChecked(!0, !0), n) {
        d.setChecked(!1, !1);
        const h = function(m) {
          m.childNodes.forEach((C) => {
            C.isLeaf || C.setChecked(!1, !1), h(C);
          });
        };
        h(d);
      }
    }
  }
  setCheckedNodes(t, n = !1) {
    const o = this.key, l = {};
    t.forEach((a) => {
      l[(a || {})[o]] = !0;
    }), this._setCheckedKeys(o, n, l);
  }
  setCheckedKeys(t, n = !1) {
    this.defaultCheckedKeys = t;
    const o = this.key, l = {};
    t.forEach((a) => {
      l[a] = !0;
    }), this._setCheckedKeys(o, n, l);
  }
  setDefaultExpandedKeys(t) {
    t = t || [], this.defaultExpandedKeys = t, t.forEach((n) => {
      const o = this.getNode(n);
      o && o.expand(null, this.autoExpandParent);
    });
  }
  setChecked(t, n, o) {
    const l = this.getNode(t);
    l && l.setChecked(!!n, o);
  }
  getCurrentNode() {
    return this.currentNode;
  }
  setCurrentNode(t) {
    const n = this.currentNode;
    n && (n.isCurrent = !1), this.currentNode = t, this.currentNode.isCurrent = !0;
  }
  setUserCurrentNode(t, n = !0) {
    const o = t[this.key], l = this.nodesMap[o];
    this.setCurrentNode(l), n && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0);
  }
  setCurrentNodeKey(t, n = !0) {
    if (t == null) {
      this.currentNode && (this.currentNode.isCurrent = !1), this.currentNode = null;
      return;
    }
    const o = this.getNode(t);
    o && (this.setCurrentNode(o), n && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0));
  }
}
const roe = Q({
  name: "ElTreeNodeContent",
  props: {
    node: {
      type: Object,
      required: !0
    },
    renderContent: Function
  },
  setup(e) {
    const t = nt("tree"), n = ot("NodeInstance"), o = ot("RootTree");
    return () => {
      const l = e.node, { data: a, store: r } = l;
      return e.renderContent ? e.renderContent(V, { _self: n, node: l, data: a, store: r }) : Ie(o.ctx.slots, "default", { node: l, data: a }, () => [
        V("span", { class: t.be("node", "label") }, [l.label])
      ]);
    };
  }
});
var soe = /* @__PURE__ */ ut(roe, [["__file", "tree-node-content.vue"]]);
function XO(e) {
  const t = ot("TreeNodeMap", null), n = {
    treeNodeExpand: (o) => {
      e.node !== o && e.node.collapse();
    },
    children: []
  };
  return t && t.children.push(n), Mt("TreeNodeMap", n), {
    broadcastExpanded: (o) => {
      if (e.accordion)
        for (const l of n.children)
          l.treeNodeExpand(o);
    }
  };
}
const ZO = Symbol("dragEvents");
function ioe({ props: e, ctx: t, el$: n, dropIndicator$: o, store: l }) {
  const a = nt("tree"), r = B({
    showDropIndicator: !1,
    draggingNode: null,
    dropNode: null,
    allowDrop: !0,
    dropType: null
  });
  return Mt(ZO, {
    treeNodeDragStart: ({ event: d, treeNode: f }) => {
      if (typeof e.allowDrag == "function" && !e.allowDrag(f.node))
        return d.preventDefault(), !1;
      d.dataTransfer.effectAllowed = "move";
      try {
        d.dataTransfer.setData("text/plain", "");
      } catch {
      }
      r.value.draggingNode = f, t.emit("node-drag-start", f.node, d);
    },
    treeNodeDragOver: ({ event: d, treeNode: f }) => {
      const v = f, h = r.value.dropNode;
      h && h.node.id !== v.node.id && vl(h.$el, a.is("drop-inner"));
      const m = r.value.draggingNode;
      if (!m || !v)
        return;
      let p = !0, C = !0, g = !0, w = !0;
      typeof e.allowDrop == "function" && (p = e.allowDrop(m.node, v.node, "prev"), w = C = e.allowDrop(m.node, v.node, "inner"), g = e.allowDrop(m.node, v.node, "next")), d.dataTransfer.dropEffect = C || p || g ? "move" : "none", (p || C || g) && (h == null ? void 0 : h.node.id) !== v.node.id && (h && t.emit("node-drag-leave", m.node, h.node, d), t.emit("node-drag-enter", m.node, v.node, d)), p || C || g ? r.value.dropNode = v : r.value.dropNode = null, v.node.nextSibling === m.node && (g = !1), v.node.previousSibling === m.node && (p = !1), v.node.contains(m.node, !1) && (C = !1), (m.node === v.node || m.node.contains(v.node)) && (p = !1, C = !1, g = !1);
      const b = v.$el.querySelector(`.${a.be("node", "content")}`).getBoundingClientRect(), y = n.value.getBoundingClientRect();
      let E;
      const S = p ? C ? 0.25 : g ? 0.45 : 1 : -1, _ = g ? C ? 0.75 : p ? 0.55 : 0 : 1;
      let k = -9999;
      const N = d.clientY - b.top;
      N < b.height * S ? E = "before" : N > b.height * _ ? E = "after" : C ? E = "inner" : E = "none";
      const L = v.$el.querySelector(`.${a.be("node", "expand-icon")}`).getBoundingClientRect(), R = o.value;
      E === "before" ? k = L.top - y.top : E === "after" && (k = L.bottom - y.top), R.style.top = `${k}px`, R.style.left = `${L.right - y.left}px`, E === "inner" ? ma(v.$el, a.is("drop-inner")) : vl(v.$el, a.is("drop-inner")), r.value.showDropIndicator = E === "before" || E === "after", r.value.allowDrop = r.value.showDropIndicator || w, r.value.dropType = E, t.emit("node-drag-over", m.node, v.node, d);
    },
    treeNodeDragEnd: (d) => {
      const { draggingNode: f, dropType: v, dropNode: h } = r.value;
      if (d.preventDefault(), d.dataTransfer.dropEffect = "move", f && h) {
        const m = { data: f.node.data };
        v !== "none" && f.node.remove(), v === "before" ? h.node.parent.insertBefore(m, h.node) : v === "after" ? h.node.parent.insertAfter(m, h.node) : v === "inner" && h.node.insertChild(m), v !== "none" && (l.value.registerNode(m), l.value.key && f.node.eachNode((p) => {
          var C;
          (C = l.value.nodesMap[p.data[l.value.key]]) == null || C.setChecked(p.checked, !l.value.checkStrictly);
        })), vl(h.$el, a.is("drop-inner")), t.emit("node-drag-end", f.node, h.node, v, d), v !== "none" && t.emit("node-drop", f.node, h.node, v, d);
      }
      f && !h && t.emit("node-drag-end", f.node, null, v, d), r.value.showDropIndicator = !1, r.value.draggingNode = null, r.value.dropNode = null, r.value.allowDrop = !0;
    }
  }), {
    dragState: r
  };
}
const coe = Q({
  name: "ElTreeNode",
  components: {
    ElCollapseTransition: jv,
    ElCheckbox: ta,
    NodeContent: soe,
    ElIcon: Ct,
    Loading: Ps
  },
  props: {
    node: {
      type: rb,
      default: () => ({})
    },
    props: {
      type: Object,
      default: () => ({})
    },
    accordion: Boolean,
    renderContent: Function,
    renderAfterExpand: Boolean,
    showCheckbox: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["node-expand"],
  setup(e, t) {
    const n = nt("tree"), { broadcastExpanded: o } = XO(e), l = ot("RootTree"), a = B(!1), r = B(!1), i = B(null), s = B(null), u = B(null), d = ot(ZO), f = Pt();
    Mt("NodeInstance", f), l || dn("Tree", "Can not find node's tree."), e.node.expanded && (a.value = !0, r.value = !0);
    const v = l.props.props.children || "children";
    Pe(() => {
      const N = e.node.data[v];
      return N && [...N];
    }, () => {
      e.node.updateChildren();
    }), Pe(() => e.node.indeterminate, (N) => {
      p(e.node.checked, N);
    }), Pe(() => e.node.checked, (N) => {
      p(N, e.node.indeterminate);
    }), Pe(() => e.node.childNodes.length, () => e.node.reInitChecked()), Pe(() => e.node.expanded, (N) => {
      xe(() => a.value = N), N && (r.value = !0);
    });
    const h = (N) => T0(l.props.nodeKey, N.data), m = (N) => {
      const L = e.props.class;
      if (!L)
        return {};
      let R;
      if (vn(L)) {
        const { data: H } = N;
        R = L(H, N);
      } else
        R = L;
      return on(R) ? { [R]: !0 } : R;
    }, p = (N, L) => {
      (i.value !== N || s.value !== L) && l.ctx.emit("check-change", e.node.data, N, L), i.value = N, s.value = L;
    }, C = (N) => {
      lb(l.store, l.ctx.emit, () => l.store.value.setCurrentNode(e.node)), l.currentNode.value = e.node, l.props.expandOnClickNode && w(), l.props.checkOnClickNode && !e.node.disabled && b(null, {
        target: { checked: !e.node.checked }
      }), l.ctx.emit("node-click", e.node.data, e.node, f, N);
    }, g = (N) => {
      l.instance.vnode.props.onNodeContextmenu && (N.stopPropagation(), N.preventDefault()), l.ctx.emit("node-contextmenu", N, e.node.data, e.node, f);
    }, w = () => {
      e.node.isLeaf || (a.value ? (l.ctx.emit("node-collapse", e.node.data, e.node, f), e.node.collapse()) : (e.node.expand(), t.emit("node-expand", e.node.data, e.node, f)));
    }, b = (N, L) => {
      e.node.setChecked(L.target.checked, !l.props.checkStrictly), xe(() => {
        const R = l.store.value;
        l.ctx.emit("check", e.node.data, {
          checkedNodes: R.getCheckedNodes(),
          checkedKeys: R.getCheckedKeys(),
          halfCheckedNodes: R.getHalfCheckedNodes(),
          halfCheckedKeys: R.getHalfCheckedKeys()
        });
      });
    };
    return {
      ns: n,
      node$: u,
      tree: l,
      expanded: a,
      childNodeRendered: r,
      oldChecked: i,
      oldIndeterminate: s,
      getNodeKey: h,
      getNodeClass: m,
      handleSelectChange: p,
      handleClick: C,
      handleContextMenu: g,
      handleExpandIconClick: w,
      handleCheckChange: b,
      handleChildNodeExpand: (N, L, R) => {
        o(L), l.ctx.emit("node-expand", N, L, R);
      },
      handleDragStart: (N) => {
        l.props.draggable && d.treeNodeDragStart({ event: N, treeNode: e });
      },
      handleDragOver: (N) => {
        N.preventDefault(), l.props.draggable && d.treeNodeDragOver({
          event: N,
          treeNode: { $el: u.value, node: e.node }
        });
      },
      handleDrop: (N) => {
        N.preventDefault();
      },
      handleDragEnd: (N) => {
        l.props.draggable && d.treeNodeDragEnd(N);
      },
      CaretRight: qx
    };
  }
}), uoe = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"], doe = ["aria-expanded"];
function foe(e, t, n, o, l, a) {
  const r = Dt("el-icon"), i = Dt("el-checkbox"), s = Dt("loading"), u = Dt("node-content"), d = Dt("el-tree-node"), f = Dt("el-collapse-transition");
  return Bt((M(), G("div", {
    ref: "node$",
    class: z([
      e.ns.b("node"),
      e.ns.is("expanded", e.expanded),
      e.ns.is("current", e.node.isCurrent),
      e.ns.is("hidden", !e.node.visible),
      e.ns.is("focusable", !e.node.disabled),
      e.ns.is("checked", !e.node.disabled && e.node.checked),
      e.getNodeClass(e.node)
    ]),
    role: "treeitem",
    tabindex: "-1",
    "aria-expanded": e.expanded,
    "aria-disabled": e.node.disabled,
    "aria-checked": e.node.checked,
    draggable: e.tree.props.draggable,
    "data-key": e.getNodeKey(e.node),
    onClick: t[1] || (t[1] = It((...v) => e.handleClick && e.handleClick(...v), ["stop"])),
    onContextmenu: t[2] || (t[2] = (...v) => e.handleContextMenu && e.handleContextMenu(...v)),
    onDragstart: t[3] || (t[3] = It((...v) => e.handleDragStart && e.handleDragStart(...v), ["stop"])),
    onDragover: t[4] || (t[4] = It((...v) => e.handleDragOver && e.handleDragOver(...v), ["stop"])),
    onDragend: t[5] || (t[5] = It((...v) => e.handleDragEnd && e.handleDragEnd(...v), ["stop"])),
    onDrop: t[6] || (t[6] = It((...v) => e.handleDrop && e.handleDrop(...v), ["stop"]))
  }, [
    X("div", {
      class: z(e.ns.be("node", "content")),
      style: bt({ paddingLeft: (e.node.level - 1) * e.tree.props.indent + "px" })
    }, [
      e.tree.props.icon || e.CaretRight ? (M(), We(r, {
        key: 0,
        class: z([
          e.ns.be("node", "expand-icon"),
          e.ns.is("leaf", e.node.isLeaf),
          {
            expanded: !e.node.isLeaf && e.expanded
          }
        ]),
        onClick: It(e.handleExpandIconClick, ["stop"])
      }, {
        default: fe(() => [
          (M(), We(Qt(e.tree.props.icon || e.CaretRight)))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : _e("v-if", !0),
      e.showCheckbox ? (M(), We(i, {
        key: 1,
        "model-value": e.node.checked,
        indeterminate: e.node.indeterminate,
        disabled: !!e.node.disabled,
        onClick: t[0] || (t[0] = It(() => {
        }, ["stop"])),
        onChange: e.handleCheckChange
      }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : _e("v-if", !0),
      e.node.loading ? (M(), We(r, {
        key: 2,
        class: z([e.ns.be("node", "loading-icon"), e.ns.is("loading")])
      }, {
        default: fe(() => [
          oe(s)
        ]),
        _: 1
      }, 8, ["class"])) : _e("v-if", !0),
      oe(u, {
        node: e.node,
        "render-content": e.renderContent
      }, null, 8, ["node", "render-content"])
    ], 6),
    oe(f, null, {
      default: fe(() => [
        !e.renderAfterExpand || e.childNodeRendered ? Bt((M(), G("div", {
          key: 0,
          class: z(e.ns.be("node", "children")),
          role: "group",
          "aria-expanded": e.expanded
        }, [
          (M(!0), G(kt, null, ln(e.node.childNodes, (v) => (M(), We(d, {
            key: e.getNodeKey(v),
            "render-content": e.renderContent,
            "render-after-expand": e.renderAfterExpand,
            "show-checkbox": e.showCheckbox,
            node: v,
            accordion: e.accordion,
            props: e.props,
            onNodeExpand: e.handleChildNodeExpand
          }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]))), 128))
        ], 10, doe)), [
          [pn, e.expanded]
        ]) : _e("v-if", !0)
      ]),
      _: 1
    })
  ], 42, uoe)), [
    [pn, e.node.visible]
  ]);
}
var poe = /* @__PURE__ */ ut(coe, [["render", foe], ["__file", "tree-node.vue"]]);
function voe({ el$: e }, t) {
  const n = nt("tree"), o = An([]), l = An([]);
  Nt(() => {
    r();
  }), Pi(() => {
    o.value = Array.from(e.value.querySelectorAll("[role=treeitem]")), l.value = Array.from(e.value.querySelectorAll("input[type=checkbox]"));
  }), Pe(l, (i) => {
    i.forEach((s) => {
      s.setAttribute("tabindex", "-1");
    });
  }), jn(e, "keydown", (i) => {
    const s = i.target;
    if (!s.className.includes(n.b("node")))
      return;
    const u = i.code;
    o.value = Array.from(e.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`));
    const d = o.value.indexOf(s);
    let f;
    if ([xt.up, xt.down].includes(u)) {
      if (i.preventDefault(), u === xt.up) {
        f = d === -1 ? 0 : d !== 0 ? d - 1 : o.value.length - 1;
        const h = f;
        for (; !t.value.getNode(o.value[f].dataset.key).canFocus; ) {
          if (f--, f === h) {
            f = -1;
            break;
          }
          f < 0 && (f = o.value.length - 1);
        }
      } else {
        f = d === -1 ? 0 : d < o.value.length - 1 ? d + 1 : 0;
        const h = f;
        for (; !t.value.getNode(o.value[f].dataset.key).canFocus; ) {
          if (f++, f === h) {
            f = -1;
            break;
          }
          f >= o.value.length && (f = 0);
        }
      }
      f !== -1 && o.value[f].focus();
    }
    [xt.left, xt.right].includes(u) && (i.preventDefault(), s.click());
    const v = s.querySelector('[type="checkbox"]');
    [xt.enter, xt.space].includes(u) && v && (i.preventDefault(), v.click());
  });
  const r = () => {
    var i;
    o.value = Array.from(e.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`)), l.value = Array.from(e.value.querySelectorAll("input[type=checkbox]"));
    const s = e.value.querySelectorAll(`.${n.is("checked")}[role=treeitem]`);
    if (s.length) {
      s[0].setAttribute("tabindex", "0");
      return;
    }
    (i = o.value[0]) == null || i.setAttribute("tabindex", "0");
  };
}
const hoe = Q({
  name: "ElTree",
  components: { ElTreeNode: poe },
  props: {
    data: {
      type: Array,
      default: () => []
    },
    emptyText: {
      type: String
    },
    renderAfterExpand: {
      type: Boolean,
      default: !0
    },
    nodeKey: String,
    checkStrictly: Boolean,
    defaultExpandAll: Boolean,
    expandOnClickNode: {
      type: Boolean,
      default: !0
    },
    checkOnClickNode: Boolean,
    checkDescendants: {
      type: Boolean,
      default: !1
    },
    autoExpandParent: {
      type: Boolean,
      default: !0
    },
    defaultCheckedKeys: Array,
    defaultExpandedKeys: Array,
    currentNodeKey: [String, Number],
    renderContent: Function,
    showCheckbox: {
      type: Boolean,
      default: !1
    },
    draggable: {
      type: Boolean,
      default: !1
    },
    allowDrag: Function,
    allowDrop: Function,
    props: {
      type: Object,
      default: () => ({
        children: "children",
        label: "label",
        disabled: "disabled"
      })
    },
    lazy: {
      type: Boolean,
      default: !1
    },
    highlightCurrent: Boolean,
    load: Function,
    filterNodeMethod: Function,
    accordion: Boolean,
    indent: {
      type: Number,
      default: 18
    },
    icon: {
      type: Dn
    }
  },
  emits: [
    "check-change",
    "current-change",
    "node-click",
    "node-contextmenu",
    "node-collapse",
    "node-expand",
    "check",
    "node-drag-start",
    "node-drag-end",
    "node-drop",
    "node-drag-leave",
    "node-drag-enter",
    "node-drag-over"
  ],
  setup(e, t) {
    const { t: n } = bn(), o = nt("tree"), l = B(new aoe({
      key: e.nodeKey,
      data: e.data,
      lazy: e.lazy,
      props: e.props,
      load: e.load,
      currentNodeKey: e.currentNodeKey,
      checkStrictly: e.checkStrictly,
      checkDescendants: e.checkDescendants,
      defaultCheckedKeys: e.defaultCheckedKeys,
      defaultExpandedKeys: e.defaultExpandedKeys,
      autoExpandParent: e.autoExpandParent,
      defaultExpandAll: e.defaultExpandAll,
      filterNodeMethod: e.filterNodeMethod
    }));
    l.value.initialize();
    const a = B(l.value.root), r = B(null), i = B(null), s = B(null), { broadcastExpanded: u } = XO(e), { dragState: d } = ioe({
      props: e,
      ctx: t,
      el$: i,
      dropIndicator$: s,
      store: l
    });
    voe({ el$: i }, l);
    const f = x(() => {
      const { childNodes: $ } = a.value;
      return !$ || $.length === 0 || $.every(({ visible: D }) => !D);
    });
    Pe(() => e.currentNodeKey, ($) => {
      l.value.setCurrentNodeKey($);
    }), Pe(() => e.defaultCheckedKeys, ($) => {
      l.value.setDefaultCheckedKey($);
    }), Pe(() => e.defaultExpandedKeys, ($) => {
      l.value.setDefaultExpandedKeys($);
    }), Pe(() => e.data, ($) => {
      l.value.setData($);
    }, { deep: !0 }), Pe(() => e.checkStrictly, ($) => {
      l.value.checkStrictly = $;
    });
    const v = ($) => {
      if (!e.filterNodeMethod)
        throw new Error("[Tree] filterNodeMethod is required when filter");
      l.value.filter($);
    }, h = ($) => T0(e.nodeKey, $.data), m = ($) => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in getNodePath");
      const D = l.value.getNode($);
      if (!D)
        return [];
      const O = [D.data];
      let F = D.parent;
      for (; F && F !== a.value; )
        O.push(F.data), F = F.parent;
      return O.reverse();
    }, p = ($, D) => l.value.getCheckedNodes($, D), C = ($) => l.value.getCheckedKeys($), g = () => {
      const $ = l.value.getCurrentNode();
      return $ ? $.data : null;
    }, w = () => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in getCurrentKey");
      const $ = g();
      return $ ? $[e.nodeKey] : null;
    }, b = ($, D) => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedNodes");
      l.value.setCheckedNodes($, D);
    }, y = ($, D) => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedKeys");
      l.value.setCheckedKeys($, D);
    }, E = ($, D, O) => {
      l.value.setChecked($, D, O);
    }, S = () => l.value.getHalfCheckedNodes(), _ = () => l.value.getHalfCheckedKeys(), k = ($, D = !0) => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentNode");
      lb(l, t.emit, () => l.value.setUserCurrentNode($, D));
    }, N = ($, D = !0) => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentKey");
      lb(l, t.emit, () => l.value.setCurrentNodeKey($, D));
    }, L = ($) => l.value.getNode($), R = ($) => {
      l.value.remove($);
    }, H = ($, D) => {
      l.value.append($, D);
    }, K = ($, D) => {
      l.value.insertBefore($, D);
    }, U = ($, D) => {
      l.value.insertAfter($, D);
    }, W = ($, D, O) => {
      u(D), t.emit("node-expand", $, D, O);
    }, A = ($, D) => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in updateKeyChild");
      l.value.updateChildren($, D);
    };
    return Mt("RootTree", {
      ctx: t,
      props: e,
      store: l,
      root: a,
      currentNode: r,
      instance: Pt()
    }), Mt(ur, void 0), {
      ns: o,
      store: l,
      root: a,
      currentNode: r,
      dragState: d,
      el$: i,
      dropIndicator$: s,
      isEmpty: f,
      filter: v,
      getNodeKey: h,
      getNodePath: m,
      getCheckedNodes: p,
      getCheckedKeys: C,
      getCurrentNode: g,
      getCurrentKey: w,
      setCheckedNodes: b,
      setCheckedKeys: y,
      setChecked: E,
      getHalfCheckedNodes: S,
      getHalfCheckedKeys: _,
      setCurrentNode: k,
      setCurrentKey: N,
      t: n,
      getNode: L,
      remove: R,
      append: H,
      insertBefore: K,
      insertAfter: U,
      handleNodeExpand: W,
      updateKeyChildren: A
    };
  }
});
function moe(e, t, n, o, l, a) {
  const r = Dt("el-tree-node");
  return M(), G("div", {
    ref: "el$",
    class: z([
      e.ns.b(),
      e.ns.is("dragging", !!e.dragState.draggingNode),
      e.ns.is("drop-not-allow", !e.dragState.allowDrop),
      e.ns.is("drop-inner", e.dragState.dropType === "inner"),
      { [e.ns.m("highlight-current")]: e.highlightCurrent }
    ]),
    role: "tree"
  }, [
    (M(!0), G(kt, null, ln(e.root.childNodes, (i) => (M(), We(r, {
      key: e.getNodeKey(i),
      node: i,
      props: e.props,
      accordion: e.accordion,
      "render-after-expand": e.renderAfterExpand,
      "show-checkbox": e.showCheckbox,
      "render-content": e.renderContent,
      onNodeExpand: e.handleNodeExpand
    }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]))), 128)),
    e.isEmpty ? (M(), G("div", {
      key: 0,
      class: z(e.ns.e("empty-block"))
    }, [
      Ie(e.$slots, "empty", {}, () => {
        var i;
        return [
          X("span", {
            class: z(e.ns.e("empty-text"))
          }, Qe((i = e.emptyText) != null ? i : e.t("el.tree.emptyText")), 3)
        ];
      })
    ], 2)) : _e("v-if", !0),
    Bt(X("div", {
      ref: "dropIndicator$",
      class: z(e.ns.e("drop-indicator"))
    }, null, 2), [
      [pn, e.dragState.showDropIndicator]
    ])
  ], 2);
}
var Lp = /* @__PURE__ */ ut(hoe, [["render", moe], ["__file", "tree.vue"]]);
Lp.install = (e) => {
  e.component(Lp.name, Lp);
};
const iv = Lp, goe = iv, boe = (e, { attrs: t, emit: n }, {
  select: o,
  tree: l,
  key: a
}) => {
  const r = nt("tree-select");
  return Pe(() => e.data, () => {
    e.filterable && xe(() => {
      var s, u;
      (u = l.value) == null || u.filter((s = o.value) == null ? void 0 : s.states.inputValue);
    });
  }, { flush: "post" }), {
    ...er(Xo(e), Object.keys(Ns.props)),
    ...t,
    "onUpdate:modelValue": (s) => n(Jt, s),
    valueKey: a,
    popperClass: x(() => {
      const s = [r.e("popper")];
      return e.popperClass && s.push(e.popperClass), s.join(" ");
    }),
    filterMethod: (s = "") => {
      var u;
      e.filterMethod ? e.filterMethod(s) : e.remoteMethod ? e.remoteMethod(s) : (u = l.value) == null || u.filter(s);
    }
  };
}, yoe = Q({
  extends: Ad,
  setup(e, t) {
    const n = Ad.setup(e, t);
    delete n.selectOptionClick;
    const o = Pt().proxy;
    return xe(() => {
      n.select.states.cachedOptions.get(o.value) || n.select.onOptionCreate(o);
    }), n;
  },
  methods: {
    selectOptionClick() {
      this.$el.parentElement.click();
    }
  }
});
function sb(e) {
  return e || e === 0;
}
function $0(e) {
  return Array.isArray(e) && e.length;
}
function Nu(e) {
  return Array.isArray(e) ? e : sb(e) ? [e] : [];
}
function Pp(e, t, n, o, l) {
  for (let a = 0; a < e.length; a++) {
    const r = e[a];
    if (t(r, a, e, l))
      return o ? o(r, a, e, l) : r;
    {
      const i = n(r);
      if ($0(i)) {
        const s = Pp(i, t, n, o, r);
        if (s)
          return s;
      }
    }
  }
}
function ib(e, t, n, o) {
  for (let l = 0; l < e.length; l++) {
    const a = e[l];
    t(a, l, e, o);
    const r = n(a);
    $0(r) && ib(r, t, n, a);
  }
}
const Coe = (e, { attrs: t, slots: n, emit: o }, {
  select: l,
  tree: a,
  key: r
}) => {
  Pe(() => e.modelValue, () => {
    e.showCheckbox && xe(() => {
      const f = a.value;
      f && !pl(f.getCheckedKeys(), Nu(e.modelValue)) && f.setCheckedKeys(Nu(e.modelValue));
    });
  }, {
    immediate: !0,
    deep: !0
  });
  const i = x(() => ({
    value: r.value,
    label: "label",
    children: "children",
    disabled: "disabled",
    isLeaf: "isLeaf",
    ...e.props
  })), s = (f, v) => {
    var h;
    const m = i.value[f];
    return vn(m) ? m(v, (h = a.value) == null ? void 0 : h.getNode(s("value", v))) : v[m];
  }, u = Nu(e.modelValue).map((f) => Pp(e.data || [], (v) => s("value", v) === f, (v) => s("children", v), (v, h, m, p) => p && s("value", p))).filter((f) => sb(f)), d = x(() => {
    if (!e.renderAfterExpand && !e.lazy)
      return [];
    const f = [];
    return ib(e.data.concat(e.cacheData), (v) => {
      const h = s("value", v);
      f.push({
        value: h,
        currentLabel: s("label", v),
        isDisabled: s("disabled", v)
      });
    }, (v) => s("children", v)), f;
  });
  return {
    ...er(Xo(e), Object.keys(iv.props)),
    ...t,
    nodeKey: r,
    expandOnClickNode: x(() => !e.checkStrictly && e.expandOnClickNode),
    defaultExpandedKeys: x(() => e.defaultExpandedKeys ? e.defaultExpandedKeys.concat(u) : u),
    renderContent: (f, { node: v, data: h, store: m }) => f(yoe, {
      value: s("value", h),
      label: s("label", h),
      disabled: s("disabled", h)
    }, e.renderContent ? () => e.renderContent(f, { node: v, data: h, store: m }) : n.default ? () => n.default({ node: v, data: h, store: m }) : void 0),
    filterNodeMethod: (f, v, h) => e.filterNodeMethod ? e.filterNodeMethod(f, v, h) : f ? new RegExp(ry(f), "i").test(s("label", v) || "") : !0,
    onNodeClick: (f, v, h) => {
      var m, p, C, g;
      if ((m = t.onNodeClick) == null || m.call(t, f, v, h), !(e.showCheckbox && e.checkOnClickNode)) {
        if (!e.showCheckbox && (e.checkStrictly || v.isLeaf)) {
          if (!s("disabled", f)) {
            const w = (p = l.value) == null ? void 0 : p.states.options.get(s("value", f));
            (C = l.value) == null || C.handleOptionSelect(w);
          }
        } else
          e.expandOnClickNode && h.proxy.handleExpandIconClick();
        (g = l.value) == null || g.focus();
      }
    },
    onCheck: (f, v) => {
      var h;
      if (!e.showCheckbox)
        return;
      const m = s("value", f), p = {};
      ib([a.value.store.root], (b) => p[b.key] = b, (b) => b.childNodes);
      const C = v.checkedKeys, g = e.multiple ? Nu(e.modelValue).filter((b) => !(b in p) && !C.includes(b)) : [], w = g.concat(C);
      if (e.checkStrictly)
        o(Jt, e.multiple ? w : w.includes(m) ? m : void 0);
      else if (e.multiple)
        o(Jt, g.concat(a.value.getCheckedKeys(!0)));
      else {
        const b = Pp([f], (S) => !$0(s("children", S)) && !s("disabled", S), (S) => s("children", S)), y = b ? s("value", b) : void 0, E = sb(e.modelValue) && !!Pp([f], (S) => s("value", S) === e.modelValue, (S) => s("children", S));
        o(Jt, y === e.modelValue || E ? void 0 : y);
      }
      xe(() => {
        var b;
        const y = Nu(e.modelValue);
        a.value.setCheckedKeys(y), (b = t.onCheck) == null || b.call(t, f, {
          checkedKeys: a.value.getCheckedKeys(),
          checkedNodes: a.value.getCheckedNodes(),
          halfCheckedKeys: a.value.getHalfCheckedKeys(),
          halfCheckedNodes: a.value.getHalfCheckedNodes()
        });
      }), (h = l.value) == null || h.focus();
    },
    cacheOptions: d
  };
};
var woe = Q({
  props: {
    data: {
      type: Array,
      default: () => []
    }
  },
  setup(e) {
    const t = ot(vf);
    return Pe(() => e.data, () => {
      var n;
      e.data.forEach((l) => {
        t.states.cachedOptions.has(l.value) || t.states.cachedOptions.set(l.value, l);
      });
      const o = ((n = t.selectRef) == null ? void 0 : n.querySelectorAll("input")) || [];
      Array.from(o).includes(document.activeElement) || t.setSelected();
    }, { flush: "post", immediate: !0 }), () => {
    };
  }
});
const Eoe = Q({
  name: "ElTreeSelect",
  inheritAttrs: !1,
  props: {
    ...Ns.props,
    ...iv.props,
    cacheData: {
      type: Array,
      default: () => []
    }
  },
  setup(e, t) {
    const { slots: n, expose: o } = t, l = B(), a = B(), r = x(() => e.nodeKey || e.valueKey || "value"), i = boe(e, t, { select: l, tree: a, key: r }), { cacheOptions: s, ...u } = Coe(e, t, {
      select: l,
      tree: a,
      key: r
    }), d = en({});
    return o(d), Nt(() => {
      Object.assign(d, {
        ...er(a.value, [
          "filter",
          "updateKeyChildren",
          "getCheckedNodes",
          "setCheckedNodes",
          "getCheckedKeys",
          "setCheckedKeys",
          "setChecked",
          "getHalfCheckedNodes",
          "getHalfCheckedKeys",
          "getCurrentKey",
          "getCurrentNode",
          "setCurrentKey",
          "setCurrentNode",
          "getNode",
          "remove",
          "append",
          "insertBefore",
          "insertAfter"
        ]),
        ...er(l.value, ["focus", "blur"])
      });
    }), () => V(Ns, en({
      ...i,
      ref: (f) => l.value = f
    }), {
      ...n,
      default: () => [
        V(woe, { data: s.value }),
        V(iv, en({
          ...u,
          ref: (f) => a.value = f
        }))
      ]
    });
  }
});
var Ap = /* @__PURE__ */ ut(Eoe, [["__file", "tree-select.vue"]]);
Ap.install = (e) => {
  e.component(Ap.name, Ap);
};
const Soe = Ap, _oe = Soe, O0 = Symbol(), xoe = {
  key: -1,
  level: -1,
  data: {}
};
var Ku = /* @__PURE__ */ ((e) => (e.KEY = "id", e.LABEL = "label", e.CHILDREN = "children", e.DISABLED = "disabled", e))(Ku || {}), cb = /* @__PURE__ */ ((e) => (e.ADD = "add", e.DELETE = "delete", e))(cb || {});
const JO = {
  type: Number,
  default: 26
}, koe = it({
  data: {
    type: Ae(Array),
    default: () => Zn([])
  },
  emptyText: {
    type: String
  },
  height: {
    type: Number,
    default: 200
  },
  props: {
    type: Ae(Object),
    default: () => Zn({
      children: "children",
      label: "label",
      disabled: "disabled",
      value: "id"
      /* KEY */
    })
  },
  highlightCurrent: {
    type: Boolean,
    default: !1
  },
  showCheckbox: {
    type: Boolean,
    default: !1
  },
  defaultCheckedKeys: {
    type: Ae(Array),
    default: () => Zn([])
  },
  checkStrictly: {
    type: Boolean,
    default: !1
  },
  defaultExpandedKeys: {
    type: Ae(Array),
    default: () => Zn([])
  },
  indent: {
    type: Number,
    default: 16
  },
  itemSize: JO,
  icon: {
    type: Dn
  },
  expandOnClickNode: {
    type: Boolean,
    default: !0
  },
  checkOnClickNode: {
    type: Boolean,
    default: !1
  },
  currentNodeKey: {
    type: Ae([String, Number])
  },
  accordion: {
    type: Boolean,
    default: !1
  },
  filterMethod: {
    type: Ae(Function)
  },
  perfMode: {
    type: Boolean,
    default: !0
  }
}), Toe = it({
  node: {
    type: Ae(Object),
    default: () => Zn(xoe)
  },
  expanded: {
    type: Boolean,
    default: !1
  },
  checked: {
    type: Boolean,
    default: !1
  },
  indeterminate: {
    type: Boolean,
    default: !1
  },
  showCheckbox: {
    type: Boolean,
    default: !1
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  current: {
    type: Boolean,
    default: !1
  },
  hiddenExpandIcon: {
    type: Boolean,
    default: !1
  },
  itemSize: JO
}), $oe = it({
  node: {
    type: Ae(Object),
    required: !0
  }
}), QO = "node-click", eN = "node-expand", tN = "node-collapse", nN = "current-change", oN = "check", lN = "check-change", aN = "node-contextmenu", Ooe = {
  [QO]: (e, t, n) => e && t && n,
  [eN]: (e, t) => e && t,
  [tN]: (e, t) => e && t,
  [nN]: (e, t) => e && t,
  [oN]: (e, t) => e && t,
  [lN]: (e, t) => e && typeof t == "boolean",
  [aN]: (e, t, n) => e && t && n
}, Noe = {
  click: (e, t) => !!(e && t),
  toggle: (e) => !!e,
  check: (e, t) => e && typeof t == "boolean"
};
function Moe(e, t) {
  const n = B(/* @__PURE__ */ new Set()), o = B(/* @__PURE__ */ new Set()), { emit: l } = Pt();
  Pe([() => t.value, () => e.defaultCheckedKeys], () => xe(() => {
    w(e.defaultCheckedKeys);
  }), {
    immediate: !0
  });
  const a = () => {
    if (!t.value || !e.showCheckbox || e.checkStrictly)
      return;
    const { levelTreeNodeMap: b, maxLevel: y } = t.value, E = n.value, S = /* @__PURE__ */ new Set();
    for (let _ = y - 1; _ >= 1; --_) {
      const k = b.get(_);
      k && k.forEach((N) => {
        const L = N.children;
        if (L) {
          let R = !0, H = !1;
          for (const K of L) {
            const U = K.key;
            if (E.has(U))
              H = !0;
            else if (S.has(U)) {
              R = !1, H = !0;
              break;
            } else
              R = !1;
          }
          R ? E.add(N.key) : H ? (S.add(N.key), E.delete(N.key)) : (E.delete(N.key), S.delete(N.key));
        }
      });
    }
    o.value = S;
  }, r = (b) => n.value.has(b.key), i = (b) => o.value.has(b.key), s = (b, y, E = !0) => {
    const S = n.value, _ = (k, N) => {
      S[N ? cb.ADD : cb.DELETE](k.key);
      const L = k.children;
      !e.checkStrictly && L && L.forEach((R) => {
        R.disabled || _(R, N);
      });
    };
    _(b, y), a(), E && u(b, y);
  }, u = (b, y) => {
    const { checkedNodes: E, checkedKeys: S } = m(), { halfCheckedNodes: _, halfCheckedKeys: k } = p();
    l(oN, b.data, {
      checkedKeys: S,
      checkedNodes: E,
      halfCheckedKeys: k,
      halfCheckedNodes: _
    }), l(lN, b.data, y);
  };
  function d(b = !1) {
    return m(b).checkedKeys;
  }
  function f(b = !1) {
    return m(b).checkedNodes;
  }
  function v() {
    return p().halfCheckedKeys;
  }
  function h() {
    return p().halfCheckedNodes;
  }
  function m(b = !1) {
    const y = [], E = [];
    if (t != null && t.value && e.showCheckbox) {
      const { treeNodeMap: S } = t.value;
      n.value.forEach((_) => {
        const k = S.get(_);
        k && (!b || b && k.isLeaf) && (E.push(_), y.push(k.data));
      });
    }
    return {
      checkedKeys: E,
      checkedNodes: y
    };
  }
  function p() {
    const b = [], y = [];
    if (t != null && t.value && e.showCheckbox) {
      const { treeNodeMap: E } = t.value;
      o.value.forEach((S) => {
        const _ = E.get(S);
        _ && (y.push(S), b.push(_.data));
      });
    }
    return {
      halfCheckedNodes: b,
      halfCheckedKeys: y
    };
  }
  function C(b) {
    n.value.clear(), o.value.clear(), xe(() => {
      w(b);
    });
  }
  function g(b, y) {
    if (t != null && t.value && e.showCheckbox) {
      const E = t.value.treeNodeMap.get(b);
      E && s(E, y, !1);
    }
  }
  function w(b) {
    if (t != null && t.value) {
      const { treeNodeMap: y } = t.value;
      if (e.showCheckbox && y && b)
        for (const E of b) {
          const S = y.get(E);
          S && !r(S) && s(S, !0, !1);
        }
    }
  }
  return {
    updateCheckedKeys: a,
    toggleCheckbox: s,
    isChecked: r,
    isIndeterminate: i,
    getCheckedKeys: d,
    getCheckedNodes: f,
    getHalfCheckedKeys: v,
    getHalfCheckedNodes: h,
    setChecked: g,
    setCheckedKeys: C
  };
}
function Ioe(e, t) {
  const n = B(/* @__PURE__ */ new Set([])), o = B(/* @__PURE__ */ new Set([])), l = x(() => vn(e.filterMethod));
  function a(i) {
    var s;
    if (!l.value)
      return;
    const u = /* @__PURE__ */ new Set(), d = o.value, f = n.value, v = [], h = ((s = t.value) == null ? void 0 : s.treeNodes) || [], m = e.filterMethod;
    f.clear();
    function p(C) {
      C.forEach((g) => {
        v.push(g), m != null && m(i, g.data) ? v.forEach((b) => {
          u.add(b.key);
        }) : g.isLeaf && f.add(g.key);
        const w = g.children;
        if (w && p(w), !g.isLeaf) {
          if (!u.has(g.key))
            f.add(g.key);
          else if (w) {
            let b = !0;
            for (const y of w)
              if (!f.has(y.key)) {
                b = !1;
                break;
              }
            b ? d.add(g.key) : d.delete(g.key);
          }
        }
        v.pop();
      });
    }
    return p(h), u;
  }
  function r(i) {
    return o.value.has(i.key);
  }
  return {
    hiddenExpandIconKeySet: o,
    hiddenNodeKeySet: n,
    doFilter: a,
    isForceHiddenExpandIcon: r
  };
}
function Roe(e, t) {
  const n = B(new Set(e.defaultExpandedKeys)), o = B(), l = An();
  Pe(() => e.currentNodeKey, (Y) => {
    o.value = Y;
  }, {
    immediate: !0
  }), Pe(() => e.data, (Y) => {
    ce(Y);
  }, {
    immediate: !0
  });
  const {
    isIndeterminate: a,
    isChecked: r,
    toggleCheckbox: i,
    getCheckedKeys: s,
    getCheckedNodes: u,
    getHalfCheckedKeys: d,
    getHalfCheckedNodes: f,
    setChecked: v,
    setCheckedKeys: h
  } = Moe(e, l), { doFilter: m, hiddenNodeKeySet: p, isForceHiddenExpandIcon: C } = Ioe(e, l), g = x(() => {
    var Y;
    return ((Y = e.props) == null ? void 0 : Y.value) || Ku.KEY;
  }), w = x(() => {
    var Y;
    return ((Y = e.props) == null ? void 0 : Y.children) || Ku.CHILDREN;
  }), b = x(() => {
    var Y;
    return ((Y = e.props) == null ? void 0 : Y.disabled) || Ku.DISABLED;
  }), y = x(() => {
    var Y;
    return ((Y = e.props) == null ? void 0 : Y.label) || Ku.LABEL;
  }), E = x(() => {
    const Y = n.value, ve = p.value, ie = [], he = l.value && l.value.treeNodes || [];
    function De() {
      const $e = [];
      for (let ue = he.length - 1; ue >= 0; --ue)
        $e.push(he[ue]);
      for (; $e.length; ) {
        const ue = $e.pop();
        if (ue && (ve.has(ue.key) || ie.push(ue), Y.has(ue.key))) {
          const Ne = ue.children;
          if (Ne) {
            const je = Ne.length;
            for (let Fe = je - 1; Fe >= 0; --Fe)
              $e.push(Ne[Fe]);
          }
        }
      }
    }
    return De(), ie;
  }), S = x(() => E.value.length > 0);
  function _(Y) {
    const ve = /* @__PURE__ */ new Map(), ie = /* @__PURE__ */ new Map();
    let he = 1;
    function De(ue, Ne = 1, je = void 0) {
      var Fe;
      const Ve = [];
      for (const Ze of ue) {
        const ae = L(Ze), pe = {
          level: Ne,
          key: ae,
          data: Ze
        };
        pe.label = H(Ze), pe.parent = je;
        const ke = N(Ze);
        pe.disabled = R(Ze), pe.isLeaf = !ke || ke.length === 0, ke && ke.length && (pe.children = De(ke, Ne + 1, pe)), Ve.push(pe), ve.set(ae, pe), ie.has(Ne) || ie.set(Ne, []), (Fe = ie.get(Ne)) == null || Fe.push(pe);
      }
      return Ne > he && (he = Ne), Ve;
    }
    const $e = De(Y);
    return {
      treeNodeMap: ve,
      levelTreeNodeMap: ie,
      maxLevel: he,
      treeNodes: $e
    };
  }
  function k(Y) {
    const ve = m(Y);
    ve && (n.value = ve);
  }
  function N(Y) {
    return Y[w.value];
  }
  function L(Y) {
    return Y ? Y[g.value] : "";
  }
  function R(Y) {
    return Y[b.value];
  }
  function H(Y) {
    return Y[y.value];
  }
  function K(Y) {
    n.value.has(Y.key) ? O(Y) : D(Y);
  }
  function U(Y) {
    n.value = new Set(Y);
  }
  function W(Y, ve) {
    t(QO, Y.data, Y, ve), A(Y), e.expandOnClickNode && K(Y), e.showCheckbox && e.checkOnClickNode && !Y.disabled && i(Y, !r(Y), !0);
  }
  function A(Y) {
    Z(Y) || (o.value = Y.key, t(nN, Y.data, Y));
  }
  function $(Y, ve) {
    i(Y, ve);
  }
  function D(Y) {
    const ve = n.value;
    if (l.value && e.accordion) {
      const { treeNodeMap: ie } = l.value;
      ve.forEach((he) => {
        const De = ie.get(he);
        Y && Y.level === (De == null ? void 0 : De.level) && ve.delete(he);
      });
    }
    ve.add(Y.key), t(eN, Y.data, Y);
  }
  function O(Y) {
    n.value.delete(Y.key), t(tN, Y.data, Y);
  }
  function F(Y) {
    return n.value.has(Y.key);
  }
  function j(Y) {
    return !!Y.disabled;
  }
  function Z(Y) {
    const ve = o.value;
    return ve !== void 0 && ve === Y.key;
  }
  function te() {
    var Y, ve;
    if (o.value)
      return (ve = (Y = l.value) == null ? void 0 : Y.treeNodeMap.get(o.value)) == null ? void 0 : ve.data;
  }
  function de() {
    return o.value;
  }
  function Oe(Y) {
    o.value = Y;
  }
  function ce(Y) {
    xe(() => l.value = _(Y));
  }
  function ne(Y) {
    var ve;
    const ie = Mn(Y) ? L(Y) : Y;
    return (ve = l.value) == null ? void 0 : ve.treeNodeMap.get(ie);
  }
  return {
    tree: l,
    flattenTree: E,
    isNotEmpty: S,
    getKey: L,
    getChildren: N,
    toggleExpand: K,
    toggleCheckbox: i,
    isExpanded: F,
    isChecked: r,
    isIndeterminate: a,
    isDisabled: j,
    isCurrent: Z,
    isForceHiddenExpandIcon: C,
    handleNodeClick: W,
    handleNodeCheck: $,
    getCurrentNode: te,
    getCurrentKey: de,
    setCurrentKey: Oe,
    getCheckedKeys: s,
    getCheckedNodes: u,
    getHalfCheckedKeys: d,
    getHalfCheckedNodes: f,
    setChecked: v,
    setCheckedKeys: h,
    filter: k,
    setData: ce,
    getNode: ne,
    expandNode: D,
    collapseNode: O,
    setExpandedKeys: U
  };
}
var Doe = Q({
  name: "ElTreeNodeContent",
  props: $oe,
  setup(e) {
    const t = ot(O0), n = nt("tree");
    return () => {
      const o = e.node, { data: l } = o;
      return t != null && t.ctx.slots.default ? t.ctx.slots.default({ node: o, data: l }) : V("span", { class: n.be("node", "label") }, [o == null ? void 0 : o.label]);
    };
  }
});
const Loe = ["aria-expanded", "aria-disabled", "aria-checked", "data-key", "onClick"], Poe = Q({
  name: "ElTreeNode"
}), Aoe = /* @__PURE__ */ Q({
  ...Poe,
  props: Toe,
  emits: Noe,
  setup(e, { emit: t }) {
    const n = e, o = ot(O0), l = nt("tree"), a = x(() => {
      var f;
      return (f = o == null ? void 0 : o.props.indent) != null ? f : 16;
    }), r = x(() => {
      var f;
      return (f = o == null ? void 0 : o.props.icon) != null ? f : qx;
    }), i = (f) => {
      t("click", n.node, f);
    }, s = () => {
      t("toggle", n.node);
    }, u = (f) => {
      t("check", n.node, f);
    }, d = (f) => {
      var v, h, m, p;
      (m = (h = (v = o == null ? void 0 : o.instance) == null ? void 0 : v.vnode) == null ? void 0 : h.props) != null && m.onNodeContextmenu && (f.stopPropagation(), f.preventDefault()), o == null || o.ctx.emit(aN, f, (p = n.node) == null ? void 0 : p.data, n.node);
    };
    return (f, v) => {
      var h, m, p;
      return M(), G("div", {
        ref: "node$",
        class: z([
          c(l).b("node"),
          c(l).is("expanded", f.expanded),
          c(l).is("current", f.current),
          c(l).is("focusable", !f.disabled),
          c(l).is("checked", !f.disabled && f.checked)
        ]),
        role: "treeitem",
        tabindex: "-1",
        "aria-expanded": f.expanded,
        "aria-disabled": f.disabled,
        "aria-checked": f.checked,
        "data-key": (h = f.node) == null ? void 0 : h.key,
        onClick: It(i, ["stop"]),
        onContextmenu: d
      }, [
        X("div", {
          class: z(c(l).be("node", "content")),
          style: bt({
            paddingLeft: `${(f.node.level - 1) * c(a)}px`,
            height: f.itemSize + "px"
          })
        }, [
          c(r) ? (M(), We(c(Ct), {
            key: 0,
            class: z([
              c(l).is("leaf", !!((m = f.node) != null && m.isLeaf)),
              c(l).is("hidden", f.hiddenExpandIcon),
              {
                expanded: !((p = f.node) != null && p.isLeaf) && f.expanded
              },
              c(l).be("node", "expand-icon")
            ]),
            onClick: It(s, ["stop"])
          }, {
            default: fe(() => [
              (M(), We(Qt(c(r))))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : _e("v-if", !0),
          f.showCheckbox ? (M(), We(c(ta), {
            key: 1,
            "model-value": f.checked,
            indeterminate: f.indeterminate,
            disabled: f.disabled,
            onChange: u,
            onClick: v[0] || (v[0] = It(() => {
            }, ["stop"]))
          }, null, 8, ["model-value", "indeterminate", "disabled"])) : _e("v-if", !0),
          oe(c(Doe), { node: f.node }, null, 8, ["node"])
        ], 6)
      ], 42, Loe);
    };
  }
});
var Foe = /* @__PURE__ */ ut(Aoe, [["__file", "tree-node.vue"]]);
const Voe = Q({
  name: "ElTreeV2"
}), Boe = /* @__PURE__ */ Q({
  ...Voe,
  props: koe,
  emits: Ooe,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = Yn(), a = x(() => o.itemSize);
    Mt(O0, {
      ctx: {
        emit: n,
        slots: l
      },
      props: o,
      instance: Pt()
    }), Mt(ur, void 0);
    const { t: r } = bn(), i = nt("tree"), {
      flattenTree: s,
      isNotEmpty: u,
      toggleExpand: d,
      isExpanded: f,
      isIndeterminate: v,
      isChecked: h,
      isDisabled: m,
      isCurrent: p,
      isForceHiddenExpandIcon: C,
      handleNodeClick: g,
      handleNodeCheck: w,
      toggleCheckbox: b,
      getCurrentNode: y,
      getCurrentKey: E,
      setCurrentKey: S,
      getCheckedKeys: _,
      getCheckedNodes: k,
      getHalfCheckedKeys: N,
      getHalfCheckedNodes: L,
      setChecked: R,
      setCheckedKeys: H,
      filter: K,
      setData: U,
      getNode: W,
      expandNode: A,
      collapseNode: $,
      setExpandedKeys: D
    } = Roe(o, n);
    return t({
      toggleCheckbox: b,
      getCurrentNode: y,
      getCurrentKey: E,
      setCurrentKey: S,
      getCheckedKeys: _,
      getCheckedNodes: k,
      getHalfCheckedKeys: N,
      getHalfCheckedNodes: L,
      setChecked: R,
      setCheckedKeys: H,
      filter: K,
      setData: U,
      getNode: W,
      expandNode: A,
      collapseNode: $,
      setExpandedKeys: D
    }), (O, F) => {
      var j;
      return M(), G("div", {
        class: z([c(i).b(), { [c(i).m("highlight-current")]: O.highlightCurrent }]),
        role: "tree"
      }, [
        c(u) ? (M(), We(c(aO), {
          key: 0,
          "class-name": c(i).b("virtual-list"),
          data: c(s),
          total: c(s).length,
          height: O.height,
          "item-size": c(a),
          "perf-mode": O.perfMode
        }, {
          default: fe(({ data: Z, index: te, style: de }) => [
            (M(), We(Foe, {
              key: Z[te].key,
              style: bt(de),
              node: Z[te],
              expanded: c(f)(Z[te]),
              "show-checkbox": O.showCheckbox,
              checked: c(h)(Z[te]),
              indeterminate: c(v)(Z[te]),
              "item-size": c(a),
              disabled: c(m)(Z[te]),
              current: c(p)(Z[te]),
              "hidden-expand-icon": c(C)(Z[te]),
              onClick: c(g),
              onToggle: c(d),
              onCheck: c(w)
            }, null, 8, ["style", "node", "expanded", "show-checkbox", "checked", "indeterminate", "item-size", "disabled", "current", "hidden-expand-icon", "onClick", "onToggle", "onCheck"]))
          ]),
          _: 1
        }, 8, ["class-name", "data", "total", "height", "item-size", "perf-mode"])) : (M(), G("div", {
          key: 1,
          class: z(c(i).e("empty-block"))
        }, [
          X("span", {
            class: z(c(i).e("empty-text"))
          }, Qe((j = O.emptyText) != null ? j : c(r)("el.tree.emptyText")), 3)
        ], 2))
      ], 2);
    };
  }
});
var Hoe = /* @__PURE__ */ ut(Boe, [["__file", "tree.vue"]]);
const zoe = Yt(Hoe), rN = Symbol("uploadContextKey"), Woe = "ElUpload";
class Koe extends Error {
  constructor(t, n, o, l) {
    super(t), this.name = "UploadAjaxError", this.status = n, this.method = o, this.url = l;
  }
}
function FE(e, t, n) {
  let o;
  return n.response ? o = `${n.response.error || n.response}` : n.responseText ? o = `${n.responseText}` : o = `fail to ${t.method} ${e} ${n.status}`, new Koe(o, n.status, t.method, e);
}
function Uoe(e) {
  const t = e.responseText || e.response;
  if (!t)
    return t;
  try {
    return JSON.parse(t);
  } catch {
    return t;
  }
}
const joe = (e) => {
  typeof XMLHttpRequest > "u" && lo(Woe, "XMLHttpRequest is undefined");
  const t = new XMLHttpRequest(), n = e.action;
  t.upload && t.upload.addEventListener("progress", (a) => {
    const r = a;
    r.percent = a.total > 0 ? a.loaded / a.total * 100 : 0, e.onProgress(r);
  });
  const o = new FormData();
  if (e.data)
    for (const [a, r] of Object.entries(e.data))
      Kt(r) && r.length ? o.append(a, ...r) : o.append(a, r);
  o.append(e.filename, e.file, e.file.name), t.addEventListener("error", () => {
    e.onError(FE(n, e, t));
  }), t.addEventListener("load", () => {
    if (t.status < 200 || t.status >= 300)
      return e.onError(FE(n, e, t));
    e.onSuccess(Uoe(t));
  }), t.open(e.method, n, !0), e.withCredentials && "withCredentials" in t && (t.withCredentials = !0);
  const l = e.headers || {};
  if (l instanceof Headers)
    l.forEach((a, r) => t.setRequestHeader(r, a));
  else
    for (const [a, r] of Object.entries(l))
      zo(r) || t.setRequestHeader(a, String(r));
  return t.send(o), t;
}, sN = ["text", "picture", "picture-card"];
let qoe = 1;
const ub = () => Date.now() + qoe++, iN = it({
  action: {
    type: String,
    default: "#"
  },
  headers: {
    type: Ae(Object)
  },
  method: {
    type: String,
    default: "post"
  },
  data: {
    type: Ae([Object, Function, Promise]),
    default: () => Zn({})
  },
  multiple: {
    type: Boolean,
    default: !1
  },
  name: {
    type: String,
    default: "file"
  },
  drag: {
    type: Boolean,
    default: !1
  },
  withCredentials: Boolean,
  showFileList: {
    type: Boolean,
    default: !0
  },
  accept: {
    type: String,
    default: ""
  },
  fileList: {
    type: Ae(Array),
    default: () => Zn([])
  },
  autoUpload: {
    type: Boolean,
    default: !0
  },
  listType: {
    type: String,
    values: sN,
    default: "text"
  },
  httpRequest: {
    type: Ae(Function),
    default: joe
  },
  disabled: Boolean,
  limit: Number
}), Yoe = it({
  ...iN,
  beforeUpload: {
    type: Ae(Function),
    default: no
  },
  beforeRemove: {
    type: Ae(Function)
  },
  onRemove: {
    type: Ae(Function),
    default: no
  },
  onChange: {
    type: Ae(Function),
    default: no
  },
  onPreview: {
    type: Ae(Function),
    default: no
  },
  onSuccess: {
    type: Ae(Function),
    default: no
  },
  onProgress: {
    type: Ae(Function),
    default: no
  },
  onError: {
    type: Ae(Function),
    default: no
  },
  onExceed: {
    type: Ae(Function),
    default: no
  },
  crossorigin: {
    type: Ae(String)
  }
}), Goe = it({
  files: {
    type: Ae(Array),
    default: () => Zn([])
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  handlePreview: {
    type: Ae(Function),
    default: no
  },
  listType: {
    type: String,
    values: sN,
    default: "text"
  },
  crossorigin: {
    type: Ae(String)
  }
}), Xoe = {
  remove: (e) => !!e
}, Zoe = ["onKeydown"], Joe = ["src", "crossorigin"], Qoe = ["onClick"], ele = ["title"], tle = ["onClick"], nle = ["onClick"], ole = Q({
  name: "ElUploadList"
}), lle = /* @__PURE__ */ Q({
  ...ole,
  props: Goe,
  emits: Xoe,
  setup(e, { emit: t }) {
    const n = e, { t: o } = bn(), l = nt("upload"), a = nt("icon"), r = nt("list"), i = Nl(), s = B(!1), u = x(() => [
      l.b("list"),
      l.bm("list", n.listType),
      l.is("disabled", n.disabled)
    ]), d = (f) => {
      t("remove", f);
    };
    return (f, v) => (M(), We(Ab, {
      tag: "ul",
      class: z(c(u)),
      name: c(r).b()
    }, {
      default: fe(() => [
        (M(!0), G(kt, null, ln(f.files, (h) => (M(), G("li", {
          key: h.uid || h.name,
          class: z([
            c(l).be("list", "item"),
            c(l).is(h.status),
            { focusing: s.value }
          ]),
          tabindex: "0",
          onKeydown: Rn((m) => !c(i) && d(h), ["delete"]),
          onFocus: v[0] || (v[0] = (m) => s.value = !0),
          onBlur: v[1] || (v[1] = (m) => s.value = !1),
          onClick: v[2] || (v[2] = (m) => s.value = !1)
        }, [
          Ie(f.$slots, "default", { file: h }, () => [
            f.listType === "picture" || h.status !== "uploading" && f.listType === "picture-card" ? (M(), G("img", {
              key: 0,
              class: z(c(l).be("list", "item-thumbnail")),
              src: h.url,
              crossorigin: f.crossorigin,
              alt: ""
            }, null, 10, Joe)) : _e("v-if", !0),
            h.status === "uploading" || f.listType !== "picture-card" ? (M(), G("div", {
              key: 1,
              class: z(c(l).be("list", "item-info"))
            }, [
              X("a", {
                class: z(c(l).be("list", "item-name")),
                onClick: It((m) => f.handlePreview(h), ["prevent"])
              }, [
                oe(c(Ct), {
                  class: z(c(a).m("document"))
                }, {
                  default: fe(() => [
                    oe(c(E8))
                  ]),
                  _: 1
                }, 8, ["class"]),
                X("span", {
                  class: z(c(l).be("list", "item-file-name")),
                  title: h.name
                }, Qe(h.name), 11, ele)
              ], 10, Qoe),
              h.status === "uploading" ? (M(), We(c(c0), {
                key: 0,
                type: f.listType === "picture-card" ? "circle" : "line",
                "stroke-width": f.listType === "picture-card" ? 6 : 2,
                percentage: Number(h.percentage),
                style: bt(f.listType === "picture-card" ? "" : "margin-top: 0.5rem")
              }, null, 8, ["type", "stroke-width", "percentage", "style"])) : _e("v-if", !0)
            ], 2)) : _e("v-if", !0),
            X("label", {
              class: z(c(l).be("list", "item-status-label"))
            }, [
              f.listType === "text" ? (M(), We(c(Ct), {
                key: 0,
                class: z([c(a).m("upload-success"), c(a).m("circle-check")])
              }, {
                default: fe(() => [
                  oe(c(cy))
                ]),
                _: 1
              }, 8, ["class"])) : ["picture-card", "picture"].includes(f.listType) ? (M(), We(c(Ct), {
                key: 1,
                class: z([c(a).m("upload-success"), c(a).m("check")])
              }, {
                default: fe(() => [
                  oe(c(lf))
                ]),
                _: 1
              }, 8, ["class"])) : _e("v-if", !0)
            ], 2),
            c(i) ? _e("v-if", !0) : (M(), We(c(Ct), {
              key: 2,
              class: z(c(a).m("close")),
              onClick: (m) => d(h)
            }, {
              default: fe(() => [
                oe(c(Fa))
              ]),
              _: 2
            }, 1032, ["class", "onClick"])),
            _e(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
            _e(" This is a bug which needs to be fixed "),
            _e(" TODO: Fix the incorrect navigation interaction "),
            c(i) ? _e("v-if", !0) : (M(), G("i", {
              key: 3,
              class: z(c(a).m("close-tip"))
            }, Qe(c(o)("el.upload.deleteTip")), 3)),
            f.listType === "picture-card" ? (M(), G("span", {
              key: 4,
              class: z(c(l).be("list", "item-actions"))
            }, [
              X("span", {
                class: z(c(l).be("list", "item-preview")),
                onClick: (m) => f.handlePreview(h)
              }, [
                oe(c(Ct), {
                  class: z(c(a).m("zoom-in"))
                }, {
                  default: fe(() => [
                    oe(c(Jx))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 10, tle),
              c(i) ? _e("v-if", !0) : (M(), G("span", {
                key: 0,
                class: z(c(l).be("list", "item-delete")),
                onClick: (m) => d(h)
              }, [
                oe(c(Ct), {
                  class: z(c(a).m("delete"))
                }, {
                  default: fe(() => [
                    oe(c(C8))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 10, nle))
            ], 2)) : _e("v-if", !0)
          ])
        ], 42, Zoe))), 128)),
        Ie(f.$slots, "append")
      ]),
      _: 3
    }, 8, ["class", "name"]));
  }
});
var VE = /* @__PURE__ */ ut(lle, [["__file", "upload-list.vue"]]);
const ale = it({
  disabled: {
    type: Boolean,
    default: !1
  }
}), rle = {
  file: (e) => Kt(e)
}, sle = ["onDrop", "onDragover"], cN = "ElUploadDrag", ile = Q({
  name: cN
}), cle = /* @__PURE__ */ Q({
  ...ile,
  props: ale,
  emits: rle,
  setup(e, { emit: t }) {
    ot(rN) || lo(cN, "usage: <el-upload><el-upload-dragger /></el-upload>");
    const o = nt("upload"), l = B(!1), a = Nl(), r = (s) => {
      if (a.value)
        return;
      l.value = !1, s.stopPropagation();
      const u = Array.from(s.dataTransfer.files);
      t("file", u);
    }, i = () => {
      a.value || (l.value = !0);
    };
    return (s, u) => (M(), G("div", {
      class: z([c(o).b("dragger"), c(o).is("dragover", l.value)]),
      onDrop: It(r, ["prevent"]),
      onDragover: It(i, ["prevent"]),
      onDragleave: u[0] || (u[0] = It((d) => l.value = !1, ["prevent"]))
    }, [
      Ie(s.$slots, "default")
    ], 42, sle));
  }
});
var ule = /* @__PURE__ */ ut(cle, [["__file", "upload-dragger.vue"]]);
const dle = it({
  ...iN,
  beforeUpload: {
    type: Ae(Function),
    default: no
  },
  onRemove: {
    type: Ae(Function),
    default: no
  },
  onStart: {
    type: Ae(Function),
    default: no
  },
  onSuccess: {
    type: Ae(Function),
    default: no
  },
  onProgress: {
    type: Ae(Function),
    default: no
  },
  onError: {
    type: Ae(Function),
    default: no
  },
  onExceed: {
    type: Ae(Function),
    default: no
  }
}), fle = ["onKeydown"], ple = ["name", "multiple", "accept"], vle = Q({
  name: "ElUploadContent",
  inheritAttrs: !1
}), hle = /* @__PURE__ */ Q({
  ...vle,
  props: dle,
  setup(e, { expose: t }) {
    const n = e, o = nt("upload"), l = Nl(), a = An({}), r = An(), i = (p) => {
      if (p.length === 0)
        return;
      const { autoUpload: C, limit: g, fileList: w, multiple: b, onStart: y, onExceed: E } = n;
      if (g && w.length + p.length > g) {
        E(p, w);
        return;
      }
      b || (p = p.slice(0, 1));
      for (const S of p) {
        const _ = S;
        _.uid = ub(), y(_), C && s(_);
      }
    }, s = async (p) => {
      if (r.value.value = "", !n.beforeUpload)
        return d(p);
      let C, g = {};
      try {
        const b = n.data, y = n.beforeUpload(p);
        g = mC(n.data) ? jp(n.data) : n.data, C = await y, mC(n.data) && pl(b, g) && (g = jp(n.data));
      } catch {
        C = !1;
      }
      if (C === !1) {
        n.onRemove(p);
        return;
      }
      let w = p;
      C instanceof Blob && (C instanceof File ? w = C : w = new File([C], p.name, {
        type: p.type
      })), d(Object.assign(w, {
        uid: p.uid
      }), g);
    }, u = async (p, C) => vn(p) ? p(C) : p, d = async (p, C) => {
      const {
        headers: g,
        data: w,
        method: b,
        withCredentials: y,
        name: E,
        action: S,
        onProgress: _,
        onSuccess: k,
        onError: N,
        httpRequest: L
      } = n;
      try {
        C = await u(C ?? w, p);
      } catch {
        n.onRemove(p);
        return;
      }
      const { uid: R } = p, H = {
        headers: g || {},
        withCredentials: y,
        file: p,
        data: C,
        method: b,
        filename: E,
        action: S,
        onProgress: (U) => {
          _(U, p);
        },
        onSuccess: (U) => {
          k(U, p), delete a.value[R];
        },
        onError: (U) => {
          N(U, p), delete a.value[R];
        }
      }, K = L(H);
      a.value[R] = K, K instanceof Promise && K.then(H.onSuccess, H.onError);
    }, f = (p) => {
      const C = p.target.files;
      C && i(Array.from(C));
    }, v = () => {
      l.value || (r.value.value = "", r.value.click());
    }, h = () => {
      v();
    };
    return t({
      abort: (p) => {
        YF(a.value).filter(p ? ([g]) => String(p.uid) === g : () => !0).forEach(([g, w]) => {
          w instanceof XMLHttpRequest && w.abort(), delete a.value[g];
        });
      },
      upload: s
    }), (p, C) => (M(), G("div", {
      class: z([c(o).b(), c(o).m(p.listType), c(o).is("drag", p.drag)]),
      tabindex: "0",
      onClick: v,
      onKeydown: Rn(It(h, ["self"]), ["enter", "space"])
    }, [
      p.drag ? (M(), We(ule, {
        key: 0,
        disabled: c(l),
        onFile: i
      }, {
        default: fe(() => [
          Ie(p.$slots, "default")
        ]),
        _: 3
      }, 8, ["disabled"])) : Ie(p.$slots, "default", { key: 1 }),
      X("input", {
        ref_key: "inputRef",
        ref: r,
        class: z(c(o).e("input")),
        name: p.name,
        multiple: p.multiple,
        accept: p.accept,
        type: "file",
        onChange: f,
        onClick: C[0] || (C[0] = It(() => {
        }, ["stop"]))
      }, null, 42, ple)
    ], 42, fle));
  }
});
var BE = /* @__PURE__ */ ut(hle, [["__file", "upload-content.vue"]]);
const HE = "ElUpload", zE = (e) => {
  var t;
  (t = e.url) != null && t.startsWith("blob:") && URL.revokeObjectURL(e.url);
}, mle = (e, t) => {
  const n = Q2(e, "fileList", void 0, { passive: !0 }), o = (v) => n.value.find((h) => h.uid === v.uid);
  function l(v) {
    var h;
    (h = t.value) == null || h.abort(v);
  }
  function a(v = ["ready", "uploading", "success", "fail"]) {
    n.value = n.value.filter((h) => !v.includes(h.status));
  }
  const r = (v, h) => {
    const m = o(h);
    m && (console.error(v), m.status = "fail", n.value.splice(n.value.indexOf(m), 1), e.onError(v, m, n.value), e.onChange(m, n.value));
  }, i = (v, h) => {
    const m = o(h);
    m && (e.onProgress(v, m, n.value), m.status = "uploading", m.percentage = Math.round(v.percent));
  }, s = (v, h) => {
    const m = o(h);
    m && (m.status = "success", m.response = v, e.onSuccess(v, m, n.value), e.onChange(m, n.value));
  }, u = (v) => {
    zo(v.uid) && (v.uid = ub());
    const h = {
      name: v.name,
      percentage: 0,
      status: "ready",
      size: v.size,
      raw: v,
      uid: v.uid
    };
    if (e.listType === "picture-card" || e.listType === "picture")
      try {
        h.url = URL.createObjectURL(v);
      } catch (m) {
        dn(HE, m.message), e.onError(m, h, n.value);
      }
    n.value = [...n.value, h], e.onChange(h, n.value);
  }, d = async (v) => {
    const h = v instanceof File ? o(v) : v;
    h || lo(HE, "file to be removed not found");
    const m = (p) => {
      l(p);
      const C = n.value;
      C.splice(C.indexOf(p), 1), e.onRemove(p, C), zE(p);
    };
    e.beforeRemove ? await e.beforeRemove(h, n.value) !== !1 && m(h) : m(h);
  };
  function f() {
    n.value.filter(({ status: v }) => v === "ready").forEach(({ raw: v }) => {
      var h;
      return v && ((h = t.value) == null ? void 0 : h.upload(v));
    });
  }
  return Pe(() => e.listType, (v) => {
    v !== "picture-card" && v !== "picture" || (n.value = n.value.map((h) => {
      const { raw: m, url: p } = h;
      if (!p && m)
        try {
          h.url = URL.createObjectURL(m);
        } catch (C) {
          e.onError(C, h, n.value);
        }
      return h;
    }));
  }), Pe(n, (v) => {
    for (const h of v)
      h.uid || (h.uid = ub()), h.status || (h.status = "success");
  }, { immediate: !0, deep: !0 }), {
    uploadFiles: n,
    abort: l,
    clearFiles: a,
    handleError: r,
    handleProgress: i,
    handleStart: u,
    handleSuccess: s,
    handleRemove: d,
    submit: f,
    revokeFileObjectURL: zE
  };
}, gle = Q({
  name: "ElUpload"
}), ble = /* @__PURE__ */ Q({
  ...gle,
  props: Yoe,
  setup(e, { expose: t }) {
    const n = e, o = Nl(), l = An(), {
      abort: a,
      submit: r,
      clearFiles: i,
      uploadFiles: s,
      handleStart: u,
      handleError: d,
      handleRemove: f,
      handleSuccess: v,
      handleProgress: h,
      revokeFileObjectURL: m
    } = mle(n, l), p = x(() => n.listType === "picture-card"), C = x(() => ({
      ...n,
      fileList: s.value,
      onStart: u,
      onProgress: h,
      onSuccess: v,
      onError: d,
      onRemove: f
    }));
    return zn(() => {
      s.value.forEach(m);
    }), Mt(rN, {
      accept: Pn(n, "accept")
    }), t({
      abort: a,
      submit: r,
      clearFiles: i,
      handleStart: u,
      handleRemove: f
    }), (g, w) => (M(), G("div", null, [
      c(p) && g.showFileList ? (M(), We(VE, {
        key: 0,
        disabled: c(o),
        "list-type": g.listType,
        files: c(s),
        crossorigin: g.crossorigin,
        "handle-preview": g.onPreview,
        onRemove: c(f)
      }, rl({
        append: fe(() => [
          oe(BE, Et({
            ref_key: "uploadRef",
            ref: l
          }, c(C)), {
            default: fe(() => [
              g.$slots.trigger ? Ie(g.$slots, "trigger", { key: 0 }) : _e("v-if", !0),
              !g.$slots.trigger && g.$slots.default ? Ie(g.$slots, "default", { key: 1 }) : _e("v-if", !0)
            ]),
            _: 3
          }, 16)
        ]),
        _: 2
      }, [
        g.$slots.file ? {
          name: "default",
          fn: fe(({ file: b }) => [
            Ie(g.$slots, "file", { file: b })
          ])
        } : void 0
      ]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : _e("v-if", !0),
      !c(p) || c(p) && !g.showFileList ? (M(), We(BE, Et({
        key: 1,
        ref_key: "uploadRef",
        ref: l
      }, c(C)), {
        default: fe(() => [
          g.$slots.trigger ? Ie(g.$slots, "trigger", { key: 0 }) : _e("v-if", !0),
          !g.$slots.trigger && g.$slots.default ? Ie(g.$slots, "default", { key: 1 }) : _e("v-if", !0)
        ]),
        _: 3
      }, 16)) : _e("v-if", !0),
      g.$slots.trigger ? Ie(g.$slots, "default", { key: 2 }) : _e("v-if", !0),
      Ie(g.$slots, "tip"),
      !c(p) && g.showFileList ? (M(), We(VE, {
        key: 3,
        disabled: c(o),
        "list-type": g.listType,
        files: c(s),
        crossorigin: g.crossorigin,
        "handle-preview": g.onPreview,
        onRemove: c(f)
      }, rl({ _: 2 }, [
        g.$slots.file ? {
          name: "default",
          fn: fe(({ file: b }) => [
            Ie(g.$slots, "file", { file: b })
          ])
        } : void 0
      ]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : _e("v-if", !0)
    ]));
  }
});
var yle = /* @__PURE__ */ ut(ble, [["__file", "upload.vue"]]);
const uN = Yt(yle), Cle = it({
  zIndex: {
    type: Number,
    default: 9
  },
  rotate: {
    type: Number,
    default: -22
  },
  width: Number,
  height: Number,
  image: String,
  content: {
    type: Ae([String, Array]),
    default: "Element Plus"
  },
  font: {
    type: Ae(Object)
  },
  gap: {
    type: Ae(Array),
    default: () => [100, 100]
  },
  offset: {
    type: Ae(Array)
  }
});
function wle(e) {
  return e.replace(/([A-Z])/g, "-$1").toLowerCase();
}
function Ele(e) {
  return Object.keys(e).map((t) => `${wle(t)}: ${e[t]};`).join(" ");
}
function Sle() {
  return window.devicePixelRatio || 1;
}
const _le = (e, t) => {
  let n = !1;
  return e.removedNodes.length && t && (n = Array.from(e.removedNodes).includes(t)), e.type === "attributes" && e.target === t && (n = !0), n;
}, dN = 3;
function hm(e, t, n = 1) {
  const o = document.createElement("canvas"), l = o.getContext("2d"), a = e * n, r = t * n;
  return o.setAttribute("width", `${a}px`), o.setAttribute("height", `${r}px`), l.save(), [l, o, a, r];
}
function xle() {
  function e(t, n, o, l, a, r, i, s) {
    const [u, d, f, v] = hm(l, a, o);
    if (t instanceof HTMLImageElement)
      u.drawImage(t, 0, 0, f, v);
    else {
      const {
        color: j,
        fontSize: Z,
        fontStyle: te,
        fontWeight: de,
        fontFamily: Oe,
        textAlign: ce,
        textBaseline: ne
      } = r, Y = Number(Z) * o;
      u.font = `${te} normal ${de} ${Y}px/${a}px ${Oe}`, u.fillStyle = j, u.textAlign = ce, u.textBaseline = ne;
      const ve = Array.isArray(t) ? t : [t];
      ve == null || ve.forEach((ie, he) => {
        u.fillText(ie ?? "", f / 2, he * (Y + dN * o));
      });
    }
    const h = Math.PI / 180 * Number(n), m = Math.max(l, a), [p, C, g] = hm(m, m, o);
    p.translate(g / 2, g / 2), p.rotate(h), f > 0 && v > 0 && p.drawImage(d, -f / 2, -v / 2);
    function w(j, Z) {
      const te = j * Math.cos(h) - Z * Math.sin(h), de = j * Math.sin(h) + Z * Math.cos(h);
      return [te, de];
    }
    let b = 0, y = 0, E = 0, S = 0;
    const _ = f / 2, k = v / 2;
    [
      [0 - _, 0 - k],
      [0 + _, 0 - k],
      [0 + _, 0 + k],
      [0 - _, 0 + k]
    ].forEach(([j, Z]) => {
      const [te, de] = w(j, Z);
      b = Math.min(b, te), y = Math.max(y, te), E = Math.min(E, de), S = Math.max(S, de);
    });
    const L = b + g / 2, R = E + g / 2, H = y - b, K = S - E, U = i * o, W = s * o, A = (H + U) * 2, $ = K + W, [D, O] = hm(A, $);
    function F(j = 0, Z = 0) {
      D.drawImage(C, L, R, H, K, j, Z, H, K);
    }
    return F(), F(H + U, -K / 2 - W / 2), F(H + U, +K / 2 + W / 2), [O.toDataURL(), A / o, $ / o];
  }
  return e;
}
const kle = Q({
  name: "ElWatermark"
}), Tle = /* @__PURE__ */ Q({
  ...kle,
  props: Cle,
  setup(e) {
    const t = e, n = {
      position: "relative"
    }, o = x(() => {
      var L, R;
      return (R = (L = t.font) == null ? void 0 : L.color) != null ? R : "rgba(0,0,0,.15)";
    }), l = x(() => {
      var L, R;
      return (R = (L = t.font) == null ? void 0 : L.fontSize) != null ? R : 16;
    }), a = x(() => {
      var L, R;
      return (R = (L = t.font) == null ? void 0 : L.fontWeight) != null ? R : "normal";
    }), r = x(() => {
      var L, R;
      return (R = (L = t.font) == null ? void 0 : L.fontStyle) != null ? R : "normal";
    }), i = x(() => {
      var L, R;
      return (R = (L = t.font) == null ? void 0 : L.fontFamily) != null ? R : "sans-serif";
    }), s = x(() => {
      var L, R;
      return (R = (L = t.font) == null ? void 0 : L.textAlign) != null ? R : "center";
    }), u = x(() => {
      var L, R;
      return (R = (L = t.font) == null ? void 0 : L.textBaseline) != null ? R : "top";
    }), d = x(() => t.gap[0]), f = x(() => t.gap[1]), v = x(() => d.value / 2), h = x(() => f.value / 2), m = x(() => {
      var L, R;
      return (R = (L = t.offset) == null ? void 0 : L[0]) != null ? R : v.value;
    }), p = x(() => {
      var L, R;
      return (R = (L = t.offset) == null ? void 0 : L[1]) != null ? R : h.value;
    }), C = () => {
      const L = {
        zIndex: t.zIndex,
        position: "absolute",
        left: 0,
        top: 0,
        width: "100%",
        height: "100%",
        pointerEvents: "none",
        backgroundRepeat: "repeat"
      };
      let R = m.value - v.value, H = p.value - h.value;
      return R > 0 && (L.left = `${R}px`, L.width = `calc(100% - ${R}px)`, R = 0), H > 0 && (L.top = `${H}px`, L.height = `calc(100% - ${H}px)`, H = 0), L.backgroundPosition = `${R}px ${H}px`, L;
    }, g = An(null), w = An(), b = B(!1), y = () => {
      w.value && (w.value.remove(), w.value = void 0);
    }, E = (L, R) => {
      var H;
      g.value && w.value && (b.value = !0, w.value.setAttribute("style", Ele({
        ...C(),
        backgroundImage: `url('${L}')`,
        backgroundSize: `${Math.floor(R)}px`
      })), (H = g.value) == null || H.append(w.value), setTimeout(() => {
        b.value = !1;
      }));
    }, S = (L) => {
      let R = 120, H = 64;
      const K = t.image, U = t.content, W = t.width, A = t.height;
      if (!K && L.measureText) {
        L.font = `${Number(l.value)}px ${i.value}`;
        const $ = Array.isArray(U) ? U : [U], D = $.map((O) => {
          const F = L.measureText(O);
          return [
            F.width,
            F.fontBoundingBoxAscent !== void 0 ? F.fontBoundingBoxAscent + F.fontBoundingBoxDescent : F.actualBoundingBoxAscent + F.actualBoundingBoxDescent
          ];
        });
        R = Math.ceil(Math.max(...D.map((O) => O[0]))), H = Math.ceil(Math.max(...D.map((O) => O[1]))) * $.length + ($.length - 1) * dN;
      }
      return [W ?? R, A ?? H];
    }, _ = xle(), k = () => {
      const R = document.createElement("canvas").getContext("2d"), H = t.image, K = t.content, U = t.rotate;
      if (R) {
        w.value || (w.value = document.createElement("div"));
        const W = Sle(), [A, $] = S(R), D = (O) => {
          const [F, j] = _(O || "", U, W, A, $, {
            color: o.value,
            fontSize: l.value,
            fontStyle: r.value,
            fontWeight: a.value,
            fontFamily: i.value,
            textAlign: s.value,
            textBaseline: u.value
          }, d.value, f.value);
          E(F, j);
        };
        if (H) {
          const O = new Image();
          O.onload = () => {
            D(O);
          }, O.onerror = () => {
            D(K);
          }, O.crossOrigin = "anonymous", O.referrerPolicy = "no-referrer", O.src = H;
        } else
          D(K);
      }
    };
    return Nt(() => {
      k();
    }), Pe(() => t, () => {
      k();
    }, {
      deep: !0,
      flush: "post"
    }), zn(() => {
      y();
    }), J2(g, (L) => {
      b.value || L.forEach((R) => {
        _le(R, w.value) && (y(), k());
      });
    }, {
      attributes: !0,
      subtree: !0,
      childList: !0
    }), (L, R) => (M(), G("div", {
      ref_key: "containerRef",
      ref: g,
      style: bt([n])
    }, [
      Ie(L.$slots, "default")
    ], 4));
  }
});
var $le = /* @__PURE__ */ ut(Tle, [["__file", "watermark.vue"]]);
const Ole = Yt($le), Nle = it({
  zIndex: {
    type: Number,
    default: 1001
  },
  visible: Boolean,
  fill: {
    type: String,
    default: "rgba(0,0,0,0.5)"
  },
  pos: {
    type: Ae(Object)
  },
  targetAreaClickable: {
    type: Boolean,
    default: !0
  }
}), Mle = (e, t, n, o, l) => {
  const a = B(null), r = () => {
    let f;
    return on(e.value) ? f = document.querySelector(e.value) : vn(e.value) ? f = e.value() : f = e.value, f;
  }, i = () => {
    const f = r();
    if (!f || !t.value) {
      a.value = null;
      return;
    }
    !Ile(f) && t.value && f.scrollIntoView(l.value);
    const { left: v, top: h, width: m, height: p } = f.getBoundingClientRect();
    a.value = {
      left: v,
      top: h,
      width: m,
      height: p,
      radius: 0
    };
  };
  Nt(() => {
    Pe([t, e], () => {
      i();
    }, {
      immediate: !0
    }), window.addEventListener("resize", i);
  }), zn(() => {
    window.removeEventListener("resize", i);
  });
  const s = (f) => {
    var v;
    return (v = Kt(n.value.offset) ? n.value.offset[f] : n.value.offset) != null ? v : 6;
  }, u = x(() => {
    var f;
    if (!a.value)
      return a.value;
    const v = s(0), h = s(1), m = ((f = n.value) == null ? void 0 : f.radius) || 2;
    return {
      left: a.value.left - v,
      top: a.value.top - h,
      width: a.value.width + v * 2,
      height: a.value.height + h * 2,
      radius: m
    };
  }), d = x(() => {
    const f = r();
    return !o.value || !f || !window.DOMRect ? f || void 0 : {
      getBoundingClientRect() {
        var v, h, m, p;
        return window.DOMRect.fromRect({
          width: ((v = u.value) == null ? void 0 : v.width) || 0,
          height: ((h = u.value) == null ? void 0 : h.height) || 0,
          x: ((m = u.value) == null ? void 0 : m.left) || 0,
          y: ((p = u.value) == null ? void 0 : p.top) || 0
        });
      }
    };
  });
  return {
    mergedPosInfo: u,
    triggerTarget: d
  };
}, Jv = Symbol("ElTour");
function Ile(e) {
  const t = window.innerWidth || document.documentElement.clientWidth, n = window.innerHeight || document.documentElement.clientHeight, { top: o, right: l, bottom: a, left: r } = e.getBoundingClientRect();
  return o >= 0 && r >= 0 && l <= t && a <= n;
}
const Rle = (e, t, n, o, l, a, r, i) => {
  const s = B(), u = B(), d = B({}), f = {
    x: s,
    y: u,
    placement: o,
    strategy: l,
    middlewareData: d
  }, v = x(() => {
    const g = [
      Ok(c(a)),
      $5(),
      T5(),
      Dle()
    ];
    return c(i) && c(n) && g.push(Fk({
      element: c(n)
    })), g;
  }), h = async () => {
    if (!fn)
      return;
    const g = c(e), w = c(t);
    if (!g || !w)
      return;
    const b = await Vk(g, w, {
      placement: c(o),
      strategy: c(l),
      middleware: c(v)
    });
    Lc(f).forEach((y) => {
      f[y].value = b[y];
    });
  }, m = x(() => {
    if (!c(e))
      return {
        position: "fixed",
        top: "50%",
        left: "50%",
        transform: "translate3d(-50%, -50%, 0)",
        maxWidth: "100vw",
        zIndex: c(r)
      };
    const { overflow: g } = c(d);
    return {
      position: c(l),
      zIndex: c(r),
      top: c(u) != null ? `${c(u)}px` : "",
      left: c(s) != null ? `${c(s)}px` : "",
      maxWidth: g != null && g.maxWidth ? `${g == null ? void 0 : g.maxWidth}px` : ""
    };
  }), p = x(() => {
    if (!c(i))
      return {};
    const { arrow: g } = c(d);
    return {
      left: (g == null ? void 0 : g.x) != null ? `${g == null ? void 0 : g.x}px` : "",
      top: (g == null ? void 0 : g.y) != null ? `${g == null ? void 0 : g.y}px` : ""
    };
  });
  let C;
  return Nt(() => {
    const g = c(e), w = c(t);
    g && w && (C = k5(g, w, h)), ol(() => {
      h();
    });
  }), zn(() => {
    C && C();
  }), {
    update: h,
    contentStyle: m,
    arrowStyle: p
  };
}, Dle = () => ({
  name: "overflow",
  async fn(e) {
    const t = await My(e);
    let n = 0;
    return t.left > 0 && (n = t.left), t.right > 0 && (n = t.right), {
      data: {
        maxWidth: e.rects.floating.width - n
      }
    };
  }
}), Lle = { style: {
  width: "100%",
  height: "100%"
} }, Ple = ["d"], Ale = Q({
  name: "ElTourMask",
  inheritAttrs: !1
}), Fle = /* @__PURE__ */ Q({
  ...Ale,
  props: Nle,
  setup(e) {
    const t = e, { ns: n } = ot(Jv), o = x(() => {
      var i, s;
      return (s = (i = t.pos) == null ? void 0 : i.radius) != null ? s : 2;
    }), l = x(() => {
      const i = o.value, s = `a${i},${i} 0 0 1`;
      return {
        topRight: `${s} ${i},${i}`,
        bottomRight: `${s} ${-i},${i}`,
        bottomLeft: `${s} ${-i},${-i}`,
        topLeft: `${s} ${i},${-i}`
      };
    }), a = x(() => {
      const i = window.innerWidth, s = window.innerHeight, u = l.value, d = `M${i},0 L0,0 L0,${s} L${i},${s} L${i},0 Z`, f = o.value;
      return t.pos ? `${d} M${t.pos.left + f},${t.pos.top} h${t.pos.width - f * 2} ${u.topRight} v${t.pos.height - f * 2} ${u.bottomRight} h${-t.pos.width + f * 2} ${u.bottomLeft} v${-t.pos.height + f * 2} ${u.topLeft} z` : d;
    }), r = x(() => ({
      fill: t.fill,
      pointerEvents: "auto",
      cursor: "auto"
    }));
    return by(Pn(t, "visible"), {
      ns: n
    }), (i, s) => i.visible ? (M(), G("div", Et({
      key: 0,
      class: c(n).e("mask"),
      style: {
        position: "fixed",
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        zIndex: i.zIndex,
        pointerEvents: i.pos && i.targetAreaClickable ? "none" : "auto"
      }
    }, i.$attrs), [
      (M(), G("svg", Lle, [
        X("path", {
          class: z(c(n).e("hollow")),
          style: bt(c(r)),
          d: c(a)
        }, null, 14, Ple)
      ]))
    ], 16)) : _e("v-if", !0);
  }
});
var Vle = /* @__PURE__ */ ut(Fle, [["__file", "mask.vue"]]);
const Ble = ["absolute", "fixed"], Hle = [
  "top-start",
  "top-end",
  "top",
  "bottom-start",
  "bottom-end",
  "bottom",
  "left-start",
  "left-end",
  "left",
  "right-start",
  "right-end",
  "right"
], N0 = it({
  placement: {
    type: Ae(String),
    values: Hle,
    default: "bottom"
  },
  reference: {
    type: Ae(Object),
    default: null
  },
  strategy: {
    type: Ae(String),
    values: Ble,
    default: "absolute"
  },
  offset: {
    type: Number,
    default: 10
  },
  showArrow: Boolean,
  zIndex: {
    type: Number,
    default: 2001
  }
}), zle = {
  close: () => !0
}, Wle = ["data-side"], Kle = Q({
  name: "ElTourContent"
}), Ule = /* @__PURE__ */ Q({
  ...Kle,
  props: N0,
  emits: zle,
  setup(e, { emit: t }) {
    const n = e, o = B(n.placement), l = B(n.strategy), a = B(null), r = B(null);
    Pe(() => n.placement, () => {
      o.value = n.placement;
    });
    const { contentStyle: i, arrowStyle: s } = Rle(Pn(n, "reference"), a, r, o, l, Pn(n, "offset"), Pn(n, "zIndex"), Pn(n, "showArrow")), u = x(() => o.value.split("-")[0]), { ns: d } = ot(Jv), f = () => {
      t("close");
    }, v = (h) => {
      h.detail.focusReason === "pointer" && h.preventDefault();
    };
    return (h, m) => (M(), G("div", {
      ref_key: "contentRef",
      ref: a,
      style: bt(c(i)),
      class: z(c(d).e("content")),
      "data-side": c(u),
      tabindex: "-1"
    }, [
      oe(c(pf), {
        loop: "",
        trapped: "",
        "focus-start-el": "container",
        "focus-trap-el": a.value || void 0,
        onReleaseRequested: f,
        onFocusoutPrevented: v
      }, {
        default: fe(() => [
          Ie(h.$slots, "default")
        ]),
        _: 3
      }, 8, ["focus-trap-el"]),
      h.showArrow ? (M(), G("span", {
        key: 0,
        ref_key: "arrowRef",
        ref: r,
        style: bt(c(s)),
        class: z(c(d).e("arrow"))
      }, null, 6)) : _e("v-if", !0)
    ], 14, Wle));
  }
});
var jle = /* @__PURE__ */ ut(Ule, [["__file", "content.vue"]]), qle = Q({
  name: "ElTourSteps",
  props: {
    current: {
      type: Number,
      default: 0
    }
  },
  emits: ["update-total"],
  setup(e, { slots: t, emit: n }) {
    let o = 0;
    return () => {
      var l, a;
      const r = (l = t.default) == null ? void 0 : l.call(t), i = [];
      let s = 0;
      function u(d) {
        Kt(d) && d.forEach((f) => {
          var v;
          ((v = (f == null ? void 0 : f.type) || {}) == null ? void 0 : v.name) === "ElTourStep" && (i.push(f), s += 1);
        });
      }
      return r.length && u(bs((a = r[0]) == null ? void 0 : a.children)), o !== s && (o = s, n("update-total", s)), i.length ? i[e.current] : null;
    };
  }
});
const Yle = it({
  modelValue: Boolean,
  current: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: !0
  },
  showClose: {
    type: Boolean,
    default: !0
  },
  closeIcon: {
    type: Dn
  },
  placement: N0.placement,
  contentStyle: {
    type: Ae([Object])
  },
  mask: {
    type: Ae([Boolean, Object]),
    default: !0
  },
  gap: {
    type: Ae(Object),
    default: () => ({
      offset: 6,
      radius: 2
    })
  },
  zIndex: {
    type: Number
  },
  scrollIntoViewOptions: {
    type: Ae([Boolean, Object]),
    default: () => ({
      block: "center"
    })
  },
  type: {
    type: Ae(String)
  },
  appendTo: {
    type: Ae([String, Object]),
    default: "body"
  },
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  targetAreaClickable: {
    type: Boolean,
    default: !0
  }
}), Gle = {
  [Jt]: (e) => $o(e),
  "update:current": (e) => Ot(e),
  close: (e) => Ot(e),
  finish: () => !0,
  change: (e) => Ot(e)
}, Xle = Q({
  name: "ElTour"
}), Zle = /* @__PURE__ */ Q({
  ...Xle,
  props: Yle,
  emits: Gle,
  setup(e, { emit: t }) {
    const n = e, o = nt("tour"), l = B(0), a = B(), r = Q2(n, "current", t, {
      passive: !0
    }), i = x(() => {
      var N;
      return (N = a.value) == null ? void 0 : N.target;
    }), s = x(() => [
      o.b(),
      C.value === "primary" ? o.m("primary") : ""
    ]), u = x(() => {
      var N;
      return ((N = a.value) == null ? void 0 : N.placement) || n.placement;
    }), d = x(() => {
      var N, L;
      return (L = (N = a.value) == null ? void 0 : N.contentStyle) != null ? L : n.contentStyle;
    }), f = x(() => {
      var N, L;
      return (L = (N = a.value) == null ? void 0 : N.mask) != null ? L : n.mask;
    }), v = x(() => !!f.value && n.modelValue), h = x(() => $o(f.value) ? void 0 : f.value), m = x(() => {
      var N, L;
      return !!i.value && ((L = (N = a.value) == null ? void 0 : N.showArrow) != null ? L : n.showArrow);
    }), p = x(() => {
      var N, L;
      return (L = (N = a.value) == null ? void 0 : N.scrollIntoViewOptions) != null ? L : n.scrollIntoViewOptions;
    }), C = x(() => {
      var N, L;
      return (L = (N = a.value) == null ? void 0 : N.type) != null ? L : n.type;
    }), { nextZIndex: g } = au(), w = g(), b = x(() => {
      var N;
      return (N = n.zIndex) != null ? N : w;
    }), { mergedPosInfo: y, triggerTarget: E } = Mle(i, Pn(n, "modelValue"), Pn(n, "gap"), f, p);
    Pe(() => n.modelValue, (N) => {
      N || (r.value = 0);
    });
    const S = () => {
      n.closeOnPressEscape && (t("update:modelValue", !1), t("close", r.value));
    }, _ = (N) => {
      l.value = N;
    }, k = Yn();
    return Mt(Jv, {
      currentStep: a,
      current: r,
      total: l,
      showClose: Pn(n, "showClose"),
      closeIcon: Pn(n, "closeIcon"),
      mergedType: C,
      ns: o,
      slots: k,
      updateModelValue(N) {
        t("update:modelValue", N);
      },
      onClose() {
        t("close", r.value);
      },
      onFinish() {
        t("finish");
      },
      onChange() {
        t("change", r.value);
      }
    }), (N, L) => {
      var R, H;
      return M(), G(kt, null, [
        (M(), We(ka, { to: N.appendTo }, [
          X("div", Et({ class: c(s) }, N.$attrs), [
            oe(Vle, {
              visible: c(v),
              fill: (R = c(h)) == null ? void 0 : R.color,
              style: bt((H = c(h)) == null ? void 0 : H.style),
              pos: c(y),
              "z-index": c(b),
              "target-area-clickable": N.targetAreaClickable
            }, null, 8, ["visible", "fill", "style", "pos", "z-index", "target-area-clickable"]),
            N.modelValue ? (M(), We(jle, {
              key: c(r),
              reference: c(E),
              placement: c(u),
              "show-arrow": c(m),
              "z-index": c(b),
              style: bt(c(d)),
              onClose: S
            }, {
              default: fe(() => [
                oe(c(qle), {
                  current: c(r),
                  onUpdateTotal: _
                }, {
                  default: fe(() => [
                    Ie(N.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["current"])
              ]),
              _: 3
            }, 8, ["reference", "placement", "show-arrow", "z-index", "style"])) : _e("v-if", !0)
          ], 16)
        ], 8, ["to"])),
        _e(" just for IDE "),
        _e("v-if", !0)
      ], 64);
    };
  }
});
var Jle = /* @__PURE__ */ ut(Zle, [["__file", "tour.vue"]]);
const Qle = it({
  target: {
    type: Ae([String, Object, Function])
  },
  title: String,
  description: String,
  showClose: {
    type: Boolean,
    default: void 0
  },
  closeIcon: {
    type: Dn
  },
  showArrow: {
    type: Boolean,
    default: void 0
  },
  placement: N0.placement,
  mask: {
    type: Ae([Boolean, Object]),
    default: void 0
  },
  contentStyle: {
    type: Ae([Object])
  },
  prevButtonProps: {
    type: Ae(Object)
  },
  nextButtonProps: {
    type: Ae(Object)
  },
  scrollIntoViewOptions: {
    type: Ae([Boolean, Object]),
    default: void 0
  },
  type: {
    type: Ae(String)
  }
}), eae = {
  close: () => !0
}, tae = Q({
  name: "ElTourStep"
}), nae = /* @__PURE__ */ Q({
  ...tae,
  props: Qle,
  emits: eae,
  setup(e, { emit: t }) {
    const n = e, { Close: o } = fy, { t: l } = bn(), {
      currentStep: a,
      current: r,
      total: i,
      showClose: s,
      closeIcon: u,
      mergedType: d,
      ns: f,
      slots: v,
      updateModelValue: h,
      onClose: m,
      onFinish: p,
      onChange: C
    } = ot(Jv);
    Pe(n, (k) => {
      a.value = k;
    }, {
      immediate: !0
    });
    const g = x(() => {
      var k;
      return (k = n.showClose) != null ? k : s.value;
    }), w = x(() => {
      var k, N;
      return (N = (k = n.closeIcon) != null ? k : u.value) != null ? N : o;
    }), b = (k) => {
      if (k)
        return FF(k, ["children", "onClick"]);
    }, y = () => {
      var k, N;
      r.value -= 1, (k = n.prevButtonProps) != null && k.onClick && ((N = n.prevButtonProps) == null || N.onClick()), C();
    }, E = () => {
      var k;
      r.value >= i.value - 1 ? S() : r.value += 1, (k = n.nextButtonProps) != null && k.onClick && n.nextButtonProps.onClick(), C();
    }, S = () => {
      _(), p();
    }, _ = () => {
      h(!1), m(), t("close");
    };
    return (k, N) => (M(), G(kt, null, [
      c(g) ? (M(), G("button", {
        key: 0,
        "aria-label": "Close",
        class: z(c(f).e("closebtn")),
        type: "button",
        onClick: _
      }, [
        oe(c(Ct), {
          class: z(c(f).e("close"))
        }, {
          default: fe(() => [
            (M(), We(Qt(c(w))))
          ]),
          _: 1
        }, 8, ["class"])
      ], 2)) : _e("v-if", !0),
      X("header", {
        class: z([c(f).e("header"), { "show-close": c(s) }])
      }, [
        Ie(k.$slots, "header", {}, () => [
          X("span", {
            role: "heading",
            class: z(c(f).e("title"))
          }, Qe(k.title), 3)
        ])
      ], 2),
      X("div", {
        class: z(c(f).e("body"))
      }, [
        Ie(k.$slots, "default", {}, () => [
          X("span", null, Qe(k.description), 1)
        ])
      ], 2),
      X("footer", {
        class: z(c(f).e("footer"))
      }, [
        X("div", {
          class: z(c(f).b("indicators"))
        }, [
          c(v).indicators ? (M(), We(Qt(c(v).indicators), {
            key: 0,
            current: c(r),
            total: c(i)
          }, null, 8, ["current", "total"])) : (M(!0), G(kt, { key: 1 }, ln(c(i), (L, R) => (M(), G("span", {
            key: L,
            class: z([c(f).b("indicator"), R === c(r) ? "is-active" : ""])
          }, null, 2))), 128))
        ], 2),
        X("div", {
          class: z(c(f).b("buttons"))
        }, [
          c(r) > 0 ? (M(), We(c(Do), Et({
            key: 0,
            size: "small",
            type: c(d)
          }, b(k.prevButtonProps), { onClick: y }), {
            default: fe(() => {
              var L, R;
              return [
                Ut(Qe((R = (L = k.prevButtonProps) == null ? void 0 : L.children) != null ? R : c(l)("el.tour.previous")), 1)
              ];
            }),
            _: 1
          }, 16, ["type"])) : _e("v-if", !0),
          c(r) <= c(i) - 1 ? (M(), We(c(Do), Et({
            key: 1,
            size: "small",
            type: c(d) === "primary" ? "default" : "primary"
          }, b(k.nextButtonProps), { onClick: E }), {
            default: fe(() => {
              var L, R;
              return [
                Ut(Qe((R = (L = k.nextButtonProps) == null ? void 0 : L.children) != null ? R : c(r) === c(i) - 1 ? c(l)("el.tour.finish") : c(l)("el.tour.next")), 1)
              ];
            }),
            _: 1
          }, 16, ["type"])) : _e("v-if", !0)
        ], 2)
      ], 2)
    ], 64));
  }
});
var fN = /* @__PURE__ */ ut(nae, [["__file", "step.vue"]]);
const oae = Yt(Jle, {
  TourStep: fN
}), lae = Jn(fN), aae = it({
  container: {
    type: Ae([
      String,
      Object
    ])
  },
  offset: {
    type: Number,
    default: 0
  },
  bound: {
    type: Number,
    default: 15
  },
  duration: {
    type: Number,
    default: 300
  },
  marker: {
    type: Boolean,
    default: !0
  },
  type: {
    type: Ae(String),
    default: "default"
  },
  direction: {
    type: Ae(String),
    default: "vertical"
  }
}), rae = {
  change: (e) => on(e),
  click: (e, t) => e instanceof MouseEvent && (on(t) || To(t))
}, pN = Symbol("anchor"), sae = Q({
  name: "ElAnchor"
}), iae = /* @__PURE__ */ Q({
  ...sae,
  props: aae,
  emits: rae,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = B(""), a = B(null), r = B(null), i = B(), s = {};
    let u = !1, d = 0;
    const f = nt("anchor"), v = x(() => [
      f.b(),
      o.type === "underline" ? f.m("underline") : "",
      f.m(o.direction)
    ]), h = (k) => {
      s[k.href] = k.el;
    }, m = (k) => {
      delete s[k];
    }, p = (k) => {
      l.value !== k && (l.value = k, n("change", k));
    };
    let C = null;
    const g = (k) => {
      if (!i.value)
        return;
      const N = Vf(k);
      if (!N)
        return;
      C && C(), u = !0;
      const L = YC(N, i.value), R = Qm(N, L), H = L.scrollHeight - L.clientHeight, K = Math.min(R - o.offset, H);
      C = ZF(i.value, d, K, o.duration, () => {
        setTimeout(() => {
          u = !1;
        }, 20);
      });
    }, w = (k) => {
      k && (p(k), g(k));
    }, b = (k, N) => {
      n("click", k, N), w(N);
    }, y = vV(() => {
      i.value && (d = GC(i.value));
      const k = E();
      u || To(k) || p(k);
    }), E = () => {
      if (!i.value)
        return;
      const k = GC(i.value), N = [];
      for (const L of Object.keys(s)) {
        const R = Vf(L);
        if (!R)
          continue;
        const H = YC(R, i.value), K = Qm(R, H);
        N.push({
          top: K - o.offset - o.bound,
          href: L
        });
      }
      N.sort((L, R) => L.top - R.top);
      for (let L = 0; L < N.length; L++) {
        const R = N[L], H = N[L + 1];
        if (L === 0 && k === 0)
          return "";
        if (R.top <= k && (!H || H.top > k))
          return R.href;
      }
    }, S = () => {
      const k = Vf(o.container);
      !k || Iv(k) ? i.value = window : i.value = k;
    };
    jn(i, "scroll", y);
    const _ = x(() => {
      if (!a.value || !r.value || !l.value)
        return {};
      const k = s[l.value];
      if (!k)
        return {};
      const N = a.value.getBoundingClientRect(), L = r.value.getBoundingClientRect(), R = k.getBoundingClientRect();
      return o.direction === "horizontal" ? {
        left: `${R.left - N.left}px`,
        width: `${R.width}px`,
        opacity: 1
      } : {
        top: `${R.top - N.top + (R.height - L.height) / 2}px`,
        opacity: 1
      };
    });
    return Nt(() => {
      S();
      const k = decodeURIComponent(window.location.hash);
      Vf(k) ? w(k) : y();
    }), Pe(() => o.container, () => {
      S();
    }), Mt(pN, {
      ns: f,
      direction: o.direction,
      currentAnchor: l,
      addLink: h,
      removeLink: m,
      handleClick: b
    }), t({
      scrollTo: w
    }), (k, N) => (M(), G("div", {
      ref_key: "anchorRef",
      ref: a,
      class: z(c(v))
    }, [
      k.marker ? (M(), G("div", {
        key: 0,
        ref_key: "markerRef",
        ref: r,
        class: z(c(f).e("marker")),
        style: bt(c(_))
      }, null, 6)) : _e("v-if", !0),
      X("div", {
        class: z(c(f).e("list"))
      }, [
        Ie(k.$slots, "default")
      ], 2)
    ], 2));
  }
});
var cae = /* @__PURE__ */ ut(iae, [["__file", "anchor.vue"]]);
const uae = it({
  title: String,
  href: String
}), dae = ["href"], fae = Q({
  name: "ElAnchorLink"
}), pae = /* @__PURE__ */ Q({
  ...fae,
  props: uae,
  setup(e) {
    const t = e, n = B(null), {
      ns: o,
      direction: l,
      currentAnchor: a,
      addLink: r,
      removeLink: i,
      handleClick: s
    } = ot(pN), u = x(() => [
      o.e("link"),
      o.is("active", a.value === t.href)
    ]), d = (f) => {
      s(f, t.href);
    };
    return Pe(() => t.href, (f, v) => {
      xe(() => {
        v && i(v), f && r({
          href: f,
          el: n.value
        });
      });
    }), Nt(() => {
      const { href: f } = t;
      f && r({
        href: f,
        el: n.value
      });
    }), zn(() => {
      const { href: f } = t;
      f && i(f);
    }), (f, v) => (M(), G("div", {
      class: z(c(o).e("item"))
    }, [
      X("a", {
        ref_key: "linkRef",
        ref: n,
        class: z(c(u)),
        href: f.href,
        onClick: d
      }, [
        Ie(f.$slots, "default", {}, () => [
          Ut(Qe(f.title), 1)
        ])
      ], 10, dae),
      f.$slots["sub-link"] && c(l) === "vertical" ? (M(), G("div", {
        key: 0,
        class: z(c(o).e("list"))
      }, [
        Ie(f.$slots, "sub-link")
      ], 2)) : _e("v-if", !0)
    ], 2));
  }
});
var vN = /* @__PURE__ */ ut(pae, [["__file", "anchor-link.vue"]]);
const vae = Yt(cae, {
  AnchorLink: vN
}), hae = Jn(vN), mae = it({
  options: {
    type: Ae(Array),
    default: () => []
  },
  modelValue: {
    type: [String, Number, Boolean],
    default: void 0
  },
  block: Boolean,
  size: Lo,
  disabled: Boolean,
  validateEvent: {
    type: Boolean,
    default: !0
  },
  id: String,
  name: String,
  ...Zo(["ariaLabel"])
}), gae = {
  [Jt]: (e) => on(e) || Ot(e),
  [qn]: (e) => on(e) || Ot(e)
}, bae = ["id", "aria-label", "aria-labelledby"], yae = ["name", "disabled", "checked", "onChange"], Cae = Q({
  name: "ElSegmented"
}), wae = /* @__PURE__ */ Q({
  ...Cae,
  props: mae,
  emits: gae,
  setup(e, { emit: t }) {
    const n = e, o = nt("segmented"), l = il(), a = Mo(), r = Nl(), { formItem: i } = ml(), { inputId: s, isLabeledByFormItem: u } = Wa(n, {
      formItemContext: i
    }), d = B(null), f = V3(), v = en({
      isInit: !1,
      width: 0,
      translateX: 0,
      disabled: !1,
      focusVisible: !1
    }), h = (N) => {
      const L = m(N);
      t(Jt, L), t(qn, L);
    }, m = (N) => Mn(N) ? N.value : N, p = (N) => Mn(N) ? N.label : N, C = (N) => !!(r.value || Mn(N) && N.disabled), g = (N) => n.modelValue === m(N), w = (N) => n.options.find((L) => m(L) === N), b = (N) => [
      o.e("item"),
      o.is("selected", g(N)),
      o.is("disabled", C(N))
    ], y = () => {
      if (!d.value)
        return;
      const N = d.value.querySelector(".is-selected"), L = d.value.querySelector(".is-selected input");
      if (!N || !L) {
        v.width = 0, v.translateX = 0, v.disabled = !1, v.focusVisible = !1;
        return;
      }
      const R = N.getBoundingClientRect();
      v.isInit = !0, v.width = R.width, v.translateX = N.offsetLeft, v.disabled = C(w(n.modelValue));
      try {
        v.focusVisible = L.matches(":focus-visible");
      } catch {
      }
    }, E = x(() => [
      o.b(),
      o.m(a.value),
      o.is("block", n.block)
    ]), S = x(() => ({
      width: `${v.width}px`,
      transform: `translateX(${v.translateX}px)`,
      display: v.isInit ? "block" : "none"
    })), _ = x(() => [
      o.e("item-selected"),
      o.is("disabled", v.disabled),
      o.is("focus-visible", v.focusVisible)
    ]), k = x(() => n.name || l.value);
    return Xn(d, y), Pe(f, y), Pe(() => n.modelValue, () => {
      var N;
      y(), n.validateEvent && ((N = i == null ? void 0 : i.validate) == null || N.call(i, "change").catch((L) => dn(L)));
    }, {
      flush: "post"
    }), (N, L) => (M(), G("div", {
      id: c(s),
      ref_key: "segmentedRef",
      ref: d,
      class: z(c(E)),
      role: "radiogroup",
      "aria-label": c(u) ? void 0 : N.ariaLabel || "segmented",
      "aria-labelledby": c(u) ? c(i).labelId : void 0
    }, [
      X("div", {
        class: z(c(o).e("group"))
      }, [
        X("div", {
          style: bt(c(S)),
          class: z(c(_))
        }, null, 6),
        (M(!0), G(kt, null, ln(N.options, (R, H) => (M(), G("label", {
          key: H,
          class: z(b(R))
        }, [
          X("input", {
            class: z(c(o).e("item-input")),
            type: "radio",
            name: c(k),
            disabled: C(R),
            checked: g(R),
            onChange: (K) => h(R)
          }, null, 42, yae),
          X("div", {
            class: z(c(o).e("item-label"))
          }, [
            Ie(N.$slots, "default", { item: R }, () => [
              Ut(Qe(p(R)), 1)
            ])
          ], 2)
        ], 2))), 128))
      ], 2)
    ], 10, bae));
  }
});
var Eae = /* @__PURE__ */ ut(wae, [["__file", "segmented.vue"]]);
const Sae = Yt(Eae);
var _ae = [
  X5,
  sB,
  $H,
  Bte,
  LH,
  zH,
  zy,
  nz,
  oz,
  Do,
  fT,
  w9,
  k9,
  j9,
  q9,
  ZT,
  KW,
  cK,
  ta,
  dW,
  Uy,
  wK,
  t$,
  n$,
  MK,
  vU,
  z5,
  kU,
  TU,
  $U,
  OU,
  NU,
  b$,
  rq,
  sq,
  x$,
  k$,
  T$,
  n0,
  o0,
  l0,
  P$,
  jk,
  qk,
  Ct,
  gG,
  A$,
  nl,
  a0,
  MG,
  ZG,
  JG,
  QG,
  eX,
  sX,
  q$,
  Y$,
  X$,
  oT,
  c0,
  jy,
  kW,
  YT,
  HZ,
  jZ,
  mK,
  zr,
  Ns,
  Ad,
  j$,
  IJ,
  BJ,
  HJ,
  gQ,
  EQ,
  hO,
  RQ,
  gO,
  bO,
  yO,
  tte,
  nte,
  Vte,
  HO,
  zO,
  Uc,
  ane,
  e9,
  dne,
  mne,
  gne,
  hl,
  Wne,
  GO,
  goe,
  _oe,
  zoe,
  uN,
  Ole,
  oae,
  lae,
  vae,
  hae,
  Sae
];
const pa = "ElInfiniteScroll", xae = 50, kae = 200, Tae = 0, $ae = {
  delay: {
    type: Number,
    default: kae
  },
  distance: {
    type: Number,
    default: Tae
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  immediate: {
    type: Boolean,
    default: !0
  }
}, M0 = (e, t) => Object.entries($ae).reduce((n, [o, l]) => {
  var a, r;
  const { type: i, default: s } = l, u = e.getAttribute(`infinite-scroll-${o}`);
  let d = (r = (a = t[u]) != null ? a : u) != null ? r : s;
  return d = d === "false" ? !1 : d, d = i(d), n[o] = Number.isNaN(d) ? s : d, n;
}, {}), hN = (e) => {
  const { observer: t } = e[pa];
  t && (t.disconnect(), delete e[pa].observer);
}, Oae = (e, t) => {
  const { container: n, containerEl: o, instance: l, observer: a, lastScrollTop: r } = e[pa], { disabled: i, distance: s } = M0(e, l), { clientHeight: u, scrollHeight: d, scrollTop: f } = o, v = f - r;
  if (e[pa].lastScrollTop = f, a || i || v < 0)
    return;
  let h = !1;
  if (n === e)
    h = d - (u + f) <= s;
  else {
    const { clientTop: m, scrollHeight: p } = e, C = Qm(e, o);
    h = f + u >= C + m + p - s;
  }
  h && t.call(l);
};
function mm(e, t) {
  const { containerEl: n, instance: o } = e[pa], { disabled: l } = M0(e, o);
  l || n.clientHeight === 0 || (n.scrollHeight <= n.clientHeight ? t.call(o) : hN(e));
}
const Nae = {
  async mounted(e, t) {
    const { instance: n, value: o } = t;
    vn(o) || lo(pa, "'v-infinite-scroll' binding value must be a function"), await xe();
    const { delay: l, immediate: a } = M0(e, n), r = sy(e, !0), i = r === window ? document.documentElement : r, s = mi(Oae.bind(null, e, o), l);
    if (r) {
      if (e[pa] = {
        instance: n,
        container: r,
        containerEl: i,
        delay: l,
        cb: o,
        onScroll: s,
        lastScrollTop: i.scrollTop
      }, a) {
        const u = new MutationObserver(mi(mm.bind(null, e, o), xae));
        e[pa].observer = u, u.observe(e, { childList: !0, subtree: !0 }), mm(e, o);
      }
      r.addEventListener("scroll", s);
    }
  },
  unmounted(e) {
    if (!e[pa])
      return;
    const { container: t, onScroll: n } = e[pa];
    t == null || t.removeEventListener("scroll", n), hN(e);
  },
  async updated(e) {
    if (!e[pa])
      await xe();
    else {
      const { containerEl: t, cb: n, observer: o } = e[pa];
      t.clientHeight && o && mm(e, n);
    }
  }
}, db = Nae;
db.install = (e) => {
  e.directive("InfiniteScroll", db);
};
const Mae = db;
function Iae(e) {
  let t;
  const n = B(!1), o = en({
    ...e,
    originalPosition: "",
    originalOverflow: "",
    visible: !1
  });
  function l(v) {
    o.text = v;
  }
  function a() {
    const v = o.parent, h = f.ns;
    if (!v.vLoadingAddClassList) {
      let m = v.getAttribute("loading-number");
      m = Number.parseInt(m) - 1, m ? v.setAttribute("loading-number", m.toString()) : (vl(v, h.bm("parent", "relative")), v.removeAttribute("loading-number")), vl(v, h.bm("parent", "hidden"));
    }
    r(), d.unmount();
  }
  function r() {
    var v, h;
    (h = (v = f.$el) == null ? void 0 : v.parentNode) == null || h.removeChild(f.$el);
  }
  function i() {
    var v;
    e.beforeClose && !e.beforeClose() || (n.value = !0, clearTimeout(t), t = window.setTimeout(s, 400), o.visible = !1, (v = e.closed) == null || v.call(e));
  }
  function s() {
    if (!n.value)
      return;
    const v = o.parent;
    n.value = !1, v.vLoadingAddClassList = void 0, a();
  }
  const u = Q({
    name: "ElLoading",
    setup(v, { expose: h }) {
      const { ns: m, zIndex: p } = zv("loading");
      return h({
        ns: m,
        zIndex: p
      }), () => {
        const C = o.spinner || o.svg, g = V("svg", {
          class: "circular",
          viewBox: o.svgViewBox ? o.svgViewBox : "0 0 50 50",
          ...C ? { innerHTML: C } : {}
        }, [
          V("circle", {
            class: "path",
            cx: "25",
            cy: "25",
            r: "20",
            fill: "none"
          })
        ]), w = o.text ? V("p", { class: m.b("text") }, [o.text]) : void 0;
        return V(Ko, {
          name: m.b("fade"),
          onAfterLeave: s
        }, {
          default: fe(() => [
            Bt(oe("div", {
              style: {
                backgroundColor: o.background || ""
              },
              class: [
                m.b("mask"),
                o.customClass,
                o.fullscreen ? "is-fullscreen" : ""
              ]
            }, [
              V("div", {
                class: m.b("spinner")
              }, [g, w])
            ]), [[pn, o.visible]])
          ])
        });
      };
    }
  }), d = U2(u), f = d.mount(document.createElement("div"));
  return {
    ...Xo(o),
    setText: l,
    removeElLoadingChild: r,
    close: i,
    handleAfterLeave: s,
    vm: f,
    get $el() {
      return f.$el;
    }
  };
}
let ep;
const fb = function(e = {}) {
  if (!fn)
    return;
  const t = Rae(e);
  if (t.fullscreen && ep)
    return ep;
  const n = Iae({
    ...t,
    closed: () => {
      var l;
      (l = t.closed) == null || l.call(t), t.fullscreen && (ep = void 0);
    }
  });
  Dae(t, t.parent, n), WE(t, t.parent, n), t.parent.vLoadingAddClassList = () => WE(t, t.parent, n);
  let o = t.parent.getAttribute("loading-number");
  return o ? o = `${Number.parseInt(o) + 1}` : o = "1", t.parent.setAttribute("loading-number", o), t.parent.appendChild(n.$el), xe(() => n.visible.value = t.visible), t.fullscreen && (ep = n), n;
}, Rae = (e) => {
  var t, n, o, l;
  let a;
  return on(e.target) ? a = (t = document.querySelector(e.target)) != null ? t : document.body : a = e.target || document.body, {
    parent: a === document.body || e.body ? document.body : a,
    background: e.background || "",
    svg: e.svg || "",
    svgViewBox: e.svgViewBox || "",
    spinner: e.spinner || !1,
    text: e.text || "",
    fullscreen: a === document.body && ((n = e.fullscreen) != null ? n : !0),
    lock: (o = e.lock) != null ? o : !1,
    customClass: e.customClass || "",
    visible: (l = e.visible) != null ? l : !0,
    target: a
  };
}, Dae = async (e, t, n) => {
  const { nextZIndex: o } = n.vm.zIndex || n.vm._.exposed.zIndex, l = {};
  if (e.fullscreen)
    n.originalPosition.value = ps(document.body, "position"), n.originalOverflow.value = ps(document.body, "overflow"), l.zIndex = o();
  else if (e.parent === document.body) {
    n.originalPosition.value = ps(document.body, "position"), await xe();
    for (const a of ["top", "left"]) {
      const r = a === "top" ? "scrollTop" : "scrollLeft";
      l[a] = `${e.target.getBoundingClientRect()[a] + document.body[r] + document.documentElement[r] - Number.parseInt(ps(document.body, `margin-${a}`), 10)}px`;
    }
    for (const a of ["height", "width"])
      l[a] = `${e.target.getBoundingClientRect()[a]}px`;
  } else
    n.originalPosition.value = ps(t, "position");
  for (const [a, r] of Object.entries(l))
    n.$el.style[a] = r;
}, WE = (e, t, n) => {
  const o = n.vm.ns || n.vm._.exposed.ns;
  ["absolute", "fixed", "sticky"].includes(n.originalPosition.value) ? vl(t, o.bm("parent", "relative")) : ma(t, o.bm("parent", "relative")), e.fullscreen && e.lock ? ma(t, o.bm("parent", "hidden")) : vl(t, o.bm("parent", "hidden"));
}, Fp = Symbol("ElLoading"), KE = (e, t) => {
  var n, o, l, a;
  const r = t.instance, i = (v) => Mn(t.value) ? t.value[v] : void 0, s = (v) => {
    const h = on(v) && (r == null ? void 0 : r[v]) || v;
    return h && B(h);
  }, u = (v) => s(i(v) || e.getAttribute(`element-loading-${cD(v)}`)), d = (n = i("fullscreen")) != null ? n : t.modifiers.fullscreen, f = {
    text: u("text"),
    svg: u("svg"),
    svgViewBox: u("svgViewBox"),
    spinner: u("spinner"),
    background: u("background"),
    customClass: u("customClass"),
    fullscreen: d,
    target: (o = i("target")) != null ? o : d ? void 0 : e,
    body: (l = i("body")) != null ? l : t.modifiers.body,
    lock: (a = i("lock")) != null ? a : t.modifiers.lock
  };
  e[Fp] = {
    options: f,
    instance: fb(f)
  };
}, Lae = (e, t) => {
  for (const n of Object.keys(t))
    fl(t[n]) && (t[n].value = e[n]);
}, UE = {
  mounted(e, t) {
    t.value && KE(e, t);
  },
  updated(e, t) {
    const n = e[Fp];
    t.oldValue !== t.value && (t.value && !t.oldValue ? KE(e, t) : t.value && t.oldValue ? Mn(t.value) && Lae(t.value, n.options) : n == null || n.instance.close());
  },
  unmounted(e) {
    var t;
    (t = e[Fp]) == null || t.instance.close(), e[Fp] = null;
  }
}, mN = {
  install(e) {
    e.directive("loading", UE), e.config.globalProperties.$loading = fb;
  },
  directive: UE,
  service: fb
}, gN = ["success", "info", "warning", "error"], dl = Zn({
  customClass: "",
  center: !1,
  dangerouslyUseHTMLString: !1,
  duration: 3e3,
  icon: void 0,
  id: "",
  message: "",
  onClose: void 0,
  showClose: !1,
  type: "info",
  plain: !1,
  offset: 16,
  zIndex: 0,
  grouping: !1,
  repeatNum: 1,
  appendTo: fn ? document.body : void 0
}), Pae = it({
  customClass: {
    type: String,
    default: dl.customClass
  },
  center: {
    type: Boolean,
    default: dl.center
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: dl.dangerouslyUseHTMLString
  },
  duration: {
    type: Number,
    default: dl.duration
  },
  icon: {
    type: Dn,
    default: dl.icon
  },
  id: {
    type: String,
    default: dl.id
  },
  message: {
    type: Ae([
      String,
      Object,
      Function
    ]),
    default: dl.message
  },
  onClose: {
    type: Ae(Function),
    default: dl.onClose
  },
  showClose: {
    type: Boolean,
    default: dl.showClose
  },
  type: {
    type: String,
    values: gN,
    default: dl.type
  },
  plain: {
    type: Boolean,
    default: dl.plain
  },
  offset: {
    type: Number,
    default: dl.offset
  },
  zIndex: {
    type: Number,
    default: dl.zIndex
  },
  grouping: {
    type: Boolean,
    default: dl.grouping
  },
  repeatNum: {
    type: Number,
    default: dl.repeatNum
  }
}), Aae = {
  destroy: () => !0
}, Pa = g3([]), Fae = (e) => {
  const t = Pa.findIndex((l) => l.id === e), n = Pa[t];
  let o;
  return t > 0 && (o = Pa[t - 1]), { current: n, prev: o };
}, Vae = (e) => {
  const { prev: t } = Fae(e);
  return t ? t.vm.exposed.bottom.value : 0;
}, Bae = (e, t) => Pa.findIndex((o) => o.id === e) > 0 ? 16 : t, Hae = ["id"], zae = ["innerHTML"], Wae = Q({
  name: "ElMessage"
}), Kae = /* @__PURE__ */ Q({
  ...Wae,
  props: Pae,
  emits: Aae,
  setup(e, { expose: t }) {
    const n = e, { Close: o } = py, { ns: l, zIndex: a } = zv("message"), { currentZIndex: r, nextZIndex: i } = a, s = B(), u = B(!1), d = B(0);
    let f;
    const v = x(() => n.type ? n.type === "error" ? "danger" : n.type : "info"), h = x(() => {
      const _ = n.type;
      return { [l.bm("icon", _)]: _ && Ts[_] };
    }), m = x(() => n.icon || Ts[n.type] || ""), p = x(() => Vae(n.id)), C = x(() => Bae(n.id, n.offset) + p.value), g = x(() => d.value + C.value), w = x(() => ({
      top: `${C.value}px`,
      zIndex: r.value
    }));
    function b() {
      n.duration !== 0 && ({ stop: f } = ki(() => {
        E();
      }, n.duration));
    }
    function y() {
      f == null || f();
    }
    function E() {
      u.value = !1;
    }
    function S({ code: _ }) {
      _ === xt.esc && E();
    }
    return Nt(() => {
      b(), i(), u.value = !0;
    }), Pe(() => n.repeatNum, () => {
      y(), b();
    }), jn(document, "keydown", S), Xn(s, () => {
      d.value = s.value.getBoundingClientRect().height;
    }), t({
      visible: u,
      bottom: g,
      close: E
    }), (_, k) => (M(), We(Ko, {
      name: c(l).b("fade"),
      onBeforeLeave: _.onClose,
      onAfterLeave: k[0] || (k[0] = (N) => _.$emit("destroy")),
      persisted: ""
    }, {
      default: fe(() => [
        Bt(X("div", {
          id: _.id,
          ref_key: "messageRef",
          ref: s,
          class: z([
            c(l).b(),
            { [c(l).m(_.type)]: _.type },
            c(l).is("center", _.center),
            c(l).is("closable", _.showClose),
            c(l).is("plain", _.plain),
            _.customClass
          ]),
          style: bt(c(w)),
          role: "alert",
          onMouseenter: y,
          onMouseleave: b
        }, [
          _.repeatNum > 1 ? (M(), We(c(zy), {
            key: 0,
            value: _.repeatNum,
            type: c(v),
            class: z(c(l).e("badge"))
          }, null, 8, ["value", "type", "class"])) : _e("v-if", !0),
          c(m) ? (M(), We(c(Ct), {
            key: 1,
            class: z([c(l).e("icon"), c(h)])
          }, {
            default: fe(() => [
              (M(), We(Qt(c(m))))
            ]),
            _: 1
          }, 8, ["class"])) : _e("v-if", !0),
          Ie(_.$slots, "default", {}, () => [
            _.dangerouslyUseHTMLString ? (M(), G(kt, { key: 1 }, [
              _e(" Caution here, message could've been compromised, never use user's input as message "),
              X("p", {
                class: z(c(l).e("content")),
                innerHTML: _.message
              }, null, 10, zae)
            ], 2112)) : (M(), G("p", {
              key: 0,
              class: z(c(l).e("content"))
            }, Qe(_.message), 3))
          ]),
          _.showClose ? (M(), We(c(Ct), {
            key: 2,
            class: z(c(l).e("closeBtn")),
            onClick: It(E, ["stop"])
          }, {
            default: fe(() => [
              oe(c(o))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : _e("v-if", !0)
        ], 46, Hae), [
          [pn, u.value]
        ])
      ]),
      _: 3
    }, 8, ["name", "onBeforeLeave"]));
  }
});
var Uae = /* @__PURE__ */ ut(Kae, [["__file", "message.vue"]]);
let jae = 1;
const bN = (e) => {
  const t = !e || on(e) || yo(e) || vn(e) ? { message: e } : e, n = {
    ...dl,
    ...t
  };
  if (!n.appendTo)
    n.appendTo = document.body;
  else if (on(n.appendTo)) {
    let o = document.querySelector(n.appendTo);
    wa(o) || (dn("ElMessage", "the appendTo option is not an HTMLElement. Falling back to document.body."), o = document.body), n.appendTo = o;
  }
  return n;
}, qae = (e) => {
  const t = Pa.indexOf(e);
  if (t === -1)
    return;
  Pa.splice(t, 1);
  const { handler: n } = e;
  n.close();
}, Yae = ({ appendTo: e, ...t }, n) => {
  const o = `message_${jae++}`, l = t.onClose, a = document.createElement("div"), r = {
    ...t,
    id: o,
    onClose: () => {
      l == null || l(), qae(d);
    },
    onDestroy: () => {
      Es(null, a);
    }
  }, i = oe(Uae, r, vn(r.message) || yo(r.message) ? {
    default: vn(r.message) ? r.message : () => r.message
  } : null);
  i.appContext = n || Yc._context, Es(i, a), e.appendChild(a.firstElementChild);
  const s = i.component, d = {
    id: o,
    vnode: i,
    vm: s,
    handler: {
      close: () => {
        s.exposed.visible.value = !1;
      }
    },
    props: i.component.props
  };
  return d;
}, Yc = (e = {}, t) => {
  if (!fn)
    return { close: () => {
    } };
  if (Ot(hg.max) && Pa.length >= hg.max)
    return { close: () => {
    } };
  const n = bN(e);
  if (n.grouping && Pa.length) {
    const l = Pa.find(({ vnode: a }) => {
      var r;
      return ((r = a.props) == null ? void 0 : r.message) === n.message;
    });
    if (l)
      return l.props.repeatNum += 1, l.props.type = n.type, l.handler;
  }
  const o = Yae(n, t);
  return Pa.push(o), o.handler;
};
gN.forEach((e) => {
  Yc[e] = (t = {}, n) => {
    const o = bN(t);
    return Yc({ ...o, type: e }, n);
  };
});
function Gae(e) {
  for (const t of Pa)
    (!e || e === t.props.type) && t.handler.close();
}
Yc.closeAll = Gae;
Yc._context = null;
const yN = ek(Yc, "$message"), Xae = Q({
  name: "ElMessageBox",
  directives: {
    TrapFocus: Pz
  },
  components: {
    ElButton: Do,
    ElFocusTrap: pf,
    ElInput: nl,
    ElOverlay: Jy,
    ElIcon: Ct,
    ...py
  },
  inheritAttrs: !1,
  props: {
    buttonSize: {
      type: String,
      validator: tk
    },
    modal: {
      type: Boolean,
      default: !0
    },
    lockScroll: {
      type: Boolean,
      default: !0
    },
    showClose: {
      type: Boolean,
      default: !0
    },
    closeOnClickModal: {
      type: Boolean,
      default: !0
    },
    closeOnPressEscape: {
      type: Boolean,
      default: !0
    },
    closeOnHashChange: {
      type: Boolean,
      default: !0
    },
    center: Boolean,
    draggable: Boolean,
    overflow: Boolean,
    roundButton: {
      default: !1,
      type: Boolean
    },
    container: {
      type: String,
      default: "body"
    },
    boxType: {
      type: String,
      default: ""
    }
  },
  emits: ["vanish", "action"],
  setup(e, { emit: t }) {
    const {
      locale: n,
      zIndex: o,
      ns: l,
      size: a
    } = zv("message-box", x(() => e.buttonSize)), { t: r } = n, { nextZIndex: i } = o, s = B(!1), u = en({
      autofocus: !0,
      beforeClose: null,
      callback: null,
      cancelButtonText: "",
      cancelButtonClass: "",
      confirmButtonText: "",
      confirmButtonClass: "",
      customClass: "",
      customStyle: {},
      dangerouslyUseHTMLString: !1,
      distinguishCancelAndClose: !1,
      icon: "",
      inputPattern: null,
      inputPlaceholder: "",
      inputType: "text",
      inputValue: null,
      inputValidator: null,
      inputErrorMessage: "",
      message: null,
      modalFade: !0,
      modalClass: "",
      showCancelButton: !1,
      showConfirmButton: !0,
      type: "",
      title: void 0,
      showInput: !1,
      action: "",
      confirmButtonLoading: !1,
      cancelButtonLoading: !1,
      confirmButtonDisabled: !1,
      editorErrorMessage: "",
      validateError: !1,
      zIndex: i()
    }), d = x(() => {
      const A = u.type;
      return { [l.bm("icon", A)]: A && Ts[A] };
    }), f = il(), v = il(), h = x(() => u.icon || Ts[u.type] || ""), m = x(() => !!u.message), p = B(), C = B(), g = B(), w = B(), b = B(), y = x(() => u.confirmButtonClass);
    Pe(() => u.inputValue, async (A) => {
      await xe(), e.boxType === "prompt" && A !== null && H();
    }, { immediate: !0 }), Pe(() => s.value, (A) => {
      var $, D;
      A && (e.boxType !== "prompt" && (u.autofocus ? g.value = (D = ($ = b.value) == null ? void 0 : $.$el) != null ? D : p.value : g.value = p.value), u.zIndex = i()), e.boxType === "prompt" && (A ? xe().then(() => {
        var O;
        w.value && w.value.$el && (u.autofocus ? g.value = (O = K()) != null ? O : p.value : g.value = p.value);
      }) : (u.editorErrorMessage = "", u.validateError = !1));
    });
    const E = x(() => e.draggable), S = x(() => e.overflow);
    nk(p, C, E, S), Nt(async () => {
      await xe(), e.closeOnHashChange && window.addEventListener("hashchange", _);
    }), zn(() => {
      e.closeOnHashChange && window.removeEventListener("hashchange", _);
    });
    function _() {
      s.value && (s.value = !1, xe(() => {
        u.action && t("action", u.action);
      }));
    }
    const k = () => {
      e.closeOnClickModal && R(u.distinguishCancelAndClose ? "close" : "cancel");
    }, N = Ty(k), L = (A) => {
      if (u.inputType !== "textarea")
        return A.preventDefault(), R("confirm");
    }, R = (A) => {
      var $;
      e.boxType === "prompt" && A === "confirm" && !H() || (u.action = A, u.beforeClose ? ($ = u.beforeClose) == null || $.call(u, A, u, _) : _());
    }, H = () => {
      if (e.boxType === "prompt") {
        const A = u.inputPattern;
        if (A && !A.test(u.inputValue || ""))
          return u.editorErrorMessage = u.inputErrorMessage || r("el.messagebox.error"), u.validateError = !0, !1;
        const $ = u.inputValidator;
        if (typeof $ == "function") {
          const D = $(u.inputValue);
          if (D === !1)
            return u.editorErrorMessage = u.inputErrorMessage || r("el.messagebox.error"), u.validateError = !0, !1;
          if (typeof D == "string")
            return u.editorErrorMessage = D, u.validateError = !0, !1;
        }
      }
      return u.editorErrorMessage = "", u.validateError = !1, !0;
    }, K = () => {
      const A = w.value.$refs;
      return A.input || A.textarea;
    }, U = () => {
      R("close");
    }, W = () => {
      e.closeOnPressEscape && U();
    };
    return e.lockScroll && by(s), {
      ...Xo(u),
      ns: l,
      overlayEvent: N,
      visible: s,
      hasMessage: m,
      typeClass: d,
      contentId: f,
      inputId: v,
      btnSize: a,
      iconComponent: h,
      confirmButtonClasses: y,
      rootRef: p,
      focusStartRef: g,
      headerRef: C,
      inputRef: w,
      confirmRef: b,
      doClose: _,
      handleClose: U,
      onCloseRequested: W,
      handleWrapperClick: k,
      handleInputEnter: L,
      handleAction: R,
      t: r
    };
  }
}), Zae = ["aria-label", "aria-describedby"], Jae = ["aria-label"], Qae = ["id"];
function ere(e, t, n, o, l, a) {
  const r = Dt("el-icon"), i = Dt("close"), s = Dt("el-input"), u = Dt("el-button"), d = Dt("el-focus-trap"), f = Dt("el-overlay");
  return M(), We(Ko, {
    name: "fade-in-linear",
    onAfterLeave: t[11] || (t[11] = (v) => e.$emit("vanish")),
    persisted: ""
  }, {
    default: fe(() => [
      Bt(oe(f, {
        "z-index": e.zIndex,
        "overlay-class": [e.ns.is("message-box"), e.modalClass],
        mask: e.modal
      }, {
        default: fe(() => [
          X("div", {
            role: "dialog",
            "aria-label": e.title,
            "aria-modal": "true",
            "aria-describedby": e.showInput ? void 0 : e.contentId,
            class: z(`${e.ns.namespace.value}-overlay-message-box`),
            onClick: t[8] || (t[8] = (...v) => e.overlayEvent.onClick && e.overlayEvent.onClick(...v)),
            onMousedown: t[9] || (t[9] = (...v) => e.overlayEvent.onMousedown && e.overlayEvent.onMousedown(...v)),
            onMouseup: t[10] || (t[10] = (...v) => e.overlayEvent.onMouseup && e.overlayEvent.onMouseup(...v))
          }, [
            oe(d, {
              loop: "",
              trapped: e.visible,
              "focus-trap-el": e.rootRef,
              "focus-start-el": e.focusStartRef,
              onReleaseRequested: e.onCloseRequested
            }, {
              default: fe(() => [
                X("div", {
                  ref: "rootRef",
                  class: z([
                    e.ns.b(),
                    e.customClass,
                    e.ns.is("draggable", e.draggable),
                    { [e.ns.m("center")]: e.center }
                  ]),
                  style: bt(e.customStyle),
                  tabindex: "-1",
                  onClick: t[7] || (t[7] = It(() => {
                  }, ["stop"]))
                }, [
                  e.title !== null && e.title !== void 0 ? (M(), G("div", {
                    key: 0,
                    ref: "headerRef",
                    class: z([e.ns.e("header"), { "show-close": e.showClose }])
                  }, [
                    X("div", {
                      class: z(e.ns.e("title"))
                    }, [
                      e.iconComponent && e.center ? (M(), We(r, {
                        key: 0,
                        class: z([e.ns.e("status"), e.typeClass])
                      }, {
                        default: fe(() => [
                          (M(), We(Qt(e.iconComponent)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : _e("v-if", !0),
                      X("span", null, Qe(e.title), 1)
                    ], 2),
                    e.showClose ? (M(), G("button", {
                      key: 0,
                      type: "button",
                      class: z(e.ns.e("headerbtn")),
                      "aria-label": e.t("el.messagebox.close"),
                      onClick: t[0] || (t[0] = (v) => e.handleAction(e.distinguishCancelAndClose ? "close" : "cancel")),
                      onKeydown: t[1] || (t[1] = Rn(It((v) => e.handleAction(e.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"]))
                    }, [
                      oe(r, {
                        class: z(e.ns.e("close"))
                      }, {
                        default: fe(() => [
                          oe(i)
                        ]),
                        _: 1
                      }, 8, ["class"])
                    ], 42, Jae)) : _e("v-if", !0)
                  ], 2)) : _e("v-if", !0),
                  X("div", {
                    id: e.contentId,
                    class: z(e.ns.e("content"))
                  }, [
                    X("div", {
                      class: z(e.ns.e("container"))
                    }, [
                      e.iconComponent && !e.center && e.hasMessage ? (M(), We(r, {
                        key: 0,
                        class: z([e.ns.e("status"), e.typeClass])
                      }, {
                        default: fe(() => [
                          (M(), We(Qt(e.iconComponent)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : _e("v-if", !0),
                      e.hasMessage ? (M(), G("div", {
                        key: 1,
                        class: z(e.ns.e("message"))
                      }, [
                        Ie(e.$slots, "default", {}, () => [
                          e.dangerouslyUseHTMLString ? (M(), We(Qt(e.showInput ? "label" : "p"), {
                            key: 1,
                            for: e.showInput ? e.inputId : void 0,
                            innerHTML: e.message
                          }, null, 8, ["for", "innerHTML"])) : (M(), We(Qt(e.showInput ? "label" : "p"), {
                            key: 0,
                            for: e.showInput ? e.inputId : void 0
                          }, {
                            default: fe(() => [
                              Ut(Qe(e.dangerouslyUseHTMLString ? "" : e.message), 1)
                            ]),
                            _: 1
                          }, 8, ["for"]))
                        ])
                      ], 2)) : _e("v-if", !0)
                    ], 2),
                    Bt(X("div", {
                      class: z(e.ns.e("input"))
                    }, [
                      oe(s, {
                        id: e.inputId,
                        ref: "inputRef",
                        modelValue: e.inputValue,
                        "onUpdate:modelValue": t[2] || (t[2] = (v) => e.inputValue = v),
                        type: e.inputType,
                        placeholder: e.inputPlaceholder,
                        "aria-invalid": e.validateError,
                        class: z({ invalid: e.validateError }),
                        onKeydown: Rn(e.handleInputEnter, ["enter"])
                      }, null, 8, ["id", "modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]),
                      X("div", {
                        class: z(e.ns.e("errormsg")),
                        style: bt({
                          visibility: e.editorErrorMessage ? "visible" : "hidden"
                        })
                      }, Qe(e.editorErrorMessage), 7)
                    ], 2), [
                      [pn, e.showInput]
                    ])
                  ], 10, Qae),
                  X("div", {
                    class: z(e.ns.e("btns"))
                  }, [
                    e.showCancelButton ? (M(), We(u, {
                      key: 0,
                      loading: e.cancelButtonLoading,
                      class: z([e.cancelButtonClass]),
                      round: e.roundButton,
                      size: e.btnSize,
                      onClick: t[3] || (t[3] = (v) => e.handleAction("cancel")),
                      onKeydown: t[4] || (t[4] = Rn(It((v) => e.handleAction("cancel"), ["prevent"]), ["enter"]))
                    }, {
                      default: fe(() => [
                        Ut(Qe(e.cancelButtonText || e.t("el.messagebox.cancel")), 1)
                      ]),
                      _: 1
                    }, 8, ["loading", "class", "round", "size"])) : _e("v-if", !0),
                    Bt(oe(u, {
                      ref: "confirmRef",
                      type: "primary",
                      loading: e.confirmButtonLoading,
                      class: z([e.confirmButtonClasses]),
                      round: e.roundButton,
                      disabled: e.confirmButtonDisabled,
                      size: e.btnSize,
                      onClick: t[5] || (t[5] = (v) => e.handleAction("confirm")),
                      onKeydown: t[6] || (t[6] = Rn(It((v) => e.handleAction("confirm"), ["prevent"]), ["enter"]))
                    }, {
                      default: fe(() => [
                        Ut(Qe(e.confirmButtonText || e.t("el.messagebox.confirm")), 1)
                      ]),
                      _: 1
                    }, 8, ["loading", "class", "round", "disabled", "size"]), [
                      [pn, e.showConfirmButton]
                    ])
                  ], 2)
                ], 6)
              ]),
              _: 3
            }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
          ], 42, Zae)
        ]),
        _: 3
      }, 8, ["z-index", "overlay-class", "mask"]), [
        [pn, e.visible]
      ])
    ]),
    _: 3
  });
}
var tre = /* @__PURE__ */ ut(Xae, [["render", ere], ["__file", "index.vue"]]);
const Ud = /* @__PURE__ */ new Map(), nre = (e) => {
  let t = document.body;
  return e.appendTo && (on(e.appendTo) && (t = document.querySelector(e.appendTo)), wa(e.appendTo) && (t = e.appendTo), wa(t) || (dn("ElMessageBox", "the appendTo option is not an HTMLElement. Falling back to document.body."), t = document.body)), t;
}, ore = (e, t, n = null) => {
  const o = oe(tre, e, vn(e.message) || yo(e.message) ? {
    default: vn(e.message) ? e.message : () => e.message
  } : null);
  return o.appContext = n, Es(o, t), nre(e).appendChild(t.firstElementChild), o.component;
}, lre = () => document.createElement("div"), are = (e, t) => {
  const n = lre();
  e.onVanish = () => {
    Es(null, n), Ud.delete(l);
  }, e.onAction = (a) => {
    const r = Ud.get(l);
    let i;
    e.showInput ? i = { value: l.inputValue, action: a } : i = a, e.callback ? e.callback(i, o.proxy) : a === "cancel" || a === "close" ? e.distinguishCancelAndClose && a !== "cancel" ? r.reject("close") : r.reject("cancel") : r.resolve(i);
  };
  const o = ore(e, n, t), l = o.proxy;
  for (const a in e)
    sl(e, a) && !sl(l.$props, a) && (l[a] = e[a]);
  return l.visible = !0, l;
};
function iu(e, t = null) {
  if (!fn)
    return Promise.reject();
  let n;
  return on(e) || yo(e) ? e = {
    message: e
  } : n = e.callback, new Promise((o, l) => {
    const a = are(e, t ?? iu._context);
    Ud.set(a, {
      options: e,
      callback: n,
      resolve: o,
      reject: l
    });
  });
}
const rre = ["alert", "confirm", "prompt"], sre = {
  alert: { closeOnPressEscape: !1, closeOnClickModal: !1 },
  confirm: { showCancelButton: !0 },
  prompt: { showCancelButton: !0, showInput: !0 }
};
rre.forEach((e) => {
  iu[e] = ire(e);
});
function ire(e) {
  return (t, n, o, l) => {
    let a = "";
    return Mn(n) ? (o = n, a = "") : To(n) ? a = "" : a = n, iu(Object.assign({
      title: a,
      message: t,
      type: "",
      ...sre[e]
    }, o, {
      boxType: e
    }), l);
  };
}
iu.close = () => {
  Ud.forEach((e, t) => {
    t.doClose();
  }), Ud.clear();
};
iu._context = null;
const ds = iu;
ds.install = (e) => {
  ds._context = e._context, e.config.globalProperties.$msgbox = ds, e.config.globalProperties.$messageBox = ds, e.config.globalProperties.$alert = ds.alert, e.config.globalProperties.$confirm = ds.confirm, e.config.globalProperties.$prompt = ds.prompt;
};
const cre = ds, CN = [
  "success",
  "info",
  "warning",
  "error"
], ure = it({
  customClass: {
    type: String,
    default: ""
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: !1
  },
  duration: {
    type: Number,
    default: 4500
  },
  icon: {
    type: Dn
  },
  id: {
    type: String,
    default: ""
  },
  message: {
    type: Ae([String, Object]),
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  onClick: {
    type: Ae(Function),
    default: () => {
    }
  },
  onClose: {
    type: Ae(Function),
    required: !0
  },
  position: {
    type: String,
    values: ["top-right", "top-left", "bottom-right", "bottom-left"],
    default: "top-right"
  },
  showClose: {
    type: Boolean,
    default: !0
  },
  title: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: [...CN, ""],
    default: ""
  },
  zIndex: Number
}), dre = {
  destroy: () => !0
}, fre = ["id"], pre = ["textContent"], vre = { key: 0 }, hre = ["innerHTML"], mre = Q({
  name: "ElNotification"
}), gre = /* @__PURE__ */ Q({
  ...mre,
  props: ure,
  emits: dre,
  setup(e, { expose: t }) {
    const n = e, { ns: o, zIndex: l } = zv("notification"), { nextZIndex: a, currentZIndex: r } = l, { Close: i } = fy, s = B(!1);
    let u;
    const d = x(() => {
      const b = n.type;
      return b && Ts[n.type] ? o.m(b) : "";
    }), f = x(() => n.type && Ts[n.type] || n.icon), v = x(() => n.position.endsWith("right") ? "right" : "left"), h = x(() => n.position.startsWith("top") ? "top" : "bottom"), m = x(() => {
      var b;
      return {
        [h.value]: `${n.offset}px`,
        zIndex: (b = n.zIndex) != null ? b : r.value
      };
    });
    function p() {
      n.duration > 0 && ({ stop: u } = ki(() => {
        s.value && g();
      }, n.duration));
    }
    function C() {
      u == null || u();
    }
    function g() {
      s.value = !1;
    }
    function w({ code: b }) {
      b === xt.delete || b === xt.backspace ? C() : b === xt.esc ? s.value && g() : p();
    }
    return Nt(() => {
      p(), a(), s.value = !0;
    }), jn(document, "keydown", w), t({
      visible: s,
      close: g
    }), (b, y) => (M(), We(Ko, {
      name: c(o).b("fade"),
      onBeforeLeave: b.onClose,
      onAfterLeave: y[1] || (y[1] = (E) => b.$emit("destroy")),
      persisted: ""
    }, {
      default: fe(() => [
        Bt(X("div", {
          id: b.id,
          class: z([c(o).b(), b.customClass, c(v)]),
          style: bt(c(m)),
          role: "alert",
          onMouseenter: C,
          onMouseleave: p,
          onClick: y[0] || (y[0] = (...E) => b.onClick && b.onClick(...E))
        }, [
          c(f) ? (M(), We(c(Ct), {
            key: 0,
            class: z([c(o).e("icon"), c(d)])
          }, {
            default: fe(() => [
              (M(), We(Qt(c(f))))
            ]),
            _: 1
          }, 8, ["class"])) : _e("v-if", !0),
          X("div", {
            class: z(c(o).e("group"))
          }, [
            X("h2", {
              class: z(c(o).e("title")),
              textContent: Qe(b.title)
            }, null, 10, pre),
            Bt(X("div", {
              class: z(c(o).e("content")),
              style: bt(b.title ? void 0 : { margin: 0 })
            }, [
              Ie(b.$slots, "default", {}, () => [
                b.dangerouslyUseHTMLString ? (M(), G(kt, { key: 1 }, [
                  _e(" Caution here, message could've been compromised, never use user's input as message "),
                  X("p", { innerHTML: b.message }, null, 8, hre)
                ], 2112)) : (M(), G("p", vre, Qe(b.message), 1))
              ])
            ], 6), [
              [pn, b.message]
            ]),
            b.showClose ? (M(), We(c(Ct), {
              key: 0,
              class: z(c(o).e("closeBtn")),
              onClick: It(g, ["stop"])
            }, {
              default: fe(() => [
                oe(c(i))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : _e("v-if", !0)
          ], 2)
        ], 46, fre), [
          [pn, s.value]
        ])
      ]),
      _: 3
    }, 8, ["name", "onBeforeLeave"]));
  }
});
var bre = /* @__PURE__ */ ut(gre, [["__file", "notification.vue"]]);
const cv = {
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  "bottom-right": []
}, pb = 16;
let yre = 1;
const Gc = function(e = {}, t = null) {
  if (!fn)
    return { close: () => {
    } };
  (typeof e == "string" || yo(e)) && (e = { message: e });
  const n = e.position || "top-right";
  let o = e.offset || 0;
  cv[n].forEach(({ vm: d }) => {
    var f;
    o += (((f = d.el) == null ? void 0 : f.offsetHeight) || 0) + pb;
  }), o += pb;
  const l = `notification_${yre++}`, a = e.onClose, r = {
    ...e,
    offset: o,
    id: l,
    onClose: () => {
      Cre(l, n, a);
    }
  };
  let i = document.body;
  wa(e.appendTo) ? i = e.appendTo : on(e.appendTo) && (i = document.querySelector(e.appendTo)), wa(i) || (dn("ElNotification", "the appendTo option is not an HTMLElement. Falling back to document.body."), i = document.body);
  const s = document.createElement("div"), u = oe(bre, r, yo(r.message) ? {
    default: () => r.message
  } : null);
  return u.appContext = t ?? Gc._context, u.props.onDestroy = () => {
    Es(null, s);
  }, Es(u, s), cv[n].push({ vm: u }), i.appendChild(s.firstElementChild), {
    close: () => {
      u.component.exposed.visible.value = !1;
    }
  };
};
CN.forEach((e) => {
  Gc[e] = (t = {}) => ((typeof t == "string" || yo(t)) && (t = {
    message: t
  }), Gc({
    ...t,
    type: e
  }));
});
function Cre(e, t, n) {
  const o = cv[t], l = o.findIndex(({ vm: u }) => {
    var d;
    return ((d = u.component) == null ? void 0 : d.props.id) === e;
  });
  if (l === -1)
    return;
  const { vm: a } = o[l];
  if (!a)
    return;
  n == null || n(a);
  const r = a.el.offsetHeight, i = t.split("-")[0];
  o.splice(l, 1);
  const s = o.length;
  if (!(s < 1))
    for (let u = l; u < s; u++) {
      const { el: d, component: f } = o[u].vm, v = Number.parseInt(d.style[i], 10) - r - pb;
      f.props.offset = v;
    }
}
function wre() {
  for (const e of Object.values(cv))
    e.forEach(({ vm: t }) => {
      t.component.exposed.visible.value = !1;
    });
}
Gc.closeAll = wre;
Gc._context = null;
const Ere = ek(Gc, "$notify");
var Sre = [
  Mae,
  mN,
  yN,
  cre,
  Ere,
  G$
], _re = K5([..._ae, ...Sre]), xre = {
  cookies: {
    path: "/"
  },
  treeOptions: {
    parentKey: "parentId",
    key: "id",
    children: "children"
  },
  parseDateFormat: "yyyy-MM-dd HH:mm:ss",
  firstDayOfWeek: 1
}, Kr = xre;
function kre(e, t, n) {
  if (e)
    if (e.forEach)
      e.forEach(t, n);
    else
      for (var o = 0, l = e.length; o < l; o++)
        t.call(n, e[o], o, e);
}
var zl = kre, Tre = Object.prototype.toString, wN = Tre, $re = wN;
function Ore(e) {
  return function(t) {
    return "[object " + e + "]" === $re.call(t);
  };
}
var gf = Ore, Nre = gf, Mre = Array.isArray || Nre("Array"), ao = Mre;
function Ire(e, t) {
  return e && e.hasOwnProperty ? e.hasOwnProperty(t) : !1;
}
var Ka = Ire, Rre = Ka;
function Dre(e, t, n) {
  if (e)
    for (var o in e)
      Rre(e, o) && t.call(n, e[o], o, e);
}
var bf = Dre, Lre = ao, Pre = zl, Are = bf;
function Fre(e, t, n) {
  return e && (Lre(e) ? Pre : Are)(e, t, n);
}
var jo = Fre;
function Vre(e) {
  return function(t) {
    return typeof t === e;
  };
}
var cu = Vre, Bre = cu, Hre = Bre("function"), na = Hre, zre = jo;
function Wre(e, t) {
  var n = Object[e];
  return function(o) {
    var l = [];
    if (o) {
      if (n)
        return n(o);
      zre(o, t > 1 ? function(a) {
        l.push(["" + a, o[a]]);
      } : function() {
        l.push(arguments[t]);
      });
    }
    return l;
  };
}
var I0 = Wre, Kre = I0, Ure = Kre("keys", 1), Ur = Ure, jre = wN, qre = bf, Yre = zl;
function gm(e, t) {
  var n = e.__proto__.constructor;
  return t ? new n(t) : new n();
}
function tp(e, t) {
  return t ? EN(e, t) : e;
}
function EN(e, t) {
  if (e)
    switch (jre.call(e)) {
      case "[object Object]": {
        var n = Object.create(Object.getPrototypeOf(e));
        return qre(e, function(r, i) {
          n[i] = tp(r, t);
        }), n;
      }
      case "[object Date]":
      case "[object RegExp]":
        return gm(e, e.valueOf());
      case "[object Array]":
      case "[object Arguments]": {
        var o = [];
        return Yre(e, function(r) {
          o.push(tp(r, t));
        }), o;
      }
      case "[object Set]": {
        var l = gm(e);
        return l.forEach(function(r) {
          l.add(tp(r, t));
        }), l;
      }
      case "[object Map]": {
        var a = gm(e);
        return a.forEach(function(r, i) {
          a.set(i, tp(r, t));
        }), a;
      }
    }
  return e;
}
function Gre(e, t) {
  return e && EN(e, t);
}
var R0 = Gre, Xre = zl, Zre = Ur, Jre = ao, Qre = R0, jE = Object.assign;
function qE(e, t, n) {
  for (var o = t.length, l, a = 1; a < o; a++)
    l = t[a], Xre(Zre(t[a]), n ? function(r) {
      e[r] = Qre(l[r], n);
    } : function(r) {
      e[r] = l[r];
    });
  return e;
}
var ese = function(e) {
  if (e) {
    var t = arguments;
    if (e === !0) {
      if (t.length > 1)
        return e = Jre(e[1]) ? [] : {}, qE(e, t, !0);
    } else
      return jE ? jE.apply(Object, t) : qE(e, t);
  }
  return e;
}, Ua = ese, tse = Kr, nse = zl, ose = jo, lse = na, ase = Ua, wi = function() {
};
function rse() {
  nse(arguments, function(e) {
    ose(e, function(t, n) {
      wi[n] = lse(t) ? function() {
        var o = t.apply(wi.$context, arguments);
        return wi.$context = null, o;
      } : t;
    });
  });
}
function sse(e) {
  return ase(tse, e);
}
wi.VERSION = "3.5.25";
wi.mixin = rse;
wi.setup = sse;
var ise = wi;
function cse(e, t, n) {
  for (var o = e.length - 1; o >= 0; o--)
    t.call(n, e[o], o, e);
}
var D0 = cse, use = D0, dse = Ur;
function fse(e, t, n) {
  use(dse(e), function(o) {
    t.call(n, e[o], o, e);
  });
}
var SN = fse;
function pse(e) {
  return e === null;
}
var jr = pse, vse = jr;
function hse(e, t) {
  return function(n) {
    return vse(n) ? t : n[e];
  };
}
var uu = hse, mse = jo, gse = na, bse = uu;
function yse(e, t, n) {
  var o = {};
  if (e)
    if (t)
      gse(t) || (t = bse(t)), mse(e, function(l, a) {
        o[a] = t.call(n, l, a, e);
      });
    else
      return e;
  return o;
}
var Cse = yse;
function wse(e) {
  return e ? e.constructor === Object : !1;
}
var du = wse, YE = ao, GE = du, Ese = jo;
function _N(e, t) {
  return GE(e) && GE(t) || YE(e) && YE(t) ? (Ese(t, function(n, o) {
    e[o] = _N(e[o], n);
  }), e) : t;
}
var Sse = function(e) {
  e || (e = {});
  for (var t = arguments, n = t.length, o, l = 1; l < n; l++)
    o = t[l], o && _N(e, o);
  return e;
}, _se = Sse, xse = jo;
function kse(e, t, n) {
  var o = [];
  if (e && arguments.length > 1) {
    if (e.map)
      return e.map(t, n);
    xse(e, function() {
      o.push(t.apply(n, arguments));
    });
  }
  return o;
}
var fu = kse, Tse = Ka, $se = ao;
function Ose(e, t, n, o, l) {
  return function(a, r, i) {
    if (a && r) {
      if (e && a[e])
        return a[e](r, i);
      if (t && $se(a)) {
        for (var s = 0, u = a.length; s < u; s++)
          if (!!r.call(i, a[s], s, a) === o)
            return [!0, !1, s, a[s]][n];
      } else
        for (var d in a)
          if (Tse(a, d) && !!r.call(i, a[d], d, a) === o)
            return [!0, !1, d, a[d]][n];
    }
    return l;
  };
}
var Qv = Ose, Nse = Qv, Mse = Nse("some", 1, 0, !0, !1), xN = Mse, Ise = Qv, Rse = Ise("every", 1, 1, !1, !0), kN = Rse, Dse = Ka;
function Lse(e, t) {
  if (e) {
    if (e.includes)
      return e.includes(t);
    for (var n in e)
      if (Dse(e, n) && t === e[n])
        return !0;
  }
  return !1;
}
var yf = Lse, XE = ao, ZE = yf;
function Pse(e, t) {
  var n, o = 0;
  if (XE(e) && XE(t)) {
    for (n = t.length; o < n; o++)
      if (!ZE(e, t[o]))
        return !1;
    return !0;
  }
  return ZE(e, t);
}
var TN = Pse, JE = jo, Ase = yf, Fse = na, Vse = uu;
function Bse(e, t, n) {
  var o = [];
  if (t) {
    Fse(t) || (t = Vse(t));
    var l, a = {};
    JE(e, function(r, i) {
      l = t.call(n, r, i, e), a[l] || (a[l] = 1, o.push(r));
    });
  } else
    JE(e, function(r) {
      Ase(o, r) || o.push(r);
    });
  return o;
}
var $N = Bse, Hse = fu;
function zse(e) {
  return Hse(e, function(t) {
    return t;
  });
}
var L0 = zse, Wse = $N, Kse = L0;
function Use() {
  for (var e = arguments, t = [], n = 0, o = e.length; n < o; n++)
    t = t.concat(Kse(e[n]));
  return Wse(t);
}
var jse = Use, qse = "undefined", ja = qse, Yse = ja, Gse = cu, Xse = Gse(Yse), hr = Xse, Zse = jr, Jse = hr;
function Qse(e) {
  return Zse(e) || Jse(e);
}
var Fs = Qse, eie = /(.+)?\[(\d+)\]$/, ON = eie;
function tie(e) {
  return e ? e.splice && e.join ? e : ("" + e).replace(/(\[\d+\])\.?/g, "$1.").replace(/\.$/, "").split(".") : [];
}
var P0 = tie, nie = ON, oie = P0, lie = Ka, aie = hr, NN = Fs;
function rie(e, t, n) {
  if (NN(e))
    return n;
  var o = iie(e, t);
  return aie(o) ? n : o;
}
function sie(e, t) {
  var n = t ? t.match(nie) : "";
  return n ? n[1] ? e[n[1]] ? e[n[1]][n[2]] : void 0 : e[n[2]] : e[t];
}
function iie(e, t) {
  if (e) {
    var n, o, l, a = 0;
    if (e[t] || lie(e, t))
      return e[t];
    if (o = oie(t), l = o.length, l) {
      for (n = e; a < l; a++)
        if (n = sie(n, o[a]), NN(n))
          return a === l - 1 ? n : void 0;
    }
    return n;
  }
}
var Cf = rie, QE = zl, cie = L0, eS = fu, tS = ao, uie = na, die = du, nS = hr, fie = jr, pie = Fs, vie = Cf, hie = uu, mie = "asc", gie = "desc";
function vb(e, t) {
  return nS(e) ? 1 : fie(e) ? nS(t) ? -1 : 1 : e && e.localeCompare ? e.localeCompare(t) : e > t ? 1 : -1;
}
function bie(e, t, n) {
  return function(o, l) {
    var a = o[e], r = l[e];
    return a === r ? n ? n(o, l) : 0 : t.order === gie ? vb(r, a) : vb(a, r);
  };
}
function yie(e, t, n, o) {
  var l = [];
  return n = tS(n) ? n : [n], QE(n, function(a, r) {
    if (a) {
      var i = a, s;
      tS(a) ? (i = a[0], s = a[1]) : die(a) && (i = a.field, s = a.order), l.push({
        field: i,
        order: s || mie
      }), QE(t, uie(i) ? function(u, d) {
        u[r] = i.call(o, u.data, d, e);
      } : function(u) {
        u[r] = i ? vie(u.data, i) : u.data;
      });
    }
  }), l;
}
function Cie(e, t, n) {
  if (e) {
    if (pie(t))
      return cie(e).sort(vb);
    for (var o, l = eS(e, function(i) {
      return { data: i };
    }), a = yie(e, l, t, n), r = a.length - 1; r >= 0; )
      o = bie(r, a[r], o), r--;
    return o && (l = l.sort(o)), eS(l, hie("data"));
  }
  return [];
}
var A0 = Cie, wie = A0, Eie = wie, Sie = Eie;
function _ie(e, t) {
  return e >= t ? e : (e = e >> 0) + Math.round(Math.random() * ((t || 9) - e));
}
var MN = _ie, xie = I0, kie = xie("values", 0), pu = kie, Tie = MN, $ie = pu;
function Oie(e) {
  for (var t, n = [], o = $ie(e), l = o.length - 1; l >= 0; l--)
    t = l > 0 ? Tie(0, l) : 0, n.push(o[t]), o.splice(t, 1);
  return n;
}
var IN = Oie, Nie = IN;
function Mie(e, t) {
  var n = Nie(e);
  return arguments.length <= 1 ? n[0] : (t < n.length && (n.length = t || 0), n);
}
var Iie = Mie;
function Rie(e) {
  return function(t) {
    if (t) {
      var n = e(t && t.replace ? t.replace(/,/g, "") : t);
      if (!isNaN(n))
        return n;
    }
    return 0;
  };
}
var RN = Rie, Die = RN, Lie = Die(parseFloat), Wi = Lie, oS = Wi;
function Pie(e, t, n) {
  var o = [], l = arguments.length;
  if (e) {
    if (t = l >= 2 ? oS(t) : 0, n = l >= 3 ? oS(n) : e.length, e.slice)
      return e.slice(t, n);
    for (; t < n; t++)
      o.push(e[t]);
  }
  return o;
}
var Ki = Pie, Aie = jo;
function Fie(e, t, n) {
  var o = [];
  if (e && t) {
    if (e.filter)
      return e.filter(t, n);
    Aie(e, function(l, a) {
      t.call(n, l, a, e) && o.push(l);
    });
  }
  return o;
}
var Vie = Fie, Bie = Qv, Hie = Bie("", 0, 2, !0), zie = Hie, Wie = Qv, Kie = Wie("find", 1, 3, !0), Uie = Kie, jie = ao, qie = pu;
function Yie(e, t, n) {
  if (e) {
    jie(e) || (e = qie(e));
    for (var o = e.length - 1; o >= 0; o--)
      if (t.call(n, e[o], o, e))
        return e[o];
  }
}
var Gie = Yie, Xie = Ur;
function Zie(e, t, n) {
  if (e) {
    var o, l, a = 0, r = null, i = n, s = arguments.length > 2, u = Xie(e);
    if (e.length && e.reduce)
      return l = function() {
        return t.apply(r, arguments);
      }, s ? e.reduce(l, i) : e.reduce(l);
    for (s && (a = 1, i = e[u[0]]), o = u.length; a < o; a++)
      i = t.call(r, i, e[u[a]], a, e);
    return i;
  }
}
var Jie = Zie, Qie = ao;
function ece(e, t, n, o) {
  if (Qie(e) && e.copyWithin)
    return e.copyWithin(t, n, o);
  var l, a, r = t >> 0, i = n >> 0, s = e.length, u = arguments.length > 3 ? o >> 0 : s;
  if (r < s && (r = r >= 0 ? r : s + r, r >= 0 && (i = i >= 0 ? i : s + i, u = u >= 0 ? u : s + u, i < u)))
    for (l = 0, a = e.slice(i, u); r < s && !(a.length <= l); r++)
      e[r] = a[l++];
  return e;
}
var tce = ece, nce = ao;
function oce(e, t) {
  var n, o = [], l = t >> 0 || 1;
  if (nce(e))
    if (l >= 0 && e.length > l)
      for (n = 0; n < e.length; )
        o.push(e.slice(n, n + l)), n += l;
    else
      o = e.length ? [e] : e;
  return o;
}
var lce = oce, ace = fu, rce = uu;
function sce(e, t) {
  return ace(e, rce(t));
}
var DN = sce, ice = na, lS = Fs, cce = Cf, uce = zl;
function dce(e) {
  return function(t, n) {
    if (t && t.length) {
      var o, l;
      return uce(t, function(a, r) {
        n && (a = ice(n) ? n(a, r, t) : cce(a, n)), !lS(a) && (lS(o) || e(o, a)) && (l = r, o = a);
      }), t[l];
    }
    return o;
  };
}
var LN = dce, fce = LN, pce = fce(function(e, t) {
  return e < t;
}), PN = pce, vce = DN, hce = PN;
function mce(e) {
  var t, n, o, l = [];
  if (e && e.length)
    for (t = 0, n = hce(e, function(a) {
      return a ? a.length : 0;
    }), o = n ? n.length : 0; t < o; t++)
      l.push(vce(e, t));
  return l;
}
var AN = mce, gce = AN;
function bce() {
  return gce(arguments);
}
var yce = bce, Cce = pu, wce = jo;
function Ece(e, t) {
  var n = {};
  return t = t || [], wce(Cce(e), function(o, l) {
    n[o] = t[l];
  }), n;
}
var Sce = Ece, FN = ao, _ce = zl;
function VN(e, t) {
  var n = [];
  return _ce(e, function(o) {
    n = n.concat(FN(o) ? t ? VN(o, t) : o : [o]);
  }), n;
}
function xce(e, t) {
  return FN(e) ? VN(e, t) : [];
}
var kce = xce, Tce = fu, $ce = ao;
function Oce(e, t) {
  for (var n = 0, o = t.length; e && n < o; )
    e = e[t[n++]];
  return o && e ? e : 0;
}
function Nce(e, t) {
  for (var n, o = arguments, l = [], a = [], r = 2, i = o.length; r < i; r++)
    l.push(o[r]);
  if ($ce(t)) {
    for (i = t.length - 1, r = 0; r < i; r++)
      a.push(t[r]);
    t = t[i];
  }
  return Tce(e, function(s) {
    if (a.length && (s = Oce(s, a)), n = s[t] || t, n && n.apply)
      return n.apply(s, l);
  });
}
var Mce = Nce;
function Ice(e, t) {
  try {
    delete e[t];
  } catch {
    e[t] = void 0;
  }
}
var BN = Ice, Rce = ao, Dce = D0, Lce = SN;
function Pce(e, t, n) {
  return e && (Rce(e) ? Dce : Lce)(e, t, n);
}
var HN = Pce, Ace = cu, Fce = Ace("object"), eh = Fce, Vce = BN, Bce = du, Hce = eh, zce = ao, Wce = jr, Kce = Ua, Uce = bf;
function jce(e, t, n) {
  if (e) {
    var o, l = arguments.length > 1 && (Wce(t) || !Hce(t)), a = l ? n : t;
    if (Bce(e))
      Uce(e, l ? function(r, i) {
        e[i] = t;
      } : function(r, i) {
        Vce(e, i);
      }), a && Kce(e, a);
    else if (zce(e)) {
      if (l)
        for (o = e.length; o > 0; )
          o--, e[o] = t;
      else
        e.length = 0;
      a && e.push.apply(e, a);
    }
  }
  return e;
}
var zN = jce, qce = BN, Yce = na, Gce = ao, Xce = jo, Zce = zl, Jce = HN, Qce = zN, eue = Fs;
function tue(e) {
  return function(t, n) {
    return n === e;
  };
}
function nue(e, t, n) {
  if (e) {
    if (!eue(t)) {
      var o = [], l = [];
      return Yce(t) || (t = tue(t)), Xce(e, function(a, r, i) {
        t.call(n, a, r, i) && o.push(r);
      }), Gce(e) ? Jce(o, function(a, r) {
        l.push(e[a]), e.splice(a, 1);
      }) : (l = {}, Zce(o, function(a) {
        l[a] = e[a], qce(e, a);
      })), l;
    }
    return Qce(e);
  }
  return e;
}
var WN = nue, oue = Kr, lue = A0, aue = R0, rue = Fs, hb = jo, sue = WN, iue = Ua;
function cue(e, t) {
  hb(e, function(n) {
    n[t] && !n[t].length && sue(n, t);
  });
}
function uue(e, t) {
  var n = iue({}, oue.treeOptions, t), o = n.strict, l = n.key, a = n.parentKey, r = n.children, i = n.mapChildren, s = n.sortKey, u = n.reverse, d = n.data, f = [], v = {}, h = {}, m, p, C;
  return s && (e = lue(aue(e), s), u && (e = e.reverse())), hb(e, function(g) {
    m = g[l], h[m] = !0;
  }), hb(e, function(g) {
    m = g[l], d ? (p = {}, p[d] = g) : p = g, C = g[a], v[m] = v[m] || [], v[C] = v[C] || [], v[C].push(p), p[l] = m, p[a] = C, p[r] = v[m], i && (p[i] = v[m]), (!o || o && rue(C)) && (h[C] || f.push(p));
  }), o && cue(e, r), f;
}
var due = uue, fue = Kr, pue = jo, vue = Ua;
function KN(e, t, n) {
  var o = n.children, l = n.data, a = n.clear;
  return pue(t, function(r) {
    var i = r[o];
    l && (r = r[l]), e.push(r), i && i.length && KN(e, i, n), a && delete r[o];
  }), e;
}
function hue(e, t) {
  return KN([], e, vue({}, fue.treeOptions, t));
}
var mue = hue;
function gue(e) {
  return function(t, n, o, l) {
    var a = o || {}, r = a.children || "children";
    return e(null, t, n, l, [], [], r, a);
  };
}
var th = gue, bue = th;
function UN(e, t, n, o, l, a, r, i) {
  if (t) {
    var s, u, d, f, v, h;
    for (u = 0, d = t.length; u < d; u++) {
      if (s = t[u], f = l.concat(["" + u]), v = a.concat([s]), n.call(o, s, u, t, f, e, v))
        return { index: u, item: s, path: f, items: t, parent: e, nodes: v };
      if (r && s && (h = UN(s, s[r], n, o, f.concat([r]), v, r), h))
        return h;
    }
  }
}
var yue = bue(UN), Cue = yue, wue = th, Eue = jo;
function jN(e, t, n, o, l, a, r, i) {
  var s, u;
  Eue(t, function(d, f) {
    s = l.concat(["" + f]), u = a.concat([d]), n.call(o, d, f, t, s, e, u), d && r && (s.push(r), jN(d, d[r], n, o, s, u, r));
  });
}
var Sue = wue(jN), qN = Sue, _ue = th, xue = fu;
function YN(e, t, n, o, l, a, r, i) {
  var s, u, d, f = i.mapChildren || r;
  return xue(t, function(v, h) {
    return s = l.concat(["" + h]), u = a.concat([v]), d = n.call(o, v, h, t, s, e, u), d && v && r && v[r] && (d[f] = YN(v, v[r], n, o, s, u, r, i)), d;
  });
}
var kue = _ue(YN), Tue = kue, $ue = qN;
function Oue(e, t, n, o) {
  var l = [];
  return e && t && $ue(e, function(a, r, i, s, u, d) {
    t.call(o, a, r, i, s, u, d) && l.push(a);
  }, n), l;
}
var Nue = Oue, Mue = th, Iue = zl, Rue = Ua;
function GN(e, t, n, o, l, a, r, i, s) {
  var u, d, f, v, h, m = [], p = s.original, C = s.data, g = s.mapChildren || i, w = s.isEvery;
  return Iue(n, function(b, y) {
    u = a.concat(["" + y]), d = r.concat([b]), v = e && !w || o.call(l, b, y, n, u, t, d), h = i && b[i], v || h ? (p ? f = b : (f = Rue({}, b), C && (f[C] = b)), f[g] = GN(v, b, b[i], o, l, u, d, i, s), (v || f[g].length) && m.push(f)) : v && m.push(f);
  }), m;
}
var Due = Mue(function(e, t, n, o, l, a, r, i) {
  return GN(0, e, t, n, o, l, a, r, i);
}), Lue = Due;
function Pue(e, t) {
  if (e.indexOf)
    return e.indexOf(t);
  for (var n = 0, o = e.length; n < o; n++)
    if (t === e[n])
      return n;
}
var XN = Pue;
function Aue(e, t) {
  if (e.lastIndexOf)
    return e.lastIndexOf(t);
  for (var n = e.length - 1; n >= 0; n--)
    if (t === e[n])
      return n;
  return -1;
}
var ZN = Aue, Fue = cu, Vue = Fue("number"), mr = Vue, Bue = mr;
function Hue(e) {
  return Bue(e) && isNaN(e);
}
var zue = Hue, Wue = cu, Kue = Wue("string"), qr = Kue, Uue = gf, jue = Uue("Date"), Vs = jue, que = parseInt, wf = que;
function Yue(e) {
  return Date.UTC(e.y, e.M || 0, e.d || 1, e.H || 0, e.m || 0, e.s || 0, e.S || 0);
}
var Gue = Yue;
function Xue(e) {
  return e.getTime();
}
var Ta = Xue, uv = wf, aS = Gue, Zue = Ta, Jue = qr, Que = Vs;
function Ef(e) {
  return "(\\d{" + e + "})";
}
function ede(e) {
  return e < 10 ? e * 100 : e < 100 ? e * 10 : e;
}
function rS(e) {
  return isNaN(e) ? e : uv(e);
}
var ec = Ef(2), hc = Ef("1,2"), JN = Ef("1,7"), QN = Ef("3,4"), eM = ".{1}", Mu = eM + hc, tM = "(([zZ])|([-+]\\d{2}:?\\d{2}))", sS = [QN, Mu, Mu, Mu, Mu, Mu, eM + JN, tM], mb = [];
for (var bm = sS.length - 1; bm >= 0; bm--) {
  for (var iS = "", Ei = 0; Ei < bm + 1; Ei++)
    iS += sS[Ei];
  mb.push(new RegExp("^" + iS + "$"));
}
function tde(e) {
  for (var t, n = {}, o = 0, l = mb.length; o < l; o++)
    if (t = e.match(mb[o]), t) {
      n.y = t[1], n.M = t[2], n.d = t[3], n.H = t[4], n.m = t[5], n.s = t[6], n.S = t[7], n.Z = t[8];
      break;
    }
  return n;
}
var cS = [
  ["yyyy", QN],
  ["yy", ec],
  ["MM", ec],
  ["M", hc],
  ["dd", ec],
  ["d", hc],
  ["HH", ec],
  ["H", hc],
  ["mm", ec],
  ["m", hc],
  ["ss", ec],
  ["s", hc],
  ["SSS", Ef(3)],
  ["S", JN],
  ["Z", tM]
], nM = {}, oM = ["\\[([^\\]]+)\\]"];
for (var Ei = 0; Ei < cS.length; Ei++) {
  var ym = cS[Ei];
  nM[ym[0]] = ym[1] + "?", oM.push(ym[0]);
}
var nde = new RegExp(oM.join("|"), "g"), uS = {};
function ode(e, t) {
  var n = uS[t];
  if (!n) {
    var o = [], l = t.replace(/([$(){}*+.?\\^|])/g, "\\$1").replace(nde, function(d, f) {
      var v = d.charAt(0);
      return v === "[" ? f : (o.push(v), nM[d]);
    });
    n = uS[t] = {
      _i: o,
      _r: new RegExp(l)
    };
  }
  var a = {}, r = e.match(n._r);
  if (r) {
    for (var i = n._i, s = 1, u = r.length; s < u; s++)
      a[i[s - 1]] = r[s];
    return a;
  }
  return a;
}
function lde(e) {
  if (/^[zZ]/.test(e.Z))
    return new Date(aS(e));
  var t = e.Z.match(/([-+])(\d{2}):?(\d{2})/);
  return t ? new Date(aS(e) - (t[1] === "-" ? -1 : 1) * uv(t[2]) * 36e5 + uv(t[3]) * 6e4) : /* @__PURE__ */ new Date("");
}
function ade(e, t) {
  if (e) {
    var n = Que(e);
    if (n || !t && /^[0-9]{11,15}$/.test(e))
      return new Date(n ? Zue(e) : uv(e));
    if (Jue(e)) {
      var o = t ? ode(e, t) : tde(e);
      if (o.y)
        return o.M && (o.M = rS(o.M) - 1), o.S && (o.S = ede(rS(o.S.substring(0, 3)))), o.Z ? lde(o) : new Date(o.y, o.M || 0, o.d || 1, o.H || 0, o.m || 0, o.s || 0, o.S || 0);
    }
  }
  return /* @__PURE__ */ new Date("");
}
var oa = ade;
function rde() {
  return /* @__PURE__ */ new Date();
}
var nh = rde, sde = Vs, ide = oa, cde = nh;
function ude(e) {
  var t, n = e ? ide(e) : cde();
  return sde(n) ? (t = n.getFullYear(), t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0)) : !1;
}
var lM = ude, dde = ao, fde = Ka;
function pde(e, t, n) {
  if (e) {
    if (dde(e))
      for (var o = 0, l = e.length; o < l && t.call(n, e[o], o, e) !== !1; o++)
        ;
    else
      for (var a in e)
        if (fde(e, a) && t.call(n, e[a], a, e) === !1)
          break;
  }
}
var vde = pde, hde = ao, mde = Ka;
function gde(e, t, n) {
  if (e) {
    var o, l;
    if (hde(e))
      for (o = e.length - 1; o >= 0 && t.call(n, e[o], o, e) !== !1; o--)
        ;
    else
      for (l = mde(e), o = l.length - 1; o >= 0 && t.call(n, e[l[o]], l[o], e) !== !1; o--)
        ;
  }
}
var bde = gde, yde = ao, Cde = qr, wde = Ka;
function Ede(e, t) {
  return function(n, o) {
    if (n) {
      if (n[e])
        return n[e](o);
      if (Cde(n) || yde(n))
        return t(n, o);
      for (var l in n)
        if (wde(n, l) && o === n[l])
          return l;
    }
    return -1;
  };
}
var aM = Ede, Sde = aM, _de = XN, xde = Sde("indexOf", _de), kde = xde, Tde = aM, $de = ZN, Ode = Tde("lastIndexOf", $de), rM = Ode, Nde = ao, Mde = qr, Ide = jo;
function Rde(e) {
  var t = 0;
  return Mde(e) || Nde(e) ? e.length : (Ide(e, function() {
    t++;
  }), t);
}
var sM = Rde, Dde = mr;
function Lde(e) {
  return Dde(e) && isFinite(e);
}
var Pde = Lde, Ade = ao, Fde = jr, Vde = function(e) {
  return !Fde(e) && !isNaN(e) && !Ade(e) && e % 1 === 0;
}, iM = Vde, Bde = ao, Hde = iM, zde = jr;
function Wde(e) {
  return !zde(e) && !isNaN(e) && !Bde(e) && !Hde(e);
}
var Kde = Wde, Ude = cu, jde = Ude("boolean"), cM = jde, qde = gf, Yde = qde("RegExp"), F0 = Yde, Gde = gf, Xde = Gde("Error"), uM = Xde;
function Zde(e) {
  return e ? e.constructor === TypeError : !1;
}
var Jde = Zde;
function Qde(e) {
  for (var t in e)
    return !1;
  return !0;
}
var dM = Qde, efe = ja, tfe = typeof Symbol !== efe;
function nfe(e) {
  return tfe && Symbol.isSymbol ? Symbol.isSymbol(e) : typeof e == "symbol";
}
var fM = nfe, ofe = gf, lfe = ofe("Arguments"), afe = lfe, rfe = qr, sfe = mr;
function ife(e) {
  return !!(e && rfe(e.nodeName) && sfe(e.nodeType));
}
var cfe = ife, ufe = ja, dfe = typeof document === ufe ? 0 : document, V0 = dfe, ffe = V0;
function pfe(e) {
  return !!(e && ffe && e.nodeType === 9);
}
var vfe = pfe, hfe = ja, mfe = typeof window === hfe ? 0 : window, pM = mfe, gfe = pM;
function bfe(e) {
  return !!(gfe && (e && e === e.window));
}
var yfe = bfe, Cfe = ja, wfe = typeof FormData !== Cfe;
function Efe(e) {
  return wfe && e instanceof FormData;
}
var Sfe = Efe, _fe = ja, xfe = typeof Map !== _fe;
function kfe(e) {
  return xfe && e instanceof Map;
}
var Tfe = kfe, $fe = ja, Ofe = typeof WeakMap !== $fe;
function Nfe(e) {
  return Ofe && e instanceof WeakMap;
}
var Mfe = Nfe, Ife = ja, Rfe = typeof Set !== Ife;
function Dfe(e) {
  return Rfe && e instanceof Set;
}
var Lfe = Dfe, Pfe = ja, Afe = typeof WeakSet !== Pfe;
function Ffe(e) {
  return Afe && e instanceof WeakSet;
}
var Vfe = Ffe, Bfe = na, Hfe = qr, zfe = ao, Wfe = Ka;
function Kfe(e) {
  return function(t, n, o) {
    if (t && Bfe(n)) {
      if (zfe(t) || Hfe(t))
        return e(t, n, o);
      for (var l in t)
        if (Wfe(t, l) && n.call(o, t[l], l, t))
          return l;
    }
    return -1;
  };
}
var vM = Kfe, Ufe = vM, jfe = Ufe(function(e, t, n) {
  for (var o = 0, l = e.length; o < l; o++)
    if (t.call(n, e[o], o, e))
      return o;
  return -1;
}), B0 = jfe, dS = mr, fS = ao, pS = qr, qfe = F0, Yfe = Vs, Gfe = cM, Xfe = hr, vS = Ur, Zfe = kN;
function hM(e, t, n, o, l, a, r) {
  if (e === t)
    return !0;
  if (e && t && !dS(e) && !dS(t) && !pS(e) && !pS(t)) {
    if (qfe(e))
      return n("" + e, "" + t, l, a, r);
    if (Yfe(e) || Gfe(e))
      return n(+e, +t, l, a, r);
    var i, s, u, d = fS(e), f = fS(t);
    if (d || f ? d && f : e.constructor === t.constructor)
      return s = vS(e), u = vS(t), o && (i = o(e, t, l)), s.length === u.length ? Xfe(i) ? Zfe(s, function(v, h) {
        return v === u[h] && hM(e[v], t[u[h]], n, o, d || f ? h : v, e, t);
      }) : !!i : !1;
  }
  return n(e, t, l, a, r);
}
var mM = hM;
function Jfe(e, t) {
  return e === t;
}
var gM = Jfe, Qfe = mM, epe = gM;
function tpe(e, t) {
  return Qfe(e, t, epe);
}
var bM = tpe, hS = Ur, npe = B0, mS = bM, ope = xN, lpe = TN;
function ape(e, t) {
  var n = hS(e), o = hS(t);
  if (o.length) {
    if (lpe(n, o))
      return ope(o, function(l) {
        return npe(n, function(a) {
          return a === l && mS(e[a], t[l]);
        }) > -1;
      });
  } else
    return !0;
  return mS(e, t);
}
var rpe = ape, gS = mM, bS = gM, spe = na, ipe = hr;
function cpe(e, t, n) {
  return spe(n) ? gS(e, t, function(o, l, a, r, i) {
    var s = n(o, l, a, r, i);
    return ipe(s) ? bS(o, l) : !!s;
  }, n) : gS(e, t, bS);
}
var upe = cpe, dpe = fM, fpe = Vs, ppe = ao, vpe = F0, hpe = uM, mpe = jr;
function gpe(e) {
  return mpe(e) ? "null" : dpe(e) ? "symbol" : fpe(e) ? "date" : ppe(e) ? "array" : vpe(e) ? "regexp" : hpe(e) ? "error" : typeof e;
}
var bpe = gpe, ype = 0;
function Cpe(e) {
  return [e, ++ype].join("");
}
var wpe = Cpe, Epe = vM, Spe = Epe(function(e, t, n) {
  for (var o = e.length - 1; o >= 0; o--)
    if (t.call(n, e[o], o, e))
      return o;
  return -1;
}), _pe = Spe, xpe = du, kpe = qr;
function Tpe(e) {
  if (xpe(e))
    return e;
  if (kpe(e))
    try {
      return JSON.parse(e);
    } catch {
    }
  return {};
}
var $pe = Tpe, Ope = Fs;
function Npe(e) {
  return Ope(e) ? "" : JSON.stringify(e);
}
var Mpe = Npe, Ipe = I0, Rpe = Ipe("entries", 2), Dpe = Rpe, Lpe = na, Ppe = ao, Ape = jo, Fpe = B0;
function Vpe(e, t) {
  return function(n, o) {
    var l, a, r = {}, i = [], s = this, u = arguments, d = u.length;
    if (!Lpe(o)) {
      for (a = 1; a < d; a++)
        l = u[a], i.push.apply(i, Ppe(l) ? l : [l]);
      o = 0;
    }
    return Ape(n, function(f, v) {
      ((o ? o.call(s, f, v, n) : Fpe(i, function(h) {
        return h === v;
      }) > -1) ? e : t) && (r[v] = f);
    }), r;
  };
}
var yM = Vpe, Bpe = yM, Hpe = Bpe(1, 0), zpe = Hpe, Wpe = yM, Kpe = Wpe(0, 1), Upe = Kpe, jpe = pu;
function qpe(e) {
  return jpe(e)[0];
}
var Ype = qpe, Gpe = pu;
function Xpe(e) {
  var t = Gpe(e);
  return t[t.length - 1];
}
var Zpe = Xpe, Jpe = ON, Qpe = P0, np = Ka;
function eve(e, t) {
  if (e) {
    if (np(e, t))
      return !0;
    var n, o, l, a, r, i, s = Qpe(t), u = 0, d = s.length;
    for (r = e; u < d && (i = !1, n = s[u], a = n ? n.match(Jpe) : "", a ? (o = a[1], l = a[2], o ? r[o] && np(r[o], l) && (i = !0, r = r[o][l]) : np(r, l) && (i = !0, r = r[l])) : np(r, n) && (i = !0, r = r[n]), i); u++)
      if (u === d - 1)
        return !0;
  }
  return !1;
}
var tve = eve, yS = wf, nve = P0, ove = Ka, CS = /(.+)?\[(\d+)\]$/;
function lve(e, t, n, o, l) {
  if (e[t])
    n && (e[t] = l);
  else {
    var a, r, i = t ? t.match(CS) : null;
    if (n)
      r = l;
    else {
      var s = o ? o.match(CS) : null;
      s && !s[1] ? r = new Array(yS(s[2]) + 1) : r = {};
    }
    return i ? i[1] ? (a = yS(i[2]), e[i[1]] ? n ? e[i[1]][a] = r : e[i[1]][a] ? r = e[i[1]][a] : e[i[1]][a] = r : (e[i[1]] = new Array(a + 1), e[i[1]][a] = r)) : e[i[2]] = r : e[t] = r, r;
  }
  return e[t];
}
function ave(e, t, n) {
  if (e) {
    if ((e[t] || ove(e, t)) && !wS(t))
      e[t] = n;
    else
      for (var o = e, l = nve(t), a = l.length, r = 0; r < a; r++)
        if (!wS(l[r])) {
          var i = r === a - 1;
          o = lve(o, l[r], i, i ? null : l[r + 1], n);
        }
  }
  return e;
}
function wS(e) {
  return e === "__proto__" || e === "constructor" || e === "prototype";
}
var rve = ave, sve = dM, ive = eh, cve = na, uve = uu, dve = jo;
function fve(e) {
  return function() {
    return sve(e);
  };
}
function pve(e, t, n) {
  var o, l = {};
  return e && (t && ive(t) ? t = fve(t) : cve(t) || (t = uve(t)), dve(e, function(a, r) {
    o = t ? t.call(n, a, r, e) : a, l[o] ? l[o].push(a) : l[o] = [a];
  })), l;
}
var CM = pve, vve = CM, hve = bf;
function mve(e, t, n) {
  var o = vve(e, t, n || this);
  return hve(o, function(l, a) {
    o[a] = l.length;
  }), o;
}
var gve = mve;
function bve(e, t, n) {
  var o, l, a = [], r = arguments;
  if (r.length < 2 && (t = r[0], e = 0), o = e >> 0, l = t >> 0, o < t)
    for (n = n >> 0 || 1; o < l; o += n)
      a.push(o);
  return a;
}
var yve = bve, ES = Ur, Cve = Ki, wve = yf, Eve = zl, Sve = Ua;
function _ve(e, t) {
  if (e && t) {
    var n = Sve.apply(this, [{}].concat(Cve(arguments, 1))), o = ES(n);
    Eve(ES(e), function(l) {
      wve(o, l) && (e[l] = n[l]);
    });
  }
  return e;
}
var xve = _ve, kve = LN, Tve = kve(function(e, t) {
  return e > t;
}), $ve = Tve;
function Ove(e) {
  return (e.split(".")[1] || "").length;
}
var oh = Ove, Nve = wf;
function Mve(e, t) {
  if (e.repeat)
    return e.repeat(t);
  var n = isNaN(t) ? [] : new Array(Nve(t));
  return n.join(e) + (n.length > 0 ? e : "");
}
var Sf = Mve;
function Ive(e, t) {
  return e.substring(0, t) + "." + e.substring(t, e.length);
}
var wM = Ive, op = Sf, Cm = wM;
function Rve(e) {
  var t = "" + e, n = t.match(/^([-+]?)((\d+)|((\d+)?[.](\d+)?))e([-+]{1})([0-9]+)$/);
  if (n) {
    var o = e < 0, l = o ? "-" : "", a = n[3] || "", r = n[5] || "", i = n[6] || "", s = n[7], u = n[8], d = u - i.length, f = u - a.length, v = u - r.length;
    return s === "+" ? a ? l + a + op("0", u) : d > 0 ? l + r + i + op("0", d) : l + r + Cm(i, u) : a ? f > 0 ? l + "0." + op("0", Math.abs(f)) + a : l + Cm(a, f) : v > 0 ? l + "0." + op("0", Math.abs(v)) + r + i : l + Cm(r, v) + i;
  }
  return t;
}
var Bs = Rve, SS = oh, _S = Bs;
function Dve(e, t) {
  var n = _S(e), o = _S(t);
  return parseInt(n.replace(".", "")) * parseInt(o.replace(".", "")) / Math.pow(10, SS(n) + SS(o));
}
var EM = Dve, Lve = EM, xS = Wi, Pve = Bs;
function Ave(e) {
  return function(t, n) {
    var o = xS(t), l = o;
    if (o) {
      n = n >> 0;
      var a = Pve(o), r = a.split("."), i = r[0], s = r[1] || "", u = s.substring(0, n + 1), d = i + (u ? "." + u : "");
      if (n >= s.length)
        return xS(d);
      if (d = o, n > 0) {
        var f = Math.pow(10, n);
        l = Math[e](Lve(d, f)) / f;
      } else
        l = Math[e](d);
    }
    return l;
  };
}
var H0 = Ave, Fve = H0, Vve = Fve("round"), z0 = Vve, Bve = H0, Hve = Bve("ceil"), SM = Hve, zve = H0, Wve = zve("floor"), _M = Wve, Kve = Fs, Uve = mr, jve = Bs;
function qve(e) {
  return Uve(e) ? jve(e) : "" + (Kve(e) ? "" : e);
}
var Wl = qve, Yve = z0, Gve = Wl, Xve = Sf, Zve = wM;
function Jve(e, t) {
  t = t >> 0;
  var n = Gve(Yve(e, t)), o = n.split("."), l = o[0], a = o[1] || "", r = t - a.length;
  return t ? r > 0 ? l + "." + a + Xve("0", r) : l + Zve(a, Math.abs(r)) : l;
}
var W0 = Jve, Qve = Kr, ehe = z0, the = SM, nhe = _M, ohe = mr, lhe = Wl, ahe = W0, rhe = Bs, she = Ua;
function ihe(e, t) {
  var n = she({}, Qve.commafyOptions, t), o = n.digits, l = ohe(e), a, r, i, s, u;
  return l ? (a = (n.ceil ? the : n.floor ? nhe : ehe)(e, o), r = rhe(o ? ahe(a, o) : a).split("."), s = r[0], u = r[1], i = s && a < 0, i && (s = s.substring(1, s.length))) : (a = lhe(e).replace(/,/g, ""), r = a ? [a] : [], s = r[0]), r.length ? (i ? "-" : "") + s.replace(new RegExp("(?=(?!(\\b))(.{" + (n.spaceNumber || 3) + "})+$)", "g"), n.separator || ",") + (u ? "." + u : "") : a;
}
var che = ihe, uhe = wf, dhe = RN, fhe = dhe(uhe), phe = fhe, vhe = EM, kS = Wi;
function hhe(e, t) {
  var n = kS(e), o = kS(t);
  return vhe(n, o);
}
var K0 = hhe, TS = oh, $S = Bs, OS = K0;
function mhe(e, t) {
  var n = $S(e), o = $S(t), l = Math.pow(10, Math.max(TS(n), TS(o)));
  return (OS(e, l) + OS(t, l)) / l;
}
var xM = mhe, ghe = xM, NS = Wi;
function bhe(e, t) {
  return ghe(NS(e), NS(t));
}
var yhe = bhe, MS = oh, IS = Bs, RS = Wi, Che = W0;
function whe(e, t) {
  var n = RS(e), o = RS(t), l = IS(n), a = IS(o), r = MS(l), i = MS(a), s = Math.pow(10, Math.max(r, i)), u = r >= i ? r : i;
  return parseFloat(Che((n * s - o * s) / s, u));
}
var Ehe = whe, DS = oh, LS = Bs, She = K0;
function _he(e, t) {
  var n = LS(e), o = LS(t), l = DS(n), a = DS(o), r = a - l, i = r < 0, s = Math.pow(10, i ? Math.abs(r) : r);
  return She(n.replace(".", "") / o.replace(".", ""), i ? 1 / s : s);
}
var kM = _he, xhe = kM, PS = Wi;
function khe(e, t) {
  return xhe(PS(e), PS(t));
}
var The = khe, wm = xM, $he = na, Ohe = jo, Nhe = Cf;
function Mhe(e, t, n) {
  var o = 0;
  return Ohe(e, t ? $he(t) ? function() {
    o = wm(o, t.apply(n, arguments));
  } : function(l) {
    o = wm(o, Nhe(l, t));
  } : function(l) {
    o = wm(o, l);
  }), o;
}
var TM = Mhe, Ihe = kM, Rhe = sM, Dhe = TM;
function Lhe(e, t, n) {
  return Ihe(Dhe(e, t, n), Rhe(e));
}
var Phe = Lhe, Ahe = "first", _f = Ahe, Fhe = "last", lh = Fhe;
function Vhe(e) {
  return e.getFullYear();
}
var xf = Vhe, Bhe = 864e5, kf = Bhe;
function Hhe(e) {
  return e.getMonth();
}
var ah = Hhe, zhe = Vs, Whe = Ta;
function Khe(e) {
  return zhe(e) && !isNaN(Whe(e));
}
var $a = Khe, AS = _f, Uhe = lh, jhe = kf, qhe = xf, FS = Ta, VS = ah, Yhe = oa, Ghe = $a, Xhe = mr;
function $M(e, t, n) {
  var o = t && !isNaN(t) ? t : 0;
  if (e = Yhe(e), Ghe(e)) {
    if (n === AS)
      return new Date(qhe(e), VS(e) + o, 1);
    if (n === Uhe)
      return new Date(FS($M(e, o + 1, AS)) - 1);
    if (Xhe(n) && e.setDate(n), o) {
      var l = e.getDate();
      if (e.setMonth(VS(e) + o), l !== e.getDate())
        return e.setDate(1), new Date(FS(e) - jhe);
    }
  }
  return e;
}
var Tf = $M, Zhe = _f, BS = lh, HS = xf, Jhe = Tf, Qhe = oa, eme = $a;
function tme(e, t, n) {
  var o;
  if (e = Qhe(e), eme(e) && (t && (o = t && !isNaN(t) ? t : 0, e.setFullYear(HS(e) + o)), n || !isNaN(n))) {
    if (n === Zhe)
      return new Date(HS(e), 0, 1);
    if (n === BS)
      return e.setMonth(11), Jhe(e, 0, BS);
    e.setMonth(n);
  }
  return e;
}
var rh = tme, nme = Tf, ome = oa, lme = $a;
function ame(e) {
  var t = e.getMonth();
  return t < 3 ? 1 : t < 6 ? 2 : t < 9 ? 3 : 4;
}
function rme(e, t, n) {
  var o, l = t && !isNaN(t) ? t * 3 : 0;
  return e = ome(e), lme(e) ? (o = (ame(e) - 1) * 3, e.setMonth(o), nme(e, l, n)) : e;
}
var sme = rme, zS = _f, ime = lh, cme = wf, ume = xf, dme = ah, fme = Ta, pme = oa, vme = $a;
function OM(e, t, n) {
  if (e = pme(e), vme(e) && !isNaN(t)) {
    if (e.setDate(e.getDate() + cme(t)), n === zS)
      return new Date(ume(e), dme(e), e.getDate());
    if (n === ime)
      return new Date(fme(OM(e, 1, zS)) - 1);
  }
  return e;
}
var NM = OM;
function hme(e) {
  return e.toUpperCase();
}
var MM = hme, mme = kf, gme = mme * 7, IM = gme, bme = Kr, Em = kf, yme = IM, Cme = Ta, wme = oa, Eme = $a, WS = mr;
function Sme(e, t, n, o) {
  if (e = wme(e), Eme(e)) {
    var l = WS(n), a = WS(o), r = Cme(e);
    if (l || a) {
      var i = a ? o : bme.firstDayOfWeek, s = e.getDay(), u = l ? n : s;
      if (s !== u) {
        var d = 0;
        i > s ? d = -(7 - i + s) : i < s && (d = i - s), u > i ? r += ((u === 0 ? 7 : u) - i + d) * Em : u < i ? r += (7 - i + u + d) * Em : r += d * Em;
      }
    }
    return t && !isNaN(t) && (r += t * yme), new Date(r);
  }
  return e;
}
var RM = Sme, _me = Kr, xme = IM, kme = mr, Tme = $a, $me = RM, KS = Ta;
function Ome(e) {
  return function(t, n) {
    var o = kme(n) ? n : _me.firstDayOfWeek, l = $me(t, 0, o, o);
    if (Tme(l)) {
      var a = new Date(l.getFullYear(), l.getMonth(), l.getDate()), r = e(l), i = r.getDay();
      return i > o && r.setDate(7 - i + o + 1), i < o && r.setDate(o - i + 1), Math.floor((KS(a) - KS(r)) / xme + 1);
    }
    return NaN;
  };
}
var DM = Ome, Nme = DM, Mme = Nme(function(e) {
  return new Date(e.getFullYear(), 0, 1);
}), LM = Mme, Ime = xf, Rme = ah;
function Dme(e) {
  return new Date(Ime(e), Rme(e), e.getDate());
}
var Lme = Dme, Pme = Ta, Ame = Lme;
function Fme(e) {
  return Pme(Ame(e));
}
var Vme = Fme, Bme = kf, Hme = _f, US = Vme, zme = rh, Wme = oa, Kme = $a;
function Ume(e) {
  return e = Wme(e), Kme(e) ? Math.floor((US(e) - US(zme(e, 0, Hme))) / Bme) + 1 : NaN;
}
var PM = Ume, jme = Wl, qme = hr, Yme = Sf;
function Gme(e, t, n) {
  var o = jme(e);
  return t = t >> 0, n = qme(n) ? " " : "" + n, o.padStart ? o.padStart(t, n) : t > o.length ? (t -= o.length, t > n.length && (n += Yme(n, t / n.length)), n.slice(0, t) + o) : o;
}
var AM = Gme, Iu = Kr, Xme = MM, Zme = xf, jS = ah, Jme = oa, Qme = LM, ege = PM, tge = Ua, nge = $a, oge = na, Za = AM;
function es(e, t, n, o) {
  var l = t[n];
  return l ? oge(l) ? l(o, n, e) : l[o] : o;
}
var lge = /\[([^\]]+)]|y{2,4}|M{1,2}|d{1,2}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|S{1,3}|Z{1,2}|W{1,2}|D{1,3}|[aAeEq]/g;
function age(e, t, n) {
  if (e) {
    if (e = Jme(e), nge(e)) {
      var o = t || Iu.parseDateFormat || Iu.formatString, l = e.getHours(), a = l < 12 ? "am" : "pm", r = tge({}, Iu.parseDateRules || Iu.formatStringMatchs, n ? n.formats : null), i = function(b, y) {
        return ("" + Zme(e)).substr(4 - y);
      }, s = function(b, y) {
        return Za(jS(e) + 1, y, "0");
      }, u = function(b, y) {
        return Za(e.getDate(), y, "0");
      }, d = function(b, y) {
        return Za(l, y, "0");
      }, f = function(b, y) {
        return Za(l <= 12 ? l : l - 12, y, "0");
      }, v = function(b, y) {
        return Za(e.getMinutes(), y, "0");
      }, h = function(b, y) {
        return Za(e.getSeconds(), y, "0");
      }, m = function(b, y) {
        return Za(e.getMilliseconds(), y, "0");
      }, p = function(b, y) {
        var E = e.getTimezoneOffset() / 60 * -1;
        return es(e, r, b, (E >= 0 ? "+" : "-") + Za(E, 2, "0") + (y === 1 ? ":" : "") + "00");
      }, C = function(b, y) {
        return Za(es(e, r, b, Qme(e, (n ? n.firstDay : null) || Iu.firstDayOfWeek)), y, "0");
      }, g = function(b, y) {
        return Za(es(e, r, b, ege(e)), y, "0");
      }, w = {
        yyyy: i,
        yy: i,
        MM: s,
        M: s,
        dd: u,
        d: u,
        HH: d,
        H: d,
        hh: f,
        h: f,
        mm: v,
        m: v,
        ss: h,
        s: h,
        SSS: m,
        S: m,
        ZZ: p,
        Z: p,
        WW: C,
        W: C,
        DDD: g,
        D: g,
        a: function(b) {
          return es(e, r, b, a);
        },
        A: function(b) {
          return es(e, r, b, Xme(a));
        },
        e: function(b) {
          return es(e, r, b, e.getDay());
        },
        E: function(b) {
          return es(e, r, b, e.getDay());
        },
        q: function(b) {
          return es(e, r, b, Math.floor((jS(e) + 3) / 3));
        }
      };
      return o.replace(lge, function(b, y) {
        return y || (w[b] ? w[b](b, b.length) : b);
      });
    }
    return "Invalid Date";
  }
  return "";
}
var FM = age, rge = Ta, sge = nh, ige = Date.now || function() {
  return rge(sge());
}, VM = ige, cge = Ta, uge = VM, dge = oa, fge = Vs, pge = function(e, t) {
  if (e) {
    var n = dge(e, t);
    return fge(n) ? cge(n) : n;
  }
  return uge();
}, vge = pge, qS = FM;
function hge(e, t, n) {
  return e && t ? (e = qS(e, n), e !== "Invalid Date" && e === qS(t, n)) : !1;
}
var mge = hge, gge = DM, bge = gge(function(e) {
  return new Date(e.getFullYear(), e.getMonth(), 1);
}), yge = bge, Cge = rh, wge = oa, Ege = $a, Sge = lM;
function _ge(e, t) {
  return e = wge(e), Ege(e) ? Sge(Cge(e, t)) ? 366 : 365 : NaN;
}
var xge = _ge, kge = kf, Tge = _f, $ge = lh, YS = Ta, GS = Tf, Oge = oa, Nge = $a;
function Mge(e, t) {
  return e = Oge(e), Nge(e) ? Math.floor((YS(GS(e, t, $ge)) - YS(GS(e, t, Tge))) / kge) + 1 : NaN;
}
var Ige = Mge, XS = Ta, Rge = nh, ZS = oa, JS = $a, QS = [
  ["yyyy", 31536e6],
  ["MM", 2592e6],
  ["dd", 864e5],
  ["HH", 36e5],
  ["mm", 6e4],
  ["ss", 1e3],
  ["S", 0]
];
function Dge(e, t) {
  var n, o, l, a, r, i, s = { done: !1, time: 0 };
  if (e = ZS(e), t = t ? ZS(t) : Rge(), JS(e) && JS(t) && (n = XS(e), o = XS(t), n < o))
    for (a = s.time = o - n, s.done = !0, i = 0, r = QS.length; i < r; i++)
      l = QS[i], a >= l[1] ? i === r - 1 ? s[l[0]] = a || 0 : (s[l[0]] = Math.floor(a / l[1]), a -= s[l[0]] * l[1]) : s[l[0]] = 0;
  return s;
}
var Lge = Dge, Pge = Wl, Age = hr, Fge = Sf;
function Vge(e, t, n) {
  var o = Pge(e);
  return t = t >> 0, n = Age(n) ? " " : "" + n, o.padEnd ? o.padEnd(t, n) : t > o.length ? (t -= o.length, t > n.length && (n += Fge(n, t / n.length)), o + n.slice(0, t)) : o;
}
var Bge = Vge, Hge = Wl, zge = Sf;
function Wge(e, t) {
  return zge(Hge(e), t);
}
var Kge = Wge, Uge = Wl;
function jge(e) {
  return e && e.trimRight ? e.trimRight() : Uge(e).replace(/[\s\uFEFF\xA0]+$/g, "");
}
var BM = jge, qge = Wl;
function Yge(e) {
  return e && e.trimLeft ? e.trimLeft() : qge(e).replace(/^[\s\uFEFF\xA0]+/g, "");
}
var HM = Yge, Gge = BM, Xge = HM;
function Zge(e) {
  return e && e.trim ? e.trim() : Gge(Xge(e));
}
var zM = Zge, Jge = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
}, WM = Jge, Qge = Wl, ebe = Ur;
function tbe(e) {
  var t = new RegExp("(?:" + ebe(e).join("|") + ")", "g");
  return function(n) {
    return Qge(n).replace(t, function(o) {
      return e[o];
    });
  };
}
var KM = tbe, nbe = WM, obe = KM, lbe = obe(nbe), abe = lbe, e_ = WM, rbe = KM, sbe = jo, UM = {};
sbe(e_, function(e, t) {
  UM[e_[t]] = t;
});
var ibe = rbe(UM), cbe = ibe;
function ube(e, t, n) {
  return e.substring(t, n);
}
var jM = ube;
function dbe(e) {
  return e.toLowerCase();
}
var qM = dbe, fbe = Wl, ts = jM, Ru = MM, pbe = qM, Sm = {};
function vbe(e) {
  if (e = fbe(e), Sm[e])
    return Sm[e];
  var t = e.length, n = e.replace(/([-]+)/g, function(o, l, a) {
    return a && a + l.length < t ? "-" : "";
  });
  return t = n.length, n = n.replace(/([A-Z]+)/g, function(o, l, a) {
    var r = l.length;
    return l = pbe(l), a ? r > 2 && a + r < t ? Ru(ts(l, 0, 1)) + ts(l, 1, r - 1) + Ru(ts(l, r - 1, r)) : Ru(ts(l, 0, 1)) + ts(l, 1, r) : r > 1 && a + r < t ? ts(l, 0, r - 1) + Ru(ts(l, r - 1, r)) : l;
  }).replace(/(-[a-zA-Z])/g, function(o, l) {
    return Ru(ts(l, 1, l.length));
  }), Sm[e] = n, n;
}
var hbe = vbe, mbe = Wl, tc = jM, ns = qM, _m = {};
function gbe(e) {
  if (e = mbe(e), _m[e])
    return _m[e];
  if (/^[A-Z]+$/.test(e))
    return ns(e);
  var t = e.replace(/^([a-z])([A-Z]+)([a-z]+)$/, function(n, o, l, a) {
    var r = l.length;
    return r > 1 ? o + "-" + ns(tc(l, 0, r - 1)) + "-" + ns(tc(l, r - 1, r)) + a : ns(o + "-" + l + a);
  }).replace(/^([A-Z]+)([a-z]+)?$/, function(n, o, l) {
    var a = o.length;
    return ns(tc(o, 0, a - 1) + "-" + tc(o, a - 1, a) + (l || ""));
  }).replace(/([a-z]?)([A-Z]+)([a-z]?)/g, function(n, o, l, a, r) {
    var i = l.length;
    return i > 1 && (o && (o += "-"), a) ? (o || "") + ns(tc(l, 0, i - 1)) + "-" + ns(tc(l, i - 1, i)) + a : (o || "") + (r ? "-" : "") + ns(l) + (a || "");
  });
  return t = t.replace(/([-]+)/g, function(n, o, l) {
    return l && l + o.length < t.length ? "-" : "";
  }), _m[e] = t, t;
}
var bbe = gbe, ybe = Wl;
function Cbe(e, t, n) {
  var o = ybe(e);
  return (arguments.length === 1 ? o : o.substring(n)).indexOf(t) === 0;
}
var wbe = Cbe, Ebe = Wl;
function Sbe(e, t, n) {
  var o = Ebe(e), l = arguments.length;
  return l > 1 && (l > 2 ? o.substring(0, n).indexOf(t) === n - 1 : o.indexOf(t) === o.length - 1);
}
var _be = Sbe, xbe = Kr, kbe = Wl, Tbe = zM, $be = Cf;
function Obe(e, t, n) {
  return kbe(e).replace((n || xbe).tmplRE || /\{{2}([.\w[\]\s]+)\}{2}/g, function(o, l) {
    return $be(t, Tbe(l));
  });
}
var YM = Obe, Nbe = YM;
function Mbe(e, t) {
  return Nbe(e, t, { tmplRE: /\{([.\w[\]\s]+)\}/g });
}
var Ibe = Mbe;
function Rbe() {
}
var Dbe = Rbe, t_ = Ki;
function Lbe(e, t) {
  var n = t_(arguments, 2);
  return function() {
    return e.apply(t, t_(arguments).concat(n));
  };
}
var Pbe = Lbe, n_ = Ki;
function Abe(e, t) {
  var n = !1, o = null, l = n_(arguments, 2);
  return function() {
    return n || (o = e.apply(t, n_(arguments).concat(l)), n = !0), o;
  };
}
var Fbe = Abe, Vbe = Ki;
function Bbe(e, t, n) {
  var o = 0, l = [];
  return function() {
    var a = arguments;
    o++, o <= e && l.push(a[0]), o >= e && t.apply(n, [l].concat(Vbe(a)));
  };
}
var Hbe = Bbe, zbe = Ki;
function Wbe(e, t, n) {
  var o = 0, l = [];
  return n = n || this, function() {
    var a = arguments;
    o++, o < e && (l.push(a[0]), t.apply(n, [l].concat(zbe(a))));
  };
}
var Kbe = Wbe;
function Ube(e, t, n) {
  var o = null, l = null, a = n || {}, r = !1, i = null, s = "leading" in a ? a.leading : !0, u = "trailing" in a ? a.trailing : !1, d = function() {
    o = null, l = null;
  }, f = function() {
    r = !0, e.apply(l, o), i = setTimeout(v, t), d();
  }, v = function() {
    i = null, !r && u === !0 && f();
  }, h = function() {
    var p = i !== null;
    return p && clearTimeout(i), d(), i = null, r = !1, p;
  }, m = function() {
    o = arguments, l = this, r = !1, i === null && (s === !0 ? f() : u === !0 && (i = setTimeout(v, t)));
  };
  return m.cancel = h, m;
}
var jbe = Ube;
function qbe(e, t, n) {
  var o = null, l = null, a = n || {}, r = !1, i = null, s = typeof n == "boolean", u = "leading" in a ? a.leading : s, d = "trailing" in a ? a.trailing : !s, f = function() {
    o = null, l = null;
  }, v = function() {
    r = !0, e.apply(l, o), f();
  }, h = function() {
    u === !0 && (i = null), !r && d === !0 && v();
  }, m = function() {
    var C = i !== null;
    return C && clearTimeout(i), f(), i = null, r = !1, C;
  }, p = function() {
    r = !1, o = arguments, l = this, i === null ? u === !0 && v() : clearTimeout(i), i = setTimeout(h, t);
  };
  return p.cancel = m, p;
}
var Ybe = qbe, Gbe = Ki;
function Xbe(e, t) {
  var n = Gbe(arguments, 2), o = this;
  return setTimeout(function() {
    e.apply(o, n);
  }, t);
}
var Zbe = Xbe, Jbe = decodeURIComponent, GM = Jbe, o_ = GM, Qbe = zl, eye = qr;
function tye(e) {
  var t, n = {};
  return e && eye(e) && Qbe(e.split("&"), function(o) {
    t = o.split("="), n[o_(t[0])] = o_(t[1] || "");
  }), n;
}
var XM = tye, nye = encodeURIComponent, ZM = nye, dv = ZM, JM = jo, QM = ao, eI = jr, oye = hr, tI = du;
function nI(e, t, n) {
  var o, l = [];
  return JM(e, function(a, r) {
    o = QM(a), tI(a) || o ? l = l.concat(nI(a, t + "[" + r + "]", o)) : l.push(dv(t + "[" + (n ? "" : r) + "]") + "=" + dv(eI(a) ? "" : a));
  }), l;
}
function lye(e) {
  var t, n = [];
  return JM(e, function(o, l) {
    oye(o) || (t = QM(o), tI(o) || t ? n = n.concat(nI(o, l, t)) : n.push(dv(l) + "=" + dv(eI(o) ? "" : o)));
  }), n.join("&").replace(/%20/g, "+");
}
var aye = lye, rye = ja, sye = typeof location === rye ? 0 : location, sh = sye, lp = sh;
function iye() {
  return lp ? lp.origin || lp.protocol + "//" + lp.host : "";
}
var oI = iye, l_ = sh, cye = XM, uye = oI;
function a_(e) {
  return cye(e.split("?")[1] || "");
}
function dye(e) {
  var t, n, o, l, a = "" + e;
  return a.indexOf("//") === 0 ? a = (l_ ? l_.protocol : "") + a : a.indexOf("/") === 0 && (a = uye() + a), o = a.replace(/#.*/, "").match(/(\?.*)/), l = {
    href: a,
    hash: "",
    host: "",
    hostname: "",
    protocol: "",
    port: "",
    search: o && o[1] && o[1].length > 1 ? o[1] : ""
  }, l.path = a.replace(/^([a-z0-9.+-]*:)\/\//, function(r, i) {
    return l.protocol = i, "";
  }).replace(/^([a-z0-9.+-]*)(:\d+)?\/?/, function(r, i, s) {
    return n = s || "", l.port = n.replace(":", ""), l.hostname = i, l.host = i + n, "/";
  }).replace(/(#.*)/, function(r, i) {
    return l.hash = i.length > 1 ? i : "", "";
  }), t = l.hash.match(/#((.*)\?|(.*))/), l.pathname = l.path.replace(/(\?|#.*).*/, ""), l.origin = l.protocol + "//" + l.host, l.hashKey = t && (t[2] || t[1]) || "", l.hashQuery = a_(l.hash), l.searchQuery = a_(l.search), l;
}
var lI = dye, r_ = sh, fye = oI, pye = rM;
function vye() {
  if (r_) {
    var e = r_.pathname, t = pye(e, "/") + 1;
    return fye() + (t === e.length ? e : e.substring(0, t));
  }
  return "";
}
var hye = vye, s_ = sh, mye = lI;
function gye() {
  return s_ ? mye(s_.href) : {};
}
var bye = gye, aI = Kr, xm = V0, i_ = GM, c_ = ZM, yye = ao, u_ = eh, rI = Vs, Cye = hr, wye = yf, Eye = Ur, fv = Ua, km = zl, Sye = nh, ap = Ta, _ye = rh, xye = Tf, kye = NM;
function d_(e, t) {
  var n = parseFloat(t), o = Sye(), l = ap(o);
  switch (e) {
    case "y":
      return ap(_ye(o, n));
    case "M":
      return ap(xye(o, n));
    case "d":
      return ap(kye(o, n));
    case "h":
    case "H":
      return l + n * 60 * 60 * 1e3;
    case "m":
      return l + n * 60 * 1e3;
    case "s":
      return l + n * 1e3;
  }
  return l;
}
function Tm(e) {
  return (rI(e) ? e : new Date(e)).toUTCString();
}
function Ms(e, t, n) {
  if (xm) {
    var o, l, a, r, i, s, u = [], d = arguments;
    return yye(e) ? u = e : d.length > 1 ? u = [fv({ name: e, value: t }, n)] : u_(e) && (u = [e]), u.length > 0 ? (km(u, function(f) {
      o = fv({}, aI.cookies, f), a = [], o.name && (l = o.expires, a.push(c_(o.name) + "=" + c_(u_(o.value) ? JSON.stringify(o.value) : o.value)), l && (isNaN(l) ? l = l.replace(/^([0-9]+)(y|M|d|H|h|m|s)$/, function(v, h, m) {
        return Tm(d_(m, h));
      }) : /^[0-9]{11,13}$/.test(l) || rI(l) ? l = Tm(l) : l = Tm(d_("d", l)), o.expires = l), km(["expires", "path", "domain", "secure"], function(v) {
        Cye(o[v]) || a.push(o[v] && v === "secure" ? v : v + "=" + o[v]);
      })), xm.cookie = a.join("; ");
    }), !0) : (r = {}, i = xm.cookie, i && km(i.split("; "), function(f) {
      s = f.indexOf("="), r[i_(f.substring(0, s))] = i_(f.substring(s + 1) || "");
    }), d.length === 1 ? r[e] : r);
  }
  return !1;
}
function Tye(e) {
  return wye(sI(), e);
}
function f_(e) {
  return Ms(e);
}
function p_(e, t, n) {
  return Ms(e, t, n), Ms;
}
function v_(e, t) {
  Ms(e, "", fv({ expires: -1 }, aI.cookies, t));
}
function sI() {
  return Eye(Ms());
}
function $ye() {
  return Ms();
}
fv(Ms, {
  has: Tye,
  set: p_,
  setItem: p_,
  get: f_,
  getItem: f_,
  remove: v_,
  removeItem: v_,
  keys: sI,
  getJSON: $ye
});
var Oye = Ms, Nye = ja, $m = V0, Om = pM, Mye = Ua, Iye = zl;
function h_(e) {
  try {
    var t = "__xe_t";
    return e.setItem(t, 1), e.removeItem(t), !0;
  } catch {
    return !1;
  }
}
function rp(e) {
  return navigator.userAgent.indexOf(e) > -1;
}
function Rye() {
  var e, t, n, o = !1, l = !1, a = !1, r = {
    isNode: !1,
    isMobile: o,
    isPC: !1,
    isDoc: !!$m
  };
  if (!Om && typeof process !== Nye)
    r.isNode = !0;
  else {
    n = rp("Edge"), t = rp("Chrome"), o = /(Android|webOS|iPhone|iPad|iPod|SymbianOS|BlackBerry|Windows Phone)/.test(navigator.userAgent), r.isDoc && (e = $m.body || $m.documentElement, Iye(["webkit", "khtml", "moz", "ms", "o"], function(i) {
      r["-" + i] = !!e[i + "MatchesSelector"];
    }));
    try {
      l = h_(Om.localStorage);
    } catch {
    }
    try {
      a = h_(Om.sessionStorage);
    } catch {
    }
    Mye(r, {
      edge: n,
      firefox: rp("Firefox"),
      msie: !n && r["-ms"],
      safari: !t && !n && rp("Safari"),
      isMobile: o,
      isPC: !o,
      isLocalStorage: l,
      isSessionStorage: a
    });
  }
  return r;
}
var Dye = Rye, iI = ise, m_ = Ua, Lye = bf, Pye = SN, Aye = Cse, Fye = _se, Vye = fu, Bye = xN, Hye = kN, zye = TN, Wye = zl, Kye = D0, Uye = $N, jye = jse, qye = L0, Yye = Sie, Gye = A0, Xye = IN, Zye = Iie, Jye = Ki, Qye = Vie, e0e = zie, t0e = yf, n0e = Uie, o0e = Gie, l0e = Jie, a0e = tce, r0e = lce, s0e = yce, i0e = AN, c0e = Sce, u0e = kce, d0e = DN, f0e = Mce, p0e = due, v0e = mue, h0e = Cue, m0e = qN, g0e = Tue, b0e = Nue, y0e = Lue, C0e = XN, w0e = ZN, E0e = Ka, S0e = ao, _0e = jr, x0e = zue, k0e = hr, T0e = na, $0e = eh, O0e = qr, N0e = du, M0e = lM, I0e = Vs, R0e = Fs, D0e = jo, L0e = vde, P0e = bde, A0e = kde, F0e = rM, V0e = Ur, B0e = pu, H0e = R0, z0e = sM, W0e = HN, K0e = WN, U0e = zN, j0e = Pde, q0e = Kde, Y0e = iM, G0e = cM, X0e = mr, Z0e = F0, J0e = uM, Q0e = Jde, e1e = dM, t1e = fM, n1e = afe, o1e = cfe, l1e = vfe, a1e = yfe, r1e = Sfe, s1e = Tfe, i1e = Mfe, c1e = Lfe, u1e = Vfe, d1e = rpe, f1e = bM, p1e = upe, v1e = bpe, h1e = wpe, m1e = B0, g1e = _pe, b1e = $pe, y1e = Mpe, C1e = Dpe, w1e = zpe, E1e = Upe, S1e = Ype, _1e = Zpe, x1e = tve, k1e = Cf, T1e = rve, $1e = CM, O1e = gve, N1e = yve, M1e = xve, I1e = MN, R1e = PN, D1e = $ve, L1e = che, P1e = z0, A1e = SM, F1e = _M, V1e = W0, B1e = phe, H1e = Wi, z1e = Bs, W1e = yhe, K1e = Ehe, U1e = K0, j1e = The, q1e = TM, Y1e = Phe, G1e = rh, X1e = sme, Z1e = Tf, J1e = NM, Q1e = oa, eCe = FM, tCe = VM, nCe = vge, oCe = $a, lCe = mge, aCe = RM, rCe = PM, sCe = LM, iCe = yge, cCe = xge, uCe = Ige, dCe = Lge, fCe = Bge, pCe = AM, vCe = Kge, hCe = zM, mCe = BM, gCe = HM, bCe = abe, yCe = cbe, CCe = hbe, wCe = bbe, ECe = wbe, SCe = _be, _Ce = YM, xCe = Ibe, g_ = Wl, kCe = Dbe, TCe = uu, $Ce = Pbe, OCe = Fbe, NCe = Hbe, MCe = Kbe, ICe = jbe, RCe = Ybe, DCe = Zbe, LCe = XM, PCe = aye, ACe = lI, FCe = hye, VCe = bye, BCe = Oye, HCe = Dye;
m_(iI, {
  // object
  assign: m_,
  objectEach: Lye,
  lastObjectEach: Pye,
  objectMap: Aye,
  merge: Fye,
  // array
  uniq: Uye,
  union: jye,
  sortBy: Yye,
  orderBy: Gye,
  shuffle: Xye,
  sample: Zye,
  some: Bye,
  every: Hye,
  slice: Jye,
  filter: Qye,
  find: n0e,
  findLast: o0e,
  findKey: e0e,
  includes: t0e,
  arrayIndexOf: C0e,
  arrayLastIndexOf: w0e,
  map: Vye,
  reduce: l0e,
  copyWithin: a0e,
  chunk: r0e,
  zip: s0e,
  unzip: i0e,
  zipObject: c0e,
  flatten: u0e,
  toArray: qye,
  includeArrays: zye,
  pluck: d0e,
  invoke: f0e,
  arrayEach: Wye,
  lastArrayEach: Kye,
  toArrayTree: p0e,
  toTreeArray: v0e,
  findTree: h0e,
  eachTree: m0e,
  mapTree: g0e,
  filterTree: b0e,
  searchTree: y0e,
  // base
  hasOwnProp: E0e,
  eqNull: R0e,
  isNaN: x0e,
  isFinite: j0e,
  isUndefined: k0e,
  isArray: S0e,
  isFloat: q0e,
  isInteger: Y0e,
  isFunction: T0e,
  isBoolean: G0e,
  isString: O0e,
  isNumber: X0e,
  isRegExp: Z0e,
  isObject: $0e,
  isPlainObject: N0e,
  isDate: I0e,
  isError: J0e,
  isTypeError: Q0e,
  isEmpty: e1e,
  isNull: _0e,
  isSymbol: t1e,
  isArguments: n1e,
  isElement: o1e,
  isDocument: l1e,
  isWindow: a1e,
  isFormData: r1e,
  isMap: s1e,
  isWeakMap: i1e,
  isSet: c1e,
  isWeakSet: u1e,
  isLeapYear: M0e,
  isMatch: d1e,
  isEqual: f1e,
  isEqualWith: p1e,
  getType: v1e,
  uniqueId: h1e,
  getSize: z0e,
  indexOf: A0e,
  lastIndexOf: F0e,
  findIndexOf: m1e,
  findLastIndexOf: g1e,
  toStringJSON: b1e,
  toJSONString: y1e,
  keys: V0e,
  values: B0e,
  entries: C1e,
  pick: w1e,
  omit: E1e,
  first: S1e,
  last: _1e,
  each: D0e,
  forOf: L0e,
  lastForOf: P0e,
  lastEach: W0e,
  has: x1e,
  get: k1e,
  set: T1e,
  groupBy: $1e,
  countBy: O1e,
  clone: H0e,
  clear: U0e,
  remove: K0e,
  range: N1e,
  destructuring: M1e,
  // number
  random: I1e,
  min: D1e,
  max: R1e,
  commafy: L1e,
  round: P1e,
  ceil: A1e,
  floor: F1e,
  toFixed: V1e,
  toNumber: H1e,
  toNumberString: z1e,
  toInteger: B1e,
  add: W1e,
  subtract: K1e,
  multiply: U1e,
  divide: j1e,
  sum: q1e,
  mean: Y1e,
  // date
  now: tCe,
  timestamp: nCe,
  isValidDate: oCe,
  isDateSame: lCe,
  toStringDate: Q1e,
  toDateString: eCe,
  getWhatYear: G1e,
  getWhatQuarter: X1e,
  getWhatMonth: Z1e,
  getWhatWeek: aCe,
  getWhatDay: J1e,
  getYearDay: rCe,
  getYearWeek: sCe,
  getMonthWeek: iCe,
  getDayOfYear: cCe,
  getDayOfMonth: uCe,
  getDateDiff: dCe,
  // string
  trim: hCe,
  trimLeft: gCe,
  trimRight: mCe,
  escape: bCe,
  unescape: yCe,
  camelCase: CCe,
  kebabCase: wCe,
  repeat: vCe,
  padStart: pCe,
  padEnd: fCe,
  startsWith: ECe,
  endsWith: SCe,
  template: _Ce,
  toFormatString: xCe,
  toString: g_,
  toValueString: g_,
  // function
  noop: kCe,
  property: TCe,
  bind: $Ce,
  once: OCe,
  after: NCe,
  before: MCe,
  throttle: ICe,
  debounce: RCe,
  delay: DCe,
  // url
  unserialize: LCe,
  serialize: PCe,
  parseUrl: ACe,
  // web
  getBaseURL: FCe,
  locat: VCe,
  browse: HCe,
  cookie: BCe
});
var zCe = iI;
const I = /* @__PURE__ */ pr(zCe), tn = "vxe-icon-", ee = {
  size: null,
  zIndex: 999,
  version: 0,
  // resizeInterval: 500,
  emptyCell: "　",
  // loadingText: null, // 自定义loading提示内容，如果为null则不显示文本
  table: {
    fit: !0,
    showHeader: !0,
    animat: !0,
    delayHover: 250,
    autoResize: !0,
    minHeight: 144,
    // keepSource: false,
    // showOverflow: null,
    // showHeaderOverflow: null,
    // showFooterOverflow: null,
    // resizeInterval: 500,
    // size: null,
    // zIndex: null,
    // stripe: false,
    // border: false,
    // round: false,
    // emptyText: '暂无数据',
    // emptyRender: {
    //   name: ''
    // },
    // rowConfig: {
    //   keyField: '_X_ROW_KEY' // 行数据的唯一主键字段名
    // },
    resizeConfig: {
      refreshDelay: 250
    },
    radioConfig: {
      // trigger: 'default'
      strict: !0
    },
    checkboxConfig: {
      // trigger: 'default',
      strict: !0
    },
    tooltipConfig: {
      enterable: !0
    },
    validConfig: {
      showMessage: !0,
      autoClear: !0,
      message: "inline",
      msgMode: "single"
    },
    columnConfig: {
      maxFixedSize: 4
    },
    // menuConfig: {
    //   visibleMethod () {}
    // },
    customConfig: {
      allowFixed: !0,
      showFooter: !0
      //  storage: false,
      //  checkMethod () {}
    },
    sortConfig: {
      // remote: false,
      // trigger: 'default',
      // orders: ['asc', 'desc', null],
      // sortMethod: null,
      showIcon: !0,
      iconLayout: "vertical"
    },
    filterConfig: {
      // remote: false,
      // filterMethod: null,
      showIcon: !0
    },
    treeConfig: {
      rowField: "id",
      parentField: "parentId",
      childrenField: "children",
      hasChildField: "hasChild",
      mapChildrenField: "_X_ROW_CHILD",
      indent: 20,
      showIcon: !0
    },
    expandConfig: {
      // trigger: 'default',
      showIcon: !0
    },
    editConfig: {
      // mode: 'cell',
      showIcon: !0,
      showAsterisk: !0
    },
    importConfig: {
      modes: ["insert", "covering"]
    },
    exportConfig: {
      modes: ["current", "selected"]
    },
    printConfig: {
      modes: ["current", "selected"]
    },
    mouseConfig: {
      extension: !0
    },
    keyboardConfig: {
      isEsc: !0
    },
    areaConfig: {
      autoClear: !0,
      selectCellByHeader: !0
    },
    clipConfig: {
      isCopy: !0,
      isCut: !0,
      isPaste: !0
    },
    fnrConfig: {
      isFind: !0,
      isReplace: !0
    },
    scrollX: {
      // enabled: false,
      gt: 60
      // oSize: 0
    },
    scrollY: {
      // enabled: false,
      gt: 100
      // oSize: 0
    }
  },
  export: {
    types: {}
  },
  icon: {
    // loading
    LOADING: tn + "spinner roll vxe-loading--default-icon",
    // table
    TABLE_SORT_ASC: tn + "caret-up",
    TABLE_SORT_DESC: tn + "caret-down",
    TABLE_FILTER_NONE: tn + "funnel",
    TABLE_FILTER_MATCH: tn + "funnel",
    TABLE_EDIT: tn + "edit",
    TABLE_TITLE_PREFIX: tn + "question-circle-fill",
    TABLE_TITLE_SUFFIX: tn + "question-circle-fill",
    TABLE_TREE_LOADED: tn + "spinner roll",
    TABLE_TREE_OPEN: tn + "caret-right rotate90",
    TABLE_TREE_CLOSE: tn + "caret-right",
    TABLE_EXPAND_LOADED: tn + "spinner roll",
    TABLE_EXPAND_OPEN: tn + "arrow-right rotate90",
    TABLE_EXPAND_CLOSE: tn + "arrow-right",
    TABLE_CHECKBOX_CHECKED: tn + "checkbox-checked",
    TABLE_CHECKBOX_UNCHECKED: tn + "checkbox-unchecked",
    TABLE_CHECKBOX_INDETERMINATE: tn + "checkbox-indeterminate",
    TABLE_RADIO_CHECKED: tn + "radio-checked",
    TABLE_RADIO_UNCHECKED: tn + "radio-unchecked",
    // button
    BUTTON_DROPDOWN: tn + "arrow-down",
    BUTTON_LOADING: tn + "spinner roll",
    // select
    SELECT_LOADED: tn + "spinner roll",
    SELECT_OPEN: tn + "caret-down rotate180",
    SELECT_CLOSE: tn + "caret-down",
    // pager
    PAGER_HOME: tn + "home-page",
    PAGER_END: tn + "end-page",
    PAGER_JUMP_PREV: tn + "arrow-double-left",
    PAGER_JUMP_NEXT: tn + "arrow-double-right",
    PAGER_PREV_PAGE: tn + "arrow-left",
    PAGER_NEXT_PAGE: tn + "arrow-right",
    PAGER_JUMP_MORE: tn + "ellipsis-h",
    // input
    INPUT_CLEAR: tn + "error-circle-fill",
    INPUT_PWD: tn + "eye-fill",
    INPUT_SHOW_PWD: tn + "eye-fill-close",
    INPUT_PREV_NUM: tn + "caret-up",
    INPUT_NEXT_NUM: tn + "caret-down",
    INPUT_DATE: tn + "calendar",
    INPUT_SEARCH: tn + "search",
    // modal
    MODAL_ZOOM_IN: tn + "square",
    MODAL_ZOOM_OUT: tn + "maximize",
    MODAL_CLOSE: tn + "close",
    MODAL_INFO: tn + "info-circle-fill",
    MODAL_SUCCESS: tn + "success-circle-fill",
    MODAL_WARNING: tn + "warnion-circle-fill",
    MODAL_ERROR: tn + "error-circle-fill",
    MODAL_QUESTION: tn + "question-circle-fill",
    MODAL_LOADING: tn + "spinner roll",
    // toolbar
    TOOLBAR_TOOLS_REFRESH: tn + "repeat",
    TOOLBAR_TOOLS_REFRESH_LOADING: tn + "repeat roll",
    TOOLBAR_TOOLS_IMPORT: tn + "upload",
    TOOLBAR_TOOLS_EXPORT: tn + "download",
    TOOLBAR_TOOLS_PRINT: tn + "print",
    TOOLBAR_TOOLS_FULLSCREEN: tn + "fullscreen",
    TOOLBAR_TOOLS_MINIMIZE: tn + "minimize",
    TOOLBAR_TOOLS_CUSTOM: tn + "custom-column",
    TOOLBAR_TOOLS_FIXED_LEFT: tn + "fixed-left",
    TOOLBAR_TOOLS_FIXED_LEFT_ACTIVED: tn + "fixed-left-fill",
    TOOLBAR_TOOLS_FIXED_RIGHT: tn + "fixed-right",
    TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVED: tn + "fixed-right-fill",
    // form
    FORM_PREFIX: tn + "question-circle-fill",
    FORM_SUFFIX: tn + "question-circle-fill",
    FORM_FOLDING: tn + "arrow-up rotate180",
    FORM_UNFOLDING: tn + "arrow-up"
  },
  grid: {
    // size: null,
    // zoomConfig: {
    //   escRestore: true
    // },
    formConfig: {
      enabled: !0
    },
    pagerConfig: {
      enabled: !0
      // perfect: false
    },
    toolbarConfig: {
      enabled: !0
      // perfect: false
    },
    proxyConfig: {
      enabled: !0,
      autoLoad: !0,
      message: !0,
      props: {
        list: null,
        result: "result",
        total: "page.total",
        message: "message"
      }
      // beforeItem: null,
      // beforeColumn: null,
      // beforeQuery: null,
      // afterQuery: null,
      // beforeDelete: null,
      // afterDelete: null,
      // beforeSave: null,
      // afterSave: null
    }
  },
  tooltip: {
    // size: null,
    trigger: "hover",
    theme: "dark",
    enterDelay: 500,
    leaveDelay: 300
  },
  pager: {
    // size: null,
    // autoHidden: false,
    // perfect: true,
    // pageSize: 10,
    // pagerCount: 7,
    // pageSizes: [10, 15, 20, 50, 100],
    // layouts: ['PrevJump', 'PrevPage', 'Jump', 'PageCount', 'NextPage', 'NextJump', 'Sizes', 'Total']
  },
  form: {
    // preventSubmit: false,
    // size: null,
    // colon: false,
    validConfig: {
      showMessage: !0,
      autoPos: !0
    },
    tooltipConfig: {
      enterable: !0
    },
    titleAsterisk: !0
  },
  input: {
    // size: null,
    // transfer: false
    // parseFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
    // labelFormat: '',
    // valueFormat: '',
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1,
    digits: 2,
    controls: !0
  },
  textarea: {
    // size: null,
    // autosize: {
    //   minRows: 1,
    //   maxRows: 10
    // }
  },
  select: {
    // size: null,
    // transfer: false,
    // optionConfig: {
    //   keyField: '_X_OPTION_KEY'
    // },
    multiCharOverflow: 8
  },
  toolbar: {
    // size: null,
    // import: {
    //   mode: 'covering'
    // },
    // export: {
    //   types: ['csv', 'html', 'xml', 'txt']
    // },
    // buttons: []
  },
  button: {
    // size: null,
    // transfer: false
  },
  buttonGroup: {
    // size: null
  },
  radio: {
    // size: null,
    strict: !0
  },
  radioButton: {
    // size: null,
    strict: !0
  },
  radioGroup: {
    // size: null,
    strict: !0
  },
  checkbox: {
    // size: null
  },
  checkboxGroup: {
    // size: null
  },
  switch: {
    // size: null
  },
  modal: {
    // size: null,
    top: 15,
    showHeader: !0,
    minWidth: 340,
    minHeight: 140,
    lockView: !0,
    mask: !0,
    duration: 3e3,
    marginSize: 0,
    dblclickZoom: !0,
    showTitleOverflow: !0,
    animat: !0,
    showClose: !0,
    draggable: !0,
    // storage: false,
    storageKey: "VXE_MODAL_POSITION"
  },
  list: {
    // size: null,
    scrollY: {
      enabled: !0,
      gt: 100
      // oSize: 0
    }
  },
  i18n: (e) => e
};
function U0(e, t) {
  return `[vxe-table v4.6.12] ${ee.i18n(e, t)}`;
}
function cI(e) {
  return function(t, n) {
    const o = U0(t, n);
    return console[e](o), o;
  };
}
const qt = cI("warn"), Ht = cI("error"), Du = {}, nd = {
  mixin(e) {
    return I.each(e, (t, n) => nd.add(n, t)), nd;
  },
  get(e) {
    return Du[e] || [];
  },
  add(e, t) {
    if (process.env.NODE_ENV === "development") {
      const n = ["created", "mounted", "activated", "beforeUnmount", "unmounted", "event.clearEdit", "event.clearActived", "event.clearFilter", "event.clearAreas", "event.showMenu", "event.keydown", "event.export", "event.import"];
      n.indexOf(e) === -1 && qt("vxe.error.errProp", [`Interceptor.${e}`, n.join("|")]);
    }
    if (t) {
      let n = Du[e];
      n || (n = Du[e] = []), process.env.NODE_ENV === "development" && n.indexOf(t) > -1 && qt("vxe.error.coverProp", ["Interceptor", e]), n.push(t);
    }
    return nd;
  },
  delete(e, t) {
    const n = Du[e];
    n && (t ? I.remove(n, (o) => o === t) : delete Du[e]);
  }
};
class WCe {
  constructor() {
    Jr(this, "store", {});
  }
  mixin(t) {
    return I.each(t, (n, o) => {
      this.add(o, n);
    }), this;
  }
  has(t) {
    return !!this.get(t);
  }
  get(t) {
    return this.store[t];
  }
  add(t, n) {
    const o = this.store[t];
    if (I.isFunction(n) && (process.env.NODE_ENV === "development" && qt("vxe.error.delProp", ["formats -> callback", "cellFormatMethod"]), n = {
      cellFormatMethod: n
    }), process.env.NODE_ENV === "development") {
      const l = I.keys(o);
      I.each(n, (a, r) => {
        l.includes(r) && qt("vxe.error.coverProp", [t, r]);
      });
    }
    return this.store[t] = o ? I.merge(o, n) : n, this;
  }
  delete(t) {
    delete this.store[t];
  }
  forEach(t) {
    I.objectEach(this.store, t);
  }
}
const jd = new WCe();
process.env.NODE_ENV === "development" && Object.assign(jd, { _name: "Formats" });
var os = null, b_ = "z-index-manage", uI = "m", dI = "s", qd = {
  m: 1e3,
  s: 1e3
};
function fI() {
  return typeof document < "u";
}
function KCe() {
  var e = 0;
  if (fI())
    for (var t = document.body.getElementsByTagName("*"), n = 0; n < t.length; n++) {
      var o = t[n];
      if (o && o.style && o.nodeType === 1) {
        var l = o.style.zIndex;
        l && /^\d+$/.test(l) && (e = Math.max(e, Number(l)));
      }
    }
  return e;
}
function pI() {
  return os || fI() && (os = document.getElementById(b_), os || (os = document.createElement("div"), os.id = b_, os.style.display = "none", document.body.appendChild(os), j0(qd.m), Y0(qd.s))), os;
}
function vI(e) {
  return function(t) {
    if (t) {
      t = Number(t), qd[e] = t;
      var n = pI();
      n && (n.dataset ? n.dataset[e] = t + "" : n.setAttribute("data-" + e, t + ""));
    }
    return qd[e];
  };
}
var j0 = vI(uI);
function hI(e, t) {
  return function(o) {
    var l, a = pI();
    if (a) {
      var r = a.dataset ? a.dataset[e] : a.getAttribute("data-" + e);
      r && (l = Number(r));
    }
    return l || (l = qd[e]), o ? Number(o) < l ? t() : o : l;
  };
}
var q0 = hI(uI, mI);
function mI() {
  return j0(q0() + 1);
}
var Y0 = vI(dI), gI = hI(dI, yI);
function bI() {
  return q0() + gI();
}
function yI() {
  return Y0(gI() + 1), bI();
}
var G0 = {
  setCurrent: j0,
  getCurrent: q0,
  getNext: mI,
  setSubCurrent: Y0,
  getSubCurrent: bI,
  getSubNext: yI,
  getMax: KCe
};
function mn(e) {
  return e && e.enabled !== !1;
}
function X0(e) {
  return e == null || e === "";
}
function Z0(e) {
  const t = e.name, n = I.lastIndexOf(t, "."), o = t.substring(n + 1, t.length).toLowerCase();
  return { filename: t.substring(0, n), type: o };
}
function dr() {
  return G0.getNext();
}
function Yr() {
  return G0.getCurrent();
}
function wc(e) {
  return e && e.children && e.children.length > 0;
}
function vo(e) {
  return e ? I.toValueString(ee.translate ? ee.translate("" + e) : e) : "";
}
function ko(e, t) {
  return "" + (X0(e) ? t ? ee.emptyCell : "" : e);
}
function La(e) {
  return e === "" || I.eqNull(e);
}
class gb {
  /* eslint-disable @typescript-eslint/no-use-before-define */
  constructor(t, n, { renderHeader: o, renderCell: l, renderFooter: a, renderData: r } = {}) {
    const i = t.xegrid, s = n.formatter, u = I.isBoolean(n.visible) ? n.visible : !0;
    if (process.env.NODE_ENV === "development") {
      const d = ["seq", "checkbox", "radio", "expand", "html"];
      if (n.type && d.indexOf(n.type) === -1 && qt("vxe.error.errProp", [`type=${n.type}`, d.join(", ")]), (I.isBoolean(n.cellRender) || n.cellRender && !I.isObject(n.cellRender)) && qt("vxe.error.errProp", [`column.cell-render=${n.cellRender}`, "column.cell-render={}"]), (I.isBoolean(n.editRender) || n.editRender && !I.isObject(n.editRender)) && qt("vxe.error.errProp", [`column.edit-render=${n.editRender}`, "column.edit-render={}"]), n.cellRender && n.editRender && qt("vxe.error.errConflicts", ["column.cell-render", "column.edit-render"]), n.type === "expand") {
        const { props: f } = t, { treeConfig: v } = f, { computeTreeOpts: h } = t.getComputeMaps(), m = h.value;
        v && (m.showLine || m.line) && Ht("vxe.error.errConflicts", ["tree-config.showLine", "column.type=expand"]);
      }
      if (s) {
        if (I.isString(s)) {
          const f = jd.get(s) || I[s];
          (!f || !I.isFunction(f.cellFormatMethod)) && Ht("vxe.error.notFormats", [s]);
        } else if (I.isArray(s)) {
          const f = jd.get(s[0]) || I[s[0]];
          (!f || !I.isFunction(f.cellFormatMethod)) && Ht("vxe.error.notFormats", [s[0]]);
        }
      }
    }
    if (Object.assign(this, {
      // 基本属性
      type: n.type,
      property: n.field,
      field: n.field,
      title: n.title,
      width: n.width,
      minWidth: n.minWidth,
      maxWidth: n.maxWidth,
      resizable: n.resizable,
      fixed: n.fixed,
      align: n.align,
      headerAlign: n.headerAlign,
      footerAlign: n.footerAlign,
      showOverflow: n.showOverflow,
      showHeaderOverflow: n.showHeaderOverflow,
      showFooterOverflow: n.showFooterOverflow,
      className: n.className,
      headerClassName: n.headerClassName,
      footerClassName: n.footerClassName,
      formatter: s,
      sortable: n.sortable,
      sortBy: n.sortBy,
      sortType: n.sortType,
      filters: _I(n.filters),
      filterMultiple: I.isBoolean(n.filterMultiple) ? n.filterMultiple : !0,
      filterMethod: n.filterMethod,
      filterResetMethod: n.filterResetMethod,
      filterRecoverMethod: n.filterRecoverMethod,
      filterRender: n.filterRender,
      treeNode: n.treeNode,
      cellType: n.cellType,
      cellRender: n.cellRender,
      editRender: n.editRender,
      contentRender: n.contentRender,
      headerExportMethod: n.headerExportMethod,
      exportMethod: n.exportMethod,
      footerExportMethod: n.footerExportMethod,
      titleHelp: n.titleHelp,
      titlePrefix: n.titlePrefix,
      titleSuffix: n.titleSuffix,
      // 自定义参数
      params: n.params,
      // 渲染属性
      id: n.colId || I.uniqueId("col_"),
      parentId: null,
      visible: u,
      // 内部属性（一旦被使用，将导致不可升级版本）
      halfVisible: !1,
      defaultVisible: u,
      defaultFixed: n.fixed,
      checked: !1,
      halfChecked: !1,
      disabled: !1,
      // 分组层级
      level: 1,
      // 跨行
      rowSpan: 1,
      // 跨列
      colSpan: 1,
      // 数据排序
      order: null,
      sortTime: 0,
      // 列排序
      sortNumber: 0,
      renderSortNumber: 0,
      renderWidth: 0,
      renderHeight: 0,
      resizeWidth: 0,
      renderLeft: 0,
      renderArgs: [],
      model: {},
      renderHeader: o || n.renderHeader,
      renderCell: l || n.renderCell,
      renderFooter: a || n.renderFooter,
      renderData: r,
      // 单元格插槽，只对 grid 有效
      slots: n.slots
    }), i) {
      const { computeProxyOpts: d } = i.getComputeMaps(), f = d.value;
      f.beforeColumn && f.beforeColumn({ $grid: i, column: this });
    }
  }
  getTitle() {
    return vo(this.title || (this.type === "seq" ? ee.i18n("vxe.table.seqTitle") : ""));
  }
  getKey() {
    return this.field || (this.type ? `type=${this.type}` : null);
  }
  update(t, n) {
    t !== "filters" && (t === "field" && (this.property = n), this[t] = n);
  }
}
const Nm = {}, Jl = I.browse();
function vs(e, t) {
  return e ? I.isFunction(e) ? e(t) : e : "";
}
function CI(e) {
  return Nm[e] || (Nm[e] = new RegExp(`(?:^|\\s)${e}(?!\\S)`, "g")), Nm[e];
}
function wI(e, t, n) {
  if (e) {
    const o = e.parentNode;
    if (n.top += e.offsetTop, n.left += e.offsetLeft, o && o !== document.documentElement && o !== document.body && (n.top -= o.scrollTop, n.left -= o.scrollLeft), !(t && (e === t || e.offsetParent === t)) && e.offsetParent)
      return wI(e.offsetParent, t, n);
  }
  return n;
}
function bb(e) {
  return e && /^\d+(px)?$/.test(e);
}
function Uu(e) {
  return e && /^\d+%$/.test(e);
}
function Ar(e, t) {
  return e && e.className && e.className.match && e.className.match(CI(t));
}
function Xl(e, t) {
  e && Ar(e, t) && (e.className = e.className.replace(CI(t), ""));
}
function Mr(e, t) {
  e && !Ar(e, t) && (Xl(e, t), e.className = `${e.className} ${t}`);
}
function Cs() {
  const e = document.documentElement, t = document.body;
  return {
    scrollTop: e.scrollTop || t.scrollTop,
    scrollLeft: e.scrollLeft || t.scrollLeft,
    visibleHeight: e.clientHeight || t.clientHeight,
    visibleWidth: e.clientWidth || t.clientWidth
  };
}
function Lu(e) {
  return e ? e.offsetHeight : 0;
}
function yb(e) {
  if (e) {
    const t = getComputedStyle(e), n = I.toNumber(t.paddingTop), o = I.toNumber(t.paddingBottom);
    return n + o;
  }
  return 0;
}
function sp(e, t) {
  e && (e.scrollTop = t);
}
function y_(e, t) {
  e && (e.scrollLeft = t);
}
function J0(e, t) {
  const n = t.type === "html" ? e.innerText : e.textContent;
  e.getAttribute("title") !== n && e.setAttribute("title", n);
}
function _n(e, t, n, o) {
  let l, a = e.target.shadowRoot && e.composed && e.composedPath()[0] || e.target;
  for (; a && a.nodeType && a !== document; ) {
    if (n && Ar(a, n) && (!o || o(a)))
      l = a;
    else if (a === t)
      return { flag: n ? !!l : !0, container: t, targetElem: l };
    a = a.parentNode;
  }
  return { flag: !1 };
}
function UCe(e, t) {
  return wI(e, t, { left: 0, top: 0 });
}
function lr(e) {
  const t = e.getBoundingClientRect(), n = t.top, o = t.left, { scrollTop: l, scrollLeft: a, visibleHeight: r, visibleWidth: i } = Cs();
  return { boundingTop: n, top: l + n, boundingLeft: o, left: a + o, visibleHeight: r, visibleWidth: i };
}
const C_ = "scrollIntoViewIfNeeded", w_ = "scrollIntoView";
function EI(e) {
  e && (e[C_] ? e[C_]() : e[w_] && e[w_]());
}
function jCe(e, t) {
  e && e.dispatchEvent(new Event(t));
}
function Mm(e) {
  return e && e.nodeType === 1;
}
const SI = (e, t) => {
  const n = [];
  return e.forEach((o) => {
    o.parentId = t ? t.id : null, o.visible && (o.children && o.children.length && o.children.some((l) => l.visible) ? (n.push(o), n.push(...SI(o.children, o))) : n.push(o));
  }), n;
}, qCe = (e) => {
  let t = 1;
  const n = (a, r) => {
    if (r && (a.level = r.level + 1, t < a.level && (t = a.level)), a.children && a.children.length && a.children.some((i) => i.visible)) {
      let i = 0;
      a.children.forEach((s) => {
        s.visible && (n(s, a), i += s.colSpan);
      }), a.colSpan = i;
    } else
      a.colSpan = 1;
  };
  e.forEach((a) => {
    a.level = 1, n(a);
  });
  const o = [];
  for (let a = 0; a < t; a++)
    o.push([]);
  return SI(e).forEach((a) => {
    a.children && a.children.length && a.children.some((r) => r.visible) ? a.rowSpan = 1 : a.rowSpan = t - a.level + 1, o[a.level - 1].push(a);
  }), o;
};
function Im(e, t, n) {
  const { internalData: o } = e;
  return e.clearScroll().then(() => {
    if (t || n)
      return o.lastScrollLeft = 0, o.lastScrollTop = 0, e.scrollTo(t, n);
  });
}
function E_(e) {
  e && e._onscroll && (e.onscroll = null);
}
function pv(e) {
  e && e._onscroll && (e.onscroll = e._onscroll);
}
function Rm() {
  return I.uniqueId("row_");
}
function ti(e) {
  const { props: t } = e, { computeRowOpts: n } = e.getComputeMaps(), { rowId: o } = t, l = n.value;
  return o || l.keyField || "_X_ROW_KEY";
}
function yt(e, t) {
  const n = I.get(t, ti(e));
  return I.eqNull(n) ? "" : encodeURIComponent(n);
}
const El = (e, t) => t ? I.isString(t) ? e.getColumnByField(t) : t : null;
function Dm(e) {
  if (e) {
    const t = getComputedStyle(e), n = I.toNumber(t.paddingLeft), o = I.toNumber(t.paddingRight);
    return n + o;
  }
  return 0;
}
function nc(e) {
  if (e) {
    const t = getComputedStyle(e), n = I.toNumber(t.marginLeft), o = I.toNumber(t.marginRight);
    return e.offsetWidth + n + o;
  }
  return 0;
}
function ls(e, t) {
  return e.querySelector(".vxe-cell" + t);
}
function _I(e) {
  return e && I.isArray(e) ? e.map(({ label: t, value: n, data: o, resetValue: l, checked: a }) => ({ label: t, value: n, data: o, resetValue: l, checked: !!a, _checked: !!a })) : e;
}
function YCe(e) {
  return e.map((t, n) => n % 2 === 0 ? Number(t) + 1 : ".").join("");
}
function xa(e, t) {
  return I.get(e, t.field);
}
function Or(e, t, n) {
  return I.set(e, t.field, n);
}
function GCe(e) {
  const { $table: t, column: n, cell: o } = e, { props: l } = t, { computeResizableOpts: a } = t.getComputeMaps(), r = a.value, { minWidth: i } = r;
  if (i) {
    const b = I.isFunction(i) ? i(e) : i;
    if (b !== "auto")
      return Math.max(1, I.toNumber(b));
  }
  const { showHeaderOverflow: s } = l, { showHeaderOverflow: u, minWidth: d } = n, f = I.isUndefined(u) || I.isNull(u) ? s : u, p = f === "title" || (f === !0 || f === "tooltip") || f === "ellipsis", C = I.floor((I.toNumber(getComputedStyle(o).fontSize) || 14) * 1.6), g = Dm(o) + Dm(ls(o, ""));
  let w = C + g;
  if (p) {
    const b = Dm(ls(o, "--title>.vxe-cell--checkbox")), y = nc(ls(o, ">.vxe-cell--required-icon")), E = nc(ls(o, ">.vxe-cell--edit-icon")), S = nc(ls(o, ">.vxe-cell-title-prefix-icon")), _ = nc(ls(o, ">.vxe-cell-title-suffix-icon")), k = nc(ls(o, ">.vxe-cell--sort")), N = nc(ls(o, ">.vxe-cell--filter"));
    w += b + y + E + S + _ + N + k;
  }
  if (d) {
    const { refTableBody: b } = t.getRefMaps(), y = b.value, E = y ? y.$el : null;
    if (E) {
      if (Uu(d)) {
        const _ = (E.clientWidth - 1) / 100;
        return Math.max(w, Math.floor(I.toInteger(d) * _));
      } else if (bb(d))
        return Math.max(w, I.toInteger(d));
    }
  }
  return w;
}
function Vp(e) {
  return e && (e.constructor === gb || e instanceof gb);
}
function XCe(e, t, n) {
  return Vp(t) ? t : en(new gb(e, t, n));
}
function xI(e, t, n) {
  Object.keys(t).forEach((o) => {
    Pe(() => t[o], (l) => {
      n.update(o, l), e && (o === "filters" ? (e.setFilter(n, l), e.handleUpdateDataQueue()) : ["visible", "fixed", "width", "minWidth", "maxWidth"].includes(o) && e.handleRefreshColumnQueue());
    });
  });
}
function kI(e, t, n, o) {
  const { reactData: l } = e, { staticColumns: a } = l, r = t.parentNode, i = o ? o.column : null, s = i ? i.children : a;
  r && s && (s.splice(I.arrayIndexOf(r.children, t), 0, n), l.staticColumns = a.slice(0));
}
function TI(e, t) {
  const { reactData: n } = e, { staticColumns: o } = n, l = I.findTree(o, (a) => a.id === t.id, { children: "children" });
  l && l.items.splice(l.index, 1), n.staticColumns = o.slice(0);
}
function S_(e, t) {
  const { internalData: n } = e, { fullColumnIdData: o } = n;
  if (!t)
    return null;
  let l = t.parentId;
  for (; o[l]; ) {
    const a = o[l].column;
    if (l = a.parentId, !l)
      return a;
  }
  return t;
}
function $I(e, t, n) {
  for (let o = 0; o < e.length; o++) {
    const { row: l, col: a, rowspan: r, colspan: i } = e[o];
    if (a > -1 && l > -1 && r && i) {
      if (l === t && a === n)
        return { rowspan: r, colspan: i };
      if (t >= l && t < l + r && n >= a && n < a + i)
        return { rowspan: 0, colspan: 0 };
    }
  }
}
function ZCe(e) {
  const { props: t, internalData: n } = e;
  return n.initStatus = !1, e.clearSort(), e.clearCurrentRow(), e.clearCurrentColumn(), e.clearRadioRow(), e.clearRadioReserve(), e.clearCheckboxRow(), e.clearCheckboxReserve(), e.clearRowExpand(), e.clearTreeExpand(), e.clearTreeExpandReserve(), e.clearPendingRow(), e.clearFilter && e.clearFilter(), e.clearSelected && (t.keyboardConfig || t.mouseConfig) && e.clearSelected(), e.clearCellAreas && t.mouseConfig && (e.clearCellAreas(), e.clearCopyCellArea()), e.clearScroll();
}
function JCe(e) {
  return e.clearFilter && e.clearFilter(), ZCe(e);
}
function __(e, t) {
  const { reactData: n, internalData: o } = e, { refTableBody: l } = e.getRefMaps(), { scrollYLoad: a } = n, { afterFullData: r, scrollYStore: i } = o, s = l.value, u = s ? s.$el : null;
  if (u) {
    const d = u.querySelector(`[rowid="${yt(e, t)}"]`);
    if (d) {
      const f = u.clientHeight, v = u.scrollTop, h = d.offsetParent, m = d.offsetTop + (h ? h.offsetTop : 0), p = d.clientHeight;
      if (m < v || m > v + f)
        return e.scrollTo(null, m);
      if (m + p >= f + v)
        return e.scrollTo(null, v + p);
    } else if (a)
      return e.scrollTo(null, (r.indexOf(t) - 1) * i.rowHeight);
  }
  return Promise.resolve();
}
function QCe(e, t) {
  const { reactData: n, internalData: o } = e, { refTableBody: l } = e.getRefMaps(), { scrollXLoad: a } = n, { visibleColumn: r } = o, i = l.value, s = i ? i.$el : null;
  if (s) {
    const u = s.querySelector(`.${t.id}`);
    if (u) {
      const d = s.clientWidth, f = s.scrollLeft, v = u.offsetParent, h = u.offsetLeft + (v ? v.offsetLeft : 0), m = u.clientWidth;
      if (h < f || h > f + d)
        return e.scrollTo(h);
      if (h + m >= d + f)
        return e.scrollTo(f + m);
    } else if (a) {
      let d = 0;
      for (let f = 0; f < r.length && r[f] !== t; f++)
        d += r[f].renderWidth;
      return e.scrollTo(d);
    }
  }
  return Promise.resolve();
}
function Nc(e) {
  return "on" + e.substring(0, 1).toLocaleUpperCase() + e.substring(1);
}
function oo(e) {
  return I.isArray(e) ? e : [e];
}
const Q0 = "modelValue", e1 = { transfer: !0 };
function OI(e) {
  switch (e.name) {
    case "input":
    case "textarea":
      return "input";
  }
  return "update:modelValue";
}
function NI(e) {
  switch (e.name) {
    case "input":
    case "textarea":
    case "VxeInput":
    case "VxeTextarea":
    case "$input":
    case "$textarea":
      return "input";
  }
  return "change";
}
function ewe(e, t) {
  return e && t.valueFormat ? I.toStringDate(e, t.valueFormat) : e;
}
function twe(e, t, n) {
  const { dateConfig: o = {} } = t;
  return I.toDateString(ewe(e, t), o.labelFormat || n);
}
function x_(e, t) {
  return twe(e, t, ee.i18n(`vxe.input.date.labelFormat.${t.type}`));
}
function MI(e) {
  return `vxe-${e.replace("$", "")}`;
}
function ar({ name: e }) {
  return Dt(e);
}
function Xc({ name: e }) {
  return Dt(MI(e));
}
function II(e, t, n) {
  const { $panel: o } = e;
  o.changeOption({}, t, n);
}
function Zc(e) {
  let { name: t, attrs: n } = e;
  return t === "input" && (n = Object.assign({ type: "text" }, n)), n;
}
function RI(e) {
  const { name: t, immediate: n, props: o } = e;
  if (!n) {
    if (t === "VxeInput" || t === "$input") {
      const { type: l } = o || {};
      return !(!l || l === "text" || l === "number" || l === "integer" || l === "float");
    }
    return !(t === "input" || t === "textarea" || t === "$textarea");
  }
  return n;
}
function vu(e, t, n, o) {
  return I.assign({ immediate: RI(e) }, e1, o, e.props, { [Q0]: n });
}
function vv(e, t, n, o) {
  return I.assign({}, e1, o, e.props, { [Q0]: n });
}
function rr(e, t, n, o) {
  return I.assign({}, e1, o, e.props, { [Q0]: n });
}
function ih(e, t) {
  return t.$type === "cell" || RI(e);
}
function Pu(e, t, n) {
  const { placeholder: o } = e;
  return [
    V("span", {
      class: "vxe-cell--label"
    }, o && X0(n) ? [
      V("span", {
        class: "vxe-cell--placeholder"
      }, ko(vo(o), 1))
    ] : ko(n, 1))
  ];
}
function t1(e, t, n, o) {
  const { events: l } = e, a = OI(e), r = NI(e), i = r === a, s = {};
  return l && I.objectEach(l, (u, d) => {
    s[Nc(d)] = function(...f) {
      u(t, ...f);
    };
  }), n && (s[Nc(a)] = function(u) {
    n(u), i && o && o(u), l && l[a] && l[a](t, u);
  }), !i && o && (s[Nc(r)] = function(...u) {
    o(...u), l && l[r] && l[r](t, ...u);
  }), s;
}
function hu(e, t, n, o) {
  const { events: l } = e, a = OI(e), r = NI(e), i = {};
  return I.objectEach(l, (s, u) => {
    i[Nc(u)] = function(...d) {
      process.env.NODE_ENV === "development" && (I.isFunction(s) || Ht("vxe.error.errFunc", [s])), s(t, ...d);
    };
  }), n && (i[Nc(a)] = function(s) {
    n(s), l && l[a] && l[a](t, s);
  }), o && (i[Nc(r)] = function(...s) {
    o(...s), l && l[r] && l[r](t, ...s);
  }), i;
}
function ch(e, t) {
  const { $table: n, row: o, column: l } = t, { name: a } = e, { model: r } = l, i = ih(e, t);
  return hu(e, t, (s) => {
    i ? Or(o, l, s) : (r.update = !0, r.value = s);
  }, (s) => {
    if (!i && ["VxeInput", "VxeTextarea", "$input", "$textarea"].includes(a)) {
      const u = s.value;
      r.update = !0, r.value = u, n.updateStatus(t, u);
    } else
      n.updateStatus(t);
  });
}
function hv(e, t, n) {
  return hu(e, t, (o) => {
    n.data = o;
  }, () => {
    II(t, !I.eqNull(n.data), n);
  });
}
function Ir(e, t) {
  const { $form: n, data: o, property: l } = t;
  return hu(e, t, (a) => {
    I.set(o, l, a);
  }, () => {
    n.updateStatus(t);
  });
}
function DI(e, t) {
  const { $table: n, row: o, column: l } = t, { model: a } = l;
  return t1(e, t, (r) => {
    const i = r.target.value;
    ih(e, t) ? Or(o, l, i) : (a.update = !0, a.value = i);
  }, (r) => {
    const i = r.target.value;
    n.updateStatus(t, i);
  });
}
function LI(e, t, n) {
  return t1(e, t, (o) => {
    n.data = o.target.value;
  }, () => {
    II(t, !I.eqNull(n.data), n);
  });
}
function PI(e, t) {
  const { $form: n, data: o, property: l } = t;
  return t1(e, t, (a) => {
    const r = a.target.value;
    I.set(o, l, r);
  }, () => {
    n.updateStatus(t);
  });
}
function Lm(e, t) {
  const { row: n, column: o } = t, { name: l } = e, a = ih(e, t) ? xa(n, o) : o.model.value;
  return [
    V(l, {
      class: `vxe-default-${l}`,
      ...Zc(e),
      value: a,
      ...DI(e, t)
    })
  ];
}
function k_(e, t) {
  return [
    V(ar(e), {
      ...vu(e, t, null),
      ...hu(e, t)
    })
  ];
}
function ip(e, t) {
  const { row: n, column: o } = t, l = xa(n, o);
  return [
    V(ar(e), {
      ...vu(e, t, l),
      ...ch(e, t)
    })
  ];
}
function cp(e, t) {
  const { row: n, column: o } = t, l = xa(n, o);
  return [
    V(Xc(e), {
      ...vu(e, t, l),
      ...ch(e, t)
    })
  ];
}
function AI(e, t) {
  return [
    V(Dt("vxe-button"), {
      ...vu(e, t, null),
      ...hu(e, t)
    })
  ];
}
function nwe(e, t) {
  return e.children.map((n) => AI(n, t)[0]);
}
function Cb(e, t, n) {
  const { optionGroups: o, optionGroupProps: l = {} } = e, a = l.options || "options", r = l.label || "label";
  return o.map((i, s) => V("optgroup", {
    key: s,
    label: i[r]
  }, n(i[a], e, t)));
}
function mv(e, t, n) {
  const { optionProps: o = {} } = t, { row: l, column: a } = n, r = o.label || "label", i = o.value || "value", s = o.disabled || "disabled", u = ih(t, n) ? xa(l, a) : a.model.value;
  return e.map((d, f) => V("option", {
    key: f,
    value: d[i],
    disabled: d[s],
    /* eslint-disable eqeqeq */
    selected: d[i] == u
  }, d[r]));
}
function owe(e, t) {
  const { column: n } = t, { name: o } = e, l = Zc(e);
  return n.filters.map((a, r) => V(o, {
    key: r,
    class: `vxe-default-${o}`,
    ...l,
    value: a.data,
    ...LI(e, t, a)
  }));
}
function lwe(e, t) {
  const { column: n } = t;
  return n.filters.map((o, l) => {
    const a = o.data;
    return V(ar(e), {
      key: l,
      ...vv(e, e, a),
      ...hv(e, t, o)
    });
  });
}
function awe(e, t) {
  const { column: n } = t;
  return n.filters.map((o, l) => {
    const a = o.data;
    return V(Xc(e), {
      key: l,
      ...vv(e, e, a),
      ...hv(e, t, o)
    });
  });
}
function oc({ option: e, row: t, column: n }) {
  const { data: o } = e;
  return I.get(t, n.property) == o;
}
function T_(e, t) {
  return [
    V("select", {
      class: "vxe-default-select",
      ...Zc(e),
      ...DI(e, t)
    }, e.optionGroups ? Cb(e, t, mv) : mv(e.options, e, t))
  ];
}
function $_(e, t) {
  const { row: n, column: o } = t, { options: l, optionProps: a, optionGroups: r, optionGroupProps: i } = e, s = xa(n, o);
  return [
    V(ar(e), {
      ...vu(e, t, s, { options: l, optionProps: a, optionGroups: r, optionGroupProps: i }),
      ...ch(e, t)
    })
  ];
}
function O_(e, t) {
  const { row: n, column: o } = t, { options: l, optionProps: a, optionGroups: r, optionGroupProps: i } = e, s = xa(n, o);
  return [
    V(Xc(e), {
      ...vu(e, t, s, { options: l, optionProps: a, optionGroups: r, optionGroupProps: i }),
      ...ch(e, t)
    })
  ];
}
function Bp(e, { row: t, column: n }) {
  const { props: o = {}, options: l, optionGroups: a, optionProps: r = {}, optionGroupProps: i = {} } = e, s = I.get(t, n.property);
  let u;
  const d = r.label || "label", f = r.value || "value";
  return X0(s) ? "" : I.map(o.multiple ? s : [s], a ? (v) => {
    const h = i.options || "options";
    for (let m = 0; m < a.length && (u = I.find(a[m][h], (p) => p[f] == v), !u); m++)
      ;
    return u ? u[d] : v;
  } : (v) => (u = I.find(l, (h) => h[f] == v), u ? u[d] : v)).join(", ");
}
function N_(e, t) {
  const { data: n, property: o } = t, { name: l } = e, a = Zc(e), r = I.get(n, o);
  return [
    V(l, {
      class: `vxe-default-${l}`,
      ...a,
      value: a && l === "input" && (a.type === "submit" || a.type === "reset") ? null : r,
      ...PI(e, t)
    })
  ];
}
function Pm(e, t) {
  const { data: n, property: o } = t, l = I.get(n, o);
  return [
    V(ar(e), {
      ...rr(e, t, l),
      ...Ir(e, t)
    })
  ];
}
function Am(e, t) {
  const { data: n, property: o } = t, l = I.get(n, o);
  return [
    V(Xc(e), {
      ...rr(e, t, l),
      ...Ir(e, t)
    })
  ];
}
function FI(e, t) {
  return [
    V(Dt("vxe-button"), {
      ...rr(e, t, null),
      ...hu(e, t)
    })
  ];
}
function rwe(e, t) {
  return e.children.map((n) => FI(n, t)[0]);
}
function M_(e, t, n) {
  const { data: o, property: l } = n, { optionProps: a = {} } = t, r = a.label || "label", i = a.value || "value", s = a.disabled || "disabled", u = I.get(o, l);
  return e.map((d, f) => V("option", {
    key: f,
    value: d[i],
    disabled: d[s],
    /* eslint-disable eqeqeq */
    selected: d[i] == u
  }, d[r]));
}
function Fm(e) {
  const { row: t, column: n, options: o } = e;
  return o.original ? xa(t, n) : Bp(n.editRender || n.cellRender, e);
}
function Vm(e, t) {
  const { data: n, property: o } = t, l = I.get(n, o);
  return [
    V(ar(e), {
      ...rr(e, t, l),
      ...Ir(e, t)
    })
  ];
}
function I_(e, t) {
  const { options: n, optionProps: o } = e, { data: l, property: a } = t, r = I.get(l, a);
  return [
    V(ar(e), {
      options: n,
      optionProps: o,
      ...rr(e, t, r),
      ...Ir(e, t)
    })
  ];
}
function R_(e, t) {
  const { name: n, options: o, optionProps: l = {} } = e, { data: a, property: r } = t, i = l.label || "label", s = l.value || "value", u = l.disabled || "disabled", d = I.get(a, r), f = MI(n);
  return o ? [
    V(Dt(`${f}-group`), {
      ...rr(e, t, d),
      ...Ir(e, t)
    }, {
      default: () => o.map((v, h) => V(Dt(f), {
        key: h,
        label: v[s],
        content: v[i],
        disabled: v[u]
      }))
    })
  ] : [
    V(Dt(f), {
      ...rr(e, t, d),
      ...Ir(e, t)
    })
  ];
}
const up = {
  input: {
    autofocus: "input",
    renderEdit: Lm,
    renderDefault: Lm,
    renderFilter: owe,
    defaultFilterMethod: oc,
    renderItemContent: N_
  },
  textarea: {
    autofocus: "textarea",
    renderEdit: Lm,
    renderItemContent: N_
  },
  select: {
    renderEdit: T_,
    renderDefault: T_,
    renderCell(e, t) {
      return Pu(e, t, Bp(e, t));
    },
    renderFilter(e, t) {
      const { column: n } = t;
      return n.filters.map((o, l) => V("select", {
        key: l,
        class: "vxe-default-select",
        ...Zc(e),
        ...LI(e, t, o)
      }, e.optionGroups ? Cb(e, t, mv) : mv(e.options, e, t)));
    },
    defaultFilterMethod: oc,
    renderItemContent(e, t) {
      return [
        V("select", {
          class: "vxe-default-select",
          ...Zc(e),
          ...PI(e, t)
        }, e.optionGroups ? Cb(e, t, M_) : M_(e.options, e, t))
      ];
    },
    exportMethod: Fm
  },
  VxeInput: {
    autofocus: ".vxe-input--inner",
    renderEdit: ip,
    renderCell(e, t) {
      const { props: n = {} } = e, { row: o, column: l } = t, a = n.digits || ee.input.digits;
      let r = I.get(o, l.property);
      if (r)
        switch (n.type) {
          case "date":
          case "week":
          case "month":
          case "year":
            r = x_(r, n);
            break;
          case "float":
            r = I.toFixed(I.floor(r, a), a);
            break;
        }
      return Pu(e, t, r);
    },
    renderDefault: ip,
    renderFilter: lwe,
    defaultFilterMethod: oc,
    renderItemContent: Pm
  },
  VxeTextarea: {
    autofocus: ".vxe-textarea--inner",
    renderItemContent: Pm
  },
  VxeButton: {
    renderDefault: k_,
    renderItemContent: Vm
  },
  VxeButtonGroup: {
    renderDefault: k_,
    renderItemContent(e, t) {
      const { options: n } = e, { data: o, property: l } = t, a = I.get(o, l);
      return [
        V(ar(e), {
          options: n,
          ...rr(e, t, a),
          ...Ir(e, t)
        })
      ];
    }
  },
  VxeSelect: {
    autofocus: ".vxe-input--inner",
    renderEdit: $_,
    renderDefault: $_,
    renderCell(e, t) {
      return Pu(e, t, Bp(e, t));
    },
    renderFilter(e, t) {
      const { column: n } = t, { options: o, optionProps: l, optionGroups: a, optionGroupProps: r } = e;
      return n.filters.map((i, s) => {
        const u = i.data;
        return V(ar(e), {
          key: s,
          ...vv(e, t, u, { options: o, optionProps: l, optionGroups: a, optionGroupProps: r }),
          ...hv(e, t, i)
        });
      });
    },
    defaultFilterMethod: oc,
    renderItemContent(e, t) {
      const { data: n, property: o } = t, { options: l, optionProps: a, optionGroups: r, optionGroupProps: i } = e, s = I.get(n, o);
      return [
        V(ar(e), {
          ...rr(e, t, s, { options: l, optionProps: a, optionGroups: r, optionGroupProps: i }),
          ...Ir(e, t)
        })
      ];
    },
    exportMethod: Fm
  },
  VxeRadio: {
    autofocus: ".vxe-radio--input",
    renderItemContent: Vm
  },
  VxeRadioGroup: {
    autofocus: ".vxe-radio--input",
    renderItemContent: I_
  },
  VxeCheckbox: {
    autofocus: ".vxe-checkbox--input",
    renderItemContent: Vm
  },
  VxeCheckboxGroup: {
    autofocus: ".vxe-checkbox--input",
    renderItemContent: I_
  },
  VxeSwitch: {
    autofocus: ".vxe-switch--button",
    renderEdit: ip,
    renderDefault: ip,
    renderItemContent: Pm
  },
  // 以下已废弃
  $input: {
    autofocus: ".vxe-input--inner",
    renderEdit: cp,
    renderCell(e, t) {
      const { props: n = {} } = e, { row: o, column: l } = t, a = n.digits || ee.input.digits;
      let r = I.get(o, l.property);
      if (r)
        switch (n.type) {
          case "date":
          case "week":
          case "month":
          case "year":
            r = x_(r, n);
            break;
          case "float":
            r = I.toFixed(I.floor(r, a), a);
            break;
        }
      return Pu(e, t, r);
    },
    renderDefault: cp,
    renderFilter: awe,
    defaultFilterMethod: oc,
    renderItemContent: Am
  },
  $textarea: {
    autofocus: ".vxe-textarea--inner",
    renderItemContent: Am
  },
  $button: {
    renderDefault: AI,
    renderItemContent: FI
  },
  $buttons: {
    renderDefault: nwe,
    renderItemContent: rwe
  },
  $select: {
    autofocus: ".vxe-input--inner",
    renderEdit: O_,
    renderDefault: O_,
    renderCell(e, t) {
      return Pu(e, t, Bp(e, t));
    },
    renderFilter(e, t) {
      const { column: n } = t, { options: o, optionProps: l, optionGroups: a, optionGroupProps: r } = e;
      return n.filters.map((i, s) => {
        const u = i.data;
        return V(Xc(e), {
          key: s,
          ...vv(e, t, u, { options: o, optionProps: l, optionGroups: a, optionGroupProps: r }),
          ...hv(e, t, i)
        });
      });
    },
    defaultFilterMethod: oc,
    renderItemContent(e, t) {
      const { data: n, property: o } = t, { options: l, optionProps: a, optionGroups: r, optionGroupProps: i } = e, s = I.get(n, o);
      return [
        V(Xc(e), {
          ...rr(e, t, s, { options: l, optionProps: a, optionGroups: r, optionGroupProps: i }),
          ...Ir(e, t)
        })
      ];
    },
    exportMethod: Fm
  },
  $radio: {
    autofocus: ".vxe-radio--input",
    renderItemContent: R_
  },
  $checkbox: {
    autofocus: ".vxe-checkbox--input",
    renderItemContent: R_
  },
  $switch: {
    autofocus: ".vxe-switch--button",
    renderEdit: cp,
    renderDefault: cp,
    renderItemContent: Am
  }
  // 以上已废弃
}, fi = {
  mixin(e) {
    return I.each(e, (t, n) => fi.add(n, t)), fi;
  },
  get(e) {
    return up[e] || null;
  },
  add(e, t) {
    if (e && t) {
      const n = up[e];
      n ? (process.env.NODE_ENV === "development" && I.each(t, (o, l) => {
        !I.eqNull(n[l]) && n[l] !== o && qt("vxe.error.coverProp", [`Renderer.${e}`, l]);
      }), Object.assign(n, t)) : up[e] = t;
    }
    return fi;
  },
  delete(e) {
    return delete up[e], fi;
  }
};
class swe {
  constructor() {
    Jr(this, "store", {});
  }
  mixin(t) {
    return I.each(t, (n, o) => {
      this.add(o, n);
    }), this;
  }
  has(t) {
    return !!this.get(t);
  }
  get(t) {
    return this.store[t];
  }
  add(t, n) {
    const o = this.store[t];
    if (I.isFunction(n) && (process.env.NODE_ENV === "development" && qt("vxe.error.delProp", ["commands -> callback", "commandMethod"]), n = {
      commandMethod: n
    }), process.env.NODE_ENV === "development") {
      const l = I.keys(o);
      I.each(n, (a, r) => {
        l.includes(r) && qt("vxe.error.coverProp", [t, r]);
      });
    }
    return this.store[t] = o ? I.merge(o, n) : n, this;
  }
  delete(t) {
    delete this.store[t];
  }
  forEach(t) {
    I.objectEach(this.store, t);
  }
}
const n1 = new swe();
process.env.NODE_ENV === "development" && Object.assign(n1, { _name: "Commands" });
class iwe {
  constructor() {
    Jr(this, "store", {});
  }
  mixin(t) {
    return I.each(t, (n, o) => {
      this.add(o, n);
    }), this;
  }
  has(t) {
    return !!this.get(t);
  }
  get(t) {
    return this.store[t];
  }
  add(t, n) {
    const o = this.store[t];
    if (I.isFunction(n) && (process.env.NODE_ENV === "development" && qt("vxe.error.delProp", ["menus -> callback", "menuMethod"]), n = {
      menuMethod: n
    }), process.env.NODE_ENV === "development") {
      const l = I.keys(o);
      I.each(n, (a, r) => {
        l.includes(r) && qt("vxe.error.coverProp", [t, r]);
      });
    }
    return this.store[t] = o ? I.merge(o, n) : n, this;
  }
  delete(t) {
    delete this.store[t];
  }
  forEach(t) {
    I.objectEach(this.store, t);
  }
}
const o1 = new iwe();
process.env.NODE_ENV === "development" && Object.assign(o1, { _name: "Menus" });
class VI {
  constructor() {
    Jr(this, "store", {});
  }
  mixin(t) {
    return I.each(t, (n, o) => {
      this.add(o, n);
    }), this;
  }
  has(t) {
    return !!this.get(t);
  }
  get(t) {
    return this.store[t];
  }
  add(t, n) {
    const o = this.store[t];
    if (process.env.NODE_ENV === "development") {
      const l = I.keys(o);
      I.each(n, (a, r) => {
        l.includes(r) && qt("vxe.error.coverProp", [t, r]);
      });
    }
    return this.store[t] = o ? I.merge(o, n) : n, this;
  }
  delete(t) {
    delete this.store[t];
  }
  forEach(t) {
    I.objectEach(this.store, t);
  }
}
const l1 = new VI();
process.env.NODE_ENV === "development" && Object.assign(l1, { _name: "Validators" });
const BI = new VI();
function a1(e) {
  const t = (e ? e.theme : null) || ee.theme || "default";
  if (typeof document < "u") {
    const n = document.documentElement;
    n && n.setAttribute("data-vxe-table-theme", t);
  }
}
const $f = (e) => (e && (e.theme && a1(e), e.zIndex && G0.setCurrent(e.zIndex)), I.merge(ee, e));
function D_(e, t) {
  const n = [];
  return I.objectEach(e, (o, l) => {
    (o === 0 || o === t) && n.push(l);
  }), n;
}
const L_ = [];
function HI(e, t) {
  return e && e.install && L_.indexOf(e) === -1 && (e.install($t, t), L_.push(e)), $t;
}
function zI(e, t) {
  return ee.i18n(e, t);
}
function WI(e, t) {
  return e ? I.toValueString(ee.translate ? ee.translate(e, t) : e) : "";
}
class cwe {
  /**
   * 获取当前的 zIndex
   */
  get zIndex() {
    return Yr();
  }
  /**
   * 获取下一个 zIndex
   */
  get nextZIndex() {
    return dr();
  }
  /**
   * 获取所有导出类型
   */
  get exportTypes() {
    return D_(ee.export.types, 1);
  }
  /**
   * 获取所有导入类型
   */
  get importTypes() {
    return D_(ee.export.types, 2);
  }
}
const KI = new cwe(), UI = "v4", jI = $f, r1 = {}, $t = {
  v: UI,
  version: "4.6.12",
  config: $f,
  globalStore: r1,
  interceptor: nd,
  renderer: fi,
  commands: n1,
  formats: jd,
  validators: l1,
  menus: o1,
  hooks: BI,
  use: HI,
  t: zI,
  _t: WI,
  // 已废弃
  setup: jI,
  globalConfs: KI
};
a1(r1);
const od = Q({
  name: "VxeTableFilterPanel",
  props: {
    filterStore: Object
  },
  setup(e) {
    const t = ot("$xetable", {}), { reactData: n, internalData: o, getComputeMaps: l } = t, { computeFilterOpts: a } = l(), r = x(() => {
      const { filterStore: w } = e;
      return w && w.options.some((b) => b.checked);
    }), i = (w, b) => {
      const { filterStore: y } = e;
      y.options.forEach((E) => {
        E._checked = b, E.checked = b;
      }), y.isAllSelected = b, y.isIndeterminate = !1;
    }, s = (w) => {
      const { filterStore: b } = e;
      b.options.forEach((y) => {
        y.checked = y._checked;
      }), t.confirmFilterEvent(w);
    }, u = (w, b, y) => {
      const { filterStore: E } = e;
      E.options.forEach((S) => {
        S._checked = !1;
      }), y._checked = b, t.checkFilterOptions(), s(w);
    }, d = (w) => {
      const { filterStore: b } = e;
      t.handleClearFilter(b.column), t.confirmFilterEvent(w);
    }, f = (w, b, y) => {
      y._checked = b, t.checkFilterOptions();
    }, v = (w, b, y) => {
      const { filterStore: E } = e;
      E.multiple ? f(w, b, y) : u(w, b, y);
    }, h = (w, b) => {
      const { filterStore: y } = e;
      y.multiple ? i(w, b) : d(w);
    }, m = {
      changeRadioOption: u,
      changeMultipleOption: f,
      changeAllOption: h,
      changeOption: v,
      confirmFilter: s,
      resetFilter: d
    }, p = (w, b) => {
      const { filterStore: y } = e, { column: E, multiple: S, maxHeight: _ } = y, { slots: k } = E, N = k ? k.filter : null, L = Object.assign({}, o._currFilterParams, { $panel: m, $table: t });
      if (N)
        return [
          V("div", {
            class: "vxe-table--filter-template"
          }, t.callSlot(N, L))
        ];
      if (b && b.renderFilter)
        return [
          V("div", {
            class: "vxe-table--filter-template"
          }, oo(b.renderFilter(w, L)))
        ];
      const R = S ? y.isAllSelected : !y.options.some((K) => K._checked), H = S && y.isIndeterminate;
      return [
        V("ul", {
          class: "vxe-table--filter-header"
        }, [
          V("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": R,
              "is--indeterminate": H
            }],
            title: ee.i18n(S ? "vxe.table.allTitle" : "vxe.table.allFilter"),
            onClick: (K) => {
              h(K, !y.isAllSelected);
            }
          }, (S ? [
            V("span", {
              class: ["vxe-checkbox--icon", H ? ee.icon.TABLE_CHECKBOX_INDETERMINATE : R ? ee.icon.TABLE_CHECKBOX_CHECKED : ee.icon.TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            V("span", {
              class: "vxe-checkbox--label"
            }, ee.i18n("vxe.table.allFilter"))
          ]))
        ]),
        V("ul", {
          class: "vxe-table--filter-body",
          style: _ ? {
            maxHeight: `${_}px`
          } : {}
        }, y.options.map((K) => {
          const U = K._checked;
          return V("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": K._checked
            }],
            title: K.label,
            onClick: (W) => {
              v(W, !K._checked, K);
            }
          }, (S ? [
            V("span", {
              class: ["vxe-checkbox--icon", U ? ee.icon.TABLE_CHECKBOX_CHECKED : ee.icon.TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            V("span", {
              class: "vxe-checkbox--label"
            }, ko(K.label, 1))
          ]));
        }))
      ];
    }, C = () => {
      const { filterStore: w } = e, { column: b, multiple: y } = w, E = a.value, S = r.value, _ = b.filterRender, k = _ ? $t.renderer.get(_.name) : null, N = !S && !w.isAllSelected && !w.isIndeterminate;
      return y && (!k || k.showFilterFooter !== !1) ? [
        V("div", {
          class: "vxe-table--filter-footer"
        }, [
          V("button", {
            class: {
              "is--disabled": N
            },
            disabled: N,
            onClick: s
          }, E.confirmButtonText || ee.i18n("vxe.table.confirmFilter")),
          V("button", {
            onClick: d
          }, E.resetButtonText || ee.i18n("vxe.table.resetFilter"))
        ])
      ] : [];
    };
    return () => {
      const { filterStore: w } = e, { initStore: b } = n, { column: y } = w, E = y ? y.filterRender : null, S = E ? $t.renderer.get(E.name) : null, _ = S ? S.filterClassName : "", k = Object.assign({}, o._currFilterParams, { $panel: m, $table: t });
      return V("div", {
        class: [
          "vxe-table--filter-wrapper",
          "filter--prevent-default",
          vs(_, k),
          {
            "is--animat": t.props.animat,
            "is--multiple": w.multiple,
            "is--active": w.visible
          }
        ],
        style: w.style
      }, b.filter && w.visible ? p(E, S).concat(C()) : []);
    };
  }
}), uwe = ["setFilter", "clearFilter", "getCheckedFilters"], dwe = {
  setupTable(e) {
    const { props: t, reactData: n, internalData: o } = e, { refTableBody: l, refTableFilter: a } = e.getRefMaps(), { computeFilterOpts: r, computeMouseOpts: i } = e.getComputeMaps(), s = {
      checkFilterOptions() {
        const { filterStore: d } = n;
        d.isAllSelected = d.options.every((f) => f._checked), d.isIndeterminate = !d.isAllSelected && d.options.some((f) => f._checked);
      },
      /**
       * 点击筛选事件
       * 当筛选图标被点击时触发
       * 更新选项是否全部状态
       * 打开筛选面板
       * @param {Event} evnt 事件
       * @param {ColumnInfo} column 列配置
       * @param {Object} params 参数
       */
      triggerFilterEvent(d, f, v) {
        const { initStore: h, filterStore: m } = n;
        if (m.column === f && m.visible)
          m.visible = !1;
        else {
          const { target: p, pageX: C } = d, { visibleWidth: g } = Cs(), { filters: w, filterMultiple: b, filterRender: y } = f, E = y ? $t.renderer.get(y.name) : null, S = f.filterRecoverMethod || (E ? E.filterRecoverMethod : null);
          o._currFilterParams = v, Object.assign(m, {
            multiple: b,
            options: w,
            column: f,
            style: null
          }), m.options.forEach((_) => {
            const { _checked: k, checked: N } = _;
            _._checked = N, !N && k !== N && S && S({ option: _, column: f, $table: e });
          }), this.checkFilterOptions(), m.visible = !0, h.filter = !0, xe(() => {
            const k = l.value.$el, N = a.value, L = N ? N.$el : null;
            let R = 0, H = 0, K = null, U = null;
            L && (R = L.offsetWidth, H = L.offsetHeight, K = L.querySelector(".vxe-table--filter-header"), U = L.querySelector(".vxe-table--filter-footer"));
            const W = R / 2, A = 10, $ = k.clientWidth - R - A;
            let D, O;
            const F = {
              top: `${p.offsetTop + p.offsetParent.offsetTop + p.offsetHeight + 8}px`
            };
            let j = null;
            if (H >= k.clientHeight && (j = Math.max(60, k.clientHeight - (U ? U.offsetHeight : 0) - (K ? K.offsetHeight : 0))), f.fixed === "left" ? D = p.offsetLeft + p.offsetParent.offsetLeft - W : f.fixed === "right" ? O = p.offsetParent.offsetWidth - p.offsetLeft + (p.offsetParent.offsetParent.offsetWidth - p.offsetParent.offsetLeft) - f.renderWidth - W : D = p.offsetLeft + p.offsetParent.offsetLeft - W - k.scrollLeft, D) {
              const Z = C + R - W + A - g;
              Z > 0 && (D -= Z), F.left = `${Math.min($, Math.max(A, D))}px`;
            } else if (O) {
              const Z = C + R - W + A - g;
              Z > 0 && (O += Z), F.right = `${Math.max(A, O)}px`;
            }
            m.style = F, m.maxHeight = j;
          });
        }
        e.dispatchEvent("filter-visible", { column: f, field: f.field, property: f.field, filterList: e.getCheckedFilters(), visible: m.visible }, d);
      },
      handleClearFilter(d) {
        if (d) {
          const { filters: f, filterRender: v } = d;
          if (f) {
            const h = v ? $t.renderer.get(v.name) : null, m = d.filterResetMethod || (h ? h.filterResetMethod : null);
            f.forEach((p) => {
              p._checked = !1, p.checked = !1, m || (p.data = I.clone(p.resetValue, !0));
            }), m && m({ options: f, column: d, $table: e });
          }
        }
      },
      /**
       * 确认筛选
       * 当筛选面板中的确定按钮被按下时触发
       * @param {Event} evnt 事件
       */
      confirmFilterEvent(d) {
        const { mouseConfig: f } = t, { filterStore: v, scrollXLoad: h, scrollYLoad: m } = n, p = r.value, C = i.value, { column: g } = v, { field: w } = g, b = [], y = [];
        g.filters.forEach((_) => {
          _.checked && (b.push(_.value), y.push(_.data));
        });
        const E = e.getCheckedFilters(), S = { $table: e, $event: d, column: g, field: w, property: w, values: b, datas: y, filters: E, filterList: E };
        p.remote || (e.handleTableData(!0), e.checkSelectionStatus()), f && C.area && e.handleFilterEvent && e.handleFilterEvent(d, S), e.dispatchEvent("filter-change", S, d), e.closeFilter(), e.updateFooter().then(() => {
          const { scrollXLoad: _, scrollYLoad: k } = n;
          if (h || _ || m || k)
            return (h || _) && e.updateScrollXSpace(), (m || k) && e.updateScrollYSpace(), e.refreshScroll();
        }).then(() => (e.updateCellAreas(), e.recalculate(!0))).then(() => {
          setTimeout(() => e.recalculate(), 50);
        });
      }
    };
    return { ...{
      /**
       * 手动弹出筛选面板
       * @param column
       */
      openFilter(d) {
        const f = El(e, d);
        if (f && f.filters) {
          const { elemStore: v } = o, { fixed: h } = f;
          return e.scrollToColumn(f).then(() => {
            const m = v[`${h || "main"}-header-wrapper`] || v["main-header-wrapper"], p = m ? m.value : null;
            if (p) {
              const C = p.querySelector(`.vxe-header--column.${f.id} .vxe-filter--btn`);
              jCe(C, "click");
            }
          });
        }
        return xe();
      },
      /**
       * 修改筛选条件列表
       * @param {ColumnInfo} fieldOrColumn 列或字段名
       * @param {Array} options 选项
       */
      setFilter(d, f) {
        const v = El(e, d);
        return v && v.filters && (v.filters = _I(f || [])), xe();
      },
      /**
       * 清空指定列的筛选条件
       * 如果为空则清空所有列的筛选条件
       * @param {String} fieldOrColumn 列或字段名
       */
      clearFilter(d) {
        const { filterStore: f } = n, { tableFullColumn: v } = o, h = r.value;
        let m;
        return d ? (m = El(e, d), m && s.handleClearFilter(m)) : v.forEach(s.handleClearFilter), (!d || m !== f.column) && Object.assign(f, {
          isAllSelected: !1,
          isIndeterminate: !1,
          style: null,
          options: [],
          column: null,
          multiple: !1,
          visible: !1
        }), h.remote ? xe() : e.updateData();
      },
      getCheckedFilters() {
        const { tableFullColumn: d } = o, f = [];
        return d.forEach((v) => {
          const { field: h, filters: m } = v, p = [], C = [];
          m && m.length && (m.forEach((g) => {
            g.checked && (p.push(g.value), C.push(g.data));
          }), p.length && f.push({ column: v, field: h, property: h, values: p, datas: C }));
        }), f;
      }
    }, ...s };
  },
  setupGrid(e) {
    return e.extendTableMethods(uwe);
  }
};
let Au;
const Hp = en({
  modals: []
}), fwe = Q({
  setup() {
    return () => {
      const { modals: e } = Hp;
      return V("div", {
        class: "vxe-dynamics--modal"
      }, e.map((t) => V(Dt("vxe-modal"), t)));
    };
  }
}), Fn = U2(fwe);
function pwe() {
  Au || (Au = document.createElement("div"), Au.className = "vxe-dynamics", document.body.appendChild(Au), Fn.mount(Au));
}
const s1 = {
  Panel: od,
  install(e) {
    $t.hooks.add("$tableFilter", dwe), e.component(od.name, od);
  }
}, vwe = s1;
Fn.component(od.name, od);
const ld = Q({
  name: "VxeTableMenuPanel",
  setup(e, t) {
    const n = I.uniqueId(), o = ot("$xetable", {}), { reactData: l } = o, a = B(), r = {
      refElem: a
    }, i = {
      xID: n,
      props: e,
      context: t,
      getRefMaps: () => r
    }, s = () => {
      const { ctxMenuStore: u } = l, { computeMenuOpts: d } = o.getComputeMaps(), f = d.value;
      return V(ka, {
        to: "body",
        disabled: !1
      }, [
        V("div", {
          ref: a,
          class: ["vxe-table--context-menu-wrapper", f.className, {
            "is--visible": u.visible
          }],
          style: u.style
        }, u.list.map((v, h) => v.every((m) => m.visible === !1) ? _e() : V("ul", {
          class: "vxe-context-menu--option-wrapper",
          key: h
        }, v.map((m, p) => {
          const C = m.children && m.children.some((g) => g.visible !== !1);
          return m.visible === !1 ? null : V("li", {
            class: [m.className, {
              "link--disabled": m.disabled,
              "link--active": m === u.selected
            }],
            key: `${h}_${p}`
          }, [
            V("a", {
              class: "vxe-context-menu--link",
              onClick(g) {
                o.ctxMenuLinkEvent(g, m);
              },
              onMouseover(g) {
                o.ctxMenuMouseoverEvent(g, m);
              },
              onMouseout(g) {
                o.ctxMenuMouseoutEvent(g, m);
              }
            }, [
              V("i", {
                class: ["vxe-context-menu--link-prefix", m.prefixIcon]
              }),
              V("span", {
                class: "vxe-context-menu--link-content"
              }, vo(m.name)),
              V("i", {
                class: ["vxe-context-menu--link-suffix", C ? m.suffixIcon || "suffix--haschild" : m.suffixIcon]
              })
            ]),
            C ? V("ul", {
              class: ["vxe-table--context-menu-clild-wrapper", {
                "is--show": m === u.selected && u.showChild
              }]
            }, m.children.map((g, w) => g.visible === !1 ? null : V("li", {
              class: [g.className, {
                "link--disabled": g.disabled,
                "link--active": g === u.selectChild
              }],
              key: `${h}_${p}_${w}`
            }, [
              V("a", {
                class: "vxe-context-menu--link",
                onClick(b) {
                  o.ctxMenuLinkEvent(b, g);
                },
                onMouseover(b) {
                  o.ctxMenuMouseoverEvent(b, m, g);
                },
                onMouseout(b) {
                  o.ctxMenuMouseoutEvent(b, m);
                }
              }, [
                V("i", {
                  class: ["vxe-context-menu--link-prefix", g.prefixIcon]
                }),
                V("span", {
                  class: "vxe-context-menu--link-content"
                }, vo(g.name))
              ])
            ]))) : null
          ]);
        }))))
      ]);
    };
    return i.renderVN = s, i;
  },
  render() {
    return this.renderVN();
  }
}), un = {
  F2: "F2",
  ESCAPE: "Escape",
  ENTER: "Enter",
  TAB: "Tab",
  DELETE: "Delete",
  BACKSPACE: "Backspace",
  SPACEBAR: " ",
  CONTEXT_MENU: "ContextMenu",
  ARROW_UP: "ArrowUp",
  ARROW_DOWN: "ArrowDown",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown"
}, P_ = {
  " ": "Spacebar",
  Apps: un.CONTEXT_MENU,
  Del: un.DELETE,
  Up: un.ARROW_UP,
  Down: un.ARROW_DOWN,
  Left: un.ARROW_LEFT,
  Right: un.ARROW_RIGHT
}, qI = Jl.firefox ? "DOMMouseScroll" : "mousewheel", wb = [], Cn = (e, t) => {
  const { key: n } = e;
  return t = t.toLowerCase(), n ? t === n.toLowerCase() || !!(P_[n] && P_[n].toLowerCase() === t) : !1;
};
function Ja(e) {
  const t = e.type === qI;
  wb.forEach(({ type: n, cb: o }) => {
    e.cancelBubble || (n === e.type || t && n === "mousewheel") && o(e);
  });
}
const wn = {
  on(e, t, n) {
    wb.push({ comp: e, type: t, cb: n });
  },
  off(e, t) {
    I.remove(wb, (n) => n.comp === e && n.type === t);
  },
  trigger: Ja,
  eqKeypad(e, t) {
    const { key: n } = e;
    return t.toLowerCase() === n.toLowerCase();
  }
};
Jl.isDoc && (Jl.msie || (window.addEventListener("copy", Ja, !1), window.addEventListener("cut", Ja, !1), window.addEventListener("paste", Ja, !1)), document.addEventListener("keydown", Ja, !1), document.addEventListener("contextmenu", Ja, !1), window.addEventListener("mousedown", Ja, !1), window.addEventListener("blur", Ja, !1), window.addEventListener("resize", Ja, !1), window.addEventListener(qI, I.throttle(Ja, 100, { leading: !0, trailing: !1 }), { passive: !0, capture: !1 }));
const hwe = ["closeMenu"], mwe = {
  setupTable(e) {
    const { xID: t, props: n, reactData: o, internalData: l } = e, { refElem: a, refTableFilter: r, refTableMenu: i } = e.getRefMaps(), { computeMouseOpts: s, computeIsMenu: u, computeMenuOpts: d } = e.getComputeMaps();
    let f = {}, v = {};
    const h = (m, p, C) => {
      const { ctxMenuStore: g } = o, w = u.value, b = d.value, y = b[p], E = b.visibleMethod;
      if (y) {
        const { options: S, disabled: _ } = y;
        _ ? m.preventDefault() : w && S && S.length && (C.options = S, e.preventEvent(m, "event.showMenu", C, () => {
          if (!E || E(C)) {
            m.preventDefault(), e.updateZindex();
            const { scrollTop: k, scrollLeft: N, visibleHeight: L, visibleWidth: R } = Cs();
            let H = m.clientY + k, K = m.clientX + N;
            const U = () => {
              l._currMenuParams = C, Object.assign(g, {
                visible: !0,
                list: S,
                selected: null,
                selectChild: null,
                showChild: !1,
                style: {
                  zIndex: l.tZindex,
                  top: `${H}px`,
                  left: `${K}px`
                }
              }), xe(() => {
                const O = i.value.getRefMaps().refElem.value, F = O.clientHeight, j = O.clientWidth, { boundingTop: Z, boundingLeft: te } = lr(O), de = Z + F - L, Oe = te + j - R;
                de > -10 && (g.style.top = `${Math.max(k + 2, H - F - 2)}px`), Oe > -10 && (g.style.left = `${Math.max(N + 2, K - j - 2)}px`);
              });
            }, { keyboard: W, row: A, column: $ } = C;
            W && A && $ ? e.scrollToRow(A, $).then(() => {
              const D = e.getCell(A, $);
              if (D) {
                const { boundingTop: O, boundingLeft: F } = lr(D);
                H = O + k + Math.floor(D.offsetHeight / 2), K = F + N + Math.floor(D.offsetWidth / 2);
              }
              U();
            }) : U();
          } else
            f.closeMenu();
        }));
      }
      e.closeFilter();
    };
    return f = {
      /**
       * 关闭快捷菜单
       */
      closeMenu() {
        return Object.assign(o.ctxMenuStore, {
          visible: !1,
          selected: null,
          selectChild: null,
          showChild: !1
        }), xe();
      }
    }, v = {
      /**
       * 处理菜单的移动
       */
      moveCtxMenu(m, p, C, g, w, b) {
        let y;
        const E = I.findIndexOf(b, (S) => p[C] === S);
        if (g)
          w && wc(p.selected) ? p.showChild = !0 : (p.showChild = !1, p.selectChild = null);
        else if (Cn(m, un.ARROW_UP)) {
          for (let S = E - 1; S >= 0; S--)
            if (b[S].visible !== !1) {
              y = b[S];
              break;
            }
          p[C] = y || b[b.length - 1];
        } else if (Cn(m, un.ARROW_DOWN)) {
          for (let S = E + 1; S < b.length; S++)
            if (b[S].visible !== !1) {
              y = b[S];
              break;
            }
          p[C] = y || b[0];
        } else
          p[C] && (Cn(m, un.ENTER) || Cn(m, un.SPACEBAR)) && v.ctxMenuLinkEvent(m, p[C]);
      },
      handleOpenMenuEvent: h,
      /**
       * 快捷菜单事件处理
       */
      handleGlobalContextmenuEvent(m) {
        const { mouseConfig: p, menuConfig: C } = n, { editStore: g, ctxMenuStore: w } = o, { visibleColumn: b } = l, y = r.value, E = i.value, S = s.value, _ = d.value, k = a.value, { selected: N } = g, L = ["header", "body", "footer"];
        if (mn(C)) {
          if (w.visible && E && _n(m, E.getRefMaps().refElem.value).flag) {
            m.preventDefault();
            return;
          }
          if (l._keyCtx) {
            const R = "body", H = { type: R, $table: e, keyboard: !0, columns: b.slice(0), $event: m };
            if (p && S.area) {
              const K = e.getActiveCellArea();
              if (K && K.row && K.column) {
                H.row = K.row, H.column = K.column, h(m, R, H);
                return;
              }
            } else if (p && S.selected && N.row && N.column) {
              H.row = N.row, H.column = N.column, h(m, R, H);
              return;
            }
          }
          for (let R = 0; R < L.length; R++) {
            const H = L[R], K = _n(m, k, `vxe-${H}--column`, (W) => W.parentNode.parentNode.parentNode.getAttribute("xid") === t), U = { type: H, $table: e, columns: b.slice(0), $event: m };
            if (K.flag) {
              const W = K.targetElem, A = e.getColumnNode(W), $ = A ? A.item : null;
              let D = `${H}-`;
              if ($ && Object.assign(U, { column: $, columnIndex: e.getColumnIndex($), cell: W }), H === "body") {
                const F = e.getRowNode(W.parentNode), j = F ? F.item : null;
                D = "", j && (U.row = j, U.rowIndex = e.getRowIndex(j));
              }
              const O = `${D}cell-menu`;
              h(m, H, U), e.dispatchEvent(O, U, m);
              return;
            } else if (_n(m, k, `vxe-table--${H}-wrapper`, (W) => W.getAttribute("xid") === t).flag) {
              _.trigger === "cell" ? m.preventDefault() : h(m, H, U);
              return;
            }
          }
        }
        y && !_n(m, y.$el).flag && e.closeFilter(), f.closeMenu();
      },
      ctxMenuMouseoverEvent(m, p, C) {
        const g = m.currentTarget, { ctxMenuStore: w } = o;
        m.preventDefault(), m.stopPropagation(), w.selected = p, w.selectChild = C, C || (w.showChild = wc(p), w.showChild && xe(() => {
          const b = g.nextElementSibling;
          if (b) {
            const { boundingTop: y, boundingLeft: E, visibleHeight: S, visibleWidth: _ } = lr(g), k = y + g.offsetHeight, N = E + g.offsetWidth;
            let L = "", R = "";
            N + b.offsetWidth > _ - 10 && (L = "auto", R = `${g.offsetWidth}px`);
            let H = "", K = "";
            k + b.offsetHeight > S - 10 && (H = "auto", K = "0"), b.style.left = L, b.style.right = R, b.style.top = H, b.style.bottom = K;
          }
        }));
      },
      ctxMenuMouseoutEvent(m, p) {
        const { ctxMenuStore: C } = o;
        p.children || (C.selected = null), C.selectChild = null;
      },
      /**
       * 快捷菜单点击事件
       */
      ctxMenuLinkEvent(m, p) {
        if (!p.disabled && (p.code || !p.children || !p.children.length)) {
          const C = $t.menus.get(p.code), g = Object.assign({}, l._currMenuParams, { menu: p, $table: e, $grid: e.xegrid, $event: m });
          C && C.menuMethod && C.menuMethod(g, m), e.dispatchEvent("menu-click", g, m), f.closeMenu();
        }
      }
    }, { ...f, ...v };
  },
  setupGrid(e) {
    return e.extendTableMethods(hwe);
  }
}, i1 = {
  Panel: ld,
  install(e) {
    $t.hooks.add("$tableMenu", mwe), e.component(ld.name, ld);
  }
}, gwe = i1;
Fn.component(ld.name, ld);
const bwe = ["insert", "insertAt", "insertNextAt", "remove", "removeCheckboxRow", "removeRadioRow", "removeCurrentRow", "getRecordset", "getInsertRecords", "getRemoveRecords", "getUpdateRecords", "getEditRecord", "getActiveRecord", "getSelectedCell", "clearEdit", "clearActived", "clearSelected", "isEditByRow", "isActiveByRow", "setEditRow", "setActiveRow", "setEditCell", "setActiveCell", "setSelectCell"], ywe = {
  setupTable(e) {
    const { props: t, reactData: n, internalData: o } = e, { refElem: l } = e.getRefMaps(), { computeMouseOpts: a, computeEditOpts: r, computeCheckboxOpts: i, computeTreeOpts: s } = e.getComputeMaps();
    let u = {}, d = {};
    const f = (g, w) => {
      const { model: b, editRender: y } = w;
      y && (b.value = xa(g, w), b.update = !1);
    }, v = (g, w) => {
      const { model: b, editRender: y } = w;
      y && b.update && (Or(g, w, b.value), b.update = !1, b.value = null);
    }, h = () => {
      const g = l.value;
      if (g) {
        const w = g.querySelector(".col--selected");
        w && Xl(w, "col--selected");
      }
    };
    function m() {
      const { editStore: g, tableColumn: w } = n, b = r.value, { actived: y } = g, { row: E, column: S } = y;
      (E || S) && (b.mode === "row" ? w.forEach((_) => v(E, _)) : v(E, S));
    }
    function p(g, w) {
      const { tableFullTreeData: b, afterFullData: y, fullDataRowIdData: E, fullAllDataRowIdData: S } = o, _ = s.value, { rowField: k, parentField: N, mapChildrenField: L } = _, R = _.children || _.childrenField, H = w ? "push" : "unshift";
      g.forEach((K) => {
        const U = K[N], W = yt(e, K), A = U ? I.findTree(b, ($) => U === $[k], { children: L }) : null;
        if (A) {
          const { item: $ } = A, D = S[yt(e, $)], O = D ? D.level : 0;
          let F = $[R], j = $[L];
          I.isArray(F) || (F = $[R] = []), I.isArray(j) || (j = $[R] = []), F[H](K), j[H](K);
          const Z = { row: K, rowid: W, seq: -1, index: -1, _index: -1, $index: -1, items: F, parent: $, level: O + 1 };
          E[W] = Z, S[W] = Z;
        } else {
          process.env.NODE_ENV === "development" && U && qt("vxe.error.unableInsert"), y[H](K), b[H](K);
          const $ = { row: K, rowid: W, seq: -1, index: -1, _index: -1, $index: -1, items: b, parent: null, level: 0 };
          E[W] = $, S[W] = $;
        }
      });
    }
    const C = (g, w, b) => {
      const { treeConfig: y } = t, { mergeList: E, editStore: S } = n, { tableFullTreeData: _, afterFullData: k, tableFullData: N, fullDataRowIdData: L, fullAllDataRowIdData: R } = o, H = s.value, { transform: K, rowField: U, mapChildrenField: W } = H, A = H.children || H.childrenField;
      I.isArray(g) || (g = [g]);
      const $ = en(e.defineField(g.map((O) => Object.assign(y && K ? { [W]: [], [A]: [] } : {}, O))));
      if (I.eqNull(w))
        y && K ? p($, !1) : (k.unshift(...$), N.unshift(...$), E.forEach((O) => {
          const { row: F } = O;
          F > 0 && (O.row = F + $.length);
        }));
      else if (w === -1)
        y && K ? p($, !0) : (k.push(...$), N.push(...$), E.forEach((O) => {
          const { row: F, rowspan: j } = O;
          F + j > k.length && (O.rowspan = j + $.length);
        }));
      else if (y && K) {
        const O = I.findTree(_, (F) => w[U] === F[U], { children: W });
        if (O) {
          const { parent: F } = O, j = F ? F[W] : _, Z = R[yt(e, F)], te = Z ? Z.level : 0;
          if ($.forEach((de, Oe) => {
            const ce = yt(e, de);
            process.env.NODE_ENV === "development" && de[H.parentField] && F && de[H.parentField] !== F[U] && Ht("vxe.error.errProp", [`${H.parentField}=${de[H.parentField]}`, `${H.parentField}=${F[U]}`]), F && (de[H.parentField] = F[U]);
            let ne = O.index + Oe;
            b && (ne = ne + 1), j.splice(ne, 0, de);
            const Y = { row: de, rowid: ce, seq: -1, index: -1, _index: -1, $index: -1, items: j, parent: F, level: te + 1 };
            L[ce] = Y, R[ce] = Y;
          }), F) {
            const de = I.findTree(_, (Oe) => w[U] === Oe[U], { children: A });
            if (de) {
              const Oe = de.items;
              let ce = de.index;
              b && (ce = ce + 1), Oe.splice(ce, 0, ...$);
            }
          }
        } else
          process.env.NODE_ENV === "development" && qt("vxe.error.unableInsert"), p($, !0);
      } else {
        if (y)
          throw new Error(U0("vxe.error.noTree", ["insert"]));
        let O = -1;
        if (I.isNumber(w) ? w < k.length && (O = w) : O = e.findRowIndexOf(k, w), b && (O = Math.min(k.length, O + 1)), O === -1)
          throw new Error(Ht("vxe.error.unableInsert"));
        k.splice(O, 0, ...$), N.splice(e.findRowIndexOf(N, w), 0, ...$), E.forEach((F) => {
          const { row: j, rowspan: Z } = F;
          j > O ? F.row = j + $.length : j + Z > O && (F.rowspan = Z + $.length);
        });
      }
      const { insertMaps: D } = S;
      return $.forEach((O) => {
        const F = yt(e, O);
        D[F] = O;
      }), e.cacheRowMap(), e.updateScrollYStatus(), e.handleTableData(y && K), y && K || e.updateAfterDataIndex(), e.updateFooter(), e.checkSelectionStatus(), n.scrollYLoad && e.updateScrollYSpace(), xe().then(() => (e.updateCellAreas(), e.recalculate())).then(() => ({
        row: $.length ? $[$.length - 1] : null,
        rows: $
      }));
    };
    return u = {
      /**
       * 往表格中插入临时数据
       *
       * @param {*} records
       */
      insert(g) {
        return C(g, null);
      },
      /**
       * 往表格指定行中插入临时数据
       * 如果 row 为空则从插入到顶部，如果为树结构，则插入到目标节点顶部
       * 如果 row 为 -1 则从插入到底部，如果为树结构，则插入到目标节点底部
       * 如果 row 为有效行则插入到该行的位置，如果为树结构，则有插入到效的目标节点该行的位置
       * @param {Object/Array} records 新的数据
       * @param {Row} row 指定行
       */
      insertAt(g, w) {
        return C(g, w);
      },
      insertNextAt(g, w) {
        return C(g, w, !0);
      },
      /**
       * 删除指定行数据
       * 如果传 row 则删除一行
       * 如果传 rows 则删除多行
       * 如果为空则删除所有
       */
      remove(g) {
        const { treeConfig: w } = t, { mergeList: b, editStore: y, selectCheckboxMaps: E } = n, { tableFullTreeData: S, afterFullData: _, tableFullData: k } = o, N = i.value, L = s.value, { transform: R, mapChildrenField: H } = L, K = L.children || L.childrenField, { actived: U, removeMaps: W, insertMaps: A } = y, { checkField: $ } = N;
        let D = [];
        if (g ? I.isArray(g) || (g = [g]) : g = k, g.forEach((O) => {
          if (!e.isInsertByRow(O)) {
            const F = yt(e, O);
            W[F] = O;
          }
        }), !$) {
          const O = { ...E };
          g.forEach((F) => {
            const j = yt(e, F);
            O[j] && delete O[j];
          }), n.selectCheckboxMaps = O;
        }
        return k === g ? (g = D = k.slice(0), o.tableFullData = [], o.afterFullData = [], e.clearMergeCells()) : w && R ? g.forEach((O) => {
          const F = yt(e, O), j = I.findTree(S, (de) => F === yt(e, de), { children: H });
          if (j) {
            const de = j.items.splice(j.index, 1);
            D.push(de[0]);
          }
          const Z = I.findTree(S, (de) => F === yt(e, de), { children: K });
          Z && Z.items.splice(Z.index, 1);
          const te = e.findRowIndexOf(_, O);
          te > -1 && _.splice(te, 1);
        }) : g.forEach((O) => {
          const F = e.findRowIndexOf(k, O);
          if (F > -1) {
            const Z = k.splice(F, 1);
            D.push(Z[0]);
          }
          const j = e.findRowIndexOf(_, O);
          j > -1 && (b.forEach((Z) => {
            const { row: te, rowspan: de } = Z;
            te > j ? Z.row = te - 1 : te + de > j && (Z.rowspan = de - 1);
          }), _.splice(j, 1));
        }), U.row && e.findRowIndexOf(g, U.row) > -1 && u.clearEdit(), g.forEach((O) => {
          const F = yt(e, O);
          A[F] && delete A[F];
        }), e.updateFooter(), e.cacheRowMap(), e.handleTableData(w && R), w && R || e.updateAfterDataIndex(), e.checkSelectionStatus(), n.scrollYLoad && e.updateScrollYSpace(), xe().then(() => (e.updateCellAreas(), e.recalculate())).then(() => ({ row: D.length ? D[D.length - 1] : null, rows: D }));
      },
      /**
       * 删除复选框选中的数据
       */
      removeCheckboxRow() {
        return u.remove(e.getCheckboxRecords()).then((g) => (e.clearCheckboxRow(), g));
      },
      /**
       * 删除单选框选中的数据
       */
      removeRadioRow() {
        const g = e.getRadioRecord();
        return u.remove(g || []).then((w) => (e.clearRadioRow(), w));
      },
      /**
       * 删除当前行选中的数据
       */
      removeCurrentRow() {
        const g = e.getCurrentRecord();
        return u.remove(g || []).then((w) => (e.clearCurrentRow(), w));
      },
      /**
       * 获取表格数据集，包含新增、删除、修改、标记
       */
      getRecordset() {
        return {
          insertRecords: u.getInsertRecords(),
          removeRecords: u.getRemoveRecords(),
          updateRecords: u.getUpdateRecords(),
          pendingRecords: e.getPendingRecords()
        };
      },
      /**
       * 获取新增的临时数据
       */
      getInsertRecords() {
        const { editStore: g } = n, { fullAllDataRowIdData: w } = o, { insertMaps: b } = g, y = [];
        return I.each(b, (E, S) => {
          w[S] && y.push(E);
        }), y;
      },
      /**
       * 获取已删除的数据
       */
      getRemoveRecords() {
        const { editStore: g } = n, { removeMaps: w } = g, b = [];
        return I.each(w, (y) => {
          b.push(y);
        }), b;
      },
      /**
       * 获取更新数据
       * 只精准匹配 row 的更改
       * 如果是树表格，子节点更改状态不会影响父节点的更新状态
       */
      getUpdateRecords() {
        const { keepSource: g, treeConfig: w } = t, { tableFullData: b } = o, y = s.value;
        return g ? (m(), w ? I.filterTree(b, (E) => e.isUpdateByRow(E), y) : b.filter((E) => e.isUpdateByRow(E))) : [];
      },
      getActiveRecord() {
        return process.env.NODE_ENV === "development" && qt("vxe.error.delFunc", ["getActiveRecord", "getEditRecord"]), this.getEditRecord();
      },
      getEditRecord() {
        const { editStore: g } = n, { afterFullData: w } = o, b = l.value, { args: y, row: E } = g.actived;
        return y && e.findRowIndexOf(w, E) > -1 && b.querySelectorAll(".vxe-body--column.col--active").length ? Object.assign({}, y) : null;
      },
      /**
       * 获取选中的单元格
       */
      getSelectedCell() {
        const { editStore: g } = n, { args: w, column: b } = g.selected;
        return w && b ? Object.assign({}, w) : null;
      },
      clearActived(g) {
        return process.env.NODE_ENV === "development" && qt("vxe.error.delFunc", ["clearActived", "clearEdit"]), this.clearEdit(g);
      },
      /**
       * 清除激活的编辑
       */
      clearEdit(g) {
        const { editStore: w } = n, { actived: b, focused: y } = w, { row: E, column: S } = b;
        return (E || S) && (m(), b.args = null, b.row = null, b.column = null, e.updateFooter(), e.dispatchEvent("edit-closed", {
          row: E,
          rowIndex: e.getRowIndex(E),
          $rowIndex: e.getVMRowIndex(E),
          column: S,
          columnIndex: e.getColumnIndex(S),
          $columnIndex: e.getVMColumnIndex(S)
        }, g || null)), ee.cellVaildMode === "obsolete" && e.clearValidate ? e.clearValidate() : (y.row = null, y.column = null, xe());
      },
      /**
       * 清除所选中源状态
       */
      clearSelected() {
        const { editStore: g } = n, { selected: w } = g;
        return w.row = null, w.column = null, h(), xe();
      },
      isActiveByRow(g) {
        return process.env.NODE_ENV === "development" && qt("vxe.error.delFunc", ["isActiveByRow", "isEditByRow"]), this.isEditByRow(g);
      },
      /**
       * 判断行是否为激活编辑状态
       * @param {Row} row 行对象
       */
      isEditByRow(g) {
        const { editStore: w } = n;
        return w.actived.row === g;
      },
      setActiveRow(g) {
        return process.env.NODE_ENV === "development" && qt("vxe.error.delFunc", ["setActiveRow", "setEditRow"]), u.setEditRow(g);
      },
      /**
       * 激活行编辑
       */
      setEditRow(g, w) {
        const { visibleColumn: b } = o;
        let y = I.find(b, (E) => mn(E.editRender));
        return w && (y = I.isString(w) ? e.getColumnByField(w) : w), e.setEditCell(g, y);
      },
      setActiveCell(g, w) {
        return process.env.NODE_ENV === "development" && qt("vxe.error.delFunc", ["setActiveCell", "setEditCell"]), u.setEditCell(g, w);
      },
      /**
       * 激活单元格编辑
       */
      setEditCell(g, w) {
        const { editConfig: b } = t, y = I.isString(w) ? e.getColumnByField(w) : w;
        return g && y && mn(b) && mn(y.editRender) ? e.scrollToRow(g, y).then(() => {
          const E = e.getCell(g, y);
          return E && (d.handleActived({
            row: g,
            rowIndex: e.getRowIndex(g),
            column: y,
            columnIndex: e.getColumnIndex(y),
            cell: E,
            $table: e
          }), o._lastCallTime = Date.now()), xe();
        }) : xe();
      },
      /**
       * 只对 trigger=dblclick 有效，选中单元格
       */
      setSelectCell(g, w) {
        const { tableData: b } = n, y = r.value, E = I.isString(w) ? e.getColumnByField(w) : w;
        if (g && E && y.trigger !== "manual") {
          const S = e.findRowIndexOf(b, g);
          if (S > -1 && E) {
            const _ = e.getCell(g, E), k = {
              row: g,
              rowIndex: S,
              column: E,
              columnIndex: e.getColumnIndex(E),
              cell: _
            };
            e.handleSelected(k, {});
          }
        }
        return xe();
      }
    }, d = {
      /**
       * 处理激活编辑
       */
      handleActived(g, w) {
        const { editConfig: b, mouseConfig: y } = t, { editStore: E, tableColumn: S } = n, _ = r.value, { mode: k } = _, { actived: N, focused: L } = E, { row: R, column: H } = g, { editRender: K } = H, U = g.cell || e.getCell(R, H), W = _.beforeEditMethod || _.activeMethod;
        if (g.cell = U, U && mn(b) && mn(K) && !e.hasPendingByRow(R)) {
          if (N.row !== R || k === "cell" && N.column !== H) {
            let A = "edit-disabled";
            if (!W || W({ ...g, $table: e, $grid: e.xegrid })) {
              y && (u.clearSelected(), e.clearCellAreas && (e.clearCellAreas(), e.clearCopyCellArea())), e.closeTooltip(), N.column && u.clearEdit(w), A = "edit-activated", H.renderHeight = U.offsetHeight, N.args = g, N.row = R, N.column = H, k === "row" ? S.forEach((D) => f(R, D)) : f(R, H);
              const $ = _.afterEditMethod;
              xe(() => {
                d.handleFocus(g, w), $ && $({ ...g, $table: e, $grid: e.xegrid });
              });
            }
            e.dispatchEvent(A, {
              row: R,
              rowIndex: e.getRowIndex(R),
              $rowIndex: e.getVMRowIndex(R),
              column: H,
              columnIndex: e.getColumnIndex(H),
              $columnIndex: e.getVMColumnIndex(H)
            }, w), A === "edit-activated" && e.dispatchEvent("edit-actived", {
              row: R,
              rowIndex: e.getRowIndex(R),
              $rowIndex: e.getVMRowIndex(R),
              column: H,
              columnIndex: e.getColumnIndex(H),
              $columnIndex: e.getVMColumnIndex(H)
            }, w);
          } else {
            const { column: A } = N;
            if (y && (u.clearSelected(), e.clearCellAreas && (e.clearCellAreas(), e.clearCopyCellArea())), A !== H) {
              const { model: $ } = A;
              $.update && Or(R, A, $.value), e.clearValidate && e.clearValidate(R, H);
            }
            H.renderHeight = U.offsetHeight, N.args = g, N.column = H, setTimeout(() => {
              d.handleFocus(g, w);
            });
          }
          L.column = null, L.row = null, e.focus();
        }
        return xe();
      },
      /**
       * 处理聚焦
       */
      handleFocus(g) {
        const { row: w, column: b, cell: y } = g, { editRender: E } = b;
        if (mn(E)) {
          const S = fi.get(E.name);
          let { autofocus: _, autoselect: k } = E, N;
          if (!_ && S && (_ = S.autofocus), !k && S && (k = S.autoselect), I.isFunction(_) ? N = _.call(this, g) : _ && (N = y.querySelector(_), N && N.focus()), N) {
            if (k)
              N.select();
            else if (Jl.msie) {
              const L = N.createTextRange();
              L.collapse(!1), L.select();
            }
          } else
            e.scrollToRow(w, b);
        }
      },
      /**
       * 处理选中源
       */
      handleSelected(g, w) {
        const { mouseConfig: b } = t, { editStore: y } = n, E = a.value, S = r.value, { actived: _, selected: k } = y, { row: N, column: L } = g, R = b && E.selected;
        return R && (k.row !== N || k.column !== L) && (_.row !== N || S.mode === "cell" && _.column !== L) && (u.clearEdit(w), u.clearSelected(), e.clearCellAreas && (e.clearCellAreas(), e.clearCopyCellArea()), k.args = g, k.row = N, k.column = L, R && d.addCellSelectedClass(), e.focus(), w && e.dispatchEvent("cell-selected", g, w)), xe();
      },
      addCellSelectedClass() {
        const { editStore: g } = n, { selected: w } = g, { row: b, column: y } = w;
        if (h(), b && y) {
          const E = e.getCell(b, y);
          E && Mr(E, "col--selected");
        }
      }
    }, { ...u, ...d };
  },
  setupGrid(e) {
    return e.extendTableMethods(bwe);
  }
}, c1 = {
  install() {
    $t.hooks.add("$tableEdit", ywe);
  }
}, Cwe = c1;
function Po(e) {
  const t = ot("xesize", null), n = x(() => e.size || (t ? t.value : null));
  return Mt("xesize", n), n;
}
const Tl = Q({
  name: "VxeButton",
  props: {
    /**
     * 按钮类型
     */
    type: String,
    mode: String,
    className: [String, Function],
    popupClassName: [String, Function],
    /**
     * 按钮尺寸
     */
    size: { type: String, default: () => ee.button.size || ee.size },
    /**
     * 用来标识这一项
     */
    name: [String, Number],
    /**
     * 按钮内容
     */
    content: String,
    /**
     * 固定显示下拉面板的方向
     */
    placement: String,
    /**
     * 按钮状态
     */
    status: String,
    /**
     * 标题
     */
    title: String,
    /**
     * 按钮的图标
     */
    icon: String,
    /**
     * 圆角边框
     */
    round: Boolean,
    /**
     * 圆角按钮
     */
    circle: Boolean,
    /**
     * 是否禁用
     */
    disabled: Boolean,
    /**
     * 是否加载中
     */
    loading: Boolean,
    /**
     * 在下拉面板关闭时销毁内容
     */
    destroyOnClose: Boolean,
    /**
     * 是否将弹框容器插入于 body 内
     */
    transfer: { type: Boolean, default: () => ee.button.transfer }
  },
  emits: [
    "click",
    "mouseenter",
    "mouseleave",
    "dropdown-click"
  ],
  setup(e, t) {
    const { slots: n, emit: o } = t, l = I.uniqueId(), a = Po(e), r = en({
      inited: !1,
      showPanel: !1,
      animatVisible: !1,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: ""
    }), i = {
      showTime: null
    }, s = B(), u = B(), d = B(), f = {
      refElem: s
    }, v = {
      xID: l,
      props: e,
      context: t,
      reactData: r,
      internalData: i,
      getRefMaps: () => f
    }, h = ot("$xebuttongroup", null);
    let m = {};
    const p = x(() => {
      const { type: D } = e;
      return D ? ["submit", "reset", "button"].indexOf(D) > -1 : !1;
    }), C = x(() => {
      const { type: D, mode: O } = e;
      return O === "text" || D === "text" || h && h.props.mode === "text" ? "text" : "button";
    }), g = x(() => {
      const { status: D } = e;
      return D || (h ? h.props.status : "");
    }), w = x(() => {
      const { round: D } = e;
      return D || (h ? h.props.round : !1);
    }), b = x(() => {
      const { circle: D } = e;
      return D || (h ? h.props.circle : !1);
    }), y = () => {
      r.panelIndex < Yr() && (r.panelIndex = dr());
    }, E = () => xe().then(() => {
      const { transfer: D, placement: O } = e, { panelIndex: F } = r, j = u.value, Z = d.value;
      if (Z && j) {
        const te = j.offsetHeight, de = j.offsetWidth, Oe = Z.offsetHeight, ce = Z.offsetWidth, ne = 5, Y = {
          zIndex: F
        }, { top: ve, left: ie, boundingTop: he, visibleHeight: De, visibleWidth: $e } = lr(j);
        let ue = "bottom";
        if (D) {
          let Ne = ie + de - ce, je = ve + te;
          O === "top" ? (ue = "top", je = ve - Oe) : O || (he + te + Oe + ne > De && (ue = "top", je = ve - Oe), je < ne && (ue = "bottom", je = ve + te)), Ne + ce + ne > $e && (Ne -= Ne + ce + ne - $e), Ne < ne && (Ne = ne), Object.assign(Y, {
            left: `${Ne}px`,
            right: "auto",
            top: `${je}px`,
            minWidth: `${de}px`
          });
        } else
          O === "top" ? (ue = "top", Y.bottom = `${te}px`) : O || he + te + Oe > De && he - te - Oe > ne && (ue = "top", Y.bottom = `${te}px`);
        return r.panelStyle = Y, r.panelPlacement = ue, xe();
      }
    }), S = (D) => {
      h ? h.handleClick({ name: e.name }, D) : m.dispatchEvent("click", { $event: D }, D);
    }, _ = (D) => {
      D.button === 0 && D.stopPropagation();
    }, k = (D) => {
      const O = D.currentTarget, F = d.value, { flag: j, targetElem: Z } = _n(D, O, "vxe-button");
      j && (F && (F.dataset.active = "N"), r.showPanel = !1, setTimeout(() => {
        (!F || F.dataset.active !== "Y") && (r.animatVisible = !1);
      }, 350), m.dispatchEvent("dropdown-click", { name: Z.getAttribute("name"), $event: D }, D));
    }, N = () => {
      const D = d.value;
      D && (D.dataset.active = "Y", r.animatVisible = !0, setTimeout(() => {
        D.dataset.active === "Y" && (r.showPanel = !0, y(), E(), setTimeout(() => {
          r.showPanel && E();
        }, 50));
      }, 20));
    }, L = (D) => {
      const O = d.value;
      O && (O.dataset.active = "Y", r.inited || (r.inited = !0), i.showTime = setTimeout(() => {
        O.dataset.active === "Y" ? N() : r.animatVisible = !1;
      }, 250)), H(D);
    }, R = (D) => {
      U(), K(D);
    }, H = (D) => {
      o("mouseenter", { $event: D });
    }, K = (D) => {
      o("mouseleave", { $event: D });
    }, U = () => {
      const D = d.value;
      clearTimeout(i.showTime), D ? (D.dataset.active = "N", setTimeout(() => {
        D.dataset.active !== "Y" && (r.showPanel = !1, setTimeout(() => {
          D.dataset.active !== "Y" && (r.animatVisible = !1);
        }, 350));
      }, 100)) : (r.animatVisible = !1, r.showPanel = !1);
    }, W = () => {
      U();
    }, A = () => {
      const { content: D, icon: O, loading: F } = e, j = [];
      return F ? j.push(V("i", {
        class: ["vxe-button--loading-icon", ee.icon.BUTTON_LOADING]
      })) : n.icon ? j.push(V("span", {
        class: "vxe-button--custom-icon"
      }, n.icon({}))) : O && j.push(V("i", {
        class: ["vxe-button--icon", O]
      })), n.default ? j.push(V("span", {
        class: "vxe-button--content"
      }, n.default({}))) : D && j.push(V("span", {
        class: "vxe-button--content"
      }, vo(D))), j;
    };
    m = {
      dispatchEvent(D, O, F) {
        o(D, Object.assign({ $button: v, $event: F }, O));
      },
      focus() {
        return u.value.focus(), xe();
      },
      blur() {
        return u.value.blur(), xe();
      }
    }, Object.assign(v, m), Nt(() => {
      wn.on(v, "mousewheel", (D) => {
        const O = d.value;
        r.showPanel && !_n(D, O).flag && U();
      });
    }), wo(() => {
      wn.off(v, "mousewheel");
    });
    const $ = () => {
      const { className: D, popupClassName: O, transfer: F, title: j, type: Z, destroyOnClose: te, name: de, disabled: Oe, loading: ce } = e, { inited: ne, showPanel: Y } = r, ve = p.value, ie = C.value, he = g.value, De = w.value, $e = b.value, ue = a.value;
      return n.dropdowns ? V("div", {
        ref: s,
        class: ["vxe-button--dropdown", D ? I.isFunction(D) ? D({ $button: v }) : D : "", {
          [`size--${ue}`]: ue,
          "is--active": Y
        }]
      }, [
        V("button", {
          ref: u,
          class: ["vxe-button", `type--${ie}`, {
            [`size--${ue}`]: ue,
            [`theme--${he}`]: he,
            "is--round": De,
            "is--circle": $e,
            "is--disabled": Oe || ce,
            "is--loading": ce
          }],
          title: j,
          name: de,
          type: ve ? Z : "button",
          disabled: Oe || ce,
          onMouseenter: L,
          onMouseleave: R,
          onClick: S
        }, A().concat([
          V("i", {
            class: `vxe-button--dropdown-arrow ${ee.icon.BUTTON_DROPDOWN}`
          })
        ])),
        V(ka, {
          to: "body",
          disabled: F ? !ne : !0
        }, [
          V("div", {
            ref: d,
            class: ["vxe-button--dropdown-panel", O ? I.isFunction(O) ? O({ $button: v }) : O : "", {
              [`size--${ue}`]: ue,
              "animat--leave": r.animatVisible,
              "animat--enter": Y
            }],
            placement: r.panelPlacement,
            style: r.panelStyle
          }, ne ? [
            V("div", {
              class: "vxe-button--dropdown-wrapper",
              onMousedown: _,
              onClick: k,
              onMouseenter: N,
              onMouseleave: W
            }, te && !Y ? [] : n.dropdowns({}))
          ] : [])
        ])
      ]) : V("button", {
        ref: u,
        class: ["vxe-button", `type--${ie}`, D ? I.isFunction(D) ? D({ $button: v }) : D : "", {
          [`size--${ue}`]: ue,
          [`theme--${he}`]: he,
          "is--round": De,
          "is--circle": $e,
          "is--disabled": Oe || ce,
          "is--loading": ce
        }],
        title: j,
        name: de,
        type: ve ? Z : "button",
        disabled: Oe || ce,
        onClick: S,
        onMouseenter: H,
        onMouseleave: K
      }, A());
    };
    return v.renderVN = $, v;
  },
  render() {
    return this.renderVN();
  }
}), Bm = Q({
  name: "VxeLoading",
  props: {
    modelValue: Boolean,
    icon: String,
    text: String
  },
  setup(e, { slots: t }) {
    const n = x(() => e.icon || ee.icon.LOADING), o = x(() => {
      const l = ee.loadingText;
      return e.text || (l === null ? l : ee.i18n("vxe.loading.text"));
    });
    return () => {
      const l = n.value, a = o.value;
      return V("div", {
        class: ["vxe-loading", {
          "is--visible": e.modelValue
        }]
      }, t.default ? [
        V("div", {
          class: "vxe-loading--wrapper"
        }, t.default({}))
      ] : [
        V("div", {
          class: "vxe-loading--chunk"
        }, [
          l ? V("i", {
            class: l
          }) : V("div", {
            class: "vxe-loading--spinner"
          }),
          a ? V("div", {
            class: "vxe-loading--text"
          }, `${a}`) : null
        ])
      ]);
    };
  }
}), uh = Object.assign(Bm, {
  install(e) {
    e.component(Bm.name, Bm);
  }
}), pi = [], Fu = [], ws = Q({
  name: "VxeModal",
  props: {
    modelValue: Boolean,
    id: String,
    type: { type: String, default: "modal" },
    loading: { type: Boolean, default: null },
    status: String,
    iconStatus: String,
    className: String,
    top: { type: [Number, String], default: () => ee.modal.top },
    position: [String, Object],
    title: String,
    duration: { type: [Number, String], default: () => ee.modal.duration },
    message: [Number, String],
    content: [Number, String],
    cancelButtonText: { type: String, default: () => ee.modal.cancelButtonText },
    confirmButtonText: { type: String, default: () => ee.modal.confirmButtonText },
    lockView: { type: Boolean, default: () => ee.modal.lockView },
    lockScroll: Boolean,
    mask: { type: Boolean, default: () => ee.modal.mask },
    maskClosable: { type: Boolean, default: () => ee.modal.maskClosable },
    escClosable: { type: Boolean, default: () => ee.modal.escClosable },
    resize: Boolean,
    showHeader: { type: Boolean, default: () => ee.modal.showHeader },
    showFooter: { type: Boolean, default: () => ee.modal.showFooter },
    showZoom: Boolean,
    showClose: { type: Boolean, default: () => ee.modal.showClose },
    dblclickZoom: { type: Boolean, default: () => ee.modal.dblclickZoom },
    width: [Number, String],
    height: [Number, String],
    minWidth: { type: [Number, String], default: () => ee.modal.minWidth },
    minHeight: { type: [Number, String], default: () => ee.modal.minHeight },
    zIndex: Number,
    marginSize: { type: [Number, String], default: () => ee.modal.marginSize },
    fullscreen: Boolean,
    draggable: { type: Boolean, default: () => ee.modal.draggable },
    remember: { type: Boolean, default: () => ee.modal.remember },
    destroyOnClose: { type: Boolean, default: () => ee.modal.destroyOnClose },
    showTitleOverflow: { type: Boolean, default: () => ee.modal.showTitleOverflow },
    transfer: { type: Boolean, default: () => ee.modal.transfer },
    storage: { type: Boolean, default: () => ee.modal.storage },
    storageKey: { type: String, default: () => ee.modal.storageKey },
    animat: { type: Boolean, default: () => ee.modal.animat },
    size: { type: String, default: () => ee.modal.size || ee.size },
    beforeHideMethod: { type: Function, default: () => ee.modal.beforeHideMethod },
    slots: Object
  },
  emits: [
    "update:modelValue",
    "show",
    "hide",
    "before-hide",
    "close",
    "confirm",
    "cancel",
    "zoom"
  ],
  setup(e, t) {
    const { slots: n, emit: o } = t, l = I.uniqueId(), a = Po(e), r = en({
      inited: !1,
      visible: !1,
      contentVisible: !1,
      modalTop: 0,
      modalZindex: 0,
      zoomLocat: null,
      firstOpen: !0
    }), i = B(), s = B(), u = B(), d = B(), f = {
      refElem: i
    }, v = {
      xID: l,
      props: e,
      context: t,
      reactData: r,
      getRefMaps: () => f
    };
    let h = {};
    const m = x(() => e.type === "message"), p = () => s.value, C = () => {
      const { width: $e, height: ue } = e, Ne = p();
      return Ne.style.width = `${$e ? isNaN($e) ? $e : `${$e}px` : ""}`, Ne.style.height = `${ue ? isNaN(ue) ? ue : `${ue}px` : ""}`, xe();
    }, g = () => {
      const { zIndex: $e } = e, { modalZindex: ue } = r;
      $e ? r.modalZindex = $e : ue < Yr() && (r.modalZindex = dr());
    }, w = () => xe().then(() => {
      const { position: $e } = e, ue = I.toNumber(e.marginSize), Ne = p(), je = document.documentElement.clientWidth || document.body.clientWidth, Fe = document.documentElement.clientHeight || document.body.clientHeight, Ve = $e === "center", { top: Ze, left: ae } = I.isString($e) ? { top: $e, left: $e } : Object.assign({}, $e), pe = Ve || Ze === "center", ke = Ve || ae === "center";
      let Ue = "", Xe = "";
      ae && !ke ? Xe = isNaN(ae) ? ae : `${ae}px` : Xe = `${Math.max(ue, je / 2 - Ne.offsetWidth / 2)}px`, Ze && !pe ? Ue = isNaN(Ze) ? Ze : `${Ze}px` : Ue = `${Math.max(ue, Fe / 2 - Ne.offsetHeight / 2)}px`, Ne.style.top = Ue, Ne.style.left = Xe;
    }), b = () => {
      xe(() => {
        let $e = 0;
        Fu.forEach((ue) => {
          const Ne = ue.getBox();
          $e += I.toNumber(ue.props.top), ue.reactData.modalTop = $e, $e += Ne.clientHeight;
        });
      });
    }, y = () => {
      Fu.indexOf(v) > -1 && I.remove(Fu, ($e) => $e === v), b();
    }, E = ($e) => {
      const { remember: ue, beforeHideMethod: Ne } = e, { visible: je } = r, Fe = m.value, Ve = { type: $e };
      return je && Promise.resolve(Ne ? Ne(Ve) : null).then((Ze) => {
        I.isError(Ze) || (Fe && y(), r.contentVisible = !1, ue || (r.zoomLocat = null), I.remove(pi, (ae) => ae === v), h.dispatchEvent("before-hide", Ve), setTimeout(() => {
          r.visible = !1, o("update:modelValue", !1), h.dispatchEvent("hide", Ve);
        }, 200));
      }).catch((Ze) => Ze), xe();
    }, S = ($e) => {
      const ue = "close";
      h.dispatchEvent(ue, { type: ue }, $e), E(ue);
    }, _ = ($e) => {
      const ue = "confirm";
      h.dispatchEvent(ue, { type: ue }, $e), E(ue);
    }, k = ($e) => {
      const ue = "cancel";
      h.dispatchEvent(ue, { type: ue }, $e), E(ue);
    }, N = ($e) => {
      const ue = ee.version, Ne = I.toStringJSON(localStorage.getItem($e) || "");
      return Ne && Ne._v === ue ? Ne : { _v: ue };
    }, L = () => {
      const { id: $e, remember: ue, storage: Ne, storageKey: je } = e;
      return !!($e && ue && Ne && N(je)[$e]);
    }, R = () => {
      const { id: $e, remember: ue, storage: Ne, storageKey: je } = e;
      if ($e && ue && Ne) {
        const Fe = N(je)[$e];
        if (Fe) {
          const Ve = p(), [Ze, ae, pe, ke, Ue, Xe, re, Te] = Fe.split(",");
          Ze && (Ve.style.left = `${Ze}px`), ae && (Ve.style.top = `${ae}px`), pe && (Ve.style.width = `${pe}px`), ke && (Ve.style.height = `${ke}px`), Ue && Xe && (r.zoomLocat = {
            left: Ue,
            top: Xe,
            width: re,
            height: Te
          });
        }
      }
    }, H = () => {
      Fu.indexOf(v) === -1 && Fu.push(v), b();
    }, K = () => {
      const { id: $e, remember: ue, storage: Ne, storageKey: je } = e, { zoomLocat: Fe } = r;
      if ($e && ue && Ne) {
        const Ve = p(), Ze = N(je);
        Ze[$e] = [
          Ve.style.left,
          Ve.style.top,
          Ve.style.width,
          Ve.style.height
        ].concat(Fe ? [
          Fe.left,
          Fe.top,
          Fe.width,
          Fe.height
        ] : []).map((ae) => ae ? I.toNumber(ae) : "").join(","), localStorage.setItem(je, I.toJSONString(Ze));
      }
    }, U = () => xe().then(() => {
      if (!r.zoomLocat) {
        const $e = Math.max(0, I.toNumber(e.marginSize)), ue = p(), { visibleHeight: Ne, visibleWidth: je } = Cs();
        r.zoomLocat = {
          top: ue.offsetTop,
          left: ue.offsetLeft,
          width: ue.offsetWidth + (ue.style.width ? 0 : 1),
          height: ue.offsetHeight + (ue.style.height ? 0 : 1)
        }, Object.assign(ue.style, {
          top: `${$e}px`,
          left: `${$e}px`,
          width: `${je - $e * 2}px`,
          height: `${Ne - $e * 2}px`
        }), K();
      }
    }), W = () => {
      const { duration: $e, remember: ue, showFooter: Ne } = e, { inited: je, visible: Fe } = r, Ve = m.value;
      return je || (r.inited = !0), Fe || (ue || C(), r.visible = !0, r.contentVisible = !1, g(), pi.push(v), setTimeout(() => {
        r.contentVisible = !0, xe(() => {
          if (Ne) {
            const pe = u.value, ke = d.value, Ue = pe || ke;
            Ue && Ue.focus();
          }
          const ae = { type: "" };
          o("update:modelValue", !0), h.dispatchEvent("show", ae);
        });
      }, 10), Ve ? (H(), $e !== -1 && setTimeout(() => E("close"), I.toNumber($e))) : xe(() => {
        const { fullscreen: Ze } = e, { firstOpen: ae } = r;
        (!ue || ae) && w().then(() => {
          setTimeout(() => w(), 20);
        }), ae ? (r.firstOpen = !1, L() ? R() : Ze && xe(() => U())) : Ze && xe(() => U());
      })), xe();
    }, A = ($e) => {
      const ue = i.value;
      e.maskClosable && $e.target === ue && E("mask");
    }, $ = ($e) => {
      if (Cn($e, un.ESCAPE)) {
        const Ne = I.max(pi, (je) => je.reactData.modalZindex);
        Ne && setTimeout(() => {
          Ne === v && Ne.props.escClosable && E("exit");
        }, 10);
      }
    }, D = () => !!r.zoomLocat, O = () => xe().then(() => {
      const { zoomLocat: $e } = r;
      if ($e) {
        const ue = p();
        r.zoomLocat = null, Object.assign(ue.style, {
          top: `${$e.top}px`,
          left: `${$e.left}px`,
          width: `${$e.width}px`,
          height: `${$e.height}px`
        }), K();
      }
    }), F = () => r.zoomLocat ? O().then(() => D()) : U().then(() => D()), j = ($e) => {
      const { zoomLocat: ue } = r, Ne = { type: ue ? "revert" : "max" };
      return F().then(() => {
        h.dispatchEvent("zoom", Ne, $e);
      });
    }, Z = () => {
      if (!m.value) {
        const ue = p();
        if (ue)
          return {
            top: ue.offsetTop,
            left: ue.offsetLeft
          };
      }
      return null;
    }, te = ($e, ue) => {
      if (!m.value) {
        const je = p();
        I.isNumber($e) && (je.style.top = `${$e}px`), I.isNumber(ue) && (je.style.left = `${ue}px`);
      }
      return xe();
    }, de = () => {
      const { modalZindex: $e } = r;
      pi.some((ue) => ue.reactData.visible && ue.reactData.modalZindex > $e) && g();
    }, Oe = ($e) => {
      const { remember: ue, storage: Ne } = e, { zoomLocat: je } = r, Fe = I.toNumber(e.marginSize), Ve = p();
      if (!je && $e.button === 0 && !_n($e, Ve, "trigger--btn").flag) {
        $e.preventDefault();
        const Ze = document.onmousemove, ae = document.onmouseup, pe = $e.clientX - Ve.offsetLeft, ke = $e.clientY - Ve.offsetTop, { visibleHeight: Ue, visibleWidth: Xe } = Cs();
        document.onmousemove = (re) => {
          re.preventDefault();
          const Te = Ve.offsetWidth, Ce = Ve.offsetHeight, Le = Fe, ge = Xe - Te - Fe - 1, Ee = Fe, me = Ue - Ce - Fe - 1;
          let Ke = re.clientX - pe, Re = re.clientY - ke;
          Ke > ge && (Ke = ge), Ke < Le && (Ke = Le), Re > me && (Re = me), Re < Ee && (Re = Ee), Ve.style.left = `${Ke}px`, Ve.style.top = `${Re}px`, Ve.className = Ve.className.replace(/\s?is--drag/, "") + " is--drag";
        }, document.onmouseup = () => {
          document.onmousemove = Ze, document.onmouseup = ae, ue && Ne && xe(() => {
            K();
          }), setTimeout(() => {
            Ve.className = Ve.className.replace(/\s?is--drag/, "");
          }, 50);
        };
      }
    }, ce = ($e) => {
      $e.preventDefault();
      const { remember: ue, storage: Ne } = e, { visibleHeight: je, visibleWidth: Fe } = Cs(), Ve = I.toNumber(e.marginSize), ae = $e.target.getAttribute("type"), pe = I.toNumber(e.minWidth), ke = I.toNumber(e.minHeight), Ue = Fe, Xe = je, re = p(), Te = document.onmousemove, Ce = document.onmouseup, Le = re.clientWidth, ge = re.clientHeight, Ee = $e.clientX, me = $e.clientY, Ke = re.offsetTop, Re = re.offsetLeft, we = { type: "resize" };
      document.onmousemove = (ze) => {
        ze.preventDefault();
        let Je, Me, et, mt;
        switch (ae) {
          case "wl":
            Je = Ee - ze.clientX, et = Je + Le, Re - Je > Ve && et > pe && (re.style.width = `${et < Ue ? et : Ue}px`, re.style.left = `${Re - Je}px`);
            break;
          case "swst":
            Je = Ee - ze.clientX, Me = me - ze.clientY, et = Je + Le, mt = Me + ge, Re - Je > Ve && et > pe && (re.style.width = `${et < Ue ? et : Ue}px`, re.style.left = `${Re - Je}px`), Ke - Me > Ve && mt > ke && (re.style.height = `${mt < Xe ? mt : Xe}px`, re.style.top = `${Ke - Me}px`);
            break;
          case "swlb":
            Je = Ee - ze.clientX, Me = ze.clientY - me, et = Je + Le, mt = Me + ge, Re - Je > Ve && et > pe && (re.style.width = `${et < Ue ? et : Ue}px`, re.style.left = `${Re - Je}px`), Ke + mt + Ve < je && mt > ke && (re.style.height = `${mt < Xe ? mt : Xe}px`);
            break;
          case "st":
            Me = me - ze.clientY, mt = ge + Me, Ke - Me > Ve && mt > ke && (re.style.height = `${mt < Xe ? mt : Xe}px`, re.style.top = `${Ke - Me}px`);
            break;
          case "wr":
            Je = ze.clientX - Ee, et = Je + Le, Re + et + Ve < Fe && et > pe && (re.style.width = `${et < Ue ? et : Ue}px`);
            break;
          case "sest":
            Je = ze.clientX - Ee, Me = me - ze.clientY, et = Je + Le, mt = Me + ge, Re + et + Ve < Fe && et > pe && (re.style.width = `${et < Ue ? et : Ue}px`), Ke - Me > Ve && mt > ke && (re.style.height = `${mt < Xe ? mt : Xe}px`, re.style.top = `${Ke - Me}px`);
            break;
          case "selb":
            Je = ze.clientX - Ee, Me = ze.clientY - me, et = Je + Le, mt = Me + ge, Re + et + Ve < Fe && et > pe && (re.style.width = `${et < Ue ? et : Ue}px`), Ke + mt + Ve < je && mt > ke && (re.style.height = `${mt < Xe ? mt : Xe}px`);
            break;
          case "sb":
            Me = ze.clientY - me, mt = Me + ge, Ke + mt + Ve < je && mt > ke && (re.style.height = `${mt < Xe ? mt : Xe}px`);
            break;
        }
        re.className = re.className.replace(/\s?is--drag/, "") + " is--drag", ue && Ne && K(), h.dispatchEvent("zoom", we, ze);
      }, document.onmouseup = () => {
        r.zoomLocat = null, document.onmousemove = Te, document.onmouseup = Ce, setTimeout(() => {
          re.className = re.className.replace(/\s?is--drag/, "");
        }, 50);
      };
    }, ne = () => {
      const { slots: $e = {}, showClose: ue, showZoom: Ne, title: je } = e, { zoomLocat: Fe } = r, Ve = n.title || $e.title, Ze = n.corner || $e.corner, ae = [
        V("div", {
          class: "vxe-modal--header-title"
        }, Ve ? oo(Ve({ $modal: v })) : je ? vo(je) : ee.i18n("vxe.alert.title"))
      ], pe = [];
      return Ze && pe.push(V("span", {
        class: "vxe-modal--corner-wrapper"
      }, oo(Ze({ $modal: v })))), Ne && pe.push(V("i", {
        class: ["vxe-modal--zoom-btn", "trigger--btn", Fe ? ee.icon.MODAL_ZOOM_OUT : ee.icon.MODAL_ZOOM_IN],
        title: ee.i18n(`vxe.modal.zoom${Fe ? "Out" : "In"}`),
        onClick: j
      })), ue && pe.push(V("i", {
        class: ["vxe-modal--close-btn", "trigger--btn", ee.icon.MODAL_CLOSE],
        title: ee.i18n("vxe.modal.close"),
        onClick: S
      })), ae.push(V("div", {
        class: "vxe-modal--header-right"
      }, pe)), ae;
    }, Y = () => {
      const { slots: $e = {}, showZoom: ue, draggable: Ne } = e, je = m.value, Fe = n.header || $e.header, Ve = [];
      if (e.showHeader) {
        const Ze = {};
        Ne && (Ze.onMousedown = Oe), ue && e.dblclickZoom && e.type === "modal" && (Ze.onDblclick = j), Ve.push(V("div", {
          class: ["vxe-modal--header", {
            "is--draggable": Ne,
            "is--ellipsis": !je && e.showTitleOverflow
          }],
          ...Ze
        }, Fe ? !r.inited || e.destroyOnClose && !r.visible ? [] : oo(Fe({ $modal: v })) : ne()));
      }
      return Ve;
    }, ve = () => {
      const { slots: $e = {}, status: ue, message: Ne } = e, je = e.content || Ne, Fe = m.value, Ve = n.default || $e.default, Ze = [];
      return ue && Ze.push(V("div", {
        class: "vxe-modal--status-wrapper"
      }, [
        V("i", {
          class: ["vxe-modal--status-icon", e.iconStatus || ee.icon[`MODAL_${ue}`.toLocaleUpperCase()]]
        })
      ])), Ze.push(V("div", {
        class: "vxe-modal--content"
      }, Ve ? !r.inited || e.destroyOnClose && !r.visible ? [] : oo(Ve({ $modal: v })) : vo(je))), Fe || Ze.push(V(uh, {
        class: "vxe-modal--loading",
        modelValue: e.loading
      })), [
        V("div", {
          class: "vxe-modal--body"
        }, Ze)
      ];
    }, ie = () => {
      const { type: $e } = e, ue = [];
      return $e === "confirm" && ue.push(V(Tl, {
        ref: d,
        content: e.cancelButtonText || ee.i18n("vxe.button.cancel"),
        onClick: k
      })), ue.push(V(Tl, {
        ref: u,
        status: "primary",
        content: e.confirmButtonText || ee.i18n("vxe.button.confirm"),
        onClick: _
      })), ue;
    }, he = () => {
      const { slots: $e = {} } = e, ue = m.value, Ne = n.footer || $e.footer, je = [];
      return e.showFooter && je.push(V("div", {
        class: "vxe-modal--footer"
      }, Ne ? !r.inited || e.destroyOnClose && !r.visible ? [] : oo(Ne({ $modal: v })) : ie())), !ue && e.resize && je.push(V("span", {
        class: "vxe-modal--resize"
      }, ["wl", "wr", "swst", "sest", "st", "swlb", "selb", "sb"].map((Fe) => V("span", {
        class: `${Fe}-resize`,
        type: Fe,
        onMousedown: ce
      })))), je;
    };
    h = {
      dispatchEvent($e, ue, Ne) {
        o($e, Object.assign({ $modal: v, $event: Ne }, ue));
      },
      open: W,
      close() {
        return E("close");
      },
      getBox: p,
      getPosition: Z,
      setPosition: te,
      isMaximized: D,
      zoom: F,
      maximize: U,
      revert: O
    }, Object.assign(v, h), Pe(() => e.width, C), Pe(() => e.height, C), Pe(() => e.modelValue, ($e) => {
      $e ? W() : E("model");
    }), Nt(() => {
      xe(() => {
        e.storage && !e.id && Ht("vxe.error.reqProp", ["modal.id"]), e.modelValue && W(), C();
      }), e.escClosable && wn.on(v, "keydown", $);
    }), wo(() => {
      wn.off(v, "keydown"), y();
    });
    const De = () => {
      const { className: $e, type: ue, animat: Ne, loading: je, status: Fe, lockScroll: Ve, lockView: Ze, mask: ae, resize: pe } = e, { inited: ke, zoomLocat: Ue, modalTop: Xe, contentVisible: re, visible: Te } = r, Ce = a.value;
      return V(ka, {
        to: "body",
        disabled: e.transfer ? !ke : !0
      }, [
        V("div", {
          ref: i,
          class: ["vxe-modal--wrapper", `type--${ue}`, $e || "", {
            [`size--${Ce}`]: Ce,
            [`status--${Fe}`]: Fe,
            "is--animat": Ne,
            "lock--scroll": Ve,
            "lock--view": Ze,
            "is--resize": pe,
            "is--mask": ae,
            "is--maximize": Ue,
            "is--visible": re,
            "is--active": Te,
            "is--loading": je
          }],
          style: {
            zIndex: r.modalZindex,
            top: Xe ? `${Xe}px` : null
          },
          onClick: A
        }, [
          V("div", {
            ref: s,
            class: "vxe-modal--box",
            onMousedown: de
          }, Y().concat(ve(), he()))
        ])
      ]);
    };
    return v.renderVN = De, v;
  },
  render() {
    return this.renderVN();
  }
});
function wwe(e) {
  if (e) {
    const t = /* @__PURE__ */ new Date();
    let n = 0, o = 0, l = 0;
    if (I.isDate(e))
      n = e.getHours(), o = e.getMinutes(), l = e.getSeconds();
    else {
      e = I.toValueString(e);
      const a = e.match(/^(\d{1,2})(:(\d{1,2}))?(:(\d{1,2}))?/);
      a && (n = I.toNumber(a[1]), o = I.toNumber(a[3]), l = I.toNumber(a[5]));
    }
    return t.setHours(n), t.setMinutes(o), t.setSeconds(l), t;
  }
  return /* @__PURE__ */ new Date("");
}
function A_(e) {
  const t = e.getMonth();
  return t < 3 ? 1 : t < 6 ? 2 : t < 9 ? 3 : 4;
}
function lc(e) {
  return I.isString(e) ? e.replace(/,/g, "") : e;
}
function F_(e, t) {
  return /^-/.test("" + e) ? I.toFixed(I.ceil(e, t), t) : I.toFixed(I.floor(e, t), t);
}
const Sr = 12, Ewe = 20, Swe = 8, Rr = Q({
  name: "VxeInput",
  props: {
    modelValue: [String, Number, Date],
    immediate: { type: Boolean, default: !0 },
    name: String,
    type: { type: String, default: "text" },
    clearable: { type: Boolean, default: () => ee.input.clearable },
    readonly: Boolean,
    disabled: Boolean,
    placeholder: {
      type: String,
      default: () => I.eqNull(ee.input.placeholder) ? ee.i18n("vxe.base.pleaseInput") : ee.input.placeholder
    },
    maxlength: [String, Number],
    autocomplete: { type: String, default: "off" },
    align: String,
    form: String,
    className: String,
    size: { type: String, default: () => ee.input.size || ee.size },
    multiple: Boolean,
    // text
    showWordCount: Boolean,
    countMethod: Function,
    // number、integer、float
    min: { type: [String, Number], default: null },
    max: { type: [String, Number], default: null },
    step: [String, Number],
    exponential: { type: Boolean, default: () => ee.input.exponential },
    // number、integer、float、password
    controls: { type: Boolean, default: () => ee.input.controls },
    // float
    digits: { type: [String, Number], default: () => ee.input.digits },
    // date、week、month、quarter、year
    startDate: { type: [String, Number, Date], default: () => ee.input.startDate },
    endDate: { type: [String, Number, Date], default: () => ee.input.endDate },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    // 已废弃 startWeek，被 startDay 替换
    startWeek: Number,
    startDay: { type: [String, Number], default: () => ee.input.startDay },
    labelFormat: { type: String, default: () => ee.input.labelFormat },
    valueFormat: { type: String, default: () => ee.input.valueFormat },
    editable: { type: Boolean, default: !0 },
    festivalMethod: { type: Function, default: () => ee.input.festivalMethod },
    disabledMethod: { type: Function, default: () => ee.input.disabledMethod },
    // week
    selectDay: { type: [String, Number], default: () => ee.input.selectDay },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: { type: Boolean, default: () => ee.input.transfer }
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "wheel",
    "click",
    "focus",
    "blur",
    "clear",
    "search-click",
    "toggle-visible",
    "prev-number",
    "next-number",
    "prefix-click",
    "suffix-click",
    "date-prev",
    "date-today",
    "date-next"
  ],
  setup(e, t) {
    const { slots: n, emit: o } = t, l = ot("$xeform", null), a = ot("$xeformiteminfo", null), r = I.uniqueId(), i = Po(e), s = en({
      inited: !1,
      panelIndex: 0,
      showPwd: !1,
      visiblePanel: !1,
      animatVisible: !1,
      panelStyle: null,
      panelPlacement: "",
      isActivated: !1,
      inputValue: e.modelValue,
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    }), u = B(), d = B(), f = B(), v = B(), h = {
      refElem: u,
      refInput: d
    }, m = {
      xID: r,
      props: e,
      context: t,
      reactData: s,
      getRefMaps: () => h
    };
    let p = {};
    const C = (le, Ge) => {
      const { type: tt } = e;
      return tt === "time" ? wwe(le) : I.toStringDate(le, Ge);
    }, g = x(() => {
      const { type: le } = e;
      return le === "time" || le === "datetime";
    }), w = x(() => ["number", "integer", "float"].indexOf(e.type) > -1), b = x(() => I.getSize(s.inputValue)), y = x(() => {
      const le = b.value;
      return e.maxlength && le > I.toNumber(e.maxlength);
    }), E = x(() => g.value || ["date", "week", "month", "quarter", "year"].indexOf(e.type) > -1), S = x(() => e.type === "password"), _ = x(() => e.type === "search"), k = x(() => I.toInteger(e.digits) || 1), N = x(() => {
      const { type: le } = e, Ge = k.value, tt = e.step;
      return le === "integer" ? I.toInteger(tt) || 1 : le === "float" ? I.toNumber(tt) || 1 / Math.pow(10, Ge) : I.toNumber(tt) || 1;
    }), L = x(() => {
      const { type: le } = e, Ge = w.value, tt = E.value, ht = S.value;
      return e.clearable && (ht || Ge || tt || le === "text" || le === "search");
    }), R = x(() => e.startDate ? I.toStringDate(e.startDate) : null), H = x(() => e.endDate ? I.toStringDate(e.endDate) : null), K = x(() => ["date", "week", "month", "quarter", "year"].includes(e.type)), U = x(() => {
      const { modelValue: le, multiple: Ge } = e, tt = E.value, ht = $.value;
      return Ge && le && tt ? I.toValueString(le).split(",").map((Tt) => {
        const gt = C(Tt, ht);
        return I.isValidDate(gt) ? gt : null;
      }) : [];
    }), W = x(() => {
      const le = U.value, Ge = $.value;
      return le.map((tt) => I.toDateString(tt, Ge));
    }), A = x(() => {
      const le = U.value, Ge = te.value;
      return le.map((tt) => I.toDateString(tt, Ge)).join(", ");
    }), $ = x(() => {
      const { type: le } = e;
      return le === "time" ? "HH:mm:ss" : e.valueFormat || (le === "datetime" ? "yyyy-MM-dd HH:mm:ss" : "yyyy-MM-dd");
    }), D = x(() => {
      const { modelValue: le } = e, Ge = E.value, tt = $.value;
      let ht = null;
      if (le && Ge) {
        const Tt = C(le, tt);
        I.isValidDate(Tt) && (ht = Tt);
      }
      return ht;
    }), O = x(() => {
      const le = R.value, { selectMonth: Ge } = s;
      return Ge && le ? Ge <= le : !1;
    }), F = x(() => {
      const le = H.value, { selectMonth: Ge } = s;
      return Ge && le ? Ge >= le : !1;
    }), j = x(() => {
      const { datetimePanelValue: le } = s;
      return le ? I.toDateString(le, "HH:mm:ss") : "";
    }), Z = x(() => {
      const le = D.value, Ge = g.value;
      return le && Ge ? (le.getHours() * 3600 + le.getMinutes() * 60 + le.getSeconds()) * 1e3 : 0;
    }), te = x(() => E.value ? e.labelFormat || ee.i18n(`vxe.input.date.labelFormat.${e.type}`) : null), de = x(() => {
      const { selectMonth: le, currentDate: Ge } = s, tt = [];
      if (le && Ge) {
        const ht = Ge.getFullYear(), Tt = le.getFullYear(), gt = new Date(Tt - Tt % Sr, 0, 1);
        for (let Ft = -4; Ft < Sr + 4; Ft++) {
          const T = I.getWhatYear(gt, Ft, "first"), P = T.getFullYear();
          tt.push({
            date: T,
            isCurrent: !0,
            isPrev: Ft < 0,
            isNow: ht === P,
            isNext: Ft >= Sr,
            year: P
          });
        }
      }
      return tt;
    }), Oe = x(() => {
      if (E.value) {
        const { datePanelType: Ge, selectMonth: tt } = s, ht = de.value;
        let Tt = "", gt;
        return tt && (Tt = tt.getFullYear(), gt = tt.getMonth() + 1), Ge === "quarter" ? ee.i18n("vxe.input.date.quarterLabel", [Tt]) : Ge === "month" ? ee.i18n("vxe.input.date.monthLabel", [Tt]) : Ge === "year" ? ht.length ? `${ht[0].year} - ${ht[ht.length - 1].year}` : "" : ee.i18n("vxe.input.date.dayLabel", [Tt, gt ? ee.i18n(`vxe.input.date.m${gt}`) : "-"]);
      }
      return "";
    }), ce = x(() => {
      const { startDay: le, startWeek: Ge } = e;
      return I.toNumber(I.isNumber(le) || I.isString(le) ? le : Ge);
    }), ne = x(() => {
      const le = [];
      if (E.value) {
        let tt = ce.value;
        le.push(tt);
        for (let ht = 0; ht < 6; ht++)
          tt >= 6 ? tt = 0 : tt++, le.push(tt);
      }
      return le;
    }), Y = x(() => E.value ? ne.value.map((tt) => ({
      value: tt,
      label: ee.i18n(`vxe.input.date.weeks.w${tt}`)
    })) : []), ve = x(() => {
      if (E.value) {
        const Ge = Y.value;
        return [{ label: ee.i18n("vxe.input.date.weeks.w") }].concat(Ge);
      }
      return [];
    }), ie = x(() => {
      const le = de.value;
      return I.chunk(le, 4);
    }), he = x(() => {
      const { selectMonth: le, currentDate: Ge } = s, tt = [];
      if (le && Ge) {
        const ht = Ge.getFullYear(), Tt = A_(Ge), gt = I.getWhatYear(le, 0, "first"), Ft = gt.getFullYear();
        for (let T = -2; T < Swe - 2; T++) {
          const P = I.getWhatQuarter(gt, T), q = P.getFullYear(), J = A_(P), se = q < Ft;
          tt.push({
            date: P,
            isPrev: se,
            isCurrent: q === Ft,
            isNow: q === ht && J === Tt,
            isNext: !se && q > Ft,
            quarter: J
          });
        }
      }
      return tt;
    }), De = x(() => {
      const le = he.value;
      return I.chunk(le, 2);
    }), $e = x(() => {
      const { selectMonth: le, currentDate: Ge } = s, tt = [];
      if (le && Ge) {
        const ht = Ge.getFullYear(), Tt = Ge.getMonth(), gt = I.getWhatYear(le, 0, "first").getFullYear();
        for (let Ft = -4; Ft < Ewe - 4; Ft++) {
          const T = I.getWhatYear(le, 0, Ft), P = T.getFullYear(), q = T.getMonth(), J = P < gt;
          tt.push({
            date: T,
            isPrev: J,
            isCurrent: P === gt,
            isNow: P === ht && q === Tt,
            isNext: !J && P > gt,
            month: q
          });
        }
      }
      return tt;
    }), ue = x(() => {
      const le = $e.value;
      return I.chunk(le, 4);
    }), Ne = x(() => {
      const { selectMonth: le, currentDate: Ge } = s, tt = [];
      if (le && Ge) {
        const ht = Z.value, Tt = ne.value, gt = Ge.getFullYear(), Ft = Ge.getMonth(), T = Ge.getDate(), P = le.getFullYear(), q = le.getMonth(), J = le.getDay(), se = -Tt.indexOf(J), ye = new Date(I.getWhatDay(le, se).getTime() + ht);
        for (let Se = 0; Se < 42; Se++) {
          const He = I.getWhatDay(ye, Se), Be = He.getFullYear(), qe = He.getMonth(), Ye = He.getDate(), lt = He < le;
          tt.push({
            date: He,
            isPrev: lt,
            isCurrent: Be === P && qe === q,
            isNow: Be === gt && qe === Ft && Ye === T,
            isNext: !lt && q !== qe,
            label: Ye
          });
        }
      }
      return tt;
    }), je = x(() => {
      const le = Ne.value;
      return I.chunk(le, 7);
    }), Fe = x(() => {
      const le = je.value, Ge = ce.value;
      return le.map((tt) => {
        const ht = tt[0];
        return [{
          date: ht.date,
          isWeekNumber: !0,
          isPrev: !1,
          isCurrent: !1,
          isNow: !1,
          isNext: !1,
          label: I.getYearWeek(ht.date, Ge)
        }].concat(tt);
      });
    }), Ve = x(() => {
      const le = [];
      if (g.value)
        for (let tt = 0; tt < 24; tt++)
          le.push({
            value: tt,
            label: ("" + tt).padStart(2, "0")
          });
      return le;
    }), Ze = x(() => {
      const le = [];
      if (g.value)
        for (let tt = 0; tt < 60; tt++)
          le.push({
            value: tt,
            label: ("" + tt).padStart(2, "0")
          });
      return le;
    }), ae = x(() => Ze.value), pe = x(() => {
      const { type: le, readonly: Ge, editable: tt, multiple: ht } = e;
      return Ge || ht || !tt || le === "week" || le === "quarter";
    }), ke = x(() => {
      const { type: le } = e, { showPwd: Ge } = s, tt = w.value, ht = E.value, Tt = S.value;
      return ht || tt || Tt && Ge || le === "number" ? "text" : le;
    }), Ue = x(() => {
      const { placeholder: le } = e;
      return le ? vo(le) : "";
    }), Xe = x(() => {
      const { maxlength: le } = e;
      return w.value && !I.toNumber(le) ? 16 : le;
    }), re = x(() => {
      const { type: le, immediate: Ge } = e;
      return Ge || !(le === "text" || le === "number" || le === "integer" || le === "float");
    }), Te = x(() => {
      const { type: le } = e, { inputValue: Ge } = s;
      return w.value ? le === "integer" ? I.toInteger(lc(Ge)) : I.toNumber(lc(Ge)) : 0;
    }), Ce = x(() => {
      const { min: le } = e, { inputValue: Ge } = s, tt = w.value, ht = Te.value;
      return (Ge || Ge === 0) && tt && le !== null ? ht <= I.toNumber(le) : !1;
    }), Le = x(() => {
      const { max: le } = e, { inputValue: Ge } = s, tt = w.value, ht = Te.value;
      return (Ge || Ge === 0) && tt && le !== null ? ht >= I.toNumber(le) : !1;
    }), ge = (le) => {
      const { type: Ge, exponential: tt } = e, ht = Xe.value, Tt = k.value, gt = Ge === "float" ? F_(le, Tt) : I.toValueString(le);
      return tt && (le === gt || I.toValueString(le).toLowerCase() === I.toNumber(gt).toExponential()) ? le : gt.slice(0, ht);
    }, Ee = (le) => {
      const { inputValue: Ge } = s;
      p.dispatchEvent(le.type, { value: Ge }, le);
    }, me = (le, Ge) => {
      s.inputValue = le, o("update:modelValue", le), p.dispatchEvent("input", { value: le }, Ge), I.toValueString(e.modelValue) !== le && (p.dispatchEvent("change", { value: le }, Ge), l && a && l.triggerItemEvent(Ge, a.itemConfig.field, le));
    }, Ke = (le, Ge) => {
      const tt = E.value, ht = re.value;
      s.inputValue = le, tt || (ht ? me(le, Ge) : p.dispatchEvent("input", { value: le }, Ge));
    }, Re = (le) => {
      const tt = le.target.value;
      Ke(tt, le);
    }, we = (le) => {
      re.value || Ee(le);
    }, ze = (le) => {
      s.isActivated = !0, E.value && zs(le), Ee(le);
    }, Je = (le) => {
      const { disabled: Ge } = e;
      if (!Ge) {
        const { inputValue: tt } = s;
        p.dispatchEvent("prefix-click", { value: tt }, le);
      }
    };
    let Me;
    const et = () => new Promise((le) => {
      s.visiblePanel = !1, Me = window.setTimeout(() => {
        s.animatVisible = !1, le();
      }, 350);
    }), mt = (le, Ge) => {
      const { type: tt } = e, ht = w.value;
      E.value && et(), (ht || ["text", "search", "password"].indexOf(tt) > -1) && focus(), p.dispatchEvent("clear", { value: Ge }, le);
    }, Lt = (le) => {
      const { disabled: Ge } = e;
      if (!Ge)
        if (Ar(le.currentTarget, "is--clear"))
          me("", le), mt(le, "");
        else {
          const { inputValue: tt } = s;
          p.dispatchEvent("suffix-click", { value: tt }, le);
        }
    }, be = (le) => {
      const { type: Ge } = e, { valueFormat: tt } = e, ht = te.value, Tt = ce.value;
      let gt = null, Ft = "";
      if (le && (gt = C(le, tt)), I.isValidDate(gt)) {
        if (Ft = I.toDateString(gt, ht, { firstDay: Tt }), ht && Ge === "week" && I.getWhatWeek(gt, 0, Tt, Tt).getFullYear() < gt.getFullYear()) {
          const P = ht.indexOf("yyyy");
          if (P > -1) {
            const q = Number(Ft.substring(P, P + 4));
            q && !isNaN(q) && (Ft = Ft.replace(`${q}`, `${q - 1}`));
          }
        }
      } else
        gt = null;
      s.datePanelValue = gt, s.datePanelLabel = Ft;
    }, an = () => {
      const le = E.value, { inputValue: Ge } = s;
      le && (be(Ge), s.inputValue = e.multiple ? A.value : s.datePanelLabel);
    }, _t = () => {
      const { type: le } = e, { inputValue: Ge } = s, tt = E.value, ht = k.value;
      if (tt)
        an();
      else if (le === "float" && Ge) {
        const Tt = F_(Ge, ht);
        Ge !== Tt && me(Tt, { type: "init" });
      }
    }, zt = (le) => e.max === null || I.toNumber(le) <= I.toNumber(e.max), jt = (le) => e.min === null || I.toNumber(le) >= I.toNumber(e.min), Sn = () => {
      s.inputValue = e.multiple ? A.value : s.datePanelLabel;
    }, hn = (le) => {
      const Ge = I.getWhatMonth(le, 0, "first");
      I.isEqual(Ge, s.selectMonth) || (s.selectMonth = Ge);
    }, xn = (le) => {
      const { modelValue: Ge, multiple: tt } = e, { datetimePanelValue: ht } = s, Tt = g.value, gt = $.value, Ft = ce.value;
      if (e.type === "week") {
        const P = I.toNumber(e.selectDay);
        le = I.getWhatWeek(le, 0, P, Ft);
      } else
        Tt && (le.setHours(ht.getHours()), le.setMinutes(ht.getMinutes()), le.setSeconds(ht.getSeconds()));
      const T = I.toDateString(le, gt, { firstDay: Ft });
      if (hn(le), tt) {
        const P = W.value;
        if (Tt) {
          const q = [...U.value], J = [], se = I.findIndexOf(q, (ye) => I.isDateSame(le, ye, "yyyyMMdd"));
          se === -1 ? q.push(le) : q.splice(se, 1), q.forEach((ye) => {
            ye && (ye.setHours(ht.getHours()), ye.setMinutes(ht.getMinutes()), ye.setSeconds(ht.getSeconds()), J.push(ye));
          }), me(J.map((ye) => I.toDateString(ye, gt)).join(","), { type: "update" });
        } else
          P.some((q) => I.isEqual(q, T)) ? me(P.filter((q) => !I.isEqual(q, T)).join(","), { type: "update" }) : me(P.concat([T]).join(","), { type: "update" });
      } else
        I.isEqual(Ge, T) || me(T, { type: "update" });
    }, yn = () => {
      const { type: le, min: Ge, max: tt, exponential: ht } = e, { inputValue: Tt, datetimePanelValue: gt } = s, Ft = w.value, T = E.value, P = te.value;
      if (!pe.value) {
        if (Ft) {
          if (Tt) {
            let J = le === "integer" ? I.toInteger(lc(Tt)) : I.toNumber(lc(Tt));
            if (jt(J) ? zt(J) || (J = tt) : J = Ge, ht) {
              const se = I.toValueString(Tt).toLowerCase();
              se === I.toNumber(J).toExponential() && (J = se);
            }
            me(ge(J), { type: "check" });
          }
        } else if (T)
          if (Tt) {
            let J = C(Tt, P);
            if (I.isValidDate(J))
              if (le === "time")
                J = I.toDateString(J, P), Tt !== J && me(J, { type: "check" }), s.inputValue = J;
              else {
                let se = !1;
                const ye = ce.value;
                if (le === "datetime") {
                  const Se = D.value;
                  (Tt !== I.toDateString(Se, P) || Tt !== I.toDateString(J, P)) && (se = !0, gt.setHours(J.getHours()), gt.setMinutes(J.getMinutes()), gt.setSeconds(J.getSeconds()));
                } else
                  se = !0;
                s.inputValue = I.toDateString(J, P, { firstDay: ye }), se && xn(J);
              }
            else
              Sn();
          } else
            me("", { type: "check" });
      }
    }, kn = (le) => {
      const { inputValue: Ge } = s;
      re.value || me(Ge, le), yn(), s.visiblePanel || (s.isActivated = !1), p.dispatchEvent("blur", { value: Ge }, le);
    }, Wn = (le) => {
      const { readonly: Ge, disabled: tt } = e, { showPwd: ht } = s;
      !tt && !Ge && (s.showPwd = !ht), p.dispatchEvent("toggle-visible", { visible: s.showPwd }, le);
    }, Vn = (le) => {
      p.dispatchEvent("search-click", {}, le);
    }, ho = (le, Ge) => {
      const { min: tt, max: ht, type: Tt } = e, { inputValue: gt } = s, Ft = N.value, T = Tt === "integer" ? I.toInteger(lc(gt)) : I.toNumber(lc(gt)), P = le ? I.add(T, Ft) : I.subtract(T, Ft);
      let q;
      jt(P) ? zt(P) ? q = P : q = ht : q = tt, Ke(ge(q), Ge);
    };
    let Qn;
    const eo = (le) => {
      const { readonly: Ge, disabled: tt } = e, ht = Ce.value;
      clearTimeout(Qn), !tt && !Ge && !ht && ho(!1, le), p.dispatchEvent("next-number", {}, le);
    }, So = (le) => {
      Qn = window.setTimeout(() => {
        eo(le), So(le);
      }, 60);
    }, st = (le) => {
      const { readonly: Ge, disabled: tt } = e, ht = Le.value;
      clearTimeout(Qn), !tt && !Ge && !ht && ho(!0, le), p.dispatchEvent("prev-number", {}, le);
    }, St = (le) => {
      const Ge = Cn(le, un.ARROW_UP), tt = Cn(le, un.ARROW_DOWN);
      (Ge || tt) && (le.preventDefault(), Ge ? st(le) : eo(le));
    }, rn = (le) => {
      const { exponential: Ge, controls: tt } = e;
      if (w.value) {
        const Tt = le.ctrlKey, gt = le.shiftKey, Ft = le.altKey, T = le.keyCode;
        !Tt && !gt && !Ft && (Cn(le, un.SPACEBAR) || (!Ge || T !== 69) && T >= 65 && T <= 90 || T >= 186 && T <= 188 || T >= 191) && le.preventDefault(), tt && St(le);
      }
      Ee(le);
    }, Tn = (le) => {
      Ee(le);
    }, mo = () => {
      clearTimeout(Qn);
    }, ro = (le) => {
      Qn = window.setTimeout(() => {
        st(le), ro(le);
      }, 60);
    }, Io = (le) => {
      if (mo(), le.button === 0) {
        const Ge = Ar(le.currentTarget, "is--prev");
        Ge ? st(le) : eo(le), Qn = window.setTimeout(() => {
          Ge ? ro(le) : So(le);
        }, 500);
      }
    }, Oo = (le) => {
      if (w.value && e.controls && s.isActivated) {
        const tt = le.deltaY;
        tt > 0 ? eo(le) : tt < 0 && st(le), le.preventDefault();
      }
      Ee(le);
    }, so = (le, Ge) => {
      s.selectMonth = I.getWhatMonth(le, Ge, "first");
    }, la = () => {
      const le = I.getWhatDay(Date.now(), 0, "first");
      s.currentDate = le, so(le, 0);
    }, aa = () => {
      let { datePanelType: le } = s;
      le === "month" || le === "quarter" ? le = "year" : le = "month", s.datePanelType = le;
    }, ft = (le) => {
      const { type: Ge } = e, { datePanelType: tt, selectMonth: ht } = s;
      O.value || (Ge === "year" ? s.selectMonth = I.getWhatYear(ht, -Sr, "first") : Ge === "month" || Ge === "quarter" ? tt === "year" ? s.selectMonth = I.getWhatYear(ht, -Sr, "first") : s.selectMonth = I.getWhatYear(ht, -1, "first") : tt === "year" ? s.selectMonth = I.getWhatYear(ht, -Sr, "first") : tt === "month" ? s.selectMonth = I.getWhatYear(ht, -1, "first") : s.selectMonth = I.getWhatMonth(ht, -1, "first"), p.dispatchEvent("date-prev", { type: Ge }, le));
    }, At = (le) => {
      la(), e.multiple || (xn(s.currentDate), et()), p.dispatchEvent("date-today", { type: e.type }, le);
    }, Xt = (le) => {
      const { type: Ge } = e, { datePanelType: tt, selectMonth: ht } = s;
      F.value || (Ge === "year" ? s.selectMonth = I.getWhatYear(ht, Sr, "first") : Ge === "month" || Ge === "quarter" ? tt === "year" ? s.selectMonth = I.getWhatYear(ht, Sr, "first") : s.selectMonth = I.getWhatYear(ht, 1, "first") : tt === "year" ? s.selectMonth = I.getWhatYear(ht, Sr, "first") : tt === "month" ? s.selectMonth = I.getWhatYear(ht, 1, "first") : s.selectMonth = I.getWhatMonth(ht, 1, "first"), p.dispatchEvent("date-next", { type: Ge }, le));
    }, sn = (le) => {
      const { disabledMethod: Ge } = e, { datePanelType: tt } = s;
      return Ge && Ge({ type: tt, viewType: tt, date: le.date, $input: m });
    }, _o = (le) => {
      const { type: Ge, multiple: tt } = e, { datePanelType: ht } = s;
      Ge === "month" ? ht === "year" ? (s.datePanelType = "month", hn(le)) : (xn(le), tt || et()) : Ge === "year" ? (xn(le), tt || et()) : Ge === "quarter" ? ht === "year" ? (s.datePanelType = "quarter", hn(le)) : (xn(le), tt || et()) : ht === "month" ? (s.datePanelType = Ge === "week" ? Ge : "day", hn(le)) : ht === "year" ? (s.datePanelType = "month", hn(le)) : (xn(le), Ge === "datetime" || tt || et());
    }, No = (le) => {
      sn(le) || _o(le.date);
    }, Oa = (le) => {
      sn({ date: le }) || (Ne.value.some((tt) => I.isDateSame(tt.date, le, "yyyyMMdd")) || hn(le), be(le));
    }, br = (le) => {
      sn({ date: le }) || (de.value.some((tt) => I.isDateSame(tt.date, le, "yyyy")) || hn(le), be(le));
    }, qa = (le) => {
      sn({ date: le }) || (he.value.some((tt) => I.isDateSame(tt.date, le, "yyyyq")) || hn(le), be(le));
    }, ra = (le) => {
      sn({ date: le }) || ($e.value.some((tt) => I.isDateSame(tt.date, le, "yyyyMM")) || hn(le), be(le));
    }, cl = (le) => {
      if (!sn(le)) {
        const { datePanelType: Ge } = s;
        Ge === "month" ? ra(le.date) : Ge === "quarter" ? qa(le.date) : Ge === "year" ? br(le.date) : Oa(le.date);
      }
    }, sa = (le) => {
      if (le) {
        const Ge = le.offsetHeight, tt = le.parentNode;
        tt.scrollTop = le.offsetTop - Ge * 4;
      }
    }, Gr = (le) => {
      s.datetimePanelValue = new Date(s.datetimePanelValue.getTime()), sa(le.currentTarget);
    }, Ya = (le, Ge) => {
      s.datetimePanelValue.setHours(Ge.value), Gr(le);
    }, Ga = () => {
      const { multiple: le } = e, { datetimePanelValue: Ge } = s, tt = D.value, ht = g.value;
      if (ht) {
        const Tt = $.value;
        if (le) {
          const gt = W.value;
          if (ht) {
            const Ft = [...U.value], T = [];
            Ft.forEach((P) => {
              P && (P.setHours(Ge.getHours()), P.setMinutes(Ge.getMinutes()), P.setSeconds(Ge.getSeconds()), T.push(P));
            }), me(T.map((P) => I.toDateString(P, Tt)).join(","), { type: "update" });
          } else
            me(gt.join(","), { type: "update" });
        } else
          xn(tt || s.currentDate);
      }
      et();
    }, ia = (le, Ge) => {
      s.datetimePanelValue.setMinutes(Ge.value), Gr(le);
    }, Xr = (le, Ge) => {
      s.datetimePanelValue.setSeconds(Ge.value), Gr(le);
    }, Ml = (le) => {
      const { isActivated: Ge, datePanelValue: tt, datePanelType: ht } = s;
      if (Ge) {
        le.preventDefault();
        const Tt = Cn(le, un.ARROW_LEFT), gt = Cn(le, un.ARROW_UP), Ft = Cn(le, un.ARROW_RIGHT), T = Cn(le, un.ARROW_DOWN);
        if (ht === "year") {
          let P = I.getWhatYear(tt || Date.now(), 0, "first");
          Tt ? P = I.getWhatYear(P, -1) : gt ? P = I.getWhatYear(P, -4) : Ft ? P = I.getWhatYear(P, 1) : T && (P = I.getWhatYear(P, 4)), br(P);
        } else if (ht === "quarter") {
          let P = I.getWhatQuarter(tt || Date.now(), 0, "first");
          Tt ? P = I.getWhatQuarter(P, -1) : gt ? P = I.getWhatQuarter(P, -2) : Ft ? P = I.getWhatQuarter(P, 1) : T && (P = I.getWhatQuarter(P, 2)), qa(P);
        } else if (ht === "month") {
          let P = I.getWhatMonth(tt || Date.now(), 0, "first");
          Tt ? P = I.getWhatMonth(P, -1) : gt ? P = I.getWhatMonth(P, -4) : Ft ? P = I.getWhatMonth(P, 1) : T && (P = I.getWhatMonth(P, 4)), ra(P);
        } else {
          let P = tt || I.getWhatDay(Date.now(), 0, "first");
          const q = ce.value;
          Tt ? P = I.getWhatDay(P, -1) : gt ? P = I.getWhatWeek(P, -1, q) : Ft ? P = I.getWhatDay(P, 1) : T && (P = I.getWhatWeek(P, 1, q)), Oa(P);
        }
      }
    }, Ro = (le) => {
      const { isActivated: Ge } = s;
      if (Ge) {
        const tt = Cn(le, un.PAGE_UP);
        le.preventDefault(), tt ? ft(le) : Xt(le);
      }
    }, yr = () => {
      const { type: le } = e, Ge = g.value, tt = D.value;
      ["year", "quarter", "month", "week"].indexOf(le) > -1 ? s.datePanelType = le : s.datePanelType = "day", s.currentDate = I.getWhatDay(Date.now(), 0, "first"), tt ? (so(tt, 0), be(tt)) : la(), Ge && (s.datetimePanelValue = s.datePanelValue || I.getWhatDay(Date.now(), 0, "first"), xe(() => {
        const ht = v.value;
        I.arrayEach(ht.querySelectorAll("li.is--selected"), sa);
      }));
    }, Un = () => {
      s.panelIndex < Yr() && (s.panelIndex = dr());
    }, Jo = () => xe().then(() => {
      const { transfer: le, placement: Ge } = e, { panelIndex: tt } = s, ht = d.value, Tt = f.value;
      if (ht && Tt) {
        const gt = ht.offsetHeight, Ft = ht.offsetWidth, T = Tt.offsetHeight, P = Tt.offsetWidth, q = 5, J = {
          zIndex: tt
        }, { boundingTop: se, boundingLeft: ye, visibleHeight: Se, visibleWidth: He } = lr(ht);
        let Be = "bottom";
        if (console.log(lr(ht)), le) {
          let qe = ye, Ye = se + gt;
          Ge === "top" ? (Be = "top", Ye = se - T) : Ge || (Ye + T + q > Se && (Be = "top", Ye = se - T), Ye < q && (Be = "bottom", Ye = se + gt)), qe + P + q > He && (qe -= qe + P + q - He), qe < q && (qe = q), Object.assign(J, {
            left: `${qe}px`,
            top: `${Ye}px`,
            minWidth: `${Ft}px`
          });
        } else
          Ge === "top" ? (Be = "top", J.bottom = `${gt}px`) : Ge || se + gt + T > Se && se - gt - T > q && (Be = "top", J.bottom = `${gt}px`);
        return s.panelStyle = J, s.panelPlacement = Be, xe();
      }
    }), Na = () => {
      const { disabled: le } = e, { visiblePanel: Ge } = s, tt = E.value;
      return !le && !Ge ? (s.inited || (s.inited = !0), clearTimeout(Me), s.isActivated = !0, s.animatVisible = !0, tt && yr(), setTimeout(() => {
        s.visiblePanel = !0;
      }, 10), Un(), Jo()) : xe();
    }, zs = (le) => {
      const { readonly: Ge } = e;
      Ge || (le.preventDefault(), Na());
    }, gu = (le) => {
      Ee(le);
    }, Of = (le) => {
      const { disabled: Ge } = e, { visiblePanel: tt, isActivated: ht } = s, Tt = E.value, gt = u.value, Ft = f.value;
      !Ge && ht && (s.isActivated = _n(le, gt).flag || _n(le, Ft).flag, s.isActivated || (Tt ? tt && (et(), yn()) : yn()));
    }, xh = (le) => {
      const { clearable: Ge, disabled: tt } = e, { visiblePanel: ht } = s, Tt = E.value;
      if (!tt) {
        const gt = Cn(le, un.TAB), Ft = Cn(le, un.DELETE), T = Cn(le, un.ESCAPE), P = Cn(le, un.ENTER), q = Cn(le, un.ARROW_LEFT), J = Cn(le, un.ARROW_UP), se = Cn(le, un.ARROW_RIGHT), ye = Cn(le, un.ARROW_DOWN), Se = Cn(le, un.PAGE_UP), He = Cn(le, un.PAGE_DOWN), Be = q || J || se || ye;
        let qe = s.isActivated;
        gt ? (qe && yn(), qe = !1, s.isActivated = qe) : Be ? Tt && qe && (ht ? Ml(le) : (J || ye) && zs(le)) : P ? Tt && (ht ? s.datePanelValue ? _o(s.datePanelValue) : et() : qe && zs(le)) : (Se || He) && Tt && qe && Ro(le), gt || T ? ht && et() : Ft && Ge && qe && mt(le, null);
      }
    }, Nf = (le) => {
      const { disabled: Ge } = e, { visiblePanel: tt } = s;
      if (!Ge && tt) {
        const ht = f.value;
        _n(le, ht).flag ? Jo() : (et(), yn());
      }
    }, Ui = () => {
      const { isActivated: le, visiblePanel: Ge } = s;
      Ge ? (et(), yn()) : le && yn();
    }, Cr = (le, Ge) => {
      const { festivalMethod: tt } = e;
      if (tt) {
        const { datePanelType: ht } = s, Tt = tt({ type: ht, viewType: ht, date: le.date, $input: m }), gt = Tt ? I.isString(Tt) ? { label: Tt } : Tt : {}, Ft = gt.extra ? I.isString(gt.extra) ? { label: gt.extra } : gt.extra : null, T = [
          V("span", {
            class: ["vxe-input--date-label", {
              "is-notice": gt.notice
            }]
          }, Ft && Ft.label ? [
            V("span", Ge),
            V("span", {
              class: ["vxe-input--date-label--extra", Ft.important ? "is-important" : "", Ft.className],
              style: Ft.style
            }, I.toValueString(Ft.label))
          ] : Ge)
        ], P = gt.label;
        if (P) {
          const q = I.toValueString(P).split(",");
          T.push(V("span", {
            class: ["vxe-input--date-festival", gt.important ? "is-important" : "", gt.className],
            style: gt.style
          }, [
            q.length > 1 ? V("span", {
              class: ["vxe-input--date-festival--overlap", `overlap--${q.length}`]
            }, q.map((J) => V("span", J.substring(0, 3)))) : V("span", {
              class: "vxe-input--date-festival--label"
            }, q[0].substring(0, 3))
          ]));
        }
        return T;
      }
      return Ge;
    }, kh = () => {
      const { multiple: le } = e, { datePanelType: Ge, datePanelValue: tt } = s, ht = D.value, Tt = Y.value, gt = je.value, Ft = U.value, T = "yyyyMMdd";
      return [
        V("table", {
          class: `vxe-input--date-${Ge}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          V("thead", [
            V("tr", Tt.map((P) => V("th", P.label)))
          ]),
          V("tbody", gt.map((P) => V("tr", P.map((q) => V("td", {
            class: {
              "is--prev": q.isPrev,
              "is--current": q.isCurrent,
              "is--now": q.isNow,
              "is--next": q.isNext,
              "is--disabled": sn(q),
              "is--selected": le ? Ft.some((J) => I.isDateSame(J, q.date, T)) : I.isDateSame(ht, q.date, T),
              "is--hover": I.isDateSame(tt, q.date, T)
            },
            onClick: () => No(q),
            onMouseenter: () => cl(q)
          }, Cr(q, q.label))))))
        ])
      ];
    }, Mf = () => {
      const { multiple: le } = e, { datePanelType: Ge, datePanelValue: tt } = s, ht = D.value, Tt = ve.value, gt = Fe.value, Ft = U.value, T = "yyyyMMdd";
      return [
        V("table", {
          class: `vxe-input--date-${Ge}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          V("thead", [
            V("tr", Tt.map((P) => V("th", P.label)))
          ]),
          V("tbody", gt.map((P) => {
            const q = le ? P.some((se) => Ft.some((ye) => I.isDateSame(ye, se.date, T))) : P.some((se) => I.isDateSame(ht, se.date, T)), J = P.some((se) => I.isDateSame(tt, se.date, T));
            return V("tr", P.map((se) => V("td", {
              class: {
                "is--prev": se.isPrev,
                "is--current": se.isCurrent,
                "is--now": se.isNow,
                "is--next": se.isNext,
                "is--disabled": sn(se),
                "is--selected": q,
                "is--hover": J
              },
              // event
              onClick: () => No(se),
              onMouseenter: () => cl(se)
            }, Cr(se, se.label))));
          }))
        ])
      ];
    }, Th = () => {
      const { multiple: le } = e, { datePanelType: Ge, datePanelValue: tt } = s, ht = D.value, Tt = ue.value, gt = U.value, Ft = "yyyyMM";
      return [
        V("table", {
          class: `vxe-input--date-${Ge}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          V("tbody", Tt.map((T) => V("tr", T.map((P) => V("td", {
            class: {
              "is--prev": P.isPrev,
              "is--current": P.isCurrent,
              "is--now": P.isNow,
              "is--next": P.isNext,
              "is--disabled": sn(P),
              "is--selected": le ? gt.some((q) => I.isDateSame(q, P.date, Ft)) : I.isDateSame(ht, P.date, Ft),
              "is--hover": I.isDateSame(tt, P.date, Ft)
            },
            onClick: () => No(P),
            onMouseenter: () => cl(P)
          }, Cr(P, ee.i18n(`vxe.input.date.months.m${P.month}`)))))))
        ])
      ];
    }, $h = () => {
      const { multiple: le } = e, { datePanelType: Ge, datePanelValue: tt } = s, ht = D.value, Tt = De.value, gt = U.value, Ft = "yyyyq";
      return [
        V("table", {
          class: `vxe-input--date-${Ge}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          V("tbody", Tt.map((T) => V("tr", T.map((P) => V("td", {
            class: {
              "is--prev": P.isPrev,
              "is--current": P.isCurrent,
              "is--now": P.isNow,
              "is--next": P.isNext,
              "is--disabled": sn(P),
              "is--selected": le ? gt.some((q) => I.isDateSame(q, P.date, Ft)) : I.isDateSame(ht, P.date, Ft),
              "is--hover": I.isDateSame(tt, P.date, Ft)
            },
            onClick: () => No(P),
            onMouseenter: () => cl(P)
          }, Cr(P, ee.i18n(`vxe.input.date.quarters.q${P.quarter}`)))))))
        ])
      ];
    }, Oh = () => {
      const { multiple: le } = e, { datePanelType: Ge, datePanelValue: tt } = s, ht = D.value, Tt = ie.value, gt = U.value, Ft = "yyyy";
      return [
        V("table", {
          class: `vxe-input--date-${Ge}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          V("tbody", Tt.map((T) => V("tr", T.map((P) => V("td", {
            class: {
              "is--prev": P.isPrev,
              "is--current": P.isCurrent,
              "is--now": P.isNow,
              "is--next": P.isNext,
              "is--disabled": sn(P),
              "is--selected": le ? gt.some((q) => I.isDateSame(q, P.date, Ft)) : I.isDateSame(ht, P.date, Ft),
              "is--hover": I.isDateSame(tt, P.date, Ft)
            },
            onClick: () => No(P),
            onMouseenter: () => cl(P)
          }, Cr(P, P.year))))))
        ])
      ];
    }, Nh = () => {
      const { datePanelType: le } = s;
      switch (le) {
        case "week":
          return Mf();
        case "month":
          return Th();
        case "quarter":
          return $h();
        case "year":
          return Oh();
      }
      return kh();
    }, If = () => {
      const { multiple: le } = e, { datePanelType: Ge } = s, tt = O.value, ht = F.value, Tt = Oe.value;
      return [
        V("div", {
          class: "vxe-input--date-picker-header"
        }, [
          V("div", {
            class: "vxe-input--date-picker-type-wrapper"
          }, [
            Ge === "year" ? V("span", {
              class: "vxe-input--date-picker-label"
            }, Tt) : V("span", {
              class: "vxe-input--date-picker-btn",
              onClick: aa
            }, Tt)
          ]),
          V("div", {
            class: "vxe-input--date-picker-btn-wrapper"
          }, [
            V("span", {
              class: ["vxe-input--date-picker-btn vxe-input--date-picker-prev-btn", {
                "is--disabled": tt
              }],
              onClick: ft
            }, [
              V("i", {
                class: "vxe-icon-caret-left"
              })
            ]),
            V("span", {
              class: "vxe-input--date-picker-btn vxe-input--date-picker-current-btn",
              onClick: At
            }, [
              V("i", {
                class: "vxe-icon-dot"
              })
            ]),
            V("span", {
              class: ["vxe-input--date-picker-btn vxe-input--date-picker-next-btn", {
                "is--disabled": ht
              }],
              onClick: Xt
            }, [
              V("i", {
                class: "vxe-icon-caret-right"
              })
            ]),
            le && K.value ? V("span", {
              class: "vxe-input--date-picker-btn vxe-input--date-picker-confirm-btn"
            }, [
              V("button", {
                class: "vxe-input--date-picker-confirm",
                type: "button",
                onClick: Ga
              }, ee.i18n("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        V("div", {
          class: "vxe-input--date-picker-body"
        }, Nh())
      ];
    }, Rf = () => {
      const { datetimePanelValue: le } = s, Ge = j.value, tt = Ve.value, ht = Ze.value, Tt = ae.value;
      return [
        V("div", {
          class: "vxe-input--time-picker-header"
        }, [
          V("span", {
            class: "vxe-input--time-picker-title"
          }, Ge),
          V("button", {
            class: "vxe-input--time-picker-confirm",
            type: "button",
            onClick: Ga
          }, ee.i18n("vxe.button.confirm"))
        ]),
        V("div", {
          ref: v,
          class: "vxe-input--time-picker-body"
        }, [
          V("ul", {
            class: "vxe-input--time-picker-hour-list"
          }, tt.map((gt, Ft) => V("li", {
            key: Ft,
            class: {
              "is--selected": le && le.getHours() === gt.value
            },
            onClick: (T) => Ya(T, gt)
          }, gt.label))),
          V("ul", {
            class: "vxe-input--time-picker-minute-list"
          }, ht.map((gt, Ft) => V("li", {
            key: Ft,
            class: {
              "is--selected": le && le.getMinutes() === gt.value
            },
            onClick: (T) => ia(T, gt)
          }, gt.label))),
          V("ul", {
            class: "vxe-input--time-picker-second-list"
          }, Tt.map((gt, Ft) => V("li", {
            key: Ft,
            class: {
              "is--selected": le && le.getSeconds() === gt.value
            },
            onClick: (T) => Xr(T, gt)
          }, gt.label)))
        ])
      ];
    }, Mh = () => {
      const { type: le, transfer: Ge } = e, { inited: tt, animatVisible: ht, visiblePanel: Tt, panelPlacement: gt, panelStyle: Ft } = s, T = i.value, P = E.value, q = [];
      return P ? (le === "datetime" ? q.push(V("div", {
        class: "vxe-input--panel-layout-wrapper"
      }, [
        V("div", {
          class: "vxe-input--panel-left-wrapper"
        }, If()),
        V("div", {
          class: "vxe-input--panel-right-wrapper"
        }, Rf())
      ])) : le === "time" ? q.push(V("div", {
        class: "vxe-input--panel-wrapper"
      }, Rf())) : q.push(V("div", {
        class: "vxe-input--panel-wrapper"
      }, If())), V(ka, {
        to: "body",
        disabled: Ge ? !tt : !0
      }, [
        V("div", {
          ref: f,
          class: ["vxe-table--ignore-clear vxe-input--panel", `type--${le}`, {
            [`size--${T}`]: T,
            "is--transfer": Ge,
            "animat--leave": ht,
            "animat--enter": Tt
          }],
          placement: gt,
          style: Ft
        }, q)
      ])) : null;
    }, Ih = () => {
      const le = Le.value, Ge = Ce.value;
      return V("span", {
        class: "vxe-input--number-suffix"
      }, [
        V("span", {
          class: ["vxe-input--number-prev is--prev", {
            "is--disabled": le
          }],
          onMousedown: Io,
          onMouseup: mo,
          onMouseleave: mo
        }, [
          V("i", {
            class: ["vxe-input--number-prev-icon", ee.icon.INPUT_PREV_NUM]
          })
        ]),
        V("span", {
          class: ["vxe-input--number-next is--next", {
            "is--disabled": Ge
          }],
          onMousedown: Io,
          onMouseup: mo,
          onMouseleave: mo
        }, [
          V("i", {
            class: ["vxe-input--number-next-icon", ee.icon.INPUT_NEXT_NUM]
          })
        ])
      ]);
    }, Rh = () => V("span", {
      class: "vxe-input--date-picker-suffix",
      onClick: zs
    }, [
      V("i", {
        class: ["vxe-input--date-picker-icon", ee.icon.INPUT_DATE]
      })
    ]), ji = () => V("span", {
      class: "vxe-input--search-suffix",
      onClick: Vn
    }, [
      V("i", {
        class: ["vxe-input--search-icon", ee.icon.INPUT_SEARCH]
      })
    ]), bu = () => {
      const { showPwd: le } = s;
      return V("span", {
        class: "vxe-input--password-suffix",
        onClick: Wn
      }, [
        V("i", {
          class: ["vxe-input--password-icon", le ? ee.icon.INPUT_SHOW_PWD : ee.icon.INPUT_PWD]
        })
      ]);
    }, Df = () => {
      const { prefixIcon: le } = e, Ge = n.prefix, tt = [];
      return Ge ? tt.push(V("span", {
        class: "vxe-input--prefix-icon"
      }, Ge({}))) : le && tt.push(V("i", {
        class: ["vxe-input--prefix-icon", le]
      })), tt.length ? V("span", {
        class: "vxe-input--prefix",
        onClick: Je
      }, tt) : null;
    }, Dh = () => {
      const { disabled: le, suffixIcon: Ge } = e, { inputValue: tt } = s, ht = n.suffix, Tt = L.value, gt = [];
      return ht ? gt.push(V("span", {
        class: "vxe-input--suffix-icon"
      }, ht({}))) : Ge && gt.push(V("i", {
        class: ["vxe-input--suffix-icon", Ge]
      })), Tt && gt.push(V("i", {
        class: ["vxe-input--clear-icon", ee.icon.INPUT_CLEAR]
      })), gt.length ? V("span", {
        class: ["vxe-input--suffix", {
          "is--clear": Tt && !le && !(tt === "" || I.eqNull(tt))
        }],
        onClick: Lt
      }, gt) : null;
    }, yu = () => {
      const { controls: le } = e, Ge = w.value, tt = E.value, ht = S.value, Tt = _.value;
      let gt;
      return ht ? gt = bu() : Ge ? le && (gt = Ih()) : tt ? gt = Rh() : Tt && (gt = ji()), gt ? V("span", {
        class: "vxe-input--extra-suffix"
      }, [gt]) : null;
    };
    p = {
      dispatchEvent(le, Ge, tt) {
        o(le, Object.assign({ $input: m, $event: tt }, Ge));
      },
      focus() {
        const le = d.value;
        return s.isActivated = !0, le.focus(), xe();
      },
      blur() {
        return d.value.blur(), s.isActivated = !1, xe();
      },
      select() {
        return d.value.select(), s.isActivated = !1, xe();
      },
      showPanel: Na,
      hidePanel: et,
      updatePlacement: Jo
    }, Object.assign(m, p), Pe(() => e.modelValue, (le) => {
      s.inputValue = le, an();
    }), Pe(() => e.type, () => {
      Object.assign(s, {
        inputValue: e.modelValue,
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      }), _t();
    }), Pe(te, () => {
      E.value && (be(s.datePanelValue), s.inputValue = e.multiple ? A.value : s.datePanelLabel);
    }), xe(() => {
      wn.on(m, "mousewheel", Nf), wn.on(m, "mousedown", Of), wn.on(m, "keydown", xh), wn.on(m, "blur", Ui);
    }), wo(() => {
      mo(), wn.off(m, "mousewheel"), wn.off(m, "mousedown"), wn.off(m, "keydown"), wn.off(m, "blur");
    }), _t();
    const Cu = () => {
      const { className: le, controls: Ge, type: tt, align: ht, showWordCount: Tt, countMethod: gt, name: Ft, disabled: T, readonly: P, autocomplete: q } = e, { inputValue: J, visiblePanel: se, isActivated: ye } = s, Se = i.value, He = y.value, Be = b.value, qe = E.value, Ye = pe.value, lt = Xe.value, dt = ke.value, rt = Ue.value, pt = [], ct = Df(), vt = Dh();
      ct && pt.push(ct), pt.push(V("input", {
        ref: d,
        class: "vxe-input--inner",
        value: J,
        name: Ft,
        type: dt,
        placeholder: rt,
        maxlength: lt,
        readonly: Ye,
        disabled: T,
        autocomplete: q,
        onKeydown: rn,
        onKeyup: Tn,
        onWheel: Oo,
        onClick: gu,
        onInput: Re,
        onChange: we,
        onFocus: ze,
        onBlur: kn
      })), vt && pt.push(vt), pt.push(yu()), qe && pt.push(Mh());
      let at = !1;
      return Tt && ["text", "search"].includes(tt) && (at = !0, pt.push(V("span", {
        class: ["vxe-input--count", {
          "is--error": He
        }]
      }, gt ? `${gt({ value: J })}` : `${Be}${lt ? `/${lt}` : ""}`))), V("div", {
        ref: u,
        class: ["vxe-input", `type--${tt}`, le, {
          [`size--${Se}`]: Se,
          [`is--${ht}`]: ht,
          "is--controls": Ge,
          "is--prefix": !!ct,
          "is--suffix": !!vt,
          "is--readonly": P,
          "is--visivle": se,
          "is--count": at,
          "is--disabled": T,
          "is--active": ye
        }]
      }, pt);
    };
    return m.renderVN = Cu, m;
  },
  render() {
    return this.renderVN();
  }
}), Yl = Q({
  name: "VxeCheckbox",
  props: {
    modelValue: [String, Number, Boolean],
    label: { type: [String, Number], default: null },
    indeterminate: Boolean,
    title: [String, Number],
    checkedValue: { type: [String, Number, Boolean], default: !0 },
    uncheckedValue: { type: [String, Number, Boolean], default: !1 },
    content: [String, Number],
    disabled: Boolean,
    size: { type: String, default: () => ee.checkbox.size || ee.size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(e, t) {
    const { slots: n, emit: o } = t, l = ot("$xeform", null), a = ot("$xeformiteminfo", null), i = {
      xID: I.uniqueId(),
      props: e,
      context: t
    };
    let s = {};
    const u = Po(e), d = ot("$xecheckboxgroup", null), f = x(() => d ? I.includes(d.props.modelValue, e.label) : e.modelValue === e.checkedValue), v = x(() => {
      if (e.disabled)
        return !0;
      if (d) {
        const { props: p } = d, { computeIsMaximize: C } = d.getComputeMaps(), g = C.value, w = f.value;
        return p.disabled || g && !w;
      }
      return !1;
    }), h = (p) => {
      const { checkedValue: C, uncheckedValue: g } = e;
      if (!v.value) {
        const b = p.target.checked, y = b ? C : g, E = { checked: b, value: y, label: e.label };
        d ? d.handleChecked(E, p) : (o("update:modelValue", y), s.dispatchEvent("change", E, p), l && a && l.triggerItemEvent(p, a.itemConfig.field, y));
      }
    };
    s = {
      dispatchEvent(p, C, g) {
        o(p, Object.assign({ $checkbox: i, $event: g }, C));
      }
    }, Object.assign(i, s);
    const m = () => {
      const p = u.value, C = v.value, g = f.value, w = e.indeterminate;
      return V("label", {
        class: ["vxe-checkbox", {
          [`size--${p}`]: p,
          "is--indeterminate": w,
          "is--disabled": C,
          "is--checked": g
        }],
        title: e.title
      }, [
        V("input", {
          class: "vxe-checkbox--input",
          type: "checkbox",
          disabled: C,
          checked: g,
          onChange: h
        }),
        V("span", {
          class: ["vxe-checkbox--icon", w ? "vxe-icon-checkbox-indeterminate" : g ? "vxe-icon-checkbox-checked" : "vxe-icon-checkbox-unchecked"]
        }),
        V("span", {
          class: "vxe-checkbox--label"
        }, n.default ? n.default({}) : vo(e.content))
      ]);
    };
    return i.renderVN = m, i;
  },
  render() {
    return this.renderVN();
  }
});
function as(e) {
  return e.visible !== !1;
}
function _we() {
  return I.uniqueId("opt_");
}
const Si = Q({
  name: "VxeSelect",
  props: {
    modelValue: null,
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => I.eqNull(ee.select.placeholder) ? ee.i18n("vxe.base.pleaseSelect") : ee.select.placeholder
    },
    loading: Boolean,
    disabled: Boolean,
    multiple: Boolean,
    multiCharOverflow: { type: [Number, String], default: () => ee.select.multiCharOverflow },
    prefixIcon: String,
    placement: String,
    options: Array,
    optionProps: Object,
    optionGroups: Array,
    optionGroupProps: Object,
    optionConfig: Object,
    className: [String, Function],
    popupClassName: [String, Function],
    max: { type: [String, Number], default: null },
    size: { type: String, default: () => ee.select.size || ee.size },
    filterable: Boolean,
    filterMethod: Function,
    remote: Boolean,
    remoteMethod: Function,
    emptyText: String,
    // 已废弃，被 option-config.keyField 替换
    optionId: { type: String, default: () => ee.select.optionId },
    // 已废弃，被 option-config.useKey 替换
    optionKey: Boolean,
    transfer: { type: Boolean, default: () => ee.select.transfer }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "blur",
    "focus"
  ],
  setup(e, t) {
    const { slots: n, emit: o } = t, l = ot("$xeform", null), a = ot("$xeformiteminfo", null), r = I.uniqueId(), i = Po(e), s = en({
      inited: !1,
      staticOptions: [],
      fullGroupList: [],
      fullOptionList: [],
      visibleGroupList: [],
      visibleOptionList: [],
      remoteValueList: [],
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      currentOption: null,
      currentValue: null,
      visiblePanel: !1,
      animatVisible: !1,
      isActivated: !1,
      searchValue: "",
      searchLoading: !1
    }), u = B(), d = B(), f = B(), v = B(), h = B(), m = {
      refElem: u
    }, p = {
      xID: r,
      props: e,
      context: t,
      reactData: s,
      getRefMaps: () => m
    };
    let C = {};
    const g = x(() => e.optionProps || {}), w = x(() => e.optionGroupProps || {}), b = x(() => g.value.label || "label"), y = x(() => g.value.value || "value"), E = x(() => w.value.label || "label"), S = x(() => w.value.options || "options"), _ = x(() => {
      const { modelValue: ge, multiple: Ee, max: me } = e;
      return Ee && me ? (ge ? ge.length : 0) >= I.toNumber(me) : !1;
    }), k = x(() => Object.assign({}, ee.select.optionConfig, e.optionConfig)), N = x(() => s.fullGroupList.some((ge) => ge.options && ge.options.length)), L = x(() => I.toNumber(e.multiCharOverflow)), R = (ge, Ee) => ge && (I.isString(ge) && (ge = n[ge] || null), I.isFunction(ge)) ? oo(ge(Ee)) : [], H = (ge) => {
      const { fullOptionList: Ee, fullGroupList: me } = s, Ke = N.value, Re = y.value;
      if (Ke)
        for (let we = 0; we < me.length; we++) {
          const ze = me[we];
          if (ze.options)
            for (let Je = 0; Je < ze.options.length; Je++) {
              const Me = ze.options[Je];
              if (ge === Me[Re])
                return Me;
            }
        }
      return Ee.find((we) => ge === we[Re]);
    }, K = (ge) => {
      const { remoteValueList: Ee } = s, me = b.value, Ke = Ee.find((we) => ge === we.key), Re = Ke ? Ke.result : null;
      return I.toValueString(Re ? Re[me] : ge);
    }, U = (ge) => {
      const Ee = b.value, me = H(ge);
      return I.toValueString(me ? me[Ee] : ge);
    }, W = x(() => {
      const { modelValue: ge, multiple: Ee, remote: me } = e, Ke = L.value;
      if (ge && Ee) {
        const Re = I.isArray(ge) ? ge : [ge];
        return me ? Re.map((we) => K(we)).join(", ") : Re.map((we) => {
          const ze = U(we);
          return Ke > 0 && ze.length > Ke ? `${ze.substring(0, Ke)}...` : ze;
        }).join(", ");
      }
      return me ? K(ge) : U(ge);
    }), A = () => k.value.keyField || e.optionId || "_X_OPTION_KEY", $ = (ge) => {
      const Ee = ge[A()];
      return Ee ? encodeURIComponent(Ee) : "";
    }, D = () => {
      const { filterable: ge, filterMethod: Ee } = e, { fullOptionList: me, fullGroupList: Ke, searchValue: Re } = s, we = N.value, ze = E.value, Je = b.value;
      return we ? ge && Ee ? s.visibleGroupList = Ke.filter((Me) => as(Me) && Ee({ group: Me, option: null, searchValue: Re })) : ge ? s.visibleGroupList = Ke.filter((Me) => as(Me) && (!Re || `${Me[ze]}`.indexOf(Re) > -1)) : s.visibleGroupList = Ke.filter(as) : ge && Ee ? s.visibleOptionList = me.filter((Me) => as(Me) && Ee({ group: null, option: Me, searchValue: Re })) : ge ? s.visibleOptionList = me.filter((Me) => as(Me) && (!Re || `${Me[Je]}`.indexOf(Re) > -1)) : s.visibleOptionList = me.filter(as), xe();
    }, O = () => {
      const { fullOptionList: ge, fullGroupList: Ee } = s, me = S.value, Ke = A(), Re = (we) => {
        $(we) || (we[Ke] = _we());
      };
      Ee.length ? Ee.forEach((we) => {
        Re(we), we[me] && we[me].forEach(Re);
      }) : ge.length && ge.forEach(Re), D();
    }, F = (ge) => {
      const Ee = y.value;
      ge && (s.currentOption = ge, s.currentValue = ge[Ee]);
    }, j = (ge, Ee) => xe().then(() => {
      if (ge) {
        const me = v.value, Re = h.value.querySelector(`[optid='${$(ge)}']`);
        if (me && Re) {
          const we = me.offsetHeight, ze = 5;
          Ee ? Re.offsetTop + Re.offsetHeight - me.scrollTop > we && (me.scrollTop = Re.offsetTop + Re.offsetHeight - we) : (Re.offsetTop + ze < me.scrollTop || Re.offsetTop + ze > me.scrollTop + me.clientHeight) && (me.scrollTop = Re.offsetTop - ze);
        }
      }
    }), Z = () => {
      s.panelIndex < Yr() && (s.panelIndex = dr());
    }, te = () => xe().then(() => {
      const { transfer: ge, placement: Ee } = e, { panelIndex: me } = s, Ke = u.value, Re = h.value;
      if (Re && Ke) {
        const we = Ke.offsetHeight, ze = Ke.offsetWidth, Je = Re.offsetHeight, Me = Re.offsetWidth, et = 5, mt = {
          zIndex: me
        }, { boundingTop: Lt, boundingLeft: be, visibleHeight: an, visibleWidth: _t } = lr(Ke);
        let zt = "bottom";
        if (ge) {
          let jt = be, Sn = Lt + we;
          Ee === "top" ? (zt = "top", Sn = Lt - Je) : Ee || (Sn + Je + et > an && (zt = "top", Sn = Lt - Je), Sn < et && (zt = "bottom", Sn = Lt + we)), jt + Me + et > _t && (jt -= jt + Me + et - _t), jt < et && (jt = et), Object.assign(mt, {
            left: `${jt}px`,
            top: `${Sn}px`,
            minWidth: `${ze}px`
          });
        } else
          Ee === "top" ? (zt = "top", mt.bottom = `${we}px`) : Ee || Lt + we + Je > an && Lt - we - Je > et && (zt = "top", mt.bottom = `${we}px`);
        return s.panelStyle = mt, s.panelPlacement = zt, xe();
      }
    });
    let de;
    const Oe = () => {
      const { loading: ge, disabled: Ee, filterable: me } = e;
      !ge && !Ee && (clearTimeout(de), s.inited || (s.inited = !0), s.isActivated = !0, s.animatVisible = !0, me && D(), setTimeout(() => {
        const { modelValue: Ke, multiple: Re } = e, we = H(Re && Ke ? Ke[0] : Ke);
        s.visiblePanel = !0, we && (F(we), j(we)), je();
      }, 10), Z(), te());
    }, ce = () => {
      s.searchValue = "", s.searchLoading = !1, s.visiblePanel = !1, de = window.setTimeout(() => {
        s.animatVisible = !1;
      }, 350);
    }, ne = (ge, Ee) => {
      Ee !== e.modelValue && (o("update:modelValue", Ee), C.dispatchEvent("change", { value: Ee }, ge), l && a && l.triggerItemEvent(ge, a.itemConfig.field, Ee));
    }, Y = (ge, Ee) => {
      s.remoteValueList = [], ne(ge, Ee), C.dispatchEvent("clear", { value: Ee }, ge);
    }, ve = (ge, Ee) => {
      Y(Ee, null), ce();
    }, ie = (ge, Ee, me) => {
      const { modelValue: Ke, multiple: Re } = e, { remoteValueList: we } = s;
      if (Re) {
        let ze;
        Ke ? Ke.indexOf(Ee) === -1 ? ze = Ke.concat([Ee]) : ze = Ke.filter((Me) => Me !== Ee) : ze = [Ee];
        const Je = we.find((Me) => Me.key === Ee);
        Je ? Je.result = me : we.push({ key: Ee, result: me }), ne(ge, ze);
      } else
        s.remoteValueList = [{ key: Ee, result: me }], ne(ge, Ee), ce();
    }, he = (ge) => {
      const { disabled: Ee } = e, { visiblePanel: me } = s;
      if (!Ee && me) {
        const Ke = h.value;
        _n(ge, Ke).flag ? te() : ce();
      }
    }, De = (ge) => {
      const { disabled: Ee } = e, { visiblePanel: me } = s;
      if (!Ee) {
        const Ke = u.value, Re = h.value;
        s.isActivated = _n(ge, Ke).flag || _n(ge, Re).flag, me && !s.isActivated && ce();
      }
    }, $e = (ge, Ee) => {
      const { visibleOptionList: me, visibleGroupList: Ke } = s, Re = N.value, we = y.value, ze = S.value;
      let Je, Me, et, mt;
      if (Re)
        for (let Lt = 0; Lt < Ke.length; Lt++) {
          const be = Ke[Lt], an = be[ze], _t = be.disabled;
          if (an)
            for (let zt = 0; zt < an.length; zt++) {
              const jt = an[zt], Sn = as(jt), hn = _t || jt.disabled;
              if (!Je && !hn && (Je = jt), mt && Sn && !hn && (et = jt, !Ee))
                return { offsetOption: et };
              if (ge === jt[we]) {
                if (mt = jt, Ee)
                  return { offsetOption: Me };
              } else
                Sn && !hn && (Me = jt);
            }
        }
      else
        for (let Lt = 0; Lt < me.length; Lt++) {
          const be = me[Lt], an = be.disabled;
          if (!Je && !an && (Je = be), mt && !an && (et = be, !Ee))
            return { offsetOption: et };
          if (ge === be[we]) {
            if (mt = be, Ee)
              return { offsetOption: Me };
          } else
            an || (Me = be);
        }
      return { firstOption: Je };
    }, ue = (ge) => {
      const { clearable: Ee, disabled: me } = e, { visiblePanel: Ke, currentValue: Re, currentOption: we } = s;
      if (!me) {
        const ze = Cn(ge, un.TAB), Je = Cn(ge, un.ENTER), Me = Cn(ge, un.ESCAPE), et = Cn(ge, un.ARROW_UP), mt = Cn(ge, un.ARROW_DOWN), Lt = Cn(ge, un.DELETE), be = Cn(ge, un.SPACEBAR);
        if (ze && (s.isActivated = !1), Ke)
          if (Me || ze)
            ce();
          else if (Je)
            ge.preventDefault(), ge.stopPropagation(), ie(ge, Re, we);
          else if (et || mt) {
            ge.preventDefault();
            let { firstOption: an, offsetOption: _t } = $e(Re, et);
            !_t && !H(Re) && (_t = an), F(_t), j(_t, mt);
          } else
            be && ge.preventDefault();
        else
          (et || mt || Je || be) && s.isActivated && (ge.preventDefault(), Oe());
        s.isActivated && Lt && Ee && Y(ge, null);
      }
    }, Ne = () => {
      ce();
    }, je = () => {
      e.filterable && xe(() => {
        const ge = f.value;
        ge && ge.focus();
      });
    }, Fe = (ge) => {
      e.disabled || (s.isActivated = !0), C.dispatchEvent("focus", {}, ge);
    }, Ve = (ge) => {
      s.isActivated = !1, C.dispatchEvent("blur", {}, ge);
    }, Ze = (ge) => {
      s.searchValue = ge;
    }, ae = () => {
      s.isActivated = !0;
    }, pe = (ge) => {
      const { $event: Ee } = ge;
      Cn(Ee, un.ENTER) && (Ee.preventDefault(), Ee.stopPropagation());
    }, ke = I.debounce(function() {
      const { remote: ge, remoteMethod: Ee } = e, { searchValue: me } = s;
      ge && Ee ? (s.searchLoading = !0, Promise.resolve(Ee({ searchValue: me })).then(() => xe()).catch(() => xe()).finally(() => {
        s.searchLoading = !1, D();
      })) : D();
    }, 350, { trailing: !0 }), Ue = (ge) => {
      const { $event: Ee } = ge;
      Ee.preventDefault(), s.visiblePanel ? ce() : Oe();
    }, Xe = (ge, Ee, me) => !!(Ee.disabled || me && me.disabled || _.value && !ge), re = (ge, Ee) => {
      const { optionKey: me, modelValue: Ke, multiple: Re } = e, { currentValue: we } = s, ze = k.value, Je = b.value, Me = y.value, et = N.value, { useKey: mt } = ze, Lt = n.option;
      return ge.map((be, an) => {
        const { slots: _t, className: zt } = be, jt = be[Me], Sn = Re ? Ke && Ke.indexOf(jt) > -1 : Ke === jt, hn = !et || as(be), xn = Xe(Sn, be, Ee), yn = $(be), kn = _t ? _t.default : null, Wn = { option: be, group: null, $select: p };
        return hn ? V("div", {
          key: mt || me ? yn : an,
          class: ["vxe-select-option", zt ? I.isFunction(zt) ? zt(Wn) : zt : "", {
            "is--disabled": xn,
            "is--selected": Sn,
            "is--hover": we === jt
          }],
          // attrs
          optid: yn,
          // event
          onMousedown: (Vn) => {
            Vn.button === 0 && Vn.stopPropagation();
          },
          onClick: (Vn) => {
            xn || ie(Vn, jt, be);
          },
          onMouseenter: () => {
            xn || F(be);
          }
        }, Lt ? R(Lt, Wn) : kn ? R(kn, Wn) : ko(vo(be[Je]))) : null;
      });
    }, Te = () => {
      const { optionKey: ge } = e, { visibleGroupList: Ee } = s, me = k.value, Ke = E.value, Re = S.value, { useKey: we } = me, ze = n.option;
      return Ee.map((Je, Me) => {
        const { slots: et, className: mt } = Je, Lt = $(Je), be = Je.disabled, an = et ? et.default : null, _t = { option: Je, group: Je, $select: p };
        return V("div", {
          key: we || ge ? Lt : Me,
          class: ["vxe-optgroup", mt ? I.isFunction(mt) ? mt(_t) : mt : "", {
            "is--disabled": be
          }],
          // attrs
          optid: Lt
        }, [
          V("div", {
            class: "vxe-optgroup--title"
          }, ze ? R(ze, _t) : an ? R(an, _t) : vo(Je[Ke])),
          V("div", {
            class: "vxe-optgroup--wrapper"
          }, re(Je[Re] || [], Je))
        ]);
      });
    }, Ce = () => {
      const { visibleGroupList: ge, visibleOptionList: Ee, searchLoading: me } = s, Ke = N.value;
      if (me)
        return [
          V("div", {
            class: "vxe-select--search-loading"
          }, [
            V("i", {
              class: ["vxe-select--search-icon", ee.icon.SELECT_LOADED]
            }),
            V("span", {
              class: "vxe-select--search-text"
            }, ee.i18n("vxe.select.loadingText"))
          ])
        ];
      if (Ke) {
        if (ge.length)
          return Te();
      } else if (Ee.length)
        return re(Ee);
      return [
        V("div", {
          class: "vxe-select--empty-placeholder"
        }, e.emptyText || ee.i18n("vxe.select.emptyText"))
      ];
    };
    C = {
      dispatchEvent(ge, Ee, me) {
        o(ge, Object.assign({ $select: p, $event: me }, Ee));
      },
      isPanelVisible() {
        return s.visiblePanel;
      },
      togglePanel() {
        return s.visiblePanel ? ce() : Oe(), xe();
      },
      hidePanel() {
        return s.visiblePanel && ce(), xe();
      },
      showPanel() {
        return s.visiblePanel || Oe(), xe();
      },
      refreshOption: D,
      focus() {
        const ge = d.value;
        return s.isActivated = !0, ge.blur(), xe();
      },
      blur() {
        return d.value.blur(), s.isActivated = !1, xe();
      }
    }, Object.assign(p, C), Pe(() => s.staticOptions, (ge) => {
      ge.some((Ee) => Ee.options && Ee.options.length) ? (s.fullOptionList = [], s.fullGroupList = ge) : (s.fullGroupList = [], s.fullOptionList = ge || []), O();
    }), Pe(() => e.options, (ge) => {
      s.fullGroupList = [], s.fullOptionList = ge || [], O();
    }), Pe(() => e.optionGroups, (ge) => {
      s.fullOptionList = [], s.fullGroupList = ge || [], O();
    }), Nt(() => {
      xe(() => {
        const { options: ge, optionGroups: Ee } = e;
        Ee ? s.fullGroupList = Ee : ge && (s.fullOptionList = ge), O();
      }), wn.on(p, "mousewheel", he), wn.on(p, "mousedown", De), wn.on(p, "keydown", ue), wn.on(p, "blur", Ne);
    }), wo(() => {
      wn.off(p, "mousewheel"), wn.off(p, "mousedown"), wn.off(p, "keydown"), wn.off(p, "blur");
    });
    const Le = () => {
      const { className: ge, popupClassName: Ee, transfer: me, disabled: Ke, loading: Re, filterable: we } = e, { inited: ze, isActivated: Je, visiblePanel: Me } = s, et = i.value, mt = W.value, Lt = n.default, be = n.header, an = n.footer, _t = n.prefix;
      return V("div", {
        ref: u,
        class: ["vxe-select", ge ? I.isFunction(ge) ? ge({ $select: p }) : ge : "", {
          [`size--${et}`]: et,
          "is--visivle": Me,
          "is--disabled": Ke,
          "is--filter": we,
          "is--loading": Re,
          "is--active": Je
        }]
      }, [
        V("div", {
          class: "vxe-select-slots",
          ref: "hideOption"
        }, Lt ? Lt({}) : []),
        V(Rr, {
          ref: d,
          clearable: e.clearable,
          placeholder: e.placeholder,
          readonly: !0,
          disabled: Ke,
          type: "text",
          prefixIcon: e.prefixIcon,
          suffixIcon: Re ? ee.icon.SELECT_LOADED : Me ? ee.icon.SELECT_OPEN : ee.icon.SELECT_CLOSE,
          modelValue: mt,
          onClear: ve,
          onClick: Ue,
          onFocus: Fe,
          onBlur: Ve,
          onSuffixClick: Ue
        }, _t ? {
          prefix: () => _t({})
        } : {}),
        V(ka, {
          to: "body",
          disabled: me ? !ze : !0
        }, [
          V("div", {
            ref: h,
            class: ["vxe-table--ignore-clear vxe-select--panel", Ee ? I.isFunction(Ee) ? Ee({ $select: p }) : Ee : "", {
              [`size--${et}`]: et,
              "is--transfer": me,
              "animat--leave": !Re && s.animatVisible,
              "animat--enter": !Re && Me
            }],
            placement: s.panelPlacement,
            style: s.panelStyle
          }, ze ? [
            we ? V("div", {
              class: "vxe-select--panel-search"
            }, [
              V(Rr, {
                ref: f,
                class: "vxe-select-search--input",
                modelValue: s.searchValue,
                clearable: !0,
                placeholder: ee.i18n("vxe.select.search"),
                prefixIcon: ee.icon.INPUT_SEARCH,
                "onUpdate:modelValue": Ze,
                onFocus: ae,
                onKeydown: pe,
                onChange: ke,
                onSearch: ke
              })
            ]) : _e(),
            V("div", {
              class: "vxe-select--panel-wrapper"
            }, [
              be ? V("div", {
                class: "vxe-select--panel-header"
              }, be({})) : _e(),
              V("div", {
                class: "vxe-select--panel-body"
              }, [
                V("div", {
                  ref: v,
                  class: "vxe-select-option--wrapper"
                }, Ce())
              ]),
              an ? V("div", {
                class: "vxe-select--panel-footer"
              }, an({})) : _e()
            ])
          ] : [])
        ])
      ]);
    };
    return p.renderVN = Le, Mt("$xeselect", p), p;
  },
  render() {
    return this.renderVN();
  }
}), ad = Q({
  name: "VxeTableExportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(e) {
    const t = ot("$xetable", {}), { computeExportOpts: n, computePrintOpts: o } = t.getComputeMaps(), l = en({
      isAll: !1,
      isIndeterminate: !1,
      loading: !1
    }), a = B(), r = B(), i = B(), s = x(() => {
      const { storeData: _ } = e;
      return _.columns.every((k) => k.checked);
    }), u = x(() => {
      const { defaultOptions: _ } = e;
      return ["html", "xml", "xlsx", "pdf"].indexOf(_.type) > -1;
    }), d = x(() => {
      const { storeData: _, defaultOptions: k } = e;
      return !k.original && k.mode === "current" && (_.isPrint || ["html", "xlsx"].indexOf(k.type) > -1);
    }), f = x(() => {
      const { defaultOptions: _ } = e;
      return !_.original && ["xlsx"].indexOf(_.type) > -1;
    }), v = (_) => {
      const { storeData: k } = e, N = I.findTree(k.columns, (L) => L === _);
      if (N && N.parent) {
        const { parent: L } = N;
        L.children && L.children.length && (L.checked = L.children.every((R) => R.checked), L.halfChecked = !L.checked && L.children.some((R) => R.checked || R.halfChecked), v(L));
      }
    }, h = () => {
      const { storeData: _ } = e, k = _.columns;
      l.isAll = k.every((N) => N.disabled || N.checked), l.isIndeterminate = !l.isAll && k.some((N) => !N.disabled && (N.checked || N.halfChecked));
    }, m = (_) => {
      const k = !_.checked;
      I.eachTree([_], (N) => {
        N.checked = k, N.halfChecked = !1;
      }), v(_), h();
    }, p = () => {
      const { storeData: _ } = e, k = !l.isAll;
      I.eachTree(_.columns, (N) => {
        N.disabled || (N.checked = k, N.halfChecked = !1);
      }), l.isAll = k, h();
    }, C = () => {
      xe(() => {
        const _ = r.value, k = i.value, N = a.value, L = _ || k || N;
        L && L.focus();
      }), h();
    }, g = () => {
      const { storeData: _, defaultOptions: k } = e, { hasMerge: N, columns: L } = _, R = s.value, H = d.value, K = I.searchTree(L, (U) => U.checked, { children: "children", mapChildren: "childNodes", original: !0 });
      return Object.assign({}, k, {
        columns: K,
        isMerge: N && H && R ? k.isMerge : !1
      });
    }, w = () => {
      const { storeData: _ } = e, k = o.value;
      _.visible = !1, t.print(Object.assign({}, k, g()));
    }, b = () => {
      const { storeData: _ } = e, k = n.value;
      l.loading = !0, t.exportData(Object.assign({}, k, g())).then(() => {
        l.loading = !1, _.visible = !1;
      }).catch(() => {
        l.loading = !1;
      });
    }, y = () => {
      const { storeData: _ } = e;
      _.visible = !1;
    }, E = () => {
      const { storeData: _ } = e;
      _.isPrint ? w() : b();
    };
    return () => {
      const { defaultOptions: _, storeData: k } = e, { isAll: N, isIndeterminate: L } = l, { hasTree: R, hasMerge: H, isPrint: K, hasColgroup: U } = k, { isHeader: W } = _, A = [], $ = s.value, D = u.value, O = d.value, F = f.value;
      return I.eachTree(k.columns, (j) => {
        const Z = ko(j.getTitle(), 1), te = j.children && j.children.length, de = j.checked, Oe = j.halfChecked;
        A.push(V("li", {
          class: ["vxe-export--panel-column-option", `level--${j.level}`, {
            "is--group": te,
            "is--checked": de,
            "is--indeterminate": Oe,
            "is--disabled": j.disabled
          }],
          title: Z,
          onClick: () => {
            j.disabled || m(j);
          }
        }, [
          V("span", {
            class: ["vxe-checkbox--icon", Oe ? ee.icon.TABLE_CHECKBOX_INDETERMINATE : de ? ee.icon.TABLE_CHECKBOX_CHECKED : ee.icon.TABLE_CHECKBOX_UNCHECKED]
          }),
          V("span", {
            class: "vxe-checkbox--label"
          }, Z)
        ]));
      }), V(ws, {
        modelValue: k.visible,
        title: ee.i18n(K ? "vxe.export.printTitle" : "vxe.export.expTitle"),
        className: "vxe-table-export-popup-wrapper",
        width: 660,
        mask: !0,
        lockView: !0,
        showFooter: !1,
        escClosable: !0,
        maskClosable: !0,
        loading: l.loading,
        "onUpdate:modelValue"(j) {
          k.visible = j;
        },
        onShow: C
      }, {
        default: () => V("div", {
          class: "vxe-export--panel"
        }, [
          V("table", {
            cellspacing: 0,
            cellpadding: 0,
            border: 0
          }, [
            V("tbody", [
              [
                K ? _e() : V("tr", [
                  V("td", ee.i18n("vxe.export.expName")),
                  V("td", [
                    V(Rr, {
                      ref: r,
                      modelValue: _.filename,
                      type: "text",
                      clearable: !0,
                      placeholder: ee.i18n("vxe.export.expNamePlaceholder"),
                      "onUpdate:modelValue"(j) {
                        _.filename = j;
                      }
                    })
                  ])
                ]),
                K ? _e() : V("tr", [
                  V("td", ee.i18n("vxe.export.expType")),
                  V("td", [
                    V(Si, {
                      modelValue: _.type,
                      options: k.typeList.map((j) => ({
                        value: j.value,
                        label: ee.i18n(j.label)
                      })),
                      "onUpdate:modelValue"(j) {
                        _.type = j;
                      }
                    })
                  ])
                ]),
                K || D ? V("tr", [
                  V("td", ee.i18n("vxe.export.expSheetName")),
                  V("td", [
                    V(Rr, {
                      ref: i,
                      modelValue: _.sheetName,
                      type: "text",
                      clearable: !0,
                      placeholder: ee.i18n("vxe.export.expSheetNamePlaceholder"),
                      "onUpdate:modelValue"(j) {
                        _.sheetName = j;
                      }
                    })
                  ])
                ]) : _e(),
                V("tr", [
                  V("td", ee.i18n("vxe.export.expMode")),
                  V("td", [
                    V(Si, {
                      modelValue: _.mode,
                      options: k.modeList.map((j) => ({
                        value: j.value,
                        label: ee.i18n(j.label)
                      })),
                      "onUpdate:modelValue"(j) {
                        _.mode = j;
                      }
                    })
                  ])
                ]),
                V("tr", [
                  V("td", [ee.i18n("vxe.export.expColumn")]),
                  V("td", [
                    V("div", {
                      class: "vxe-export--panel-column"
                    }, [
                      V("ul", {
                        class: "vxe-export--panel-column-header"
                      }, [
                        V("li", {
                          class: ["vxe-export--panel-column-option", {
                            "is--checked": N,
                            "is--indeterminate": L
                          }],
                          title: ee.i18n("vxe.table.allTitle"),
                          onClick: p
                        }, [
                          V("span", {
                            class: ["vxe-checkbox--icon", L ? ee.icon.TABLE_CHECKBOX_INDETERMINATE : N ? ee.icon.TABLE_CHECKBOX_CHECKED : ee.icon.TABLE_CHECKBOX_UNCHECKED]
                          }),
                          V("span", {
                            class: "vxe-checkbox--label"
                          }, ee.i18n("vxe.export.expCurrentColumn"))
                        ])
                      ]),
                      V("ul", {
                        class: "vxe-export--panel-column-body"
                      }, A)
                    ])
                  ])
                ]),
                V("tr", [
                  V("td", ee.i18n("vxe.export.expOpts")),
                  V("td", [
                    V("div", {
                      class: "vxe-export--panel-option-row"
                    }, [
                      V(Yl, {
                        modelValue: _.isHeader,
                        title: ee.i18n("vxe.export.expHeaderTitle"),
                        content: ee.i18n("vxe.export.expOptHeader"),
                        "onUpdate:modelValue"(j) {
                          _.isHeader = j;
                        }
                      }),
                      V(Yl, {
                        modelValue: _.isFooter,
                        disabled: !k.hasFooter,
                        title: ee.i18n("vxe.export.expFooterTitle"),
                        content: ee.i18n("vxe.export.expOptFooter"),
                        "onUpdate:modelValue"(j) {
                          _.isFooter = j;
                        }
                      }),
                      V(Yl, {
                        modelValue: _.original,
                        title: ee.i18n("vxe.export.expOriginalTitle"),
                        content: ee.i18n("vxe.export.expOptOriginal"),
                        "onUpdate:modelValue"(j) {
                          _.original = j;
                        }
                      })
                    ]),
                    V("div", {
                      class: "vxe-export--panel-option-row"
                    }, [
                      V(Yl, {
                        modelValue: W && U && O ? _.isColgroup : !1,
                        title: ee.i18n("vxe.export.expColgroupTitle"),
                        disabled: !W || !U || !O,
                        content: ee.i18n("vxe.export.expOptColgroup"),
                        "onUpdate:modelValue"(j) {
                          _.isColgroup = j;
                        }
                      }),
                      V(Yl, {
                        modelValue: H && O && $ ? _.isMerge : !1,
                        title: ee.i18n("vxe.export.expMergeTitle"),
                        disabled: !H || !O || !$,
                        content: ee.i18n("vxe.export.expOptMerge"),
                        "onUpdate:modelValue"(j) {
                          _.isMerge = j;
                        }
                      }),
                      K ? _e() : V(Yl, {
                        modelValue: F ? _.useStyle : !1,
                        disabled: !F,
                        title: ee.i18n("vxe.export.expUseStyleTitle"),
                        content: ee.i18n("vxe.export.expOptUseStyle"),
                        "onUpdate:modelValue"(j) {
                          _.useStyle = j;
                        }
                      }),
                      V(Yl, {
                        modelValue: R ? _.isAllExpand : !1,
                        disabled: !R,
                        title: ee.i18n("vxe.export.expAllExpandTitle"),
                        content: ee.i18n("vxe.export.expOptAllExpand"),
                        "onUpdate:modelValue"(j) {
                          _.isAllExpand = j;
                        }
                      })
                    ])
                  ])
                ])
              ]
            ])
          ]),
          V("div", {
            class: "vxe-export--panel-btns"
          }, [
            V(Tl, {
              content: ee.i18n("vxe.export.expCancel"),
              onClick: y
            }),
            V(Tl, {
              ref: a,
              status: "primary",
              content: ee.i18n(K ? "vxe.export.expPrint" : "vxe.export.expConfirm"),
              onClick: E
            })
          ])
        ])
      });
    };
  }
}), _i = Q({
  name: "VxeRadio",
  props: {
    modelValue: [String, Number, Boolean],
    label: { type: [String, Number, Boolean], default: null },
    title: [String, Number],
    content: [String, Number],
    disabled: Boolean,
    name: String,
    strict: { type: Boolean, default: () => ee.radio.strict },
    size: { type: String, default: () => ee.radio.size || ee.size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(e, t) {
    const { slots: n, emit: o } = t, l = ot("$xeform", null), a = ot("$xeformiteminfo", null), i = {
      xID: I.uniqueId(),
      props: e,
      context: t
    }, s = Po(e), u = ot("$xeradiogroup", null);
    let d = {};
    const f = x(() => e.disabled || u && u.props.disabled), v = x(() => u ? u.name : e.name), h = x(() => u ? u.props.strict : e.strict), m = x(() => {
      const { modelValue: b, label: y } = e;
      return u ? u.props.modelValue === y : b === y;
    }), p = (b, y) => {
      u ? u.handleChecked({ label: b }, y) : (o("update:modelValue", b), d.dispatchEvent("change", { label: b }, y), l && a && l.triggerItemEvent(y, a.itemConfig.field, b));
    }, C = (b) => {
      f.value || p(e.label, b);
    }, g = (b) => {
      const y = f.value, E = h.value;
      !y && !E && e.label === (u ? u.props.modelValue : e.modelValue) && p(null, b);
    };
    d = {
      dispatchEvent(b, y, E) {
        o(b, Object.assign({ $radio: i, $event: E }, y));
      }
    }, Object.assign(i, d);
    const w = () => {
      const b = s.value, y = f.value, E = v.value, S = m.value;
      return V("label", {
        class: ["vxe-radio", {
          [`size--${b}`]: b,
          "is--checked": S,
          "is--disabled": y
        }],
        title: e.title
      }, [
        V("input", {
          class: "vxe-radio--input",
          type: "radio",
          name: E,
          checked: S,
          disabled: y,
          onChange: C,
          onClick: g
        }),
        V("span", {
          class: ["vxe-radio--icon", S ? "vxe-icon-radio-checked" : "vxe-icon-radio-unchecked"]
        }),
        V("span", {
          class: "vxe-radio--label"
        }, n.default ? n.default({}) : vo(e.content))
      ]);
    };
    return i.renderVN = w, i;
  },
  render() {
    return this.renderVN();
  }
}), Mc = Q({
  name: "VxeRadioButton",
  props: {
    modelValue: [String, Number, Boolean],
    label: { type: [String, Number, Boolean], default: null },
    title: [String, Number],
    content: [String, Number],
    disabled: Boolean,
    strict: { type: Boolean, default: () => ee.radioButton.strict },
    size: { type: String, default: () => ee.radioButton.size || ee.size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(e, t) {
    const { slots: n, emit: o } = t, l = ot("$xeform", null), a = ot("$xeformiteminfo", null), r = I.uniqueId(), i = Po(e), s = {
      xID: r,
      props: e,
      context: t
    };
    let u = {};
    const d = ot("$xeradiogroup", null), f = x(() => e.disabled || d && d.props.disabled), v = x(() => d ? d.name : null), h = x(() => d ? d.props.strict : e.strict), m = x(() => {
      const { modelValue: b, label: y } = e;
      return d ? d.props.modelValue === y : b === y;
    });
    u = {
      dispatchEvent(b, y, E) {
        o(b, Object.assign({ $radioButton: s, $event: E }, y));
      }
    }, Object.assign(s, u);
    const p = (b, y) => {
      d ? d.handleChecked({ label: b }, y) : (o("update:modelValue", b), u.dispatchEvent("change", { label: b }, y), l && a && l.triggerItemEvent(y, a.itemConfig.field, b));
    }, C = (b) => {
      f.value || p(e.label, b);
    }, g = (b) => {
      const y = f.value, E = h.value;
      !y && !E && e.label === (d ? d.props.modelValue : e.modelValue) && p(null, b);
    }, w = () => {
      const b = i.value, y = f.value, E = v.value, S = m.value;
      return V("label", {
        class: ["vxe-radio", "vxe-radio-button", {
          [`size--${b}`]: b,
          "is--disabled": y
        }],
        title: e.title
      }, [
        V("input", {
          class: "vxe-radio--input",
          type: "radio",
          name: E,
          checked: S,
          disabled: y,
          onChange: C,
          onClick: g
        }),
        V("span", {
          class: "vxe-radio--label"
        }, n.default ? n.default({}) : vo(e.content))
      ]);
    };
    return Object.assign(s, {
      renderVN: w,
      dispatchEvent
    }), w;
  }
}), xi = Q({
  name: "VxeRadioGroup",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: Boolean,
    type: String,
    options: Array,
    optionProps: Object,
    strict: { type: Boolean, default: () => ee.radioGroup.strict },
    size: { type: String, default: () => ee.radioGroup.size || ee.size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(e, t) {
    const { slots: n, emit: o } = t, l = ot("$xeform", null), a = ot("$xeformiteminfo", null), i = {
      xID: I.uniqueId(),
      props: e,
      context: t,
      name: I.uniqueId("xegroup_")
    }, s = x(() => e.optionProps || {}), u = x(() => s.value.label || "label"), d = x(() => s.value.value || "value"), f = x(() => s.value.disabled || "disabled");
    let v = {};
    Po(e);
    const h = {
      handleChecked(p, C) {
        o("update:modelValue", p.label), v.dispatchEvent("change", p), l && a && l.triggerItemEvent(C, a.itemConfig.field, p.label);
      }
    };
    v = {
      dispatchEvent(p, C, g) {
        o(p, Object.assign({ $radioGroup: i, $event: g }, C));
      }
    };
    const m = () => {
      const { options: p, type: C } = e, g = n.default, w = d.value, b = u.value, y = f.value, E = C === "button" ? Mc : _i;
      return V("div", {
        class: "vxe-radio-group"
      }, g ? g({}) : p ? p.map((S) => V(E, {
        label: S[w],
        content: S[b],
        disabled: S[y]
      })) : []);
    };
    return Object.assign(i, h, {
      renderVN: m,
      dispatchEvent
    }), Mt("$xeradiogroup", i), m;
  }
}), rd = Q({
  name: "VxeTableImportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(e) {
    const t = ot("$xetable", {}), { computeImportOpts: n } = t.getComputeMaps(), o = en({
      loading: !1
    }), l = B(), a = x(() => {
      const { storeData: m } = e;
      return `${m.filename}.${m.type}`;
    }), r = x(() => {
      const { storeData: m } = e;
      return m.file && m.type;
    }), i = x(() => {
      const { storeData: m } = e, { type: p, typeList: C } = m;
      if (p) {
        const g = I.find(C, (w) => p === w.value);
        return g ? ee.i18n(g.label) : "*.*";
      }
      return `*.${C.map((g) => g.value).join(", *.")}`;
    }), s = () => {
      const { storeData: m } = e;
      Object.assign(m, {
        filename: "",
        sheetName: "",
        type: ""
      });
    }, u = () => {
      const { storeData: m, defaultOptions: p } = e;
      t.readFile(p).then((C) => {
        const { file: g } = C;
        Object.assign(m, Z0(g), { file: g });
      }).catch((C) => C);
    }, d = () => {
      xe(() => {
        const m = l.value;
        m && m.focus();
      });
    }, f = () => {
      const { storeData: m } = e;
      m.visible = !1;
    }, v = () => {
      const { storeData: m, defaultOptions: p } = e, C = n.value;
      o.loading = !0, t.importByFile(m.file, Object.assign({}, C, p)).then(() => {
        o.loading = !1, m.visible = !1;
      }).catch(() => {
        o.loading = !1;
      });
    };
    return () => {
      const { defaultOptions: m, storeData: p } = e, C = a.value, g = r.value, w = i.value;
      return V(ws, {
        modelValue: p.visible,
        title: ee.i18n("vxe.import.impTitle"),
        className: "vxe-table-import-popup-wrapper",
        width: 440,
        mask: !0,
        lockView: !0,
        showFooter: !1,
        escClosable: !0,
        maskClosable: !0,
        loading: o.loading,
        "onUpdate:modelValue"(b) {
          p.visible = b;
        },
        onShow: d
      }, {
        default: () => V("div", {
          class: "vxe-export--panel"
        }, [
          V("table", {
            cellspacing: 0,
            cellpadding: 0,
            border: 0
          }, [
            V("tbody", [
              V("tr", [
                V("td", ee.i18n("vxe.import.impFile")),
                V("td", [
                  g ? V("div", {
                    class: "vxe-import-selected--file",
                    title: C
                  }, [
                    V("span", C),
                    V("i", {
                      class: ee.icon.INPUT_CLEAR,
                      onClick: s
                    })
                  ]) : V("button", {
                    ref: l,
                    class: "vxe-import-select--file",
                    onClick: u
                  }, ee.i18n("vxe.import.impSelect"))
                ])
              ]),
              V("tr", [
                V("td", ee.i18n("vxe.import.impType")),
                V("td", w)
              ]),
              V("tr", [
                V("td", ee.i18n("vxe.import.impOpts")),
                V("td", [
                  V(xi, {
                    modelValue: m.mode,
                    "onUpdate:modelValue"(b) {
                      m.mode = b;
                    }
                  }, {
                    default: () => p.modeList.map((b) => V(_i, { label: b.value, content: ee.i18n(b.label) }))
                  })
                ])
              ])
            ])
          ]),
          V("div", {
            class: "vxe-export--panel-btns"
          }, [
            V(Tl, {
              content: ee.i18n("vxe.import.impCancel"),
              onClick: f
            }),
            V(Tl, {
              status: "primary",
              disabled: !g,
              content: ee.i18n("vxe.import.impConfirm"),
              onClick: v
            })
          ])
        ])
      });
    };
  }
});
let ac, rs, Sl;
const xwe = 'body{margin:0;padding: 0 1px;color:#333333;font-size:14px;font-family:"Microsoft YaHei",微软雅黑,"MicrosoftJhengHei",华文细黑,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function V_() {
  const e = document.createElement("iframe");
  return e.className = "vxe-table--print-frame", e;
}
function u1(e, t) {
  return new Blob([e], { type: `text/${t.type};charset=utf-8;` });
}
function YI(e, t) {
  const { style: n } = e;
  return [
    "<!DOCTYPE html><html>",
    "<head>",
    '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">',
    `<title>${e.sheetName}</title>`,
    '<style media="print">.vxe-page-break-before{page-break-before:always;}.vxe-page-break-after{page-break-after:always;}</style>',
    `<style>${xwe}</style>`,
    n ? `<style>${n}</style>` : "",
    "</head>",
    `<body>${t}</body>`,
    "</html>"
  ].join("");
}
const gv = (e) => {
  const t = Object.assign({}, e);
  return ac || (ac = document.createElement("form"), rs = document.createElement("input"), ac.className = "vxe-table--file-form", rs.name = "file", rs.type = "file", ac.appendChild(rs), document.body.appendChild(ac)), new Promise((n, o) => {
    const l = t.types || [], a = !l.length || l.some((r) => r === "*");
    rs.multiple = !!t.multiple, rs.accept = a ? "" : `.${l.join(", .")}`, rs.onchange = (r) => {
      const { files: i } = r.target, s = i[0];
      let u = "";
      if (!a)
        for (let d = 0; d < i.length; d++) {
          const { type: f } = Z0(i[d]);
          if (!I.includes(l, f)) {
            u = f;
            break;
          }
        }
      u ? (t.message !== !1 && (process.env.NODE_ENV === "development" && ($t.modal || Ht("vxe.error.reqModule", ["Modal"])), $t.modal.message({ content: ee.i18n("vxe.error.notType", [u]), status: "error" })), o({ status: !1, files: i, file: s })) : n({ status: !0, files: i, file: s });
    }, ac.reset(), rs.click();
  });
};
function GI() {
  if (Sl) {
    if (Sl.parentNode) {
      try {
        Sl.contentDocument.write("");
      } catch {
      }
      Sl.parentNode.removeChild(Sl);
    }
    Sl = null;
  }
}
function B_() {
  Sl.parentNode || document.body.appendChild(Sl);
}
function kwe() {
  requestAnimationFrame(GI);
}
function Eb(e, t, n = "") {
  const { beforePrintMethod: o } = t;
  o && (n = o({ content: n, options: t, $table: e }) || ""), n = YI(t, n);
  const l = u1(n, t);
  Jl.msie ? (GI(), Sl = V_(), B_(), Sl.contentDocument.write(n), Sl.contentDocument.execCommand("print")) : (Sl || (Sl = V_(), Sl.onload = (a) => {
    a.target.src && (a.target.contentWindow.onafterprint = kwe, a.target.contentWindow.print());
  }), B_(), Sl.src = URL.createObjectURL(l));
}
const bv = (e) => {
  const { filename: t, type: n, content: o } = e, l = `${t}.${n}`;
  if (window.Blob) {
    const a = o instanceof Blob ? o : u1(I.toValueString(o), e);
    if (navigator.msSaveBlob)
      navigator.msSaveBlob(a, l);
    else {
      const r = URL.createObjectURL(a), i = document.createElement("a");
      i.target = "_blank", i.download = l, i.href = r, document.body.appendChild(i), i.click(), requestAnimationFrame(() => {
        i.parentNode && i.parentNode.removeChild(i), URL.revokeObjectURL(r);
      });
    }
    return Promise.resolve();
  }
  return Promise.reject(new Error(U0("vxe.error.notExp")));
};
let rc;
const Twe = "\uFEFF", ni = `\r
`;
function H_(e) {
  return e.property || ["seq", "checkbox", "radio"].indexOf(e.type) > -1;
}
const XI = (e) => {
  const t = [];
  return e.forEach((n) => {
    n.childNodes && n.childNodes.length ? (t.push(n), t.push(...XI(n.childNodes))) : t.push(n);
  }), t;
}, $we = (e) => {
  let t = 1;
  const n = (a, r) => {
    if (r && (a._level = r._level + 1, t < a._level && (t = a._level)), a.childNodes && a.childNodes.length) {
      let i = 0;
      a.childNodes.forEach((s) => {
        n(s, a), i += s._colSpan;
      }), a._colSpan = i;
    } else
      a._colSpan = 1;
  };
  e.forEach((a) => {
    a._level = 1, n(a);
  });
  const o = [];
  for (let a = 0; a < t; a++)
    o.push([]);
  return XI(e).forEach((a) => {
    a.childNodes && a.childNodes.length ? a._rowSpan = 1 : a._rowSpan = t - a._level + 1, o[a._level - 1].push(a);
  }), o;
};
function Owe(e) {
  return e === !0 ? "full" : e || "default";
}
function sc(e) {
  return e === "TRUE" || e === "true" || e === !0;
}
function dp(e, t) {
  const { footerFilterMethod: n } = e;
  return n ? t.filter((o, l) => n({ items: o, $rowIndex: l })) : t;
}
function Nwe(e, t) {
  if (t) {
    if (e.type === "seq")
      return `	${t}`;
    switch (e.cellType) {
      case "string":
        if (!isNaN(t))
          return `	${t}`;
        break;
      case "number":
        break;
      default:
        if (t.length >= 12 && !isNaN(t))
          return `	${t}`;
        break;
    }
  }
  return t;
}
function ic(e) {
  return /[",\s\n]/.test(e) ? `"${e.replace(/"/g, '""')}"` : e;
}
function ql(e, t) {
  return e.getElementsByTagName(t);
}
function z_(e) {
  return `#${e}@${I.uniqueId()}`;
}
function ZI(e, t) {
  return e.replace(/#\d+@\d+/g, (n) => I.hasOwnProp(t, n) ? t[n] : n);
}
function W_(e, t) {
  return ZI(e, t).replace(/^"+$/g, (o) => '"'.repeat(Math.ceil(o.length / 2)));
}
function JI(e, t, n) {
  const o = t.split(ni), l = [];
  let a = [];
  if (o.length) {
    const r = {}, i = Date.now();
    o.forEach((s) => {
      if (s) {
        const u = {};
        s = s.replace(/("")|(\n)/g, (f, v) => {
          const h = z_(i);
          return r[h] = v ? '"' : `
`, h;
        }).replace(/"(.*?)"/g, (f, v) => {
          const h = z_(i);
          return r[h] = ZI(v, r), h;
        });
        const d = s.split(n);
        a.length ? (d.forEach((f, v) => {
          v < a.length && (u[a[v]] = W_(f.trim(), r));
        }), l.push(u)) : a = d.map((f) => W_(f.trim(), r));
      }
    });
  }
  return { fields: a, rows: l };
}
function Mwe(e, t) {
  return JI(e, t, ",");
}
function Iwe(e, t) {
  return JI(e, t, "	");
}
function Rwe(e, t) {
  const o = new DOMParser().parseFromString(t, "text/html"), l = ql(o, "body"), a = [], r = [];
  if (l.length) {
    const i = ql(l[0], "table");
    if (i.length) {
      const s = ql(i[0], "thead");
      if (s.length) {
        I.arrayEach(ql(s[0], "tr"), (d) => {
          I.arrayEach(ql(d, "th"), (f) => {
            r.push(f.textContent);
          });
        });
        const u = ql(i[0], "tbody");
        u.length && I.arrayEach(ql(u[0], "tr"), (d) => {
          const f = {};
          I.arrayEach(ql(d, "td"), (v, h) => {
            r[h] && (f[r[h]] = v.textContent || "");
          }), a.push(f);
        });
      }
    }
  }
  return { fields: r, rows: a };
}
function Dwe(e, t) {
  const o = new DOMParser().parseFromString(t, "application/xml"), l = ql(o, "Worksheet"), a = [], r = [];
  if (l.length) {
    const i = ql(l[0], "Table");
    if (i.length) {
      const s = ql(i[0], "Row");
      s.length && (I.arrayEach(ql(s[0], "Cell"), (u) => {
        r.push(u.textContent);
      }), I.arrayEach(s, (u, d) => {
        if (d) {
          const f = {}, v = ql(u, "Cell");
          I.arrayEach(v, (h, m) => {
            r[m] && (f[r[m]] = h.textContent);
          }), a.push(f);
        }
      }));
    }
  }
  return { fields: r, rows: a };
}
function K_(e) {
  I.eachTree(e, (t) => {
    delete t._level, delete t._colSpan, delete t._rowSpan, delete t._children, delete t.childNodes;
  }, { children: "children" });
}
function Lwe(e, t) {
  const n = [];
  return e.forEach((o) => {
    const l = o.property;
    l && n.push(l);
  }), t.some((o) => n.indexOf(o) > -1);
}
const Pwe = ["exportData", "importByFile", "importData", "saveFile", "readFile", "print", "openImport", "openExport", "openPrint"], Awe = {
  setupTable(e) {
    const { props: t, reactData: n, internalData: o } = e, { computeTreeOpts: l, computePrintOpts: a, computeExportOpts: r, computeImportOpts: i, computeCustomOpts: s, computeSeqOpts: u, computeRadioOpts: d, computeCheckboxOpts: f, computeColumnOpts: v } = e.getComputeMaps(), h = ot("$xegrid", null), m = ($) => {
      const D = l.value, O = D.children || D.childrenField;
      return $[O] && $[O].length;
    }, p = ($, D, O, F) => {
      const Z = u.value.seqMethod || O.seqMethod;
      return Z ? Z({
        row: $,
        rowIndex: e.getRowIndex($),
        $rowIndex: D,
        column: O,
        columnIndex: e.getColumnIndex(O),
        $columnIndex: F
      }) : e.getRowSeq($);
    };
    function C($, D) {
      const O = v.value, F = D.headerExportMethod || O.headerExportMethod;
      return F ? F({ column: D, options: $, $table: e }) : ($.original ? D.property : D.getTitle()) || "";
    }
    const g = ($) => I.isBoolean($) ? $ ? "TRUE" : "FALSE" : $, w = ($, D, O) => {
      const { isAllExpand: F, mode: j } = $, { treeConfig: Z } = t, te = d.value, de = f.value, Oe = l.value, ce = v.value;
      if (rc || (rc = document.createElement("div")), Z) {
        const ne = Oe.children || Oe.childrenField, Y = [], ve = /* @__PURE__ */ new Map();
        return I.eachTree(O, (ie, he, De, $e, ue, Ne) => {
          const je = ie._row || ie, Fe = ue && ue._row ? ue._row : ue;
          if (F || !Fe || ve.has(Fe) && e.isTreeExpandByRow(Fe)) {
            const Ve = m(je), Ze = {
              _row: je,
              _level: Ne.length - 1,
              _hasChild: Ve,
              _expand: Ve && e.isTreeExpandByRow(je)
            };
            D.forEach((ae, pe) => {
              let ke = "";
              const Ue = ae.editRender || ae.cellRender;
              let Xe = ae.exportMethod;
              if (!Xe && Ue && Ue.name) {
                const re = $t.renderer.get(Ue.name);
                re && (Xe = re.exportMethod);
              }
              if (Xe || (Xe = ce.exportMethod), Xe)
                ke = Xe({ $table: e, row: je, column: ae, options: $ });
              else
                switch (ae.type) {
                  case "seq":
                    ke = j === "all" ? $e.map((re, Te) => Te % 2 === 0 ? Number(re) + 1 : ".").join("") : p(je, he, ae, pe);
                    break;
                  case "checkbox":
                    ke = g(e.isCheckedByCheckboxRow(je)), Ze._checkboxLabel = de.labelField ? I.get(je, de.labelField) : "", Ze._checkboxDisabled = de.checkMethod && !de.checkMethod({ row: je });
                    break;
                  case "radio":
                    ke = g(e.isCheckedByRadioRow(je)), Ze._radioLabel = te.labelField ? I.get(je, te.labelField) : "", Ze._radioDisabled = te.checkMethod && !te.checkMethod({ row: je });
                    break;
                  default:
                    if ($.original)
                      ke = xa(je, ae);
                    else if (ke = e.getCellLabel(je, ae), ae.type === "html")
                      rc.innerHTML = ke, ke = rc.innerText.trim();
                    else {
                      const re = e.getCell(je, ae);
                      re && (ke = re.innerText.trim());
                    }
                }
              Ze[ae.id] = I.toValueString(ke);
            }), ve.set(je, 1), Y.push(Object.assign(Ze, je));
          }
        }, { children: ne }), Y;
      }
      return O.map((ne, Y) => {
        const ve = {
          _row: ne
        };
        return D.forEach((ie, he) => {
          let De = "";
          const $e = ie.editRender || ie.cellRender;
          let ue = ie.exportMethod;
          if (!ue && $e && $e.name) {
            const Ne = $t.renderer.get($e.name);
            Ne && (ue = Ne.exportMethod);
          }
          if (ue)
            De = ue({ $table: e, row: ne, column: ie, options: $ });
          else
            switch (ie.type) {
              case "seq":
                De = j === "all" ? Y + 1 : p(ne, Y, ie, he);
                break;
              case "checkbox":
                De = g(e.isCheckedByCheckboxRow(ne)), ve._checkboxLabel = de.labelField ? I.get(ne, de.labelField) : "", ve._checkboxDisabled = de.checkMethod && !de.checkMethod({ row: ne });
                break;
              case "radio":
                De = g(e.isCheckedByRadioRow(ne)), ve._radioLabel = te.labelField ? I.get(ne, te.labelField) : "", ve._radioDisabled = te.checkMethod && !te.checkMethod({ row: ne });
                break;
              default:
                if ($.original)
                  De = xa(ne, ie);
                else if (De = e.getCellLabel(ne, ie), ie.type === "html")
                  rc.innerHTML = De, De = rc.innerText.trim();
                else {
                  const Ne = e.getCell(ne, ie);
                  Ne && (De = Ne.innerText.trim());
                }
            }
          ve[ie.id] = I.toValueString(De);
        }), ve;
      });
    }, b = ($) => {
      const { columns: D, dataFilterMethod: O } = $;
      let F = $.data;
      return O && (F = F.filter((j, Z) => O({ row: j, $rowIndex: Z }))), w($, D, F);
    }, y = ($, D, O) => {
      const F = v.value, j = O.editRender || O.cellRender;
      let Z = O.footerExportMethod;
      if (!Z && j && j.name) {
        const Oe = $t.renderer.get(j.name);
        Oe && (Z = Oe.footerExportMethod);
      }
      Z || (Z = F.footerExportMethod);
      const te = e.getVTColumnIndex(O);
      return Z ? Z({ $table: e, items: D, itemIndex: te, row: D, _columnIndex: te, column: O, options: $ }) : I.toValueString(D[te]);
    }, E = ($, D, O) => {
      let F = Twe;
      if ($.isHeader && (F += D.map((j) => ic(C($, j))).join(",") + ni), O.forEach((j) => {
        F += D.map((Z) => ic(Nwe(Z, j[Z.id]))).join(",") + ni;
      }), $.isFooter) {
        const { footerTableData: j } = n;
        dp($, j).forEach((te) => {
          F += D.map((de) => ic(y($, te, de))).join(",") + ni;
        });
      }
      return F;
    }, S = ($, D, O) => {
      let F = "";
      if ($.isHeader && (F += D.map((j) => ic(C($, j))).join("	") + ni), O.forEach((j) => {
        F += D.map((Z) => ic(j[Z.id])).join("	") + ni;
      }), $.isFooter) {
        const { footerTableData: j } = n;
        dp($, j).forEach((te) => {
          F += D.map((de) => ic(y($, te, de))).join(",") + ni;
        });
      }
      return F;
    }, _ = ($, D, O) => {
      const F = $[D], j = I.isUndefined(F) || I.isNull(F) ? O : F;
      let Oe = j === "title" || (j === !0 || j === "tooltip") || j === "ellipsis";
      const { scrollXLoad: ce, scrollYLoad: ne } = n;
      return (ce || ne) && !Oe && (Oe = !0), Oe;
    }, k = ($, D, O) => {
      const { id: F, border: j, treeConfig: Z, headerAlign: te, align: de, footerAlign: Oe, showOverflow: ce, showHeaderOverflow: ne } = t, { isAllSelected: Y, isIndeterminate: ve, mergeList: ie } = n, he = l.value, { print: De, isHeader: $e, isFooter: ue, isColgroup: Ne, isMerge: je, colgroups: Fe, original: Ve } = $, Ze = "check-all", pe = [
        `<table class="${[
          "vxe-table",
          `border--${Owe(j)}`,
          De ? "is--print" : "",
          $e ? "is--header" : ""
        ].filter((Ue) => Ue).join(" ")}" border="0" cellspacing="0" cellpadding="0">`,
        `<colgroup>${D.map((Ue) => `<col style="width:${Ue.renderWidth}px">`).join("")}</colgroup>`
      ];
      if ($e && (pe.push("<thead>"), Ne && !Ve ? Fe.forEach((Ue) => {
        pe.push(`<tr>${Ue.map((Xe) => {
          const re = Xe.headerAlign || Xe.align || te || de, Te = _(Xe, "showHeaderOverflow", ne) ? ["col--ellipsis"] : [], Ce = C($, Xe);
          let Le = 0, ge = 0;
          I.eachTree([Xe], (me) => {
            (!me.childNodes || !Xe.childNodes.length) && ge++, Le += me.renderWidth;
          }, { children: "childNodes" });
          const Ee = Le - ge;
          return re && Te.push(`col--${re}`), Xe.type === "checkbox" ? `<th class="${Te.join(" ")}" colspan="${Xe._colSpan}" rowspan="${Xe._rowSpan}"><div ${De ? "" : `style="width: ${Ee}px"`}><input type="checkbox" class="${Ze}" ${Y ? "checked" : ""}><span>${Ce}</span></div></th>` : `<th class="${Te.join(" ")}" colspan="${Xe._colSpan}" rowspan="${Xe._rowSpan}" title="${Ce}"><div ${De ? "" : `style="width: ${Ee}px"`}><span>${ko(Ce, !0)}</span></div></th>`;
        }).join("")}</tr>`);
      }) : pe.push(`<tr>${D.map((Ue) => {
        const Xe = Ue.headerAlign || Ue.align || te || de, re = _(Ue, "showHeaderOverflow", ne) ? ["col--ellipsis"] : [], Te = C($, Ue);
        return Xe && re.push(`col--${Xe}`), Ue.type === "checkbox" ? `<th class="${re.join(" ")}"><div ${De ? "" : `style="width: ${Ue.renderWidth}px"`}><input type="checkbox" class="${Ze}" ${Y ? "checked" : ""}><span>${Te}</span></div></th>` : `<th class="${re.join(" ")}" title="${Te}"><div ${De ? "" : `style="width: ${Ue.renderWidth}px"`}><span>${ko(Te, !0)}</span></div></th>`;
      }).join("")}</tr>`), pe.push("</thead>")), O.length && (pe.push("<tbody>"), Z ? O.forEach((Ue) => {
        pe.push("<tr>" + D.map((Xe) => {
          const re = Xe.align || de, Te = _(Xe, "showOverflow", ce) ? ["col--ellipsis"] : [], Ce = Ue[Xe.id];
          if (re && Te.push(`col--${re}`), Xe.treeNode) {
            let Le = "";
            return Ue._hasChild && (Le = `<i class="${Ue._expand ? "vxe-table--tree-fold-icon" : "vxe-table--tree-unfold-icon"}"></i>`), Te.push("vxe-table--tree-node"), Xe.type === "radio" ? `<td class="${Te.join(" ")}" title="${Ce}"><div ${De ? "" : `style="width: ${Xe.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${Ue._level * he.indent}px"><div class="vxe-table--tree-icon-wrapper">${Le}</div><div class="vxe-table--tree-cell"><input type="radio" name="radio_${F}" ${Ue._radioDisabled ? "disabled " : ""}${sc(Ce) ? "checked" : ""}><span>${Ue._radioLabel}</span></div></div></div></td>` : Xe.type === "checkbox" ? `<td class="${Te.join(" ")}" title="${Ce}"><div ${De ? "" : `style="width: ${Xe.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${Ue._level * he.indent}px"><div class="vxe-table--tree-icon-wrapper">${Le}</div><div class="vxe-table--tree-cell"><input type="checkbox" ${Ue._checkboxDisabled ? "disabled " : ""}${sc(Ce) ? "checked" : ""}><span>${Ue._checkboxLabel}</span></div></div></div></td>` : `<td class="${Te.join(" ")}" title="${Ce}"><div ${De ? "" : `style="width: ${Xe.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${Ue._level * he.indent}px"><div class="vxe-table--tree-icon-wrapper">${Le}</div><div class="vxe-table--tree-cell">${Ce}</div></div></div></td>`;
          }
          return Xe.type === "radio" ? `<td class="${Te.join(" ")}"><div ${De ? "" : `style="width: ${Xe.renderWidth}px"`}><input type="radio" name="radio_${F}" ${Ue._radioDisabled ? "disabled " : ""}${sc(Ce) ? "checked" : ""}><span>${Ue._radioLabel}</span></div></td>` : Xe.type === "checkbox" ? `<td class="${Te.join(" ")}"><div ${De ? "" : `style="width: ${Xe.renderWidth}px"`}><input type="checkbox" ${Ue._checkboxDisabled ? "disabled " : ""}${sc(Ce) ? "checked" : ""}><span>${Ue._checkboxLabel}</span></div></td>` : `<td class="${Te.join(" ")}" title="${Ce}"><div ${De ? "" : `style="width: ${Xe.renderWidth}px"`}>${ko(Ce, !0)}</div></td>`;
        }).join("") + "</tr>");
      }) : O.forEach((Ue) => {
        pe.push("<tr>" + D.map((Xe) => {
          const re = Xe.align || de, Te = _(Xe, "showOverflow", ce) ? ["col--ellipsis"] : [], Ce = Ue[Xe.id];
          let Le = 1, ge = 1;
          if (je && ie.length) {
            const Ee = e.getVTRowIndex(Ue._row), me = e.getVTColumnIndex(Xe), Ke = $I(ie, Ee, me);
            if (Ke) {
              const { rowspan: Re, colspan: we } = Ke;
              if (!Re || !we)
                return "";
              Re > 1 && (Le = Re), we > 1 && (ge = we);
            }
          }
          return re && Te.push(`col--${re}`), Xe.type === "radio" ? `<td class="${Te.join(" ")}" rowspan="${Le}" colspan="${ge}"><div ${De ? "" : `style="width: ${Xe.renderWidth}px"`}><input type="radio" name="radio_${F}" ${Ue._radioDisabled ? "disabled " : ""}${sc(Ce) ? "checked" : ""}><span>${Ue._radioLabel}</span></div></td>` : Xe.type === "checkbox" ? `<td class="${Te.join(" ")}" rowspan="${Le}" colspan="${ge}"><div ${De ? "" : `style="width: ${Xe.renderWidth}px"`}><input type="checkbox" ${Ue._checkboxDisabled ? "disabled " : ""}${sc(Ce) ? "checked" : ""}><span>${Ue._checkboxLabel}</span></div></td>` : `<td class="${Te.join(" ")}" rowspan="${Le}" colspan="${ge}" title="${Ce}"><div ${De ? "" : `style="width: ${Xe.renderWidth}px"`}>${ko(Ce, !0)}</div></td>`;
        }).join("") + "</tr>");
      }), pe.push("</tbody>")), ue) {
        const { footerTableData: Ue } = n, Xe = dp($, Ue);
        Xe.length && (pe.push("<tfoot>"), Xe.forEach((re) => {
          pe.push(`<tr>${D.map((Te) => {
            const Ce = Te.footerAlign || Te.align || Oe || de, Le = _(Te, "showOverflow", ce) ? ["col--ellipsis"] : [], ge = y($, re, Te);
            return Ce && Le.push(`col--${Ce}`), `<td class="${Le.join(" ")}" title="${ge}"><div ${De ? "" : `style="width: ${Te.renderWidth}px"`}>${ko(ge, !0)}</div></td>`;
          }).join("")}</tr>`);
        }), pe.push("</tfoot>"));
      }
      const ke = !Y && ve ? `<script>(function(){var a=document.querySelector(".${Ze}");if(a){a.indeterminate=true}})()<\/script>` : "";
      return pe.push("</table>", ke), De ? pe.join("") : YI($, pe.join(""));
    }, N = ($, D, O) => {
      let F = [
        '<?xml version="1.0"?>',
        '<?mso-application progid="Excel.Sheet"?>',
        '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40">',
        '<DocumentProperties xmlns="urn:schemas-microsoft-com:office:office">',
        "<Version>16.00</Version>",
        "</DocumentProperties>",
        '<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel">',
        "<WindowHeight>7920</WindowHeight>",
        "<WindowWidth>21570</WindowWidth>",
        "<WindowTopX>32767</WindowTopX>",
        "<WindowTopY>32767</WindowTopY>",
        "<ProtectStructure>False</ProtectStructure>",
        "<ProtectWindows>False</ProtectWindows>",
        "</ExcelWorkbook>",
        `<Worksheet ss:Name="${$.sheetName}">`,
        "<Table>",
        D.map((j) => `<Column ss:Width="${j.renderWidth}"/>`).join("")
      ].join("");
      if ($.isHeader && (F += `<Row>${D.map((j) => `<Cell><Data ss:Type="String">${C($, j)}</Data></Cell>`).join("")}</Row>`), O.forEach((j) => {
        F += "<Row>" + D.map((Z) => `<Cell><Data ss:Type="String">${j[Z.id]}</Data></Cell>`).join("") + "</Row>";
      }), $.isFooter) {
        const { footerTableData: j } = n;
        dp($, j).forEach((te) => {
          F += `<Row>${D.map((de) => `<Cell><Data ss:Type="String">${y($, te, de)}</Data></Cell>`).join("")}</Row>`;
        });
      }
      return `${F}</Table></Worksheet></Workbook>`;
    }, L = ($, D, O) => {
      if (D.length)
        switch ($.type) {
          case "csv":
            return E($, D, O);
          case "txt":
            return S($, D, O);
          case "html":
            return k($, D, O);
          case "xml":
            return N($, D, O);
        }
      return "";
    }, R = ($, D) => {
      const { filename: O, type: F, download: j } = $;
      if (!j) {
        const Z = u1(D, $);
        return Promise.resolve({ type: F, content: D, blob: Z });
      }
      bv({ filename: O, type: F, content: D }).then(() => {
        $.message !== !1 && (process.env.NODE_ENV === "development" && ($t.modal || Ht("vxe.error.reqModule", ["Modal"])), $t.modal.message({ content: ee.i18n("vxe.table.expSuccess"), status: "success" }));
      });
    }, H = ($) => {
      const { remote: D, columns: O, colgroups: F, exportMethod: j, afterExportMethod: Z } = $;
      return new Promise((te) => {
        if (D) {
          const de = { options: $, $table: e, $grid: h };
          te(j ? j(de) : de);
        } else {
          const de = b($);
          te(e.preventEvent(null, "event.export", { options: $, columns: O, colgroups: F, datas: de }, () => R($, L($, O, de))));
        }
      }).then((te) => (K_(O), $.print || Z && Z({ status: !0, options: $, $table: e, $grid: h }), Object.assign({ status: !0 }, te))).catch(() => {
        K_(O), $.print || Z && Z({ status: !1, options: $, $table: e, $grid: h });
        const te = { status: !1 };
        return Promise.reject(te);
      });
    }, K = ($, D) => {
      const { tableFullColumn: O, _importResolve: F, _importReject: j } = o;
      let Z = { fields: [], rows: [] };
      switch (D.type) {
        case "csv":
          Z = Mwe(O, $);
          break;
        case "txt":
          Z = Iwe(O, $);
          break;
        case "html":
          Z = Rwe(O, $);
          break;
        case "xml":
          Z = Dwe(O, $);
          break;
      }
      const { fields: te, rows: de } = Z;
      Lwe(O, te) ? e.createData(de).then((ce) => {
        let ne;
        return D.mode === "insert" ? ne = e.insert(ce) : ne = e.reloadData(ce), D.message !== !1 && (process.env.NODE_ENV === "development" && ($t.modal || Ht("vxe.error.reqModule", ["Modal"])), $t.modal.message({ content: ee.i18n("vxe.table.impSuccess", [de.length]), status: "success" })), ne.then(() => {
          F && F({ status: !0 });
        });
      }) : D.message !== !1 && (process.env.NODE_ENV === "development" && ($t.modal || Ht("vxe.error.reqModule", ["Modal"])), $t.modal.message({ content: ee.i18n("vxe.error.impFields"), status: "error" }), j && j({ status: !1 }));
    }, U = ($, D) => {
      const { importMethod: O, afterImportMethod: F } = D, { type: j, filename: Z } = Z0($);
      if (!O && !I.includes($t.globalConfs.importTypes, j)) {
        D.message !== !1 && (process.env.NODE_ENV === "development" && ($t.modal || Ht("vxe.error.reqModule", ["Modal"])), $t.modal.message({ content: ee.i18n("vxe.error.notType", [j]), status: "error" }));
        const de = { status: !1 };
        return Promise.reject(de);
      }
      return new Promise((de, Oe) => {
        const ce = (Y) => {
          de(Y), o._importResolve = null, o._importReject = null;
        }, ne = (Y) => {
          Oe(Y), o._importResolve = null, o._importReject = null;
        };
        if (o._importResolve = ce, o._importReject = ne, window.FileReader) {
          const Y = Object.assign({ mode: "insert" }, D, { type: j, filename: Z });
          if (Y.remote)
            O ? Promise.resolve(O({ file: $, options: Y, $table: e })).then(() => {
              ce({ status: !0 });
            }).catch(() => {
              ce({ status: !0 });
            }) : ce({ status: !0 });
          else {
            const { tableFullColumn: ve } = o;
            e.preventEvent(null, "event.import", { file: $, options: Y, columns: ve }, () => {
              const ie = new FileReader();
              ie.onerror = () => {
                Ht("vxe.error.notType", [j]), ne({ status: !1 });
              }, ie.onload = (he) => {
                K(he.target.result, Y);
              }, ie.readAsText($, Y.encoding || "UTF-8");
            });
          }
        } else
          process.env.NODE_ENV === "development" && Ht("vxe.error.notExp"), ce({ status: !0 });
      }).then(() => {
        F && F({ status: !0, options: D, $table: e });
      }).catch((de) => (F && F({ status: !1, options: D, $table: e }), Promise.reject(de)));
    }, W = ($, D) => {
      const { treeConfig: O, showHeader: F, showFooter: j } = t, { initStore: Z, mergeList: te, isGroup: de, footerTableData: Oe, exportStore: ce, exportParams: ne } = n, { collectColumn: Y } = o, ve = O, ie = s.value, he = e.getCheckboxRecords(), De = !!Oe.length, $e = !ve && te.length, ue = Object.assign({ message: !0, isHeader: F, isFooter: j }, $), Ne = ue.types || $t.globalConfs.exportTypes, je = ue.modes, Fe = ie.checkMethod, Ve = Y.slice(0), { columns: Ze } = ue, ae = Ne.map((ke) => ({
        value: ke,
        label: `vxe.export.types.${ke}`
      })), pe = je.map((ke) => ({
        value: ke,
        label: `vxe.export.modes.${ke}`
      }));
      return I.eachTree(Ve, (ke, Ue, Xe, re, Te) => {
        (ke.children && ke.children.length || H_(ke)) && (ke.checked = Ze ? Ze.some((Le) => {
          if (Vp(Le))
            return ke === Le;
          if (I.isString(Le))
            return ke.field === Le;
          {
            const ge = Le.id || Le.colId, Ee = Le.type, me = Le.property || Le.field;
            if (ge)
              return ke.id === ge;
            if (me && Ee)
              return ke.property === me && ke.type === Ee;
            if (me)
              return ke.property === me;
            if (Ee)
              return ke.type === Ee;
          }
          return !1;
        }) : ke.visible, ke.halfChecked = !1, ke.disabled = Te && Te.disabled || (Fe ? !Fe({ column: ke }) : !1));
      }), Object.assign(ce, {
        columns: Ve,
        typeList: ae,
        modeList: pe,
        hasFooter: De,
        hasMerge: $e,
        hasTree: ve,
        isPrint: D,
        hasColgroup: de,
        visible: !0
      }), Object.assign(ne, {
        mode: he.length ? "selected" : "current"
      }, ue), je.indexOf(ne.mode) === -1 && (ne.mode = je[0]), Ne.indexOf(ne.type) === -1 && (ne.type = Ne[0]), Z.export = !0, xe();
    }, A = {
      /**
       * 导出文件，支持 csv/html/xml/txt
       * 如果是树表格，则默认是导出所有节点
       * 如果是启用了虚拟滚动，则只能导出数据源，可以配合 dataFilterMethod 函数自行转换数据
       * @param {Object} options 参数
       */
      exportData($) {
        const { treeConfig: D } = t, { isGroup: O, tableGroupColumn: F } = n, { tableFullColumn: j, afterFullData: Z } = o, te = r.value, de = l.value, Oe = Object.assign({
          // filename: '',
          // sheetName: '',
          // original: false,
          // message: false,
          isHeader: !0,
          isFooter: !0,
          isColgroup: !0,
          // isMerge: false,
          // isAllExpand: false,
          download: !0,
          type: "csv",
          mode: "current"
          // data: null,
          // remote: false,
          // dataFilterMethod: null,
          // footerFilterMethod: null,
          // exportMethod: null,
          // columnFilterMethod: null,
          // beforeExportMethod: null,
          // afterExportMethod: null
        }, te, {
          print: !1
        }, $), { type: ce, mode: ne, columns: Y, original: ve, beforeExportMethod: ie } = Oe;
        let he = [];
        const De = Y && Y.length ? Y : null;
        let $e = Oe.columnFilterMethod;
        !De && !$e && ($e = ve ? ({ column: Ne }) => Ne.property : ({ column: Ne }) => H_(Ne)), De ? (Oe._isCustomColumn = !0, he = I.searchTree(I.mapTree(De, (Ne) => {
          let je;
          if (Ne) {
            if (Vp(Ne))
              je = Ne;
            else if (I.isString(Ne))
              je = e.getColumnByField(Ne);
            else {
              const Fe = Ne.id || Ne.colId, Ve = Ne.type, Ze = Ne.property || Ne.field;
              Fe ? je = e.getColumnById(Fe) : Ze && Ve ? je = j.find((ae) => ae.property === Ze && ae.type === Ve) : Ze ? je = e.getColumnByField(Ze) : Ve && (je = j.find((ae) => ae.type === Ve));
            }
            return je || {};
          }
        }, {
          children: "childNodes",
          mapChildren: "_children"
        }), (Ne, je) => Vp(Ne) && (!$e || $e({ column: Ne, $columnIndex: je })), {
          children: "_children",
          mapChildren: "childNodes",
          original: !0
        })) : he = I.searchTree(O ? F : j, (Ne, je) => Ne.visible && (!$e || $e({ column: Ne, $columnIndex: je })), { children: "children", mapChildren: "childNodes", original: !0 });
        const ue = [];
        if (I.eachTree(he, (Ne) => {
          Ne.children && Ne.children.length || ue.push(Ne);
        }, { children: "childNodes" }), Oe.columns = ue, Oe.colgroups = $we(he), Oe.filename || (Oe.filename = ee.i18n(Oe.original ? "vxe.table.expOriginFilename" : "vxe.table.expFilename", [I.toDateString(Date.now(), "yyyyMMddHHmmss")])), Oe.sheetName || (Oe.sheetName = document.title), !Oe.exportMethod && !I.includes($t.globalConfs.exportTypes, ce)) {
          process.env.NODE_ENV === "development" && Ht("vxe.error.notType", [ce]);
          const Ne = { status: !1 };
          return Promise.reject(Ne);
        }
        if (Oe.print || ie && ie({ options: Oe, $table: e, $grid: h }), !Oe.data) {
          if (Oe.data = Z, ne === "selected") {
            const Ne = e.getCheckboxRecords();
            ["html", "pdf"].indexOf(ce) > -1 && D ? Oe.data = I.searchTree(e.getTableData().fullData, (je) => e.findRowIndexOf(Ne, je) > -1, Object.assign({}, de, { data: "_row" })) : Oe.data = Ne;
          } else if (ne === "all" && (process.env.NODE_ENV === "development" && (h || qt("vxe.error.errProp", ["all", "mode=current,selected"])), h && !Oe.remote)) {
            const { reactData: Ne } = h, { computeProxyOpts: je } = h.getComputeMaps(), Fe = je.value, { beforeQueryAll: Ve, afterQueryAll: Ze, ajax: ae = {}, props: pe = {} } = Fe, ke = ae.queryAll;
            if (process.env.NODE_ENV === "development" && (ke || qt("vxe.error.notFunc", ["proxy-config.ajax.queryAll"])), ke) {
              const Ue = {
                $table: e,
                $grid: h,
                sort: Ne.sortData,
                filters: Ne.filterData,
                form: Ne.formData,
                target: ke,
                options: Oe
              };
              return Promise.resolve((Ve || ke)(Ue)).catch((Xe) => Xe).then((Xe) => (Oe.data = (pe.list ? I.get(Xe, pe.list) : Xe) || [], Ze && Ze(Ue), H(Oe)));
            }
          }
        }
        return H(Oe);
      },
      importByFile($, D) {
        const O = Object.assign({}, D), { beforeImportMethod: F } = O;
        return F && F({ options: O, $table: e }), U($, O);
      },
      importData($) {
        const D = i.value, O = Object.assign({
          types: $t.globalConfs.importTypes
          // beforeImportMethod: null,
          // afterImportMethod: null
        }, D, $), { beforeImportMethod: F, afterImportMethod: j } = O;
        return F && F({ options: O, $table: e }), gv(O).catch((Z) => (j && j({ status: !1, options: O, $table: e }), Promise.reject(Z))).then((Z) => {
          const { file: te } = Z;
          return U(te, O);
        });
      },
      saveFile($) {
        return bv($);
      },
      readFile($) {
        return gv($);
      },
      print($) {
        const D = a.value, O = Object.assign({
          original: !1
          // beforePrintMethod
        }, D, $, {
          type: "html",
          download: !1,
          remote: !1,
          print: !0
        });
        return O.sheetName || (O.sheetName = document.title), new Promise((F) => {
          O.content ? F(Eb(e, O, O.content)) : F(A.exportData(O).then(({ content: j }) => Eb(e, O, j)));
        });
      },
      openImport($) {
        const { treeConfig: D, importConfig: O } = t, { initStore: F, importStore: j, importParams: Z } = n, te = i.value, de = Object.assign({ mode: "insert", message: !0, types: $t.globalConfs.importTypes }, $, te), { types: Oe } = de;
        if (!!D) {
          de.message && $t.modal.message({ content: ee.i18n("vxe.error.treeNotImp"), status: "error" });
          return;
        }
        O || Ht("vxe.error.reqProp", ["import-config"]);
        const ne = Oe.map((ve) => ({
          value: ve,
          label: `vxe.export.types.${ve}`
        })), Y = de.modes.map((ve) => ({
          value: ve,
          label: `vxe.import.modes.${ve}`
        }));
        Object.assign(j, {
          file: null,
          type: "",
          filename: "",
          modeList: Y,
          typeList: ne,
          visible: !0
        }), Object.assign(Z, de), F.import = !0;
      },
      openExport($) {
        const D = r.value;
        process.env.NODE_ENV === "development" && (t.exportConfig || Ht("vxe.error.reqProp", ["export-config"])), W(Object.assign({}, D, $));
      },
      openPrint($) {
        const D = a.value;
        process.env.NODE_ENV === "development" && (t.printConfig || Ht("vxe.error.reqProp", ["print-config"])), W(Object.assign({}, D, $), !0);
      }
    };
    return A;
  },
  setupGrid(e) {
    return e.extendTableMethods(Pwe);
  }
}, QI = (e) => {
  const t = Object.assign({}, e, {
    type: "html"
  });
  Eb(null, t, t.content);
}, d1 = {
  ExportPanel: ad,
  ImportPanel: rd,
  install(e) {
    $t.saveFile = bv, $t.readFile = gv, $t.print = QI, $t.setup({
      export: {
        types: {
          csv: 0,
          html: 0,
          xml: 0,
          txt: 0
        }
      }
    }), $t.hooks.add("$tableExport", Awe), e.component(ad.name, ad), e.component(rd.name, rd);
  }
}, Fwe = d1;
Fn.component(ad.name, ad);
Fn.component(rd.name, rd);
function Vwe(e, t) {
  let n = 0, o = 0;
  const l = !Jl.firefox && Ar(e, "vxe-checkbox--label");
  if (l) {
    const a = getComputedStyle(e);
    n -= I.toNumber(a.paddingTop), o -= I.toNumber(a.paddingLeft);
  }
  for (; e && e !== t; )
    if (n += e.offsetTop, o += e.offsetLeft, e = e.offsetParent, l) {
      const a = getComputedStyle(e);
      n -= I.toNumber(a.paddingTop), o -= I.toNumber(a.paddingLeft);
    }
  return { offsetTop: n, offsetLeft: o };
}
const Bwe = {
  setupTable(e) {
    const { props: t, reactData: n, internalData: o } = e, { refElem: l } = e.getRefMaps(), { computeEditOpts: a, computeCheckboxOpts: r, computeMouseOpts: i, computeTreeOpts: s } = e.getComputeMaps();
    function u(h, m, p) {
      let C = 0, g = [];
      const w = p > 0, b = p > 0 ? p : Math.abs(p) + m.offsetHeight, { scrollYLoad: y } = n, { afterFullData: E, scrollYStore: S } = o;
      if (y) {
        const _ = e.getVTRowIndex(h.row);
        w ? g = E.slice(_, _ + Math.ceil(b / S.rowHeight)) : g = E.slice(_ - Math.floor(b / S.rowHeight) + 1, _ + 1);
      } else {
        const _ = w ? "next" : "previous";
        for (; m && C < b; ) {
          const k = e.getRowNode(m);
          k && (g.push(k.item), C += m.offsetHeight, m = m[`${_}ElementSibling`]);
        }
      }
      return g;
    }
    const d = (h, m) => {
      const { column: p, cell: C } = m;
      if (p.type === "checkbox") {
        const g = l.value, { elemStore: w } = o, b = h.clientX, y = h.clientY, E = w[`${p.fixed || "main"}-body-wrapper`] || w["main-body-wrapper"], S = E ? E.value : null;
        if (!S)
          return;
        const _ = S.querySelector(".vxe-table--checkbox-range"), k = document.onmousemove, N = document.onmouseup, L = C.parentNode, R = e.getCheckboxRecords();
        let H = [];
        const K = 1, U = Vwe(h.target, S), W = U.offsetTop + h.offsetY, A = U.offsetLeft + h.offsetX, $ = S.scrollTop, D = L.offsetHeight;
        let O = null, F = !1, j = 1;
        const Z = (ce, ne) => {
          e.dispatchEvent(`checkbox-range-${ce}`, { records: e.getCheckboxRecords(), reserves: e.getCheckboxReserveRecords() }, ne);
        }, te = (ce) => {
          const { clientX: ne, clientY: Y } = ce, ve = ne - b, ie = Y - y + (S.scrollTop - $);
          let he = Math.abs(ie), De = Math.abs(ve), $e = W, ue = A;
          ie < K ? ($e += ie, $e < K && ($e = K, he = W)) : he = Math.min(he, S.scrollHeight - W - K), ve < K ? (ue += ve, De > A && (ue = K, De = A)) : De = Math.min(De, S.clientWidth - A - K), _.style.height = `${he}px`, _.style.width = `${De}px`, _.style.left = `${ue}px`, _.style.top = `${$e}px`, _.style.display = "block";
          const Ne = u(m, L, ie < K ? -he : he);
          he > 10 && Ne.length !== H.length && (H = Ne, ce.ctrlKey ? Ne.forEach((je) => {
            e.handleSelectRow({ row: je }, R.indexOf(je) === -1);
          }) : (e.setAllCheckboxRow(!1), e.handleCheckedCheckboxRow(Ne, !0, !1)), Z("change", ce));
        }, de = () => {
          clearTimeout(O), O = null;
        }, Oe = (ce) => {
          de(), O = setTimeout(() => {
            if (O) {
              const { scrollLeft: ne, scrollTop: Y, clientHeight: ve, scrollHeight: ie } = S, he = Math.ceil(j * 50 / D);
              F ? Y + ve < ie ? (e.scrollTo(ne, Y + he), Oe(ce), te(ce)) : de() : Y ? (e.scrollTo(ne, Y - he), Oe(ce), te(ce)) : de();
            }
          }, 50);
        };
        Mr(g, "drag--range"), document.onmousemove = (ce) => {
          ce.preventDefault(), ce.stopPropagation();
          const { clientY: ne } = ce, { boundingTop: Y } = lr(S);
          ne < Y ? (F = !1, j = Y - ne, O || Oe(ce)) : ne > Y + S.clientHeight ? (F = !0, j = ne - Y - S.clientHeight, O || Oe(ce)) : O && de(), te(ce);
        }, document.onmouseup = (ce) => {
          de(), Xl(g, "drag--range"), _.removeAttribute("style"), document.onmousemove = k, document.onmouseup = N, Z("end", ce);
        }, Z("start", h);
      }
    }, f = (h, m) => {
      const { editConfig: p, checkboxConfig: C, mouseConfig: g } = t, w = r.value, b = i.value, y = a.value;
      if (g && b.area && e.handleCellAreaEvent)
        return e.handleCellAreaEvent(h, m);
      C && w.range && d(h, m), g && b.selected && (!p || y.mode === "cell") && e.handleSelected(m, h);
    };
    return {
      // 处理 Tab 键移动
      moveTabSelected(h, m, p) {
        const { editConfig: C } = t, { afterFullData: g, visibleColumn: w } = o, b = a.value;
        let y, E, S;
        const _ = Object.assign({}, h), k = e.getVTRowIndex(_.row), N = e.getVTColumnIndex(_.column);
        p.preventDefault(), m ? N <= 0 ? k > 0 && (E = k - 1, y = g[E], S = w.length - 1) : S = N - 1 : N >= w.length - 1 ? k < g.length - 1 && (E = k + 1, y = g[E], S = 0) : S = N + 1;
        const L = w[S];
        L && (y ? (_.rowIndex = E, _.row = y) : _.rowIndex = k, _.columnIndex = S, _.column = L, _.cell = e.getCell(_.row, _.column), C ? (b.trigger === "click" || b.trigger === "dblclick") && (b.mode === "row" ? e.handleActived(_, p) : e.scrollToRow(_.row, _.column).then(() => e.handleSelected(_, p))) : e.scrollToRow(_.row, _.column).then(() => e.handleSelected(_, p)));
      },
      // 处理当前行方向键移动
      moveCurrentRow(h, m, p) {
        const { treeConfig: C } = t, { currentRow: g } = n, { afterFullData: w } = o, b = s.value, y = b.children || b.childrenField;
        let E;
        if (p.preventDefault(), g)
          if (C) {
            const { index: S, items: _ } = I.findTree(w, (k) => k === g, { children: y });
            h && S > 0 ? E = _[S - 1] : m && S < _.length - 1 && (E = _[S + 1]);
          } else {
            const S = e.getVTRowIndex(g);
            h && S > 0 ? E = w[S - 1] : m && S < w.length - 1 && (E = w[S + 1]);
          }
        else
          E = w[0];
        if (E) {
          const S = {
            $table: e,
            row: E,
            rowIndex: e.getRowIndex(E),
            $rowIndex: e.getVMRowIndex(E)
          };
          e.scrollToRow(E).then(() => e.triggerCurrentRowEvent(p, S));
        }
      },
      // 处理可编辑方向键移动
      moveSelected(h, m, p, C, g, w) {
        const { afterFullData: b, visibleColumn: y } = o, E = Object.assign({}, h), S = e.getVTRowIndex(E.row), _ = e.getVTColumnIndex(E.column);
        w.preventDefault(), p && S > 0 ? (E.rowIndex = S - 1, E.row = b[E.rowIndex]) : g && S < b.length - 1 ? (E.rowIndex = S + 1, E.row = b[E.rowIndex]) : m && _ ? (E.columnIndex = _ - 1, E.column = y[E.columnIndex]) : C && _ < y.length - 1 && (E.columnIndex = _ + 1, E.column = y[E.columnIndex]), e.scrollToRow(E.row, E.column).then(() => {
          E.cell = e.getCell(E.row, E.column), e.handleSelected(E, w);
        });
      },
      /**
       * 表头单元格按下事件
       */
      triggerHeaderCellMousedownEvent(h, m) {
        const { mouseConfig: p } = t, C = i.value;
        if (p && C.area && e.handleHeaderCellAreaEvent) {
          const g = h.currentTarget, w = _n(h, g, "vxe-cell--sort").flag, b = _n(h, g, "vxe-cell--filter").flag;
          e.handleHeaderCellAreaEvent(h, Object.assign({ cell: g, triggerSort: w, triggerFilter: b }, m));
        }
        e.focus(), e.closeMenu && e.closeMenu();
      },
      /**
       * 单元格按下事件
       */
      triggerCellMousedownEvent(h, m) {
        const p = h.currentTarget;
        m.cell = p, f(h, m), e.focus(), e.closeFilter(), e.closeMenu && e.closeMenu();
      }
    };
  }
}, f1 = {
  install() {
    $t.hooks.add("$tableKeyboard", Bwe);
  }
}, Hwe = f1;
let Vu = class {
  constructor(t) {
    Object.assign(this, {
      $options: t,
      required: t.required,
      min: t.min,
      max: t.max,
      type: t.type,
      pattern: t.pattern,
      validator: t.validator,
      trigger: t.trigger,
      maxWidth: t.maxWidth
    });
  }
  /**
   * 获取校验不通过的消息
   * 支持国际化翻译
   */
  get content() {
    return vo(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
};
const zwe = ["fullValidate", "validate", "clearValidate"], Wwe = {
  setupTable(e) {
    const { props: t, reactData: n, internalData: o } = e, { refValidTooltip: l } = e.getRefMaps(), { computeValidOpts: a, computeTreeOpts: r, computeEditOpts: i } = e.getComputeMaps();
    let s = {}, u = {}, d;
    const f = (p) => new Promise((C) => {
      a.value.autoPos === !1 ? (e.dispatchEvent("valid-error", p, null), C()) : e.handleActived(p, { type: "valid-error", trigger: "call" }).then(() => {
        C(u.showValidTooltip(p));
      });
    }), v = (p) => {
      if (a.value.msgMode === "single") {
        const g = Object.keys(p), w = p;
        if (g.length) {
          const b = g[0];
          w[b] = p[b];
        }
        return w;
      }
      return p;
    }, h = (p, C, g) => {
      const w = {}, { editRules: b, treeConfig: y } = t, { afterFullData: E, visibleColumn: S } = o, _ = r.value, k = _.children || _.childrenField, N = a.value;
      let L;
      p === !0 ? L = E : p && (I.isFunction(p) ? C = p : L = I.isArray(p) ? p : [p]), L || (e.getInsertRecords ? L = e.getInsertRecords().concat(e.getUpdateRecords()) : L = []);
      const R = [];
      o._lastCallTime = Date.now(), d = !1, s.clearValidate();
      const H = {};
      if (b) {
        const K = e.getColumns(), U = (W) => {
          if (g || !d) {
            const A = [];
            K.forEach(($) => {
              (g || !d) && I.has(b, $.property) && A.push(u.validCellRules("all", W, $).catch(({ rule: D, rules: O }) => {
                const F = {
                  rule: D,
                  rules: O,
                  rowIndex: e.getRowIndex(W),
                  row: W,
                  columnIndex: e.getColumnIndex($),
                  column: $,
                  field: $.property,
                  $table: e
                };
                if (w[$.property] || (w[$.property] = []), H[`${yt(e, W)}:${$.id}`] = {
                  column: $,
                  row: W,
                  rule: D,
                  content: D.content
                }, w[$.property].push(F), !g)
                  return d = !0, Promise.reject(F);
              }));
            }), R.push(Promise.all(A));
          }
        };
        return y ? I.eachTree(L, U, { children: k }) : L.forEach(U), Promise.all(R).then(() => {
          const W = Object.keys(w);
          return n.validErrorMaps = v(H), xe().then(() => {
            if (W.length)
              return Promise.reject(w[W[0]][0]);
            C && C();
          });
        }).catch((W) => new Promise((A, $) => {
          const D = () => {
            xe(() => {
              C ? (C(w), A()) : ee.validToReject === "obsolete" ? $(w) : A(w);
            });
          }, O = () => {
            W.cell = e.getCell(W.row, W.column), EI(W.cell), f(W).then(D);
          };
          if (N.autoPos === !1)
            D();
          else {
            const F = W.row, j = W.column, Z = E.indexOf(F), te = S.indexOf(j), de = Z > 0 ? E[Z - 1] : F, Oe = te > 0 ? S[Z - 1] : j;
            e.scrollToRow(de, Oe).then(O);
          }
        }));
      } else
        n.validErrorMaps = {};
      return xe().then(() => {
        C && C();
      });
    };
    s = {
      /**
       * 完整校验，和 validate 的区别就是会给有效数据中的每一行进行校验
       */
      fullValidate(p, C) {
        return process.env.NODE_ENV === "development" && I.isFunction(C) && qt("vxe.error.notValidators", ["fullValidate(rows, callback)", "fullValidate(rows)"]), h(p, C, !0);
      },
      /**
       * 快速校验，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）
       */
      validate(p, C) {
        return process.env.NODE_ENV === "development" && I.isFunction(C) && qt("vxe.error.notValidators", ["validate(rows, callback)", "validate(rows)"]), h(p, C);
      },
      clearValidate(p, C) {
        const { validErrorMaps: g } = n, w = l.value, b = a.value, y = I.isArray(p) ? p : p ? [p] : [], E = I.isArray(C) ? C : (C ? [C] : []).map((_) => El(e, _));
        let S = {};
        if (w && w.reactData.visible && w.close(), b.msgMode === "single")
          return n.validErrorMaps = {}, xe();
        if (y.length && E.length)
          S = Object.assign({}, g), y.forEach((_) => {
            E.forEach((k) => {
              const N = `${yt(e, _)}:${k.id}`;
              S[N] && delete S[N];
            });
          });
        else if (y.length) {
          const _ = y.map((k) => `${yt(e, k)}`);
          I.each(g, (k, N) => {
            _.indexOf(N.split(":")[0]) > -1 && (S[N] = k);
          });
        } else if (E.length) {
          const _ = E.map((k) => `${k.id}`);
          I.each(g, (k, N) => {
            _.indexOf(N.split(":")[1]) > -1 && (S[N] = k);
          });
        }
        return n.validErrorMaps = S, xe();
      }
    };
    const m = (p, C) => {
      const { type: g, min: w, max: b, pattern: y } = p, E = g === "number", S = E ? I.toNumber(C) : I.getSize(C);
      return !!(E && isNaN(C) || !I.eqNull(w) && S < I.toNumber(w) || !I.eqNull(b) && S > I.toNumber(b) || y && !(I.isRegExp(y) ? y : new RegExp(y)).test(C));
    };
    return u = {
      /**
       * 校验数据
       * 按表格行、列顺序依次校验（同步或异步）
       * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列
       * 如果校验失败则，触发回调或者Promise<不通过列的错误消息>
       * 如果是传回调方式这返回一个校验不通过列的错误消息
       *
       * rule 配置：
       *  required=Boolean 是否必填
       *  min=Number 最小长度
       *  max=Number 最大长度
       *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex }) 自定义校验，接收一个 Promise
       *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）
       */
      validCellRules(p, C, g, w) {
        const { editRules: b } = t, { field: y } = g, E = [], S = [];
        if (y && b) {
          const _ = I.get(b, y);
          if (_) {
            const k = I.isUndefined(w) ? I.get(C, y) : w;
            _.forEach((N) => {
              const { type: L, trigger: R, required: H, validator: K } = N;
              if (p === "all" || !R || p === R)
                if (K) {
                  const U = {
                    cellValue: k,
                    rule: N,
                    rules: _,
                    row: C,
                    rowIndex: e.getRowIndex(C),
                    column: g,
                    columnIndex: e.getColumnIndex(g),
                    field: g.field,
                    $table: e,
                    $grid: e.xegrid
                  };
                  let W;
                  if (I.isString(K)) {
                    const A = $t.validators.get(K);
                    A ? A.cellValidatorMethod ? W = A.cellValidatorMethod(U) : process.env.NODE_ENV === "development" && qt("vxe.error.notValidators", [K]) : process.env.NODE_ENV === "development" && Ht("vxe.error.notValidators", [K]);
                  } else
                    W = K(U);
                  W && (I.isError(W) ? (d = !0, E.push(new Vu({ type: "custom", trigger: R, content: W.message, rule: new Vu(N) }))) : W.catch && S.push(W.catch((A) => {
                    d = !0, E.push(new Vu({ type: "custom", trigger: R, content: A && A.message ? A.message : N.content || N.message, rule: new Vu(N) }));
                  })));
                } else {
                  const U = L === "array", W = I.isArray(k);
                  let A = !0;
                  U || W ? A = !W || !k.length : I.isString(k) ? A = La(k.trim()) : A = La(k), (H ? A || m(N, k) : !A && m(N, k)) && (d = !0, E.push(new Vu(N)));
                }
            });
          }
        }
        return Promise.all(S).then(() => {
          if (E.length) {
            const _ = { rules: E, rule: E[0] };
            return Promise.reject(_);
          }
        });
      },
      hasCellRules(p, C, g) {
        const { editRules: w } = t, { field: b } = g;
        if (b && w) {
          const y = I.get(w, b);
          return y && !!I.find(y, (E) => p === "all" || !E.trigger || p === E.trigger);
        }
        return !1;
      },
      /**
       * 触发校验
       */
      triggerValidate(p) {
        const { editConfig: C, editRules: g } = t, { editStore: w } = n, { actived: b } = w, y = i.value, E = a.value;
        if (g && E.msgMode === "single" && (n.validErrorMaps = {}), C && g && b.row) {
          const { row: S, column: _, cell: k } = b.args;
          if (u.hasCellRules(p, S, _))
            return u.validCellRules(p, S, _).then(() => {
              y.mode === "row" && s.clearValidate(S, _);
            }).catch(({ rule: N }) => {
              if (!N.trigger || p === N.trigger) {
                const L = { rule: N, row: S, column: _, cell: k };
                return u.showValidTooltip(L), Promise.reject(L);
              }
              return Promise.resolve();
            });
        }
        return Promise.resolve();
      },
      /**
       * 弹出校验错误提示
       */
      showValidTooltip(p) {
        const { height: C } = t, { tableData: g, validStore: w, validErrorMaps: b } = n, { rule: y, row: E, column: S, cell: _ } = p, k = a.value, N = l.value, L = y.content;
        return w.visible = !0, k.msgMode === "single" ? n.validErrorMaps = {
          [`${yt(e, E)}:${S.id}`]: {
            column: S,
            row: E,
            rule: y,
            content: L
          }
        } : n.validErrorMaps = Object.assign({}, b, {
          [`${yt(e, E)}:${S.id}`]: {
            column: S,
            row: E,
            rule: y,
            content: L
          }
        }), e.dispatchEvent("valid-error", p, null), N && N && (k.message === "tooltip" || k.message === "default" && !C && g.length < 2) ? N.open(_, L) : xe();
      }
    }, { ...s, ...u };
  },
  setupGrid(e) {
    return e.extendTableMethods(zwe);
  }
}, p1 = {
  install() {
    $t.hooks.add("$tableValidator", Wwe);
  }
}, Kwe = p1, Ic = Q({
  name: "VxeTooltip",
  props: {
    modelValue: Boolean,
    size: { type: String, default: () => ee.tooltip.size || ee.size },
    trigger: { type: String, default: () => ee.tooltip.trigger },
    theme: { type: String, default: () => ee.tooltip.theme },
    content: { type: [String, Number], default: null },
    useHTML: Boolean,
    zIndex: [String, Number],
    popupClassName: [String, Function],
    isArrow: { type: Boolean, default: !0 },
    enterable: Boolean,
    enterDelay: { type: Number, default: () => ee.tooltip.enterDelay },
    leaveDelay: { type: Number, default: () => ee.tooltip.leaveDelay }
  },
  emits: [
    "update:modelValue"
  ],
  setup(e, t) {
    const { slots: n, emit: o } = t, l = I.uniqueId(), a = Po(e), r = en({
      target: null,
      isUpdate: !1,
      visible: !1,
      tipContent: "",
      tipActive: !1,
      tipTarget: null,
      tipZindex: 0,
      tipStore: {
        style: {},
        placement: "",
        arrowStyle: {}
      }
    }), i = B(), s = {
      refElem: i
    }, u = {
      xID: l,
      props: e,
      context: t,
      reactData: r,
      getRefMaps: () => s
    };
    let d = {};
    const f = () => {
      const { tipTarget: _, tipStore: k } = r;
      if (_) {
        const { scrollTop: N, scrollLeft: L, visibleWidth: R } = Cs(), { top: H, left: K } = lr(_), U = i.value, W = 6, A = U.offsetHeight, $ = U.offsetWidth;
        let D = K, O = H - A - W;
        D = Math.max(W, K + Math.floor((_.offsetWidth - $) / 2)), D + $ + W > L + R && (D = L + R - $ - W), H - A < N + W && (k.placement = "bottom", O = H + _.offsetHeight + W), k.style.top = `${O}px`, k.style.left = `${D}px`, k.arrowStyle.left = `${K - D + _.offsetWidth / 2}px`;
      }
    }, v = (_) => {
      _ !== r.visible && (r.visible = _, r.isUpdate = !0, o("update:modelValue", _));
    }, h = () => {
      r.tipZindex < Yr() && (r.tipZindex = dr());
    }, m = () => {
      r.visible ? d.close() : d.open();
    }, p = () => {
      d.open();
    }, C = () => {
      const { trigger: _, enterable: k, leaveDelay: N } = e;
      r.tipActive = !1, k && _ === "hover" ? setTimeout(() => {
        r.tipActive || d.close();
      }, N) : d.close();
    }, g = () => {
      r.tipActive = !0;
    }, w = () => {
      const { trigger: _, enterable: k, leaveDelay: N } = e;
      r.tipActive = !1, k && _ === "hover" && setTimeout(() => {
        r.tipActive || d.close();
      }, N);
    }, b = () => {
      const { tipStore: _ } = r, k = i.value;
      return k && (k.parentNode || document.body.appendChild(k)), v(!0), h(), _.placement = "top", _.style = { width: "auto", left: 0, top: 0, zIndex: e.zIndex || r.tipZindex }, _.arrowStyle = { left: "50%" }, d.updatePlacement();
    }, y = I.debounce(() => {
      r.tipActive && b();
    }, e.enterDelay, { leading: !1, trailing: !0 });
    d = {
      dispatchEvent(_, k, N) {
        o(_, Object.assign({ $tooltip: u, $event: N }, k));
      },
      open(_, k) {
        return d.toVisible(_ || r.target, k);
      },
      close() {
        return r.tipTarget = null, r.tipActive = !1, Object.assign(r.tipStore, {
          style: {},
          placement: "",
          arrowStyle: null
        }), v(!1), xe();
      },
      toVisible(_, k) {
        if (_) {
          const { trigger: N, enterDelay: L } = e;
          if (r.tipActive = !0, r.tipTarget = _, k && (r.tipContent = k), L && N === "hover")
            y();
          else
            return b();
        }
        return xe();
      },
      updatePlacement() {
        return xe().then(() => {
          const { tipTarget: _ } = r, k = i.value;
          if (_ && k)
            return f(), xe().then(f);
        });
      },
      isActived() {
        return r.tipActive;
      },
      setActived(_) {
        r.tipActive = !!_;
      }
    }, Object.assign(u, d), Pe(() => e.content, () => {
      r.tipContent = e.content;
    }), Pe(() => e.modelValue, () => {
      r.isUpdate || (e.modelValue ? d.open() : d.close()), r.isUpdate = !1;
    }), Nt(() => {
      xe(() => {
        const { trigger: _, content: k, modelValue: N } = e, L = i.value;
        if (L) {
          const R = L.parentNode;
          if (R) {
            r.tipContent = k, r.tipZindex = dr(), I.arrayEach(L.children, (K, U) => {
              U > 1 && (R.insertBefore(K, L), r.target || (r.target = K));
            }), R.removeChild(L);
            const { target: H } = r;
            H && (_ === "hover" ? (H.onmouseenter = p, H.onmouseleave = C) : _ === "click" && (H.onclick = m)), N && d.open();
          }
        }
      });
    }), zn(() => {
      const { trigger: _ } = e, { target: k } = r, N = i.value;
      if (k && (_ === "hover" ? (k.onmouseenter = null, k.onmouseleave = null) : _ === "click" && (k.onclick = null)), N) {
        const L = N.parentNode;
        L && L.removeChild(N);
      }
    });
    const E = () => {
      const { useHTML: _ } = e, { tipContent: k } = r, N = n.content;
      return N ? V("div", {
        key: 1,
        class: "vxe-table--tooltip-content"
      }, oo(N({}))) : _ ? V("div", {
        key: 2,
        class: "vxe-table--tooltip-content",
        innerHTML: k
      }) : V("div", {
        key: 3,
        class: "vxe-table--tooltip-content"
      }, ko(k));
    }, S = () => {
      const { popupClassName: _, theme: k, isArrow: N, enterable: L } = e, { tipActive: R, visible: H, tipStore: K } = r, U = n.default, W = a.value;
      let A;
      return L && (A = {
        onMouseenter: g,
        onMouseleave: w
      }), V("div", {
        ref: i,
        class: ["vxe-table--tooltip-wrapper", `theme--${k}`, _ ? I.isFunction(_) ? _({ $tooltip: u }) : _ : "", {
          [`size--${W}`]: W,
          [`placement--${K.placement}`]: K.placement,
          "is--enterable": L,
          "is--visible": H,
          "is--arrow": N,
          "is--active": R
        }],
        style: K.style,
        ...A
      }, [
        E(),
        V("div", {
          class: "vxe-table--tooltip-arrow",
          style: K.arrowStyle
        }),
        ...U ? oo(U({})) : []
      ]);
    };
    return u.renderVN = S, u;
  },
  render() {
    return this.renderVN();
  }
}), sd = Q({
  name: "VxeTableCustomPanel",
  props: {
    customStore: {
      type: Object,
      default: () => ({})
    }
  },
  setup(e) {
    const t = ot("$xetable", {}), { reactData: n } = t, { computeCustomOpts: o, computeColumnOpts: l, computeIsMaxFixedColumn: a } = t.getComputeMaps(), r = B(), i = B(), s = B(), u = B();
    let d;
    const f = (A) => {
      const { customStore: $ } = e;
      $.activeWrapper = !0, t.customOpenEvent(A);
    }, v = (A) => {
      const { customStore: $ } = e;
      $.activeWrapper = !1, setTimeout(() => {
        !$.activeBtn && !$.activeWrapper && t.customColseEvent(A);
      }, 300);
    }, h = (A) => {
      N(), t.closeCustom(), t.emitCustomEvent("confirm", A);
    }, m = (A) => {
      t.closeCustom(), t.emitCustomEvent("cancel", A);
    }, p = (A) => {
      t.resetColumn(!0), t.closeCustom(), t.emitCustomEvent("reset", A);
    }, C = (A) => {
      $t.modal ? $t.modal.confirm({
        content: ee.i18n("vxe.custom.cstmConfirmRestore"),
        className: "vxe-table--ignore-clear",
        escClosable: !0
      }).then(($) => {
        $ === "confirm" && p(A);
      }) : p(A);
    }, g = (A) => {
      const { customColumnList: $ } = n, D = I.findTree($, (O) => O === A);
      if (D && D.parent) {
        const { parent: O } = D;
        O.children && O.children.length && (O.visible = O.children.every((F) => F.visible), O.halfVisible = !O.visible && O.children.some((F) => F.visible || F.halfVisible), g(O));
      }
    }, w = (A) => {
      const $ = !A.visible, D = o.value;
      I.eachTree([A], (O) => {
        O.visible = $, O.halfVisible = !1;
      }), g(A), D.immediate && t.handleCustom(), t.checkCustomStatus();
    }, b = (A, $) => {
      const D = a.value;
      A.fixed === $ ? t.clearColumnFixed(A) : (!D || A.fixed) && t.setColumnFixed(A, $);
    }, y = (A) => {
      a.value || t.setColumnFixed(A, A.fixed);
    }, E = () => {
      const { customStore: A } = e, { customColumnList: $ } = n, D = o.value, { checkMethod: O } = D, F = !A.isAll;
      I.eachTree($, (j) => {
        (!O || O({ column: j })) && (j.visible = F, j.halfVisible = !1);
      }), A.isAll = F, t.checkCustomStatus();
    }, S = (A) => {
      const O = A.currentTarget.parentNode.parentNode, F = O.getAttribute("colid"), j = t.getColumnById(F);
      O.draggable = !0, u.value = j, Mr(O, "active--drag-origin");
    }, _ = (A) => {
      const O = A.currentTarget.parentNode.parentNode, F = s.value;
      O.draggable = !1, u.value = null, Xl(O, "active--drag-origin"), F && (F.style.display = "");
    }, k = (A) => {
      const $ = new Image();
      A.dataTransfer && A.dataTransfer.setDragImage($, 0, 0);
    }, N = () => {
      const { customColumnList: A } = n;
      A.forEach(($, D) => {
        const O = D + 1;
        $.renderSortNumber = O;
      });
    }, L = (A) => {
      const { customColumnList: $ } = n, D = A.currentTarget, O = s.value;
      if (d) {
        if (d !== D) {
          const F = d.getAttribute("drag-pos"), j = D.getAttribute("colid"), Z = t.getColumnById(j);
          if (!Z)
            return;
          const te = I.findIndexOf($, (ne) => ne.id === Z.id), de = d.getAttribute("colid"), Oe = t.getColumnById(de);
          if (!Oe)
            return;
          $.splice(te, 1);
          const ce = I.findIndexOf($, (ne) => ne.id === Oe.id);
          $.splice(ce + (F === "bottom" ? 1 : 0), 0, Z);
        }
        d.draggable = !1, d.removeAttribute("drag-pos"), Xl(d, "active--drag-target");
      }
      u.value = null, D.draggable = !1, D.removeAttribute("drag-pos"), O && (O.style.display = ""), Xl(D, "active--drag-target"), Xl(D, "active--drag-origin"), N();
    }, R = (A) => {
      const $ = A.currentTarget;
      d !== $ && Xl(d, "active--drag-target");
      const D = $.getAttribute("colid"), O = t.getColumnById(D);
      if (O && O.level === 1) {
        A.preventDefault();
        const j = A.clientY - $.getBoundingClientRect().y < $.clientHeight / 2 ? "top" : "bottom";
        Mr($, "active--drag-target"), $.setAttribute("drag-pos", j), d = $;
      }
      H(A);
    }, H = (A) => {
      const $ = s.value, D = i.value;
      if (D && $) {
        const O = D.parentNode, F = O.getBoundingClientRect();
        $.style.display = "block", $.style.top = `${Math.min(O.clientHeight - O.scrollTop - $.clientHeight, A.clientY - F.y)}px`, $.style.left = `${Math.min(O.clientWidth - O.scrollLeft - $.clientWidth - 16, A.clientX - F.x)}px`;
      }
    }, K = () => {
      const { customStore: A } = e, { customColumnList: $ } = n, D = o.value, { maxHeight: O } = A, { checkMethod: F, visibleMethod: j, trigger: Z } = D, te = a.value, de = [], Oe = {};
      Z === "hover" && (Oe.onMouseenter = f, Oe.onMouseleave = v), I.eachTree($, (Y, ve, ie, he, De) => {
        if (j ? j({ column: Y }) : !0) {
          const ue = Y.visible, Ne = Y.halfVisible, je = Y.children && Y.children.length, Fe = ko(Y.getTitle(), 1), Ve = F ? !F({ column: Y }) : !1;
          de.push(V("li", {
            key: Y.id,
            class: ["vxe-table-custom--option", `level--${Y.level}`, {
              "is--group": je
            }]
          }, [
            V("div", {
              title: Fe,
              class: ["vxe-table-custom--checkbox-option", {
                "is--checked": ue,
                "is--indeterminate": Ne,
                "is--disabled": Ve
              }],
              onClick: () => {
                Ve || w(Y);
              }
            }, [
              V("span", {
                class: ["vxe-checkbox--icon", Ne ? ee.icon.TABLE_CHECKBOX_INDETERMINATE : ue ? ee.icon.TABLE_CHECKBOX_CHECKED : ee.icon.TABLE_CHECKBOX_UNCHECKED]
              }),
              V("span", {
                class: "vxe-checkbox--label"
              }, Fe)
            ]),
            !De && D.allowFixed ? V("div", {
              class: "vxe-table-custom--fixed-option"
            }, [
              V("span", {
                class: ["vxe-table-custom--fixed-left-option", Y.fixed === "left" ? ee.icon.TOOLBAR_TOOLS_FIXED_LEFT_ACTIVED : ee.icon.TOOLBAR_TOOLS_FIXED_LEFT, {
                  "is--checked": Y.fixed === "left",
                  "is--disabled": te && !Y.fixed
                }],
                title: ee.i18n(Y.fixed === "left" ? "vxe.toolbar.cancelfixed" : "vxe.toolbar.fixedLeft"),
                onClick: () => {
                  b(Y, "left");
                }
              }),
              V("span", {
                class: ["vxe-table-custom--fixed-right-option", Y.fixed === "right" ? ee.icon.TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVED : ee.icon.TOOLBAR_TOOLS_FIXED_RIGHT, {
                  "is--checked": Y.fixed === "right",
                  "is--disabled": te && !Y.fixed
                }],
                title: ee.i18n(Y.fixed === "right" ? "vxe.toolbar.cancelfixed" : "vxe.toolbar.fixedRight"),
                onClick: () => {
                  b(Y, "right");
                }
              })
            ]) : null
          ]));
        }
      });
      const ce = A.isAll, ne = A.isIndeterminate;
      return V("div", {
        ref: r,
        key: "simple",
        class: ["vxe-table-custom-wrapper", {
          "is--active": A.visible
        }]
      }, [
        V("ul", {
          class: "vxe-table-custom--header"
        }, [
          V("li", {
            class: "vxe-table-custom--option"
          }, [
            V("div", {
              class: ["vxe-table-custom--checkbox-option", {
                "is--checked": ce,
                "is--indeterminate": ne
              }],
              title: ee.i18n("vxe.table.allTitle"),
              onClick: E
            }, [
              V("span", {
                class: ["vxe-checkbox--icon", ne ? ee.icon.TABLE_CHECKBOX_INDETERMINATE : ce ? ee.icon.TABLE_CHECKBOX_CHECKED : ee.icon.TABLE_CHECKBOX_UNCHECKED]
              }),
              V("span", {
                class: "vxe-checkbox--label"
              }, ee.i18n("vxe.toolbar.customAll"))
            ])
          ])
        ]),
        V("ul", {
          class: "vxe-table-custom--body",
          style: O ? {
            maxHeight: `${O}px`
          } : {},
          ...Oe
        }, de),
        D.showFooter ? V("div", {
          class: "vxe-table-custom--footer"
        }, [
          V("button", {
            class: "btn--reset",
            onClick: p
          }, D.resetButtonText || ee.i18n("vxe.toolbar.customRestore")),
          V("button", {
            class: "btn--confirm",
            onClick: h
          }, D.confirmButtonText || ee.i18n("vxe.toolbar.customConfirm"))
        ]) : null
      ]);
    }, U = () => {
      const { customStore: A } = e, { customColumnList: $ } = n, D = o.value, { checkMethod: O, visibleMethod: F } = D, j = l.value, Z = a.value, te = [];
      return I.eachTree($, (de, Oe, ce, ne, Y) => {
        if (F ? F({ column: de }) : !0) {
          const ie = de.visible, he = de.halfVisible, De = ko(de.getTitle(), 1), $e = de.children && de.children.length, ue = O ? !O({ column: de }) : !1;
          te.push(V("tr", {
            key: de.id,
            colid: de.id,
            class: [`vxe-table-custom-popup--row level--${de.level}`, {
              "is--group": $e
            }],
            onDragstart: k,
            onDragend: L,
            onDragover: R
          }, [
            V("td", {
              class: "vxe-table-custom-popup--column-item col--sort"
            }, [
              de.level === 1 ? V("span", {
                class: "vxe-table-custom-popup--column-sort-btn",
                onMousedown: S,
                onMouseup: _
              }, [
                V("i", {
                  class: "vxe-icon-sort"
                })
              ]) : null
            ]),
            V("td", {
              class: "vxe-table-custom-popup--column-item col--name"
            }, [
              V("div", {
                class: "vxe-table-custom-popup--name",
                title: De
              }, De)
            ]),
            V("td", {
              class: "vxe-table-custom-popup--column-item col--visible"
            }, [
              V("div", {
                class: ["vxe-table-custom--checkbox-option", {
                  "is--checked": ie,
                  "is--indeterminate": he,
                  "is--disabled": ue
                }],
                onClick: () => {
                  ue || w(de);
                }
              }, [
                V("span", {
                  class: ["vxe-checkbox--icon", he ? ee.icon.TABLE_CHECKBOX_INDETERMINATE : ie ? ee.icon.TABLE_CHECKBOX_CHECKED : ee.icon.TABLE_CHECKBOX_UNCHECKED]
                })
              ])
            ]),
            V("td", {
              class: "vxe-table-custom-popup--column-item col--fixed"
            }, [
              !Y && D.allowFixed ? V(xi, {
                modelValue: de.fixed || "",
                type: "button",
                size: "mini",
                options: [
                  { label: ee.i18n("vxe.custom.setting.fixedLeft"), value: "left", disabled: Z },
                  { label: ee.i18n("vxe.custom.setting.fixedUnset"), value: "" },
                  { label: ee.i18n("vxe.custom.setting.fixedRight"), value: "right", disabled: Z }
                ],
                "onUpdate:modelValue"(Ne) {
                  de.fixed = Ne;
                },
                onChange() {
                  y(de);
                }
              }) : null
            ])
          ]));
        }
      }), V(ws, {
        key: "popup",
        className: "vxe-table-custom-popup-wrapper vxe-table--ignore-clear",
        modelValue: A.visible,
        title: ee.i18n("vxe.custom.cstmTitle"),
        width: "40vw",
        minWidth: 520,
        height: "50vh",
        minHeight: 300,
        mask: !0,
        lockView: !0,
        showFooter: !0,
        resize: !0,
        escClosable: !0,
        destroyOnClose: !0,
        "onUpdate:modelValue"(de) {
          A.visible = de;
        }
      }, {
        default: () => V("div", {
          ref: i,
          class: "vxe-table-custom-popup--body"
        }, [
          V("div", {
            class: "vxe-table-custom-popup--table-wrapper"
          }, [
            V("table", {}, [
              V("colgroup", {}, [
                V("col", {
                  style: {
                    width: "80px"
                  }
                }),
                V("col", {}),
                V("col", {
                  style: {
                    width: "80px"
                  }
                }),
                V("col", {
                  style: {
                    width: "200px"
                  }
                })
              ]),
              V("thead", {}, [
                V("tr", {}, [
                  V("th", {}, [
                    V("span", {
                      class: "vxe-table-custom-popup--table-sort-help-title"
                    }, ee.i18n("vxe.custom.setting.colSort")),
                    V(Ic, {
                      enterable: !0,
                      content: ee.i18n("vxe.custom.setting.sortHelpTip")
                    }, {
                      default: () => V("i", {
                        class: "vxe-table-custom-popup--table-sort-help-icon vxe-icon-question-circle-fill"
                      })
                    })
                  ]),
                  V("th", {}, ee.i18n("vxe.custom.setting.colTitle")),
                  V("th", {}, ee.i18n("vxe.custom.setting.colVisible")),
                  V("th", {}, ee.i18n("vxe.custom.setting.colFixed", [j.maxFixedSize || 0]))
                ])
              ]),
              V(Ab, {
                class: "vxe-table-custom--body",
                tag: "tbody",
                name: "vxe-table-custom--flip"
              }, {
                default: () => te
              })
            ])
          ]),
          V("div", {
            ref: s,
            class: "vxe-table-custom-popup--drag-hint"
          }, ee.i18n("vxe.custom.cstmDragTarget", [u.value ? u.value.getTitle() : ""]))
        ]),
        footer: () => V("div", {
          class: "vxe-table-custom-popup--footer"
        }, [
          V(Tl, {
            content: D.resetButtonText || ee.i18n("vxe.custom.cstmRestore"),
            onClick: C
          }),
          V(Tl, {
            content: D.resetButtonText || ee.i18n("vxe.custom.cstmCancel"),
            onClick: m
          }),
          V(Tl, {
            status: "primary",
            content: D.confirmButtonText || ee.i18n("vxe.custom.cstmConfirm"),
            onClick: h
          })
        ])
      });
    };
    return () => o.value.mode === "popup" ? U() : K();
  }
}), Uwe = ["openCustom", "closeCustom"], jwe = {
  setupTable(e) {
    const { reactData: t, internalData: n } = e, { computeCustomOpts: o } = e.getComputeMaps(), { refTableHeader: l, refTableBody: a, refTableCustom: r } = e.getRefMaps(), i = e.xegrid, s = () => {
      const { customStore: p } = t, C = l.value, g = a.value, w = r.value, b = w ? w.$el : null, y = C.$el, E = g.$el;
      let S = 0;
      y && (S += y.clientHeight), E && (S += E.clientHeight), p.maxHeight = Math.max(0, b ? Math.min(b.clientHeight, S - 80) : 0);
    }, u = () => {
      const { initStore: p, customStore: C } = t;
      return C.visible = !0, p.custom = !0, t.customColumnList = n.collectColumn.slice(0), v(), s(), xe().then(() => s());
    }, d = () => {
      const { customStore: p } = t, C = o.value;
      return p.visible && (p.visible = !1, C.immediate || e.handleCustom()), xe();
    }, f = {
      openCustom: u,
      closeCustom: d
    }, v = () => {
      const { customStore: p } = t, { collectColumn: C } = n, g = o.value, { checkMethod: w } = g;
      p.isAll = C.every((b) => (w ? !w({ column: b }) : !1) || b.visible), p.isIndeterminate = !p.isAll && C.some((b) => (!w || w({ column: b })) && (b.visible || b.halfVisible));
    }, h = (p, C) => {
      (i || e).dispatchEvent("custom", { type: p }, C);
    };
    return { ...f, ...{
      checkCustomStatus: v,
      emitCustomEvent: h,
      triggerCustomEvent(p) {
        const { customStore: C } = e.reactData;
        C.visible ? (d(), h("close", p)) : (C.btnEl = p.target, u(), h("open", p));
      },
      customOpenEvent(p) {
        const { customStore: C } = t;
        C.visible || (C.activeBtn = !0, C.btnEl = p.target, e.openCustom(), e.emitCustomEvent("open", p));
      },
      customColseEvent(p) {
        const { customStore: C } = t;
        C.visible && (C.activeBtn = !1, e.closeCustom(), e.emitCustomEvent("close", p));
      }
    } };
  },
  setupGrid(e) {
    return e.extendTableMethods(Uwe);
  }
}, v1 = {
  Panel: sd,
  install(e) {
    $t.hooks.add("$tableCustom", jwe), e.component(sd.name, sd);
  }
}, qwe = v1;
Fn.component(sd.name, sd);
const Hm = Q({
  name: "VxeIcon",
  props: {
    name: String,
    roll: Boolean,
    status: String
  },
  emits: [
    "click"
  ],
  setup(e, { emit: t }) {
    const n = (o) => {
      t("click", { $event: o });
    };
    return () => {
      const { name: o, roll: l, status: a } = e;
      return V("i", {
        class: [`vxe-icon-${o}`, l ? "roll" : "", a ? [`theme--${a}`] : ""],
        onClick: n
      });
    };
  }
}), Yd = Object.assign(Hm, {
  install(e) {
    e.component(Hm.name, Hm);
  }
}), Ywe = Yd;
Fn.component(Yd.name, Yd);
function Gwe(e) {
  const { $table: t, column: n } = e, o = n.titlePrefix || n.titleHelp;
  return o ? [
    V("i", {
      class: ["vxe-cell-title-prefix-icon", o.icon || ee.icon.TABLE_TITLE_PREFIX],
      onMouseenter(l) {
        t.triggerHeaderTitleEvent(l, o, e);
      },
      onMouseleave(l) {
        t.handleTargetLeaveEvent(l);
      }
    })
  ] : [];
}
function Xwe(e) {
  const { $table: t, column: n } = e, o = n.titleSuffix;
  return o ? [
    V("i", {
      class: ["vxe-cell-title-suffix-icon", o.icon || ee.icon.TABLE_TITLE_SUFFIX],
      onMouseenter(l) {
        t.triggerHeaderTitleEvent(l, o, e);
      },
      onMouseleave(l) {
        t.handleTargetLeaveEvent(l);
      }
    })
  ] : [];
}
function ss(e, t) {
  const { $table: n, column: o } = e, { props: l, reactData: a } = n, { computeTooltipOpts: r } = n.getComputeMaps(), { showHeaderOverflow: i } = l, { type: s, showHeaderOverflow: u } = o, f = r.value.showAll, v = I.isUndefined(u) || I.isNull(u) ? i : u, h = v === "title", m = v === !0 || v === "tooltip", p = {};
  return (h || m || f) && (p.onMouseenter = (C) => {
    a._isResize || (h ? J0(C.currentTarget, o) : (m || f) && n.triggerHeaderTooltipEvent(C, e));
  }), (m || f) && (p.onMouseleave = (C) => {
    a._isResize || (m || f) && n.handleTargetLeaveEvent(C);
  }), [
    s === "html" && I.isString(t) ? V("span", {
      class: "vxe-cell--title",
      innerHTML: t,
      ...p
    }) : V("span", {
      class: "vxe-cell--title",
      ...p
    }, oo(t))
  ];
}
function Zwe(e) {
  const { $table: t, column: n, _columnIndex: o, items: l, row: a } = e, { slots: r, editRender: i, cellRender: s } = n, u = i || s, d = r ? r.footer : null;
  if (d)
    return t.callSlot(d, e);
  if (u) {
    const f = $t.renderer.get(u.name);
    if (f && f.renderFooter)
      return oo(f.renderFooter(u, e));
  }
  return I.isArray(l) ? [ko(l[o], 1)] : [ko(I.get(a, n.field), 1)];
}
function U_(e) {
  const { $table: t, row: n, column: o } = e;
  return ko(t.getCellLabel(n, o), 1);
}
const nn = {
  createColumn(e, t) {
    const { type: n, sortable: o, filters: l, editRender: a, treeNode: r } = t, { props: i } = e, { editConfig: s } = i, { computeEditOpts: u, computeCheckboxOpts: d } = e.getComputeMaps(), f = d.value, v = u.value, h = {
      renderHeader: nn.renderDefaultHeader,
      renderCell: r ? nn.renderTreeCell : nn.renderDefaultCell,
      renderFooter: nn.renderDefaultFooter
    };
    switch (n) {
      case "seq":
        h.renderHeader = nn.renderSeqHeader, h.renderCell = r ? nn.renderTreeIndexCell : nn.renderSeqCell;
        break;
      case "radio":
        h.renderHeader = nn.renderRadioHeader, h.renderCell = r ? nn.renderTreeRadioCell : nn.renderRadioCell;
        break;
      case "checkbox":
        h.renderHeader = nn.renderCheckboxHeader, h.renderCell = f.checkField ? r ? nn.renderTreeSelectionCellByProp : nn.renderCheckboxCellByProp : r ? nn.renderTreeSelectionCell : nn.renderCheckboxCell;
        break;
      case "expand":
        h.renderCell = nn.renderExpandCell, h.renderData = nn.renderExpandData;
        break;
      case "html":
        h.renderCell = r ? nn.renderTreeHTMLCell : nn.renderHTMLCell, l && o ? h.renderHeader = nn.renderSortAndFilterHeader : o ? h.renderHeader = nn.renderSortHeader : l && (h.renderHeader = nn.renderFilterHeader);
        break;
      default:
        s && a ? (h.renderHeader = nn.renderEditHeader, h.renderCell = v.mode === "cell" ? r ? nn.renderTreeCellEdit : nn.renderCellEdit : r ? nn.renderTreeRowEdit : nn.renderRowEdit) : l && o ? h.renderHeader = nn.renderSortAndFilterHeader : o ? h.renderHeader = nn.renderSortHeader : l && (h.renderHeader = nn.renderFilterHeader);
    }
    return XCe(e, t, h);
  },
  /**
   * 单元格
   */
  renderHeaderTitle(e) {
    const { $table: t, column: n } = e, { slots: o, editRender: l, cellRender: a } = n, r = l || a, i = o ? o.header : null;
    if (i)
      return ss(e, t.callSlot(i, e));
    if (r) {
      const s = $t.renderer.get(r.name);
      if (s && s.renderHeader)
        return ss(e, oo(s.renderHeader(r, e)));
    }
    return ss(e, ko(n.getTitle(), 1));
  },
  renderDefaultHeader(e) {
    return Gwe(e).concat(nn.renderHeaderTitle(e)).concat(Xwe(e));
  },
  renderDefaultCell(e) {
    const { $table: t, row: n, column: o } = e, { slots: l, editRender: a, cellRender: r } = o, i = a || r, s = l ? l.default : null;
    if (s)
      return t.callSlot(s, e);
    if (i) {
      const f = a ? "renderCell" : "renderDefault", v = $t.renderer.get(i.name), h = v ? v[f] : null;
      if (h)
        return oo(h(i, Object.assign({ $type: a ? "edit" : "cell" }, e)));
    }
    const u = t.getCellLabel(n, o), d = a ? a.placeholder : "";
    return [
      V("span", {
        class: "vxe-cell--label"
      }, a && La(u) ? [
        // 如果设置占位符
        V("span", {
          class: "vxe-cell--placeholder"
        }, ko(vo(d), 1))
      ] : ko(u, 1))
    ];
  },
  renderTreeCell(e) {
    return nn.renderTreeIcon(e, nn.renderDefaultCell(e));
  },
  renderDefaultFooter(e) {
    return [
      V("span", {
        class: "vxe-cell--item"
      }, Zwe(e))
    ];
  },
  /**
   * 树节点
   */
  renderTreeIcon(e, t) {
    const { $table: n, isHidden: o } = e, { reactData: l } = n, { computeTreeOpts: a } = n.getComputeMaps(), { treeExpandedMaps: r, treeExpandLazyLoadedMaps: i } = l, s = a.value, { row: u, column: d, level: f } = e, { slots: v } = d, { indent: h, lazy: m, trigger: p, iconLoaded: C, showIcon: g, iconOpen: w, iconClose: b } = s, y = s.children || s.childrenField, E = s.hasChild || s.hasChildField, S = u[y], _ = v ? v.icon : null;
    let k = !1, N = !1, L = !1;
    const R = {};
    if (_)
      return n.callSlot(_, e);
    if (!o) {
      const H = yt(n, u);
      N = !!r[H], m && (L = !!i[H], k = u[E]);
    }
    return (!p || p === "default") && (R.onClick = (H) => {
      H.stopPropagation(), n.triggerTreeExpandEvent(H, e);
    }), [
      V("div", {
        class: ["vxe-cell--tree-node", {
          "is--active": N
        }],
        style: {
          paddingLeft: `${f * h}px`
        }
      }, [
        g && (S && S.length || k) ? [
          V("div", {
            class: "vxe-tree--btn-wrapper",
            ...R
          }, [
            V("i", {
              class: ["vxe-tree--node-btn", L ? C || ee.icon.TABLE_TREE_LOADED : N ? w || ee.icon.TABLE_TREE_OPEN : b || ee.icon.TABLE_TREE_CLOSE]
            })
          ])
        ] : null,
        V("div", {
          class: "vxe-tree-cell"
        }, t)
      ])
    ];
  },
  /**
   * 索引
   */
  renderSeqHeader(e) {
    const { $table: t, column: n } = e, { slots: o } = n, l = o ? o.header : null;
    return ss(e, l ? t.callSlot(l, e) : ko(n.getTitle(), 1));
  },
  renderSeqCell(e) {
    const { $table: t, column: n } = e, { props: o } = t, { treeConfig: l } = o, { computeSeqOpts: a } = t.getComputeMaps(), r = a.value, { slots: i } = n, s = i ? i.default : null;
    if (s)
      return t.callSlot(s, e);
    const { seq: u } = e, d = r.seqMethod;
    return [ko(d ? d(e) : l ? u : (r.startIndex || 0) + u, 1)];
  },
  renderTreeIndexCell(e) {
    return nn.renderTreeIcon(e, nn.renderSeqCell(e));
  },
  /**
   * 单选
   */
  renderRadioHeader(e) {
    const { $table: t, column: n } = e, { slots: o } = n, l = o ? o.header : null, a = o ? o.title : null;
    return ss(e, l ? t.callSlot(l, e) : [
      V("span", {
        class: "vxe-radio--label"
      }, a ? t.callSlot(a, e) : ko(n.getTitle(), 1))
    ]);
  },
  renderRadioCell(e) {
    const { $table: t, column: n, isHidden: o } = e, { reactData: l } = t, { computeRadioOpts: a } = t.getComputeMaps(), { selectRadioRow: r } = l, i = a.value, { slots: s } = n, { labelField: u, checkMethod: d, visibleMethod: f } = i, { row: v } = e, h = s ? s.default : null, m = s ? s.radio : null, p = t.eqRow(v, r), C = !f || f({ row: v });
    let g = !!d, w;
    o || (w = {
      onClick(E) {
        !g && C && (E.stopPropagation(), t.triggerRadioRowEvent(E, e));
      }
    }, d && (g = !d({ row: v })));
    const b = { ...e, checked: p, disabled: g, visible: C };
    if (m)
      return t.callSlot(m, b);
    const y = [];
    return C && y.push(V("span", {
      class: ["vxe-radio--icon", p ? ee.icon.TABLE_RADIO_CHECKED : ee.icon.TABLE_RADIO_UNCHECKED]
    })), (h || u) && y.push(V("span", {
      class: "vxe-radio--label"
    }, h ? t.callSlot(h, b) : I.get(v, u))), [
      V("span", {
        class: ["vxe-cell--radio", {
          "is--checked": p,
          "is--disabled": g
        }],
        ...w
      }, y)
    ];
  },
  renderTreeRadioCell(e) {
    return nn.renderTreeIcon(e, nn.renderRadioCell(e));
  },
  /**
   * 多选
   */
  renderCheckboxHeader(e) {
    const { $table: t, column: n, isHidden: o } = e, { reactData: l } = t, { computeIsAllCheckboxDisabled: a, computeCheckboxOpts: r } = t.getComputeMaps(), { isAllSelected: i, isIndeterminate: s } = l, u = a.value, { slots: d } = n, f = d ? d.header : null, v = d ? d.title : null, h = r.value, m = n.getTitle();
    let p;
    o || (p = {
      onClick(g) {
        u || (g.stopPropagation(), t.triggerCheckAllEvent(g, !i));
      }
    });
    const C = { ...e, checked: i, disabled: u, indeterminate: s };
    return f ? ss(C, t.callSlot(f, C)) : (h.checkStrictly ? !h.showHeader : h.showHeader === !1) ? ss(C, [
      V("span", {
        class: "vxe-checkbox--label"
      }, v ? t.callSlot(v, C) : m)
    ]) : ss(C, [
      V("span", {
        class: ["vxe-cell--checkbox", {
          "is--checked": i,
          "is--disabled": u,
          "is--indeterminate": s
        }],
        title: ee.i18n("vxe.table.allTitle"),
        ...p
      }, [
        V("span", {
          class: ["vxe-checkbox--icon", s ? ee.icon.TABLE_CHECKBOX_INDETERMINATE : i ? ee.icon.TABLE_CHECKBOX_CHECKED : ee.icon.TABLE_CHECKBOX_UNCHECKED]
        })
      ].concat(v || m ? [
        V("span", {
          class: "vxe-checkbox--label"
        }, v ? t.callSlot(v, C) : m)
      ] : []))
    ]);
  },
  renderCheckboxCell(e) {
    const { $table: t, row: n, column: o, isHidden: l } = e, { props: a, reactData: r } = t, { treeConfig: i } = a, { selectCheckboxMaps: s, treeIndeterminateMaps: u } = r, { computeCheckboxOpts: d } = t.getComputeMaps(), f = d.value, { labelField: v, checkMethod: h, visibleMethod: m } = f, { slots: p } = o, C = p ? p.default : null, g = p ? p.checkbox : null;
    let w = !1, b = !1;
    const y = !m || m({ row: n });
    let E = !!h, S;
    if (!l) {
      const N = yt(t, n);
      b = !!s[N], S = {
        onClick(L) {
          !E && y && (L.stopPropagation(), t.triggerCheckRowEvent(L, e, !b));
        }
      }, h && (E = !h({ row: n })), i && (w = !!u[N]);
    }
    const _ = { ...e, checked: b, disabled: E, visible: y, indeterminate: w };
    if (g)
      return t.callSlot(g, _);
    const k = [];
    return y && k.push(V("span", {
      class: ["vxe-checkbox--icon", w ? ee.icon.TABLE_CHECKBOX_INDETERMINATE : b ? ee.icon.TABLE_CHECKBOX_CHECKED : ee.icon.TABLE_CHECKBOX_UNCHECKED]
    })), (C || v) && k.push(V("span", {
      class: "vxe-checkbox--label"
    }, C ? t.callSlot(C, _) : I.get(n, v))), [
      V("span", {
        class: ["vxe-cell--checkbox", {
          "is--checked": b,
          "is--disabled": E,
          "is--indeterminate": w,
          "is--hidden": !y
        }],
        ...S
      }, k)
    ];
  },
  renderTreeSelectionCell(e) {
    return nn.renderTreeIcon(e, nn.renderCheckboxCell(e));
  },
  renderCheckboxCellByProp(e) {
    const { $table: t, row: n, column: o, isHidden: l } = e, { props: a, reactData: r } = t, { treeConfig: i } = a, { treeIndeterminateMaps: s } = r, { computeCheckboxOpts: u } = t.getComputeMaps(), d = u.value, { labelField: f, checkField: v, checkMethod: h, visibleMethod: m } = d, p = d.indeterminateField || d.halfField, { slots: C } = o, g = C ? C.default : null, w = C ? C.checkbox : null;
    let b = !1, y = !1;
    const E = !m || m({ row: n });
    let S = !!h, _;
    if (!l) {
      const L = yt(t, n);
      y = I.get(n, v), _ = {
        onClick(R) {
          !S && E && (R.stopPropagation(), t.triggerCheckRowEvent(R, e, !y));
        }
      }, h && (S = !h({ row: n })), i && (b = !!s[L]);
    }
    const k = { ...e, checked: y, disabled: S, visible: E, indeterminate: b };
    if (w)
      return t.callSlot(w, k);
    const N = [];
    return E && (N.push(V("span", {
      class: ["vxe-checkbox--icon", b ? ee.icon.TABLE_CHECKBOX_INDETERMINATE : y ? ee.icon.TABLE_CHECKBOX_CHECKED : ee.icon.TABLE_CHECKBOX_UNCHECKED]
    })), (g || f) && N.push(V("span", {
      class: "vxe-checkbox--label"
    }, g ? t.callSlot(g, k) : I.get(n, f)))), [
      V("span", {
        class: ["vxe-cell--checkbox", {
          "is--checked": y,
          "is--disabled": S,
          "is--indeterminate": p && !y ? n[p] : b,
          "is--hidden": !E
        }],
        ..._
      }, N)
    ];
  },
  renderTreeSelectionCellByProp(e) {
    return nn.renderTreeIcon(e, nn.renderCheckboxCellByProp(e));
  },
  /**
   * 展开行
   */
  renderExpandCell(e) {
    const { $table: t, isHidden: n, row: o, column: l } = e, { reactData: a } = t, { rowExpandedMaps: r, rowExpandLazyLoadedMaps: i } = a, { computeExpandOpts: s } = t.getComputeMaps(), u = s.value, { lazy: d, labelField: f, iconLoaded: v, showIcon: h, iconOpen: m, iconClose: p, visibleMethod: C } = u, { slots: g } = l, w = g ? g.default : null, b = g ? g.icon : null;
    let y = !1, E = !1;
    if (b)
      return t.callSlot(b, e);
    if (!n) {
      const S = yt(t, o);
      y = !!r[S], d && (E = !!i[S]);
    }
    return [
      h && (!C || C(e)) ? V("span", {
        class: ["vxe-table--expanded", {
          "is--active": y
        }],
        onClick(S) {
          S.stopPropagation(), t.triggerRowExpandEvent(S, e);
        }
      }, [
        V("i", {
          class: ["vxe-table--expand-btn", E ? v || ee.icon.TABLE_EXPAND_LOADED : y ? m || ee.icon.TABLE_EXPAND_OPEN : p || ee.icon.TABLE_EXPAND_CLOSE]
        })
      ]) : null,
      w || f ? V("span", {
        class: "vxe-table--expand-label"
      }, w ? t.callSlot(w, e) : I.get(o, f)) : null
    ];
  },
  renderExpandData(e) {
    const { $table: t, column: n } = e, { slots: o, contentRender: l } = n, a = o ? o.content : null;
    if (a)
      return t.callSlot(a, e);
    if (l) {
      const r = $t.renderer.get(l.name);
      if (r && r.renderExpand)
        return oo(r.renderExpand(l, e));
    }
    return [];
  },
  /**
   * HTML 标签
   */
  renderHTMLCell(e) {
    const { $table: t, column: n } = e, { slots: o } = n, l = o ? o.default : null;
    return l ? t.callSlot(l, e) : [
      V("span", {
        class: "vxe-cell--html",
        innerHTML: U_(e)
      })
    ];
  },
  renderTreeHTMLCell(e) {
    return nn.renderTreeIcon(e, nn.renderHTMLCell(e));
  },
  /**
   * 排序和筛选
   */
  renderSortAndFilterHeader(e) {
    return nn.renderDefaultHeader(e).concat(nn.renderSortIcon(e)).concat(nn.renderFilterIcon(e));
  },
  /**
   * 排序
   */
  renderSortHeader(e) {
    return nn.renderDefaultHeader(e).concat(nn.renderSortIcon(e));
  },
  renderSortIcon(e) {
    const { $table: t, column: n } = e, { computeSortOpts: o } = t.getComputeMaps(), l = o.value, { showIcon: a, iconLayout: r, iconAsc: i, iconDesc: s } = l, { order: u } = n;
    return a ? [
      V("span", {
        class: ["vxe-cell--sort", `vxe-cell--sort-${r}-layout`]
      }, [
        V("i", {
          class: ["vxe-sort--asc-btn", i || ee.icon.TABLE_SORT_ASC, {
            "sort--active": u === "asc"
          }],
          title: ee.i18n("vxe.table.sortAsc"),
          onClick(d) {
            d.stopPropagation(), t.triggerSortEvent(d, n, "asc");
          }
        }),
        V("i", {
          class: ["vxe-sort--desc-btn", s || ee.icon.TABLE_SORT_DESC, {
            "sort--active": u === "desc"
          }],
          title: ee.i18n("vxe.table.sortDesc"),
          onClick(d) {
            d.stopPropagation(), t.triggerSortEvent(d, n, "desc");
          }
        })
      ])
    ] : [];
  },
  /**
   * 筛选
   */
  renderFilterHeader(e) {
    return nn.renderDefaultHeader(e).concat(nn.renderFilterIcon(e));
  },
  renderFilterIcon(e) {
    const { $table: t, column: n, hasFilter: o } = e, { reactData: l } = t, { filterStore: a } = l, { computeFilterOpts: r } = t.getComputeMaps(), i = r.value, { showIcon: s, iconNone: u, iconMatch: d } = i;
    return s ? [
      V("span", {
        class: ["vxe-cell--filter", {
          "is--active": a.visible && a.column === n
        }]
      }, [
        V("i", {
          class: ["vxe-filter--btn", o ? d || ee.icon.TABLE_FILTER_MATCH : u || ee.icon.TABLE_FILTER_NONE],
          title: ee.i18n("vxe.table.filter"),
          onClick(f) {
            t.triggerFilterEvent && t.triggerFilterEvent(f, e.column, e);
          }
        })
      ])
    ] : [];
  },
  /**
   * 可编辑
   */
  renderEditHeader(e) {
    const { $table: t, column: n } = e, { props: o } = t, { computeEditOpts: l } = t.getComputeMaps(), { editConfig: a, editRules: r } = o, i = l.value, { sortable: s, filters: u, editRender: d } = n;
    let f = !1;
    if (r) {
      const v = I.get(r, n.field);
      v && (f = v.some((h) => h.required));
    }
    return (mn(a) ? [
      f && i.showAsterisk ? V("i", {
        class: "vxe-cell--required-icon"
      }) : null,
      mn(d) && i.showIcon ? V("i", {
        class: ["vxe-cell--edit-icon", i.icon || ee.icon.TABLE_EDIT]
      }) : null
    ] : []).concat(nn.renderDefaultHeader(e)).concat(s ? nn.renderSortIcon(e) : []).concat(u ? nn.renderFilterIcon(e) : []);
  },
  // 行格编辑模式
  renderRowEdit(e) {
    const { $table: t, column: n } = e, { reactData: o } = t, { editStore: l } = o, { actived: a } = l, { editRender: r } = n;
    return nn.runRenderer(e, mn(r) && a && a.row === e.row);
  },
  renderTreeRowEdit(e) {
    return nn.renderTreeIcon(e, nn.renderRowEdit(e));
  },
  // 单元格编辑模式
  renderCellEdit(e) {
    const { $table: t, column: n } = e, { reactData: o } = t, { editStore: l } = o, { actived: a } = l, { editRender: r } = n;
    return nn.runRenderer(e, mn(r) && a && a.row === e.row && a.column === e.column);
  },
  renderTreeCellEdit(e) {
    return nn.renderTreeIcon(e, nn.renderCellEdit(e));
  },
  runRenderer(e, t) {
    const { $table: n, column: o } = e, { slots: l, editRender: a, formatter: r } = o, i = l ? l.default : null, s = l ? l.edit : null, u = $t.renderer.get(a.name);
    return t ? s ? n.callSlot(s, e) : u && u.renderEdit ? oo(u.renderEdit(a, Object.assign({ $type: "edit" }, e))) : [] : i ? n.callSlot(i, e) : r ? [
      V("span", {
        class: "vxe-cell--label"
      }, U_(e))
    ] : nn.renderDefaultCell(e);
  }
}, eR = {
  // 列唯一主键
  colId: [String, Number],
  // 渲染类型 index,radio,checkbox,expand,html
  type: String,
  // 列字段名
  field: String,
  // 列标题
  title: String,
  // 列宽度
  width: [Number, String],
  // 列最小宽度，把剩余宽度按比例分配
  minWidth: [Number, String],
  // 列最大宽度
  maxWidth: [Number, String],
  // 是否允许拖动列宽调整大小
  resizable: { type: Boolean, default: null },
  // 将列固定在左侧或者右侧
  fixed: String,
  // 列对其方式
  align: String,
  // 表头对齐方式
  headerAlign: String,
  // 表尾列的对齐方式
  footerAlign: String,
  // 当内容过长时显示为省略号
  showOverflow: { type: [Boolean, String], default: null },
  // 当表头内容过长时显示为省略号
  showHeaderOverflow: { type: [Boolean, String], default: null },
  // 当表尾内容过长时显示为省略号
  showFooterOverflow: { type: [Boolean, String], default: null },
  // 给单元格附加 className
  className: [String, Function],
  // 给表头单元格附加 className
  headerClassName: [String, Function],
  // 给表尾单元格附加 className
  footerClassName: [String, Function],
  // 格式化显示内容
  formatter: [Function, Array, String],
  // 是否允许排序
  sortable: Boolean,
  // 自定义排序的属性
  sortBy: [String, Function],
  // 排序的字段类型，比如字符串转数值等
  sortType: String,
  // 配置筛选条件数组
  filters: { type: Array, default: null },
  // 筛选是否允许多选
  filterMultiple: { type: Boolean, default: !0 },
  // 自定义筛选方法
  filterMethod: Function,
  // 筛选重置方法
  filterResetMethod: Function,
  // 筛选复原方法
  filterRecoverMethod: Function,
  // 筛选模板配置项
  filterRender: Object,
  // 指定为树节点
  treeNode: Boolean,
  // 是否可视
  visible: { type: Boolean, default: null },
  // 表头单元格数据导出方法
  headerExportMethod: Function,
  // 单元格数据导出方法
  exportMethod: Function,
  // 表尾单元格数据导出方法
  footerExportMethod: Function,
  // 已废弃，被 titlePrefix 替换
  titleHelp: Object,
  // 标题前缀图标配置项
  titlePrefix: Object,
  // 标题后缀图标配置项
  titleSuffix: Object,
  // 单元格值类型
  cellType: String,
  // 单元格渲染配置项
  cellRender: Object,
  // 单元格编辑渲染配置项
  editRender: Object,
  // 内容渲染配置项
  contentRender: Object,
  // 额外的参数
  params: Object
}, vi = Q({
  name: "VxeColumn",
  props: eR,
  setup(e, { slots: t }) {
    const n = B(), o = ot("$xetable", {}), l = ot("xecolgroup", null), a = nn.createColumn(o, e);
    return a.slots = t, Mt("$xegrid", null), xI(o, e, a), Nt(() => {
      kI(o, n.value, a, l);
    }), wo(() => {
      TI(o, a);
    }), () => V("div", {
      ref: n
    });
  }
}), h1 = Object.assign(vi, {
  install(e) {
    e.component(vi.name, vi), e.component("VxeTableColumn", vi);
  }
}), Jwe = h1;
Fn.component(vi.name, vi);
Fn.component("VxeTableColumn", vi);
const hi = Q({
  name: "VxeColgroup",
  props: eR,
  setup(e, { slots: t }) {
    const n = B(), o = ot("$xetable", {}), l = ot("xecolgroup", null), a = nn.createColumn(o, e), r = {};
    t.header && (r.header = t.header);
    const i = { column: a };
    return a.slots = r, a.children = [], Mt("xecolgroup", i), Mt("$xegrid", null), xI(o, e, a), Nt(() => {
      kI(o, n.value, a, l);
    }), wo(() => {
      TI(o, a);
    }), () => V("div", {
      ref: n
    }, t.default ? t.default() : []);
  }
}), m1 = Object.assign(hi, {
  install(e) {
    e.component(hi.name, hi), e.component("VxeTableColgroup", hi);
  }
}), Qwe = m1;
Fn.component(hi.name, hi);
Fn.component("VxeTableColgroup", hi);
let j_;
const ai = [], eEe = 500;
function tEe() {
  ai.length && (ai.forEach((e) => {
    e.tarList.forEach((t) => {
      const { target: n, width: o, heighe: l } = t, a = n.clientWidth, r = n.clientHeight;
      (a && o !== a || r && l !== r) && (t.width = a, t.heighe = r, setTimeout(e.callback));
    });
  }), tR());
}
function tR() {
  clearTimeout(j_), j_ = setTimeout(tEe, ee.resizeInterval || eEe);
}
class nEe {
  constructor(t) {
    Jr(this, "tarList", []);
    Jr(this, "callback");
    this.callback = t;
  }
  observe(t) {
    if (t) {
      const { tarList: n } = this;
      n.some((o) => o.target === t) || n.push({
        target: t,
        width: t.clientWidth,
        heighe: t.clientHeight
      }), ai.length || tR(), ai.some((o) => o === this) || ai.push(this);
    }
  }
  unobserve(t) {
    I.remove(ai, (n) => n.tarList.some((o) => o.target === t));
  }
  disconnect() {
    I.remove(ai, (t) => t === this);
  }
}
function nR(e) {
  return window.ResizeObserver ? new window.ResizeObserver(e) : new nEe(e);
}
const cc = "body", oEe = {
  mini: 3,
  small: 2,
  medium: 1
}, q_ = Q({
  name: "VxeTableBody",
  props: {
    tableData: Array,
    tableColumn: Array,
    fixedColumn: Array,
    fixedType: { type: String, default: null }
  },
  setup(e) {
    const t = ot("$xetable", {}), n = ot("xesize", null), { xID: o, props: l, context: a, reactData: r, internalData: i } = t, { refTableHeader: s, refTableBody: u, refTableFooter: d, refTableLeftBody: f, refTableRightBody: v, refValidTooltip: h } = t.getRefMaps(), { computeEditOpts: m, computeMouseOpts: p, computeSYOpts: C, computeEmptyOpts: g, computeKeyboardOpts: w, computeTooltipOpts: b, computeRadioOpts: y, computeExpandOpts: E, computeTreeOpts: S, computeCheckboxOpts: _, computeValidOpts: k, computeRowOpts: N, computeColumnOpts: L } = t.getComputeMaps(), R = B(), H = B(), K = B(), U = B(), W = B(), A = B(), $ = B(), D = () => {
      if (n) {
        const je = n.value;
        if (je)
          return oEe[je] || 0;
      }
      return 0;
    }, O = () => {
      const { delayHover: je } = l, { lastScrollTime: Fe, _isResize: Ve } = r;
      return !!(Ve || Fe && Date.now() < Fe + je);
    }, F = (je, Fe) => {
      let Ve = 1;
      if (!je)
        return Ve;
      const Ze = S.value, ae = Ze.children || Ze.childrenField, pe = je[ae];
      if (pe && t.isTreeExpandByRow(je))
        for (let ke = 0; ke < pe.length; ke++)
          Ve += F(pe[ke]);
      return Ve;
    }, j = (je, Fe, Ve) => {
      let Ze = 1;
      return Ve && (Ze = F(Fe[Ve - 1])), r.rowHeight * Ze - (Ve ? 1 : 12 - D());
    }, Z = (je) => {
      const { row: Fe, column: Ve } = je, { afterFullData: Ze } = i, { treeConfig: ae } = l, pe = S.value, { slots: ke, treeNode: Ue } = Ve, { fullAllDataRowIdData: Xe } = i, re = yt(t, Fe), Te = Xe[re];
      let Ce = 0, Le = 0, ge = [];
      if (Te && (Ce = Te.level, Le = Te._index, ge = Te.items), ke && ke.line)
        return t.callSlot(ke.line, je);
      const Ee = t.eqRow(Ze[0], Fe);
      return ae && Ue && (pe.showLine || pe.line) ? [
        V("div", {
          class: "vxe-tree--line-wrapper"
        }, [
          V("div", {
            class: "vxe-tree--line",
            style: {
              height: `${Ee ? 1 : j(je, ge, Le)}px`,
              left: `${Ce * pe.indent + (Ce ? 2 - D() : 0) + 16}px`
            }
          })
        ])
      ] : [];
    }, te = (je, Fe, Ve, Ze, ae, pe, ke, Ue, Xe, re, Te, Ce) => {
      const { columnKey: Le, height: ge, showOverflow: Ee, cellClassName: me, cellStyle: Ke, align: Re, spanMethod: we, mouseConfig: ze, editConfig: Je, editRules: Me, tooltipConfig: et } = l, { tableData: mt, overflowX: Lt, scrollYLoad: be, currentColumn: an, mergeList: _t, editStore: zt, isAllOverflow: jt, validErrorMaps: Sn } = r, { afterFullData: hn } = i, xn = k.value, yn = _.value, kn = m.value, Wn = b.value, Vn = N.value, ho = C.value, Qn = L.value, { type: eo, cellRender: So, editRender: st, align: St, showOverflow: rn, className: Tn, treeNode: mo, slots: ro } = Xe, { actived: Io } = zt, { rHeight: Oo } = ho, { height: so } = Vn, la = st || So, aa = la ? $t.renderer.get(la.name) : null, ft = aa ? aa.cellClassName : "", At = aa ? aa.cellStyle : "", Xt = Wn.showAll, sn = t.getColumnIndex(Xe), _o = t.getVTColumnIndex(Xe), No = mn(st);
      let Oa = Ve ? Xe.fixed !== Ve : Xe.fixed && Lt;
      const br = I.isUndefined(rn) || I.isNull(rn) ? Ee : rn;
      let qa = br === "ellipsis";
      const ra = br === "title", cl = br === !0 || br === "tooltip";
      let sa = ra || cl || qa, Gr;
      const Ya = {}, Ga = St || Re, ia = Sn[`${Fe}:${Xe.id}`], Xr = Me && xn.showMessage && (xn.message === "default" ? ge || mt.length > 1 : xn.message === "inline"), Ml = { colid: Xe.id }, Ro = { $table: t, $grid: t.xegrid, seq: je, rowid: Fe, row: ae, rowIndex: pe, $rowIndex: ke, _rowIndex: Ue, column: Xe, columnIndex: sn, $columnIndex: re, _columnIndex: _o, fixed: Ve, type: cc, isHidden: Oa, level: Ze, visibleData: hn, data: mt, items: Ce };
      if (be && !sa && (qa = sa = !0), (ra || cl || Xt || et) && (Ya.onMouseenter = (Un) => {
        O() || (ra ? J0(Un.currentTarget, Xe) : (cl || Xt) && t.triggerBodyTooltipEvent(Un, Ro), t.dispatchEvent("cell-mouseenter", Object.assign({ cell: Un.currentTarget }, Ro), Un));
      }), (cl || Xt || et) && (Ya.onMouseleave = (Un) => {
        O() || ((cl || Xt) && t.handleTargetLeaveEvent(Un), t.dispatchEvent("cell-mouseleave", Object.assign({ cell: Un.currentTarget }, Ro), Un));
      }), (yn.range || ze) && (Ya.onMousedown = (Un) => {
        t.triggerCellMousedownEvent(Un, Ro);
      }), Ya.onClick = (Un) => {
        t.triggerCellClickEvent(Un, Ro);
      }, Ya.onDblclick = (Un) => {
        t.triggerCellDblclickEvent(Un, Ro);
      }, _t.length) {
        const Un = $I(_t, Ue, _o);
        if (Un) {
          const { rowspan: Jo, colspan: Na } = Un;
          if (!Jo || !Na)
            return null;
          Jo > 1 && (Ml.rowspan = Jo), Na > 1 && (Ml.colspan = Na);
        }
      } else if (we) {
        const { rowspan: Un = 1, colspan: Jo = 1 } = we(Ro) || {};
        if (!Un || !Jo)
          return null;
        Un > 1 && (Ml.rowspan = Un), Jo > 1 && (Ml.colspan = Jo);
      }
      Oa && _t && (Ml.colspan > 1 || Ml.rowspan > 1) && (Oa = !1), !Oa && Je && (st || So) && (kn.showStatus || kn.showUpdateStatus) && (Gr = t.isUpdateByRow(ae, Xe.field));
      const yr = [];
      if (Oa && Ee && jt)
        yr.push(V("div", {
          class: ["vxe-cell", {
            "c--title": ra,
            "c--tooltip": cl,
            "c--ellipsis": qa
          }],
          style: {
            maxHeight: sa && (Oo || so) ? `${Oo || so}px` : ""
          }
        }));
      else if (yr.push(...Z(Ro), V("div", {
        class: ["vxe-cell", {
          "c--title": ra,
          "c--tooltip": cl,
          "c--ellipsis": qa
        }],
        style: {
          maxHeight: sa && (Oo || so) ? `${Oo || so}px` : ""
        },
        title: ra ? t.getCellLabel(ae, Xe) : null
      }, Xe.renderCell(Ro))), Xr && ia) {
        const Un = ia.rule, Jo = ro ? ro.valid : null, Na = { ...Ro, ...ia };
        yr.push(V("div", {
          class: ["vxe-cell--valid-error-hint", vs(xn.className, Na)],
          style: Un && Un.maxWidth ? {
            width: `${Un.maxWidth}px`
          } : null
        }, Jo ? t.callSlot(Jo, Na) : [
          V("span", {
            class: "vxe-cell--valid-error-msg"
          }, ia.content)
        ]));
      }
      return V("td", {
        class: [
          "vxe-body--column",
          Xe.id,
          {
            [`col--${Ga}`]: Ga,
            [`col--${eo}`]: eo,
            "col--last": re === Te.length - 1,
            "col--tree-node": mo,
            "col--edit": No,
            "col--ellipsis": sa,
            "fixed--hidden": Oa,
            "col--dirty": Gr,
            "col--active": Je && No && Io.row === ae && (Io.column === Xe || kn.mode === "row"),
            "col--valid-error": !!ia,
            "col--current": an === Xe
          },
          vs(ft, Ro),
          vs(Tn, Ro),
          vs(me, Ro)
        ],
        key: Le || Qn.useKey ? Xe.id : re,
        ...Ml,
        style: Object.assign({
          height: sa && (Oo || so) ? `${Oo || so}px` : ""
        }, I.isFunction(At) ? At(Ro) : At, I.isFunction(Ke) ? Ke(Ro) : Ke),
        ...Ya
      }, yr);
    }, de = (je, Fe, Ve) => {
      const { stripe: Ze, rowKey: ae, highlightHoverRow: pe, rowClassName: ke, rowStyle: Ue, showOverflow: Xe, editConfig: re, treeConfig: Te } = l, { hasFixedColumn: Ce, treeExpandedMaps: Le, scrollYLoad: ge, rowExpandedMaps: Ee, expandColumn: me, selectRadioRow: Ke, pendingRowMaps: Re, pendingRowList: we } = r, { fullAllDataRowIdData: ze } = i, Je = _.value, Me = y.value, et = S.value, mt = m.value, Lt = N.value, { transform: be } = et, an = et.children || et.childrenField, _t = [];
      return Fe.forEach((zt, jt) => {
        const Sn = {};
        let hn = jt;
        hn = t.getRowIndex(zt), (Lt.isHover || pe) && (Sn.onMouseenter = (St) => {
          O() || t.triggerHoverEvent(St, { row: zt, rowIndex: hn });
        }, Sn.onMouseleave = () => {
          O() || t.clearHoverRow();
        });
        const xn = yt(t, zt), yn = ze[xn];
        let kn = 0, Wn = -1, Vn = 0;
        yn && (kn = yn.level, Wn = yn.seq, Vn = yn._index);
        const ho = { $table: t, seq: Wn, rowid: xn, fixed: je, type: cc, level: kn, row: zt, rowIndex: hn, $rowIndex: jt, _rowIndex: Vn }, Qn = me && !!Ee[xn];
        let eo = !1, So = [], st = !1;
        if (re && (st = t.isInsertByRow(zt)), Te && !ge && !be && (So = zt[an], eo = So && So.length && !!Le[xn]), _t.push(V("tr", {
          class: [
            "vxe-body--row",
            Te ? `row--level-${kn}` : "",
            {
              "row--stripe": Ze && (t.getVTRowIndex(zt) + 1) % 2 === 0,
              "is--new": st,
              "is--expand-row": Qn,
              "is--expand-tree": eo,
              "row--new": st && (mt.showStatus || mt.showInsertStatus),
              "row--radio": Me.highlight && t.eqRow(Ke, zt),
              "row--checked": Je.highlight && t.isCheckedByCheckboxRow(zt),
              "row--pending": we.length && !!Re[xn]
            },
            vs(ke, ho)
          ],
          rowid: xn,
          style: Ue ? I.isFunction(Ue) ? Ue(ho) : Ue : null,
          key: ae || Lt.useKey || Te ? xn : jt,
          ...Sn
        }, Ve.map((St, rn) => te(Wn, xn, je, kn, zt, hn, jt, Vn, St, rn, Ve, Fe)))), Qn) {
          const St = E.value, { height: rn } = St, Tn = {};
          rn && (Tn.height = `${rn}px`), Te && (Tn.paddingLeft = `${kn * et.indent + 30}px`);
          const { showOverflow: mo } = me, ro = I.isUndefined(mo) || I.isNull(mo) ? Xe : mo, Io = { $table: t, seq: Wn, column: me, fixed: je, type: cc, level: kn, row: zt, rowIndex: hn, $rowIndex: jt, _rowIndex: Vn };
          _t.push(V("tr", {
            class: "vxe-body--expanded-row",
            key: `expand_${xn}`,
            style: Ue ? I.isFunction(Ue) ? Ue(Io) : Ue : null,
            ...Sn
          }, [
            V("td", {
              class: {
                "vxe-body--expanded-column": 1,
                "fixed--hidden": je && !Ce,
                "col--ellipsis": ro
              },
              colspan: Ve.length
            }, [
              V("div", {
                class: {
                  "vxe-body--expanded-cell": 1,
                  "is--ellipsis": rn
                },
                style: Tn
              }, [
                me.renderData(Io)
              ])
            ])
          ]));
        }
        eo && _t.push(...de(je, So, Ve));
      }), _t;
    };
    let Oe;
    const ce = (je, Fe, Ve, Ze) => {
      (Ve || Ze) && (Ve && (E_(Ve), Ve.scrollTop = Fe), Ze && (E_(Ze), Ze.scrollTop = Fe), clearTimeout(Oe), Oe = setTimeout(() => {
        pv(Ve), pv(Ze), r.lastScrollTime = Date.now();
      }, 300));
    }, ne = (je) => {
      const { fixedType: Fe } = e, { highlightHoverRow: Ve } = l, { scrollXLoad: Ze, scrollYLoad: ae } = r, { elemStore: pe, lastScrollTop: ke, lastScrollLeft: Ue } = i, Xe = N.value, re = s.value, Te = u.value, Ce = d.value, Le = f.value, ge = v.value, Ee = h.value, me = R.value, Ke = re ? re.$el : null, Re = Ce ? Ce.$el : null, we = Te.$el, ze = Le ? Le.$el : null, Je = ge ? ge.$el : null, Me = pe["main-body-ySpace"], et = Me ? Me.value : null, mt = pe["main-body-xSpace"], Lt = mt ? mt.value : null, be = ae && et ? et.clientHeight : we.clientHeight, an = Ze && Lt ? Lt.clientWidth : we.clientWidth;
      let _t = me.scrollTop;
      const zt = we.scrollLeft, jt = zt !== Ue, Sn = _t !== ke;
      i.lastScrollTop = _t, i.lastScrollLeft = zt, r.lastScrollTime = Date.now(), (Xe.isHover || Ve) && t.clearHoverRow(), ze && Fe === "left" ? (_t = ze.scrollTop, ce(Fe, _t, we, Je)) : Je && Fe === "right" ? (_t = Je.scrollTop, ce(Fe, _t, we, ze)) : (jt && (Ke && (Ke.scrollLeft = we.scrollLeft), Re && (Re.scrollLeft = we.scrollLeft)), (ze || Je) && (t.checkScrolling(), Sn && ce(Fe, _t, ze, Je))), Ze && jt && t.triggerScrollXEvent(je), ae && Sn && t.triggerScrollYEvent(je), jt && Ee && Ee.reactData.visible && Ee.updatePlacement(), t.dispatchEvent("scroll", {
        type: cc,
        fixed: Fe,
        scrollTop: _t,
        scrollLeft: zt,
        scrollHeight: we.scrollHeight,
        scrollWidth: we.scrollWidth,
        bodyHeight: be,
        bodyWidth: an,
        isX: jt,
        isY: Sn
      }, je);
    };
    let Y, ve = 0, ie = 0, he = 0, De = !1;
    const $e = (je, Fe, Ve, Ze, ae) => {
      const { elemStore: pe } = i, { scrollXLoad: ke, scrollYLoad: Ue } = r, Xe = u.value, re = f.value, Te = v.value, Ce = re ? re.$el : null, Le = Te ? Te.$el : null, ge = Xe.$el, Ee = pe["main-body-ySpace"], me = Ee ? Ee.value : null, Ke = pe["main-body-xSpace"], Re = Ke ? Ke.value : null, we = Ue && me ? me.clientHeight : ge.clientHeight, ze = ke && Re ? Re.clientWidth : ge.clientWidth, Je = De === Fe ? Math.max(0, ve - he) : 0;
      De = Fe, ve = Math.abs(Fe ? Ve - Je : Ve + Je), ie = 0, he = 0, clearTimeout(Y);
      const Me = () => {
        if (he < ve) {
          const { fixedType: et } = e;
          ie = Math.max(5, Math.floor(ie * 1.5)), he = he + ie, he > ve && (ie = ie - (he - ve));
          const { scrollTop: mt, clientHeight: Lt, scrollHeight: be } = ge, an = mt + ie * (Fe ? -1 : 1);
          ge.scrollTop = an, Ce && (Ce.scrollTop = an), Le && (Le.scrollTop = an), (Fe ? an < be - Lt : an >= 0) && (Y = setTimeout(Me, 10)), t.dispatchEvent("scroll", {
            type: cc,
            fixed: et,
            scrollTop: ge.scrollTop,
            scrollLeft: ge.scrollLeft,
            scrollHeight: ge.scrollHeight,
            scrollWidth: ge.scrollWidth,
            bodyHeight: we,
            bodyWidth: ze,
            isX: Ze,
            isY: ae
          }, je);
        }
      };
      Me();
    }, ue = (je) => {
      const { deltaY: Fe, deltaX: Ve } = je, { highlightHoverRow: Ze } = l, { scrollYLoad: ae } = r, { lastScrollTop: pe, lastScrollLeft: ke } = i, Ue = N.value, Xe = u.value, re = R.value, Te = Xe.$el, Ce = Fe, Le = Ve, ge = Ce < 0;
      if (ge ? re.scrollTop <= 0 : re.scrollTop >= re.scrollHeight - re.clientHeight)
        return;
      const Ee = re.scrollTop + Ce, me = Te.scrollLeft + Le, Ke = me !== ke, Re = Ee !== pe;
      Re && (je.preventDefault(), i.lastScrollTop = Ee, i.lastScrollLeft = me, r.lastScrollTime = Date.now(), (Ue.isHover || Ze) && t.clearHoverRow(), $e(je, ge, Ce, Ke, Re), ae && t.triggerScrollYEvent(je));
    };
    return Nt(() => {
      xe(() => {
        const { fixedType: je } = e, { elemStore: Fe } = i, Ve = `${je || "main"}-body-`, Ze = R.value;
        Fe[`${Ve}wrapper`] = R, Fe[`${Ve}table`] = H, Fe[`${Ve}colgroup`] = K, Fe[`${Ve}list`] = U, Fe[`${Ve}xSpace`] = W, Fe[`${Ve}ySpace`] = A, Fe[`${Ve}emptyBlock`] = $, Ze && (Ze.onscroll = ne, Ze._onscroll = ne);
      });
    }), zn(() => {
      const je = R.value;
      clearTimeout(Y), je && (je._onscroll = null, je.onscroll = null);
    }), wo(() => {
      const { fixedType: je } = e, { elemStore: Fe } = i, Ve = `${je || "main"}-body-`;
      Fe[`${Ve}wrapper`] = null, Fe[`${Ve}table`] = null, Fe[`${Ve}colgroup`] = null, Fe[`${Ve}list`] = null, Fe[`${Ve}xSpace`] = null, Fe[`${Ve}ySpace`] = null, Fe[`${Ve}emptyBlock`] = null;
    }), () => {
      let { fixedColumn: je, fixedType: Fe, tableColumn: Ve } = e;
      const { keyboardConfig: Ze, showOverflow: ae, spanMethod: pe, mouseConfig: ke } = l, { tableData: Ue, mergeList: Xe, scrollYLoad: re, isAllOverflow: Te } = r, { visibleColumn: Ce } = i, { slots: Le } = a, ge = C.value, Ee = g.value, me = w.value, Ke = p.value;
      Fe && (!r.expandColumn && (re || ae && Te) && !Xe.length && !pe && !(Ze && me.isMerge) ? Ve = je : Ve = Ce);
      let Re;
      const we = Le ? Le.empty : null;
      if (we)
        Re = t.callSlot(we, { $table: t, $grid: t.xegrid });
      else {
        const ze = Ee.name ? $t.renderer.get(Ee.name) : null, Je = ze ? ze.renderEmpty : null;
        Je ? Re = oo(Je(Ee, { $table: t })) : Re = l.emptyText || ee.i18n("vxe.table.emptyText");
      }
      return V("div", {
        ref: R,
        class: ["vxe-table--body-wrapper", Fe ? `fixed-${Fe}--wrapper` : "body--wrapper"],
        xid: o,
        ...ge.mode === "wheel" ? { onWheel: ue } : {}
      }, [
        Fe ? _e() : V("div", {
          ref: W,
          class: "vxe-body--x-space"
        }),
        V("div", {
          ref: A,
          class: "vxe-body--y-space"
        }),
        V("table", {
          ref: H,
          class: "vxe-table--body",
          xid: o,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          /**
           * 列宽
           */
          V("colgroup", {
            ref: K
          }, Ve.map((ze, Je) => V("col", {
            name: ze.id,
            key: Je
          }))),
          /**
           * 内容
           */
          V("tbody", {
            ref: U
          }, de(Fe, Ue, Ve))
        ]),
        V("div", {
          class: "vxe-table--checkbox-range"
        }),
        ke && Ke.area ? V("div", {
          class: "vxe-table--cell-area"
        }, [
          V("span", {
            class: "vxe-table--cell-main-area"
          }, Ke.extension ? [
            V("span", {
              class: "vxe-table--cell-main-area-btn",
              onMousedown(ze) {
                t.triggerCellExtendMousedownEvent(ze, { $table: t, fixed: Fe, type: cc });
              }
            })
          ] : []),
          V("span", {
            class: "vxe-table--cell-copy-area"
          }),
          V("span", {
            class: "vxe-table--cell-extend-area"
          }),
          V("span", {
            class: "vxe-table--cell-multi-area"
          }),
          V("span", {
            class: "vxe-table--cell-active-area"
          })
        ]) : null,
        Fe ? null : V("div", {
          class: "vxe-table--empty-block",
          ref: $
        }, [
          V("div", {
            class: "vxe-table--empty-content"
          }, Re)
        ])
      ]);
    };
  }
}), zm = "header", Y_ = Q({
  name: "VxeTableHeader",
  props: {
    tableData: Array,
    tableColumn: Array,
    tableGroupColumn: Array,
    fixedColumn: Array,
    fixedType: { type: String, default: null }
  },
  setup(e) {
    const t = ot("$xetable", {}), { xID: n, props: o, reactData: l, internalData: a } = t, { refElem: r, refTableBody: i, refLeftContainer: s, refRightContainer: u, refCellResizeBar: d } = t.getRefMaps(), { computeColumnOpts: f } = t.getComputeMaps(), v = B([]), h = B(), m = B(), p = B(), C = B(), g = B(), w = B(), b = () => {
      const { isGroup: S } = l;
      v.value = S ? qCe(e.tableGroupColumn) : [];
    }, y = (S, _) => {
      const { column: k } = _, { fixedType: N } = e, L = i.value, R = s.value, H = u.value, K = d.value, { clientX: U } = S, W = h.value, A = S.target, $ = _.cell = A.parentNode;
      let D = 0;
      const O = L.$el, F = UCe(A, W), j = A.clientWidth, Z = Math.floor(j / 2), te = GCe(_) - Z;
      let de = F.left - $.clientWidth + j + te, Oe = F.left + Z;
      const ce = document.onmousemove, ne = document.onmouseup, Y = N === "left", ve = N === "right", ie = r.value;
      let he = 0;
      if (Y || ve) {
        const $e = Y ? "nextElementSibling" : "previousElementSibling";
        let ue = $[$e];
        for (; ue && !Ar(ue, "fixed--hidden"); )
          Ar(ue, "col--group") || (he += ue.offsetWidth), ue = ue[$e];
        ve && H && (Oe = H.offsetLeft + he);
      }
      const De = function($e) {
        $e.stopPropagation(), $e.preventDefault();
        const ue = $e.clientX - U;
        let Ne = Oe + ue;
        const je = N ? 0 : O.scrollLeft;
        Y ? Ne = Math.min(Ne, (H ? H.offsetLeft : O.clientWidth) - he - te) : ve ? (de = (R ? R.clientWidth : 0) + he + te, Ne = Math.min(Ne, Oe + $.clientWidth - te)) : de = Math.max(O.scrollLeft, de), D = Math.max(Ne, de), K.style.left = `${D - je}px`;
      };
      l._isResize = !0, Mr(ie, "drag--resize"), K.style.display = "block", document.onmousemove = De, document.onmouseup = function($e) {
        document.onmousemove = ce, document.onmouseup = ne;
        const ue = k.renderWidth + (ve ? Oe - D : D - Oe);
        k.resizeWidth = ue, K.style.display = "none", l._isResize = !1, a._lastResizeTime = Date.now(), t.analyColumnWidth(), t.recalculate(!0).then(() => {
          t.saveCustomResizable(), t.updateCellAreas(), t.dispatchEvent("resizable-change", { ..._, resizeWidth: ue }, $e);
        }), Xl(ie, "drag--resize");
      }, De(S), t.closeMenu && t.closeMenu();
    };
    return Pe(() => e.tableColumn, b), Nt(() => {
      xe(() => {
        const { fixedType: S } = e, { internalData: _ } = t, { elemStore: k } = _, N = `${S || "main"}-header-`;
        k[`${N}wrapper`] = h, k[`${N}table`] = m, k[`${N}colgroup`] = p, k[`${N}list`] = C, k[`${N}xSpace`] = g, k[`${N}repair`] = w, b();
      });
    }), wo(() => {
      const { fixedType: S } = e, { internalData: _ } = t, { elemStore: k } = _, N = `${S || "main"}-header-`;
      k[`${N}wrapper`] = null, k[`${N}table`] = null, k[`${N}colgroup`] = null, k[`${N}list`] = null, k[`${N}xSpace`] = null, k[`${N}repair`] = null;
    }), () => {
      const { fixedType: S, fixedColumn: _, tableColumn: k } = e, { resizable: N, border: L, columnKey: R, headerRowClassName: H, headerCellClassName: K, headerRowStyle: U, headerCellStyle: W, showHeaderOverflow: A, headerAlign: $, align: D, mouseConfig: O } = o, { isGroup: F, currentColumn: j, scrollXLoad: Z, overflowX: te, scrollbarWidth: de } = l, { visibleColumn: Oe } = a, ce = f.value;
      let ne = v.value, Y = k;
      return F ? Y = Oe : (S && (Z || A) && (Y = _), ne = [Y]), V("div", {
        ref: h,
        class: ["vxe-table--header-wrapper", S ? `fixed-${S}--wrapper` : "body--wrapper"],
        xid: n
      }, [
        S ? _e() : V("div", {
          ref: g,
          class: "vxe-body--x-space"
        }),
        V("table", {
          ref: m,
          class: "vxe-table--header",
          xid: n,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          /**
           * 列宽
           */
          V("colgroup", {
            ref: p
          }, Y.map((ve, ie) => V("col", {
            name: ve.id,
            key: ie
          })).concat(de ? [
            V("col", {
              name: "col_gutter"
            })
          ] : [])),
          /**
           * 头部
           */
          V("thead", {
            ref: C
          }, ne.map((ve, ie) => V("tr", {
            class: ["vxe-header--row", H ? I.isFunction(H) ? H({ $table: t, $rowIndex: ie, fixed: S, type: zm }) : H : ""],
            style: U ? I.isFunction(U) ? U({ $table: t, $rowIndex: ie, fixed: S, type: zm }) : U : null
          }, ve.map((he, De) => {
            const { type: $e, showHeaderOverflow: ue, headerAlign: Ne, align: je, headerClassName: Fe } = he, Ve = he.children && he.children.length, Ze = S ? he.fixed !== S && !Ve : !!he.fixed && te, ae = I.isUndefined(ue) || I.isNull(ue) ? A : ue, pe = Ne || je || $ || D;
            let ke = ae === "ellipsis";
            const Ue = ae === "title", Xe = ae === !0 || ae === "tooltip";
            let re = Ue || Xe || ke;
            const Te = he.filters && he.filters.some((me) => me.checked), Ce = t.getColumnIndex(he), Le = t.getVTColumnIndex(he), ge = { $table: t, $grid: t.xegrid, $rowIndex: ie, column: he, columnIndex: Ce, $columnIndex: De, _columnIndex: Le, fixed: S, type: zm, isHidden: Ze, hasFilter: Te }, Ee = {
              onClick: (me) => t.triggerHeaderCellClickEvent(me, ge),
              onDblclick: (me) => t.triggerHeaderCellDblclickEvent(me, ge)
            };
            return Z && !re && (ke = re = !0), O && (Ee.onMousedown = (me) => t.triggerHeaderCellMousedownEvent(me, ge)), V("th", {
              class: [
                "vxe-header--column",
                he.id,
                {
                  [`col--${pe}`]: pe,
                  [`col--${$e}`]: $e,
                  "col--last": De === ve.length - 1,
                  "col--fixed": he.fixed,
                  "col--group": Ve,
                  "col--ellipsis": re,
                  "fixed--hidden": Ze,
                  "is--sortable": he.sortable,
                  "col--filter": !!he.filters,
                  "is--filter-active": Te,
                  "col--current": j === he
                },
                Fe ? I.isFunction(Fe) ? Fe(ge) : Fe : "",
                K ? I.isFunction(K) ? K(ge) : K : ""
              ],
              colid: he.id,
              colspan: he.colSpan > 1 ? he.colSpan : null,
              rowspan: he.rowSpan > 1 ? he.rowSpan : null,
              style: W ? I.isFunction(W) ? W(ge) : W : null,
              ...Ee,
              key: R || ce.useKey || Ve ? he.id : De
            }, [
              V("div", {
                class: ["vxe-cell", {
                  "c--title": Ue,
                  "c--tooltip": Xe,
                  "c--ellipsis": ke
                }]
              }, he.renderHeader(ge)),
              /**
               * 列宽拖动
               */
              !Ze && !Ve && (I.isBoolean(he.resizable) ? he.resizable : ce.resizable || N) ? V("div", {
                class: ["vxe-resizable", {
                  "is--line": !L || L === "none"
                }],
                onMousedown: (me) => y(me, ge)
              }) : null
            ]);
          }).concat(de ? [
            V("th", {
              class: "vxe-header--gutter col--gutter"
            })
          ] : []))))
        ]),
        /**
         * 其他
         */
        V("div", {
          ref: w,
          class: "vxe-table--header-border-line"
        })
      ]);
    };
  }
}), Wm = "footer";
function lEe(e, t, n) {
  for (let o = 0; o < e.length; o++) {
    const { row: l, col: a, rowspan: r, colspan: i } = e[o];
    if (a > -1 && l > -1 && r && i) {
      if (l === t && a === n)
        return { rowspan: r, colspan: i };
      if (t >= l && t < l + r && n >= a && n < a + i)
        return { rowspan: 0, colspan: 0 };
    }
  }
}
const G_ = Q({
  name: "VxeTableFooter",
  props: {
    footerTableData: { type: Array, default: () => [] },
    tableColumn: { type: Array, default: () => [] },
    fixedColumn: { type: Array, default: () => [] },
    fixedType: { type: String, default: null }
  },
  setup(e) {
    const t = ot("$xetable", {}), { xID: n, props: o, reactData: l, internalData: a } = t, { refTableHeader: r, refTableBody: i, refValidTooltip: s } = t.getRefMaps(), { computeTooltipOpts: u, computeColumnOpts: d } = t.getComputeMaps(), f = B(), v = B(), h = B(), m = B(), p = B(), C = (w) => {
      const { fixedType: b } = e, { scrollXLoad: y } = l, { lastScrollLeft: E } = a, S = s.value, _ = r.value, k = i.value, N = _ ? _.$el : null, L = f.value, R = k.$el, H = L.scrollLeft, K = H !== E;
      a.lastScrollLeft = H, l.lastScrollTime = Date.now(), N && (N.scrollLeft = H), R && (R.scrollLeft = H), y && K && t.triggerScrollXEvent(w), K && S && S.reactData.visible && S.updatePlacement(), t.dispatchEvent("scroll", { type: Wm, fixed: b, scrollTop: R.scrollTop, scrollLeft: H, isX: K, isY: !1 }, w);
    };
    return Nt(() => {
      xe(() => {
        const { fixedType: w } = e, { elemStore: b } = a, y = `${w || "main"}-footer-`;
        b[`${y}wrapper`] = f, b[`${y}table`] = v, b[`${y}colgroup`] = h, b[`${y}list`] = m, b[`${y}xSpace`] = p;
      });
    }), wo(() => {
      const { fixedType: w } = e, { elemStore: b } = a, y = `${w || "main"}-footer-`;
      b[`${y}wrapper`] = null, b[`${y}table`] = null, b[`${y}colgroup`] = null, b[`${y}list`] = null, b[`${y}xSpace`] = null;
    }), () => {
      let { fixedType: w, fixedColumn: b, tableColumn: y, footerTableData: E } = e;
      const { footerRowClassName: S, footerCellClassName: _, footerRowStyle: k, footerCellStyle: N, footerAlign: L, footerSpanMethod: R, align: H, columnKey: K, showFooterOverflow: U } = o, { visibleColumn: W } = a, { scrollXLoad: A, overflowX: $, scrollbarWidth: D, currentColumn: O, mergeFooterList: F } = l, j = u.value, Z = d.value;
      return w && (!l.expandColumn && (A || U) && (!F.length || !R) ? y = b : y = W), V("div", {
        ref: f,
        class: ["vxe-table--footer-wrapper", w ? `fixed-${w}--wrapper` : "body--wrapper"],
        xid: n,
        onScroll: C
      }, [
        w ? _e() : V("div", {
          ref: p,
          class: "vxe-body--x-space"
        }),
        V("table", {
          ref: v,
          class: "vxe-table--footer",
          xid: n,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          /**
           * 列宽
           */
          V("colgroup", {
            ref: h
          }, y.map((te, de) => V("col", {
            name: te.id,
            key: de
          })).concat(D ? [
            V("col", {
              name: "col_gutter"
            })
          ] : [])),
          /**
           * 底部
           */
          V("tfoot", {
            ref: m
          }, E.map((te, de) => {
            const Oe = de, ce = { $table: t, row: te, _rowIndex: de, $rowIndex: Oe, fixed: w, type: Wm };
            return V("tr", {
              class: ["vxe-footer--row", S ? I.isFunction(S) ? S(ce) : S : ""],
              style: k ? I.isFunction(k) ? k(ce) : k : null
            }, y.map((ne, Y) => {
              const { type: ve, showFooterOverflow: ie, footerAlign: he, align: De, footerClassName: $e } = ne, ue = j.showAll, Ne = ne.children && ne.children.length, je = w ? ne.fixed !== w && !Ne : ne.fixed && $, Fe = I.isUndefined(ie) || I.isNull(ie) ? U : ie, Ve = he || De || L || H;
              let Ze = Fe === "ellipsis";
              const ae = Fe === "title", pe = Fe === !0 || Fe === "tooltip";
              let ke = ae || pe || Ze;
              const Ue = { colid: ne.id }, Xe = {}, re = t.getColumnIndex(ne), Te = t.getVTColumnIndex(ne), Ce = Te, Le = {
                $table: t,
                $grid: t.xegrid,
                row: te,
                _rowIndex: de,
                $rowIndex: Oe,
                column: ne,
                columnIndex: re,
                $columnIndex: Y,
                _columnIndex: Te,
                itemIndex: Ce,
                items: te,
                fixed: w,
                type: Wm,
                data: E
              };
              if (A && !ke && (Ze = ke = !0), (ae || pe || ue) && (Xe.onMouseenter = (ge) => {
                ae ? J0(ge.currentTarget, ne) : (pe || ue) && t.triggerFooterTooltipEvent(ge, Le);
              }), (pe || ue) && (Xe.onMouseleave = (ge) => {
                (pe || ue) && t.handleTargetLeaveEvent(ge);
              }), Xe.onClick = (ge) => {
                t.dispatchEvent("footer-cell-click", Object.assign({ cell: ge.currentTarget }, Le), ge);
              }, Xe.onDblclick = (ge) => {
                t.dispatchEvent("footer-cell-dblclick", Object.assign({ cell: ge.currentTarget }, Le), ge);
              }, F.length) {
                const ge = lEe(F, de, Te);
                if (ge) {
                  const { rowspan: Ee, colspan: me } = ge;
                  if (!Ee || !me)
                    return null;
                  Ee > 1 && (Ue.rowspan = Ee), me > 1 && (Ue.colspan = me);
                }
              } else if (R) {
                const { rowspan: ge = 1, colspan: Ee = 1 } = R(Le) || {};
                if (!ge || !Ee)
                  return null;
                ge > 1 && (Ue.rowspan = ge), Ee > 1 && (Ue.colspan = Ee);
              }
              return V("td", {
                class: ["vxe-footer--column", ne.id, {
                  [`col--${Ve}`]: Ve,
                  [`col--${ve}`]: ve,
                  "col--last": Y === y.length - 1,
                  "fixed--hidden": je,
                  "col--ellipsis": ke,
                  "col--current": O === ne
                }, vs($e, Le), vs(_, Le)],
                ...Ue,
                style: N ? I.isFunction(N) ? N(Le) : N : null,
                ...Xe,
                key: K || Z.useKey ? ne.id : Y
              }, [
                V("div", {
                  class: ["vxe-cell", {
                    "c--title": ae,
                    "c--tooltip": pe,
                    "c--ellipsis": Ze
                  }]
                }, ne.renderFooter(Le))
              ]);
            }).concat(D ? [
              V("td", {
                class: "vxe-footer--gutter col--gutter"
              })
            ] : []));
          }))
        ])
      ]);
    };
  }
}), g1 = {
  /** 基本属性 */
  id: String,
  // 数据
  data: Array,
  // 表格的高度
  height: [Number, String],
  // 表格的最小高度
  minHeight: { type: [Number, String], default: () => ee.table.minHeight },
  // 表格的最大高度
  maxHeight: [Number, String],
  // 已废弃，被 column-config.resizable 替换
  resizable: { type: Boolean, default: () => ee.table.resizable },
  // 是否带有斑马纹
  stripe: { type: Boolean, default: () => ee.table.stripe },
  // 是否带有边框
  border: { type: [Boolean, String], default: () => ee.table.border },
  // 是否圆角边框
  round: { type: Boolean, default: () => ee.table.round },
  // 表格的尺寸
  size: { type: String, default: () => ee.table.size || ee.size },
  // 列的宽度是否自撑开（可能会被废弃的参数，不要使用）
  fit: { type: Boolean, default: () => ee.table.fit },
  // 表格是否加载中
  loading: Boolean,
  // 所有的列对其方式
  align: { type: String, default: () => ee.table.align },
  // 所有的表头列的对齐方式
  headerAlign: { type: String, default: () => ee.table.headerAlign },
  // 所有的表尾列的对齐方式
  footerAlign: { type: String, default: () => ee.table.footerAlign },
  // 是否显示表头
  showHeader: { type: Boolean, default: () => ee.table.showHeader },
  // （即将废弃）是否要高亮当前选中行
  highlightCurrentRow: { type: Boolean, default: () => ee.table.highlightCurrentRow },
  // （即将废弃）鼠标移到行是否要高亮显示
  highlightHoverRow: { type: Boolean, default: () => ee.table.highlightHoverRow },
  // （即将废弃）是否要高亮当前选中列
  highlightCurrentColumn: { type: Boolean, default: () => ee.table.highlightCurrentColumn },
  // （即将废弃）鼠标移到列是否要高亮显示
  highlightHoverColumn: { type: Boolean, default: () => ee.table.highlightHoverColumn },
  // （即将废弃）激活单元格编辑时是否高亮显示
  highlightCell: Boolean,
  // 是否显示表尾合计
  showFooter: Boolean,
  // 表尾数据
  footerData: Array,
  // 表尾合计的计算方法
  footerMethod: Function,
  // 给行附加 className
  rowClassName: [String, Function],
  // 给单元格附加 className
  cellClassName: [String, Function],
  // 给表头的行附加 className
  headerRowClassName: [String, Function],
  // 给表头的单元格附加 className
  headerCellClassName: [String, Function],
  // 给表尾的行附加 className
  footerRowClassName: [String, Function],
  // 给表尾的单元格附加 className
  footerCellClassName: [String, Function],
  // 给单元格附加样式
  cellStyle: [Object, Function],
  // 给表头单元格附加样式
  headerCellStyle: [Object, Function],
  // 给表尾单元格附加样式
  footerCellStyle: [Object, Function],
  // 给行附加样式
  rowStyle: [Object, Function],
  // 给表头行附加样式
  headerRowStyle: [Object, Function],
  // 给表尾行附加样式
  footerRowStyle: [Object, Function],
  // 合并指定单元格
  mergeCells: Array,
  // 合并指定的表尾
  mergeFooterItems: Array,
  // 自定义合并行或列的方法
  spanMethod: Function,
  // 表尾合并行或列
  footerSpanMethod: Function,
  // 设置所有内容过长时显示为省略号
  showOverflow: { type: [Boolean, String], default: () => ee.table.showOverflow },
  // 设置表头所有内容过长时显示为省略号
  showHeaderOverflow: { type: [Boolean, String], default: () => ee.table.showHeaderOverflow },
  // 设置表尾所有内容过长时显示为省略号
  showFooterOverflow: { type: [Boolean, String], default: () => ee.table.showFooterOverflow },
  /** 高级属性 */
  // （即将废弃）columnKey 已废弃，被 column-config.useKey 替换
  columnKey: Boolean,
  // （即将废弃）rowKey 已废弃，被 row-config.useKey 替换
  rowKey: Boolean,
  // （即将废弃）rowId 已废弃，被 row-config.keyField 替换
  rowId: { type: String, default: () => ee.table.rowId },
  zIndex: Number,
  emptyText: { type: String, default: () => ee.table.emptyText },
  keepSource: { type: Boolean, default: () => ee.table.keepSource },
  // 是否自动监听父容器变化去更新响应式表格宽高
  autoResize: { type: Boolean, default: () => ee.table.autoResize },
  // 是否自动根据状态属性去更新响应式表格宽高
  syncResize: [Boolean, String, Number],
  // 响应式布局配置项
  resizeConfig: Object,
  // 列配置信息
  columnConfig: Object,
  // 行配置信息
  rowConfig: Object,
  // 列调整配置项
  resizableConfig: Object,
  // 序号配置项
  seqConfig: Object,
  // 排序配置项
  sortConfig: Object,
  // 筛选配置项
  filterConfig: Object,
  // 单选框配置
  radioConfig: Object,
  // 复选框配置项
  checkboxConfig: Object,
  // tooltip 配置项
  tooltipConfig: Object,
  // 导出配置项
  exportConfig: Object,
  // 导入配置项
  importConfig: Object,
  // 打印配置项
  printConfig: Object,
  // 展开行配置项
  expandConfig: Object,
  // 树形结构配置项
  treeConfig: Object,
  // 快捷菜单配置项
  menuConfig: Object,
  // 鼠标配置项
  mouseConfig: Object,
  // 区域配置项
  areaConfig: Object,
  // 按键配置项
  keyboardConfig: Object,
  // 复制粘/贴配置项
  clipConfig: Object,
  // 查找/替换配置项
  fnrConfig: Object,
  // 编辑配置项
  editConfig: Object,
  // 校验配置项
  validConfig: Object,
  // 校验规则配置项
  editRules: Object,
  // 加载中配置项
  loadingConfig: Object,
  // 空内容渲染配置项
  emptyRender: Object,
  // 自定义列配置项
  customConfig: Object,
  // 横向虚拟滚动配置项
  scrollX: Object,
  // 纵向虚拟滚动配置项
  scrollY: Object,
  // （即将废弃）优化相关
  animat: { type: Boolean, default: () => ee.table.animat },
  // （可能会被废弃的参数，不要使用）
  delayHover: { type: Number, default: () => ee.table.delayHover },
  // 额外的参数
  params: Object
}, b1 = [
  "update:data",
  "keydown-start",
  "keydown",
  "keydown-end",
  "paste",
  "copy",
  "cut",
  "current-change",
  "radio-change",
  "checkbox-change",
  "checkbox-all",
  "checkbox-range-start",
  "checkbox-range-change",
  "checkbox-range-end",
  "checkbox-range-select",
  "cell-click",
  "cell-dblclick",
  "cell-menu",
  "cell-mouseenter",
  "cell-mouseleave",
  "cell-selected",
  "header-cell-click",
  "header-cell-dblclick",
  "header-cell-menu",
  "footer-cell-click",
  "footer-cell-dblclick",
  "footer-cell-menu",
  "clear-merge",
  "sort-change",
  "clear-sort",
  "filter-change",
  "filter-visible",
  "clear-filter",
  "resizable-change",
  "toggle-row-expand",
  "toggle-tree-expand",
  "menu-click",
  "edit-closed",
  "edit-actived",
  "edit-activated",
  "edit-disabled",
  "valid-error",
  "scroll",
  "custom",
  "change-fnr",
  "open-fnr",
  "show-fnr",
  "hide-fnr",
  "fnr-change",
  "fnr-find",
  "fnr-find-all",
  "fnr-replace",
  "fnr-replace-all",
  "cell-area-copy",
  "cell-area-cut",
  "cell-area-paste",
  "cell-area-merge",
  "clear-cell-area-merge",
  "header-cell-area-selection",
  "cell-area-selection-invalid",
  "cell-area-selection-start",
  "cell-area-selection-drag",
  "cell-area-selection-end",
  "cell-area-extension-start",
  "cell-area-extension-drag",
  "cell-area-extension-end",
  "cell-area-selection-all-start",
  "cell-area-selection-all-end",
  "cell-area-arrows-start",
  "cell-area-arrows-end",
  "active-cell-change-start",
  "active-cell-change-end"
], aEe = Jl["-webkit"] && !Jl.edge, Km = "VXE_TABLE_CUSTOM_COLUMN_WIDTH", Um = "VXE_TABLE_CUSTOM_COLUMN_VISIBLE", jm = "VXE_TABLE_CUSTOM_COLUMN_FIXED", qm = "VXE_TABLE_CUSTOM_COLUMN_SORT", id = Q({
  name: "VxeTable",
  props: g1,
  emits: b1,
  setup(e, t) {
    const { slots: n, emit: o } = t, l = $t.tooltip, a = I.uniqueId(), r = Po(e), i = Pt(), s = en({
      // 低性能的静态列
      staticColumns: [],
      // 渲染的列分组
      tableGroupColumn: [],
      // 可视区渲染的列
      tableColumn: [],
      // 渲染中的数据
      tableData: [],
      // 是否启用了横向 X 可视渲染方式加载
      scrollXLoad: !1,
      // 是否启用了纵向 Y 可视渲染方式加载
      scrollYLoad: !1,
      // 是否存在纵向滚动条
      overflowY: !0,
      // 是否存在横向滚动条
      overflowX: !1,
      // 纵向滚动条的宽度
      scrollbarWidth: 0,
      // 横向滚动条的高度
      scrollbarHeight: 0,
      // 最后滚动时间戳
      lastScrollTime: 0,
      // 行高
      rowHeight: 0,
      // 表格父容器的高度
      parentHeight: 0,
      // 是否使用分组表头
      isGroup: !1,
      isAllOverflow: !1,
      // 复选框属性，是否全选
      isAllSelected: !1,
      // 复选框属性，有选中且非全选状态
      isIndeterminate: !1,
      // 复选框属性，已选中的行集合
      selectCheckboxMaps: {},
      // 当前行
      currentRow: null,
      // 单选框属性，选中列
      currentColumn: null,
      // 单选框属性，选中行
      selectRadioRow: null,
      // 表尾合计数据
      footerTableData: [],
      // 展开列信息
      expandColumn: null,
      // 树节点列信息
      treeNodeColumn: null,
      hasFixedColumn: !1,
      // 已展开的行集合
      rowExpandedMaps: {},
      // 懒加载中的展开行的集合
      rowExpandLazyLoadedMaps: {},
      // 已展开树节点集合
      treeExpandedMaps: {},
      // 懒加载中的树节点的集合
      treeExpandLazyLoadedMaps: {},
      // 树节点不确定状态的集合
      treeIndeterminateMaps: {},
      // 合并单元格的对象集
      mergeList: [],
      // 合并表尾数据的对象集
      mergeFooterList: [],
      // 刷新列标识，当列筛选被改变时，触发表格刷新数据
      upDataFlag: 0,
      // 刷新列标识，当列的特定属性被改变时，触发表格刷新列
      reColumnFlag: 0,
      // 已标记的对象集
      pendingRowMaps: {},
      // 已标记的行
      pendingRowList: [],
      // 初始化标识
      initStore: {
        filter: !1,
        import: !1,
        export: !1,
        custom: !1
      },
      // 自定义列相关的信息
      customStore: {
        btnEl: null,
        isAll: !1,
        isIndeterminate: !1,
        activeBtn: !1,
        activeWrapper: !1,
        visible: !1,
        maxHeight: 0
      },
      customColumnList: [],
      // 当前选中的筛选列
      filterStore: {
        isAllSelected: !1,
        isIndeterminate: !1,
        style: null,
        options: [],
        column: null,
        multiple: !1,
        visible: !1,
        maxHeight: null
      },
      // 存放列相关的信息
      columnStore: {
        leftList: [],
        centerList: [],
        rightList: [],
        resizeList: [],
        pxList: [],
        pxMinList: [],
        scaleList: [],
        scaleMinList: [],
        autoList: []
      },
      // 存放快捷菜单的信息
      ctxMenuStore: {
        selected: null,
        visible: !1,
        showChild: !1,
        selectChild: null,
        list: [],
        style: null
      },
      // 存放可编辑相关信息
      editStore: {
        indexs: {
          columns: []
        },
        titles: {
          columns: []
        },
        // 选中源
        selected: {
          row: null,
          column: null
        },
        // 已复制源
        copyed: {
          cut: !1,
          rows: [],
          columns: []
        },
        // 激活
        actived: {
          row: null,
          column: null
        },
        // 当前被强制聚焦单元格，只会在鼠标点击后算聚焦
        focused: {
          row: null,
          column: null
        },
        insertMaps: {},
        removeMaps: {}
      },
      // 存放 tooltip 相关信息
      tooltipStore: {
        row: null,
        column: null,
        content: null,
        visible: !1
      },
      // 存放数据校验相关信息
      validStore: {
        visible: !1
      },
      validErrorMaps: {},
      // 导入相关信息
      importStore: {
        inited: !1,
        file: null,
        type: "",
        modeList: [],
        typeList: [],
        filename: "",
        visible: !1
      },
      importParams: {
        mode: "",
        types: null,
        message: !0
      },
      // 导出相关信息
      exportStore: {
        inited: !1,
        name: "",
        modeList: [],
        typeList: [],
        columns: [],
        isPrint: !1,
        hasFooter: !1,
        hasMerge: !1,
        hasTree: !1,
        hasColgroup: !1,
        visible: !1
      },
      exportParams: {
        filename: "",
        sheetName: "",
        mode: "",
        type: "",
        isColgroup: !1,
        isMerge: !1,
        isAllExpand: !1,
        useStyle: !1,
        original: !1,
        message: !0,
        isHeader: !1,
        isFooter: !1
      },
      scrollVMLoading: !1,
      _isResize: !1
    }), u = {
      tZindex: 0,
      elemStore: {},
      // 存放横向 X 虚拟滚动相关的信息
      scrollXStore: {
        offsetSize: 0,
        visibleSize: 0,
        startIndex: 0,
        endIndex: 0
      },
      // 存放纵向 Y 虚拟滚动相关信息
      scrollYStore: {
        rowHeight: 0,
        offsetSize: 0,
        visibleSize: 0,
        startIndex: 0,
        endIndex: 0
      },
      // 表格宽度
      tableWidth: 0,
      // 表格高度
      tableHeight: 0,
      // 表头高度
      headerHeight: 0,
      // 表尾高度
      footerHeight: 0,
      customHeight: 0,
      customMinHeight: 0,
      customMaxHeight: 0,
      // 当前 hover 行
      hoverRow: null,
      // 最后滚动位置
      lastScrollLeft: 0,
      lastScrollTop: 0,
      // 单选框属性，已选中保留的行
      radioReserveRow: null,
      // 复选框属性，已选中保留的行集合
      checkboxReserveRowMap: {},
      // 行数据，已展开保留的行集合
      rowExpandedReserveRowMap: {},
      // 树结构数据，已展开保留的行集合
      treeExpandedReserveRowMap: {},
      // 树结构数据，不确定状态的集合
      treeIndeterminateRowMaps: {},
      // 列表完整数据、条件处理后
      tableFullData: [],
      afterFullData: [],
      afterTreeFullData: [],
      // 列表条件处理后数据集合
      afterFullRowMaps: {},
      // 树结构完整数据、条件处理后
      tableFullTreeData: [],
      tableSynchData: [],
      tableSourceData: [],
      // 收集的列配置（带分组）
      collectColumn: [],
      // 完整所有列（不带分组）
      tableFullColumn: [],
      // 渲染所有列
      visibleColumn: [],
      // 总的缓存数据集
      fullAllDataRowIdData: {},
      // 渲染中缓存数据
      sourceDataRowIdData: {},
      fullDataRowIdData: {},
      fullColumnIdData: {},
      fullColumnFieldData: {},
      inited: !1,
      tooltipTimeout: null,
      initStatus: !1,
      isActivated: !1
    };
    let d = {}, f = {};
    const v = B(), h = B(), m = B(), p = B(), C = B(), g = B(), w = B(), b = B(), y = B(), E = B(), S = B(), _ = B(), k = B(), N = B(), L = B(), R = B(), H = B(), K = B(), U = B(), W = B(), A = ot("$xegrid", null);
    let $;
    const D = x(() => Object.assign({}, ee.table.validConfig, e.validConfig)), O = x(() => Object.assign({}, ee.table.scrollX, e.scrollX)), F = x(() => Object.assign({}, ee.table.scrollY, e.scrollY)), j = x(() => ({
      default: 48,
      medium: 44,
      small: 40,
      mini: 36
    })), Z = x(() => Object.assign({}, ee.table.columnConfig, e.columnConfig)), te = x(() => Object.assign({}, ee.table.rowConfig, e.rowConfig)), de = x(() => Object.assign({}, ee.table.resizeConfig, e.resizeConfig)), Oe = x(() => Object.assign({}, ee.table.resizableConfig, e.resizableConfig)), ce = x(() => Object.assign({ startIndex: 0 }, ee.table.seqConfig, e.seqConfig)), ne = x(() => Object.assign({}, ee.table.radioConfig, e.radioConfig)), Y = x(() => Object.assign({}, ee.table.checkboxConfig, e.checkboxConfig));
    let ve = B();
    ve = x(() => Object.assign({}, ee.tooltip, ee.table.tooltipConfig, e.tooltipConfig));
    const ie = x(() => ({
      ...ve.value
    })), he = x(() => {
      const T = ve.value;
      return Object.assign({ isArrow: !1 }, T);
    }), De = x(() => Object.assign({}, ee.table.editConfig, e.editConfig)), $e = x(() => Object.assign({ orders: ["asc", "desc", null] }, ee.table.sortConfig, e.sortConfig)), ue = x(() => Object.assign({}, ee.table.filterConfig, e.filterConfig)), Ne = x(() => Object.assign({}, ee.table.mouseConfig, e.mouseConfig)), je = x(() => Object.assign({}, ee.table.areaConfig, e.areaConfig)), Fe = x(() => Object.assign({}, ee.table.keyboardConfig, e.keyboardConfig)), Ve = x(() => Object.assign({}, ee.table.clipConfig, e.clipConfig)), Ze = x(() => Object.assign({}, ee.table.fnrConfig, e.fnrConfig)), ae = x(() => Object.assign({}, ee.table.menuConfig, e.menuConfig)), pe = x(() => {
      const P = ae.value.header;
      return P && P.options ? P.options : [];
    }), ke = x(() => {
      const P = ae.value.body;
      return P && P.options ? P.options : [];
    }), Ue = x(() => {
      const P = ae.value.footer;
      return P && P.options ? P.options : [];
    }), Xe = x(() => {
      const T = ae.value, P = pe.value, q = ke.value, J = Ue.value;
      return !!(e.menuConfig && mn(T) && (P.length || q.length || J.length));
    }), re = x(() => {
      const { ctxMenuStore: T } = s, P = [];
      return T.list.forEach((q) => {
        q.forEach((J) => {
          P.push(J);
        });
      }), P;
    }), Te = x(() => Object.assign({}, ee.table.exportConfig, e.exportConfig)), Ce = x(() => Object.assign({}, ee.table.importConfig, e.importConfig)), Le = x(() => Object.assign({}, ee.table.printConfig, e.printConfig)), ge = x(() => Object.assign({}, ee.table.expandConfig, e.expandConfig)), Ee = x(() => Object.assign({}, ee.table.treeConfig, e.treeConfig)), me = x(() => Object.assign({}, ee.table.emptyRender, e.emptyRender)), Ke = x(() => Object.assign({}, ee.table.loadingConfig, e.loadingConfig)), Re = x(() => e.border ? Math.max(2, Math.ceil(s.scrollbarWidth / s.tableColumn.length)) : 1), we = x(() => Object.assign({}, ee.table.customConfig, e.customConfig)), ze = x(() => {
      const { collectColumn: T } = u;
      let P = 0;
      return T.forEach((q) => {
        q.fixed && P++;
      }), P;
    }), Je = x(() => {
      const T = ze.value, P = Z.value, { maxFixedSize: q } = P;
      return q ? T >= q : !1;
    }), Me = x(() => {
      const { border: T } = e;
      return T === !0 ? "full" : T || "default";
    }), et = x(() => {
      const { tableData: T } = s, { tableFullData: P } = u, q = Y.value, { strict: J, checkMethod: se } = q;
      return J ? T.length || P.length ? se ? P.every((ye) => !se({ row: ye })) : !1 : !0 : !1;
    }), mt = {
      refElem: v,
      refTooltip: h,
      refValidTooltip: p,
      refTableFilter: g,
      refTableCustom: w,
      refTableMenu: C,
      refTableHeader: b,
      refTableBody: y,
      refTableFooter: E,
      refTableLeftHeader: S,
      refTableLeftBody: _,
      refTableLeftFooter: k,
      refTableRightHeader: N,
      refTableRightBody: L,
      refTableRightFooter: R,
      refLeftContainer: H,
      refRightContainer: K,
      refCellResizeBar: U
    }, Lt = {
      computeSize: r,
      computeValidOpts: D,
      computeSXOpts: O,
      computeSYOpts: F,
      computeColumnOpts: Z,
      computeRowOpts: te,
      computeResizeleOpts: de,
      computeResizableOpts: Oe,
      computeSeqOpts: ce,
      computeRadioOpts: ne,
      computeCheckboxOpts: Y,
      computeTooltipOpts: ve,
      computeEditOpts: De,
      computeSortOpts: $e,
      computeFilterOpts: ue,
      computeMouseOpts: Ne,
      computeAreaOpts: je,
      computeKeyboardOpts: Fe,
      computeClipOpts: Ve,
      computeFNROpts: Ze,
      computeHeaderMenu: pe,
      computeBodyMenu: ke,
      computeFooterMenu: Ue,
      computeIsMenu: Xe,
      computeMenuOpts: ae,
      computeExportOpts: Te,
      computeImportOpts: Ce,
      computePrintOpts: Le,
      computeExpandOpts: ge,
      computeTreeOpts: Ee,
      computeEmptyOpts: me,
      computeLoadingOpts: Ke,
      computeCustomOpts: we,
      computeFixedColumnSize: ze,
      computeIsMaxFixedColumn: Je,
      computeIsAllCheckboxDisabled: et
    }, be = {
      xID: a,
      props: e,
      context: t,
      instance: i,
      reactData: s,
      internalData: u,
      getRefMaps: () => mt,
      getComputeMaps: () => Lt,
      xegrid: A
    }, an = (T, P, q) => {
      const J = I.get(T, q), se = I.get(P, q);
      return La(J) && La(se) ? !0 : I.isString(J) || I.isNumber(J) ? "" + J == "" + se : I.isEqual(J, se);
    }, _t = (T) => {
      const P = $e.value, { orders: q } = P, J = T.order || null, se = q.indexOf(J) + 1;
      return q[se < q.length ? se : 0];
    }, zt = (T) => {
      const P = ee.version, q = I.toStringJSON(localStorage.getItem(T) || "");
      return q && q._v === P ? q : { _v: P };
    }, jt = (T) => {
      const { fullAllDataRowIdData: P } = u, q = {};
      return I.each(T, (J, se) => {
        P[se] && (q[se] = J);
      }), q;
    }, Sn = (T) => {
      const { fullDataRowIdData: P } = u, q = [];
      return I.each(T, (J, se) => {
        P[se] && be.findRowIndexOf(q, P[se].row) === -1 && q.push(P[se].row);
      }), q;
    }, hn = () => {
      const { visibleColumn: T } = u, P = y.value, q = P ? P.$el : null;
      if (q) {
        const { scrollLeft: J, clientWidth: se } = q, ye = J + se;
        let Se = -1, He = 0, Be = 0;
        for (let qe = 0, Ye = T.length; qe < Ye && (He += T[qe].renderWidth, Se === -1 && J < He && (Se = qe), !(Se >= 0 && (Be++, He > ye))); qe++)
          ;
        return { toVisibleIndex: Math.max(0, Se), visibleSize: Math.max(8, Be) };
      }
      return { toVisibleIndex: 0, visibleSize: 8 };
    }, xn = () => {
      const T = b.value, P = y.value, q = P ? P.$el : null, J = r.value, se = j.value;
      if (q) {
        const ye = T ? T.$el : null;
        let Se = 0, He;
        He = q.querySelector("tr"), !He && ye && (He = ye.querySelector("tr")), He && (Se = He.clientHeight), Se || (Se = se[J || "default"]);
        const Be = Math.max(8, Math.ceil(q.clientHeight / Se) + 2);
        return { rowHeight: Se, visibleSize: Be };
      }
      return { rowHeight: 0, visibleSize: 8 };
    }, yn = (T, P, q) => {
      for (let J = 0, se = T.length; J < se; J++) {
        const ye = T[J], { startIndex: Se, endIndex: He } = P, Be = ye[q], qe = ye[q + "span"], Ye = Be + qe;
        Be < Se && Se < Ye && (P.startIndex = Be), Be < He && He < Ye && (P.endIndex = Ye), (P.startIndex !== Se || P.endIndex !== He) && (J = -1);
      }
    }, kn = (T, P, q) => {
      if (T) {
        const { treeConfig: J } = e, { visibleColumn: se } = u;
        I.isArray(T) || (T = [T]), J && T.length && Ht("vxe.error.noTree", ["merge-cells | merge-footer-items"]), T.forEach((ye) => {
          let { row: Se, col: He, rowspan: Be, colspan: qe } = ye;
          if (q && I.isNumber(Se) && (Se = q[Se]), I.isNumber(He) && (He = se[He]), (q ? Se : I.isNumber(Se)) && He && (Be || qe) && (Be = I.toNumber(Be) || 1, qe = I.toNumber(qe) || 1, Be > 1 || qe > 1)) {
            const Ye = I.findIndexOf(P, (dt) => (dt._row === Se || yt(be, dt._row) === yt(be, Se)) && (dt._col.id === He || dt._col.id === He.id)), lt = P[Ye];
            if (lt)
              lt.rowspan = Be, lt.colspan = qe, lt._rowspan = Be, lt._colspan = qe;
            else {
              const dt = q ? be.findRowIndexOf(q, Se) : Se, rt = d.getVTColumnIndex(He);
              P.push({
                row: dt,
                col: rt,
                rowspan: Be,
                colspan: qe,
                _row: Se,
                _col: He,
                _rowspan: Be,
                _colspan: qe
              });
            }
          }
        });
      }
    }, Wn = (T, P, q) => {
      const J = [];
      if (T) {
        const { treeConfig: se } = e, { visibleColumn: ye } = u;
        I.isArray(T) || (T = [T]), se && T.length && Ht("vxe.error.noTree", ["merge-cells | merge-footer-items"]), T.forEach((Se) => {
          let { row: He, col: Be } = Se;
          q && I.isNumber(He) && (He = q[He]), I.isNumber(Be) && (Be = ye[Be]);
          const qe = I.findIndexOf(P, (Ye) => (Ye._row === He || yt(be, Ye._row) === yt(be, He)) && (Ye._col.id === Be || Ye._col.id === Be.id));
          if (qe > -1) {
            const Ye = P.splice(qe, 1);
            J.push(Ye[0]);
          }
        });
      }
      return J;
    }, Vn = () => {
      const { tableFullColumn: T } = u;
      T.forEach((P) => {
        P.order = null;
      });
    }, ho = (T) => {
      const { parentHeight: P } = s, q = e[T];
      let J = 0;
      if (q)
        if (q === "auto")
          J = P;
        else {
          const se = be.getExcludeHeight();
          Uu(q) ? J = Math.floor((I.toInteger(q) || 1) / 100 * P) : J = I.toNumber(q), J = Math.max(40, J - se);
        }
      return J;
    }, Qn = () => {
      const { id: T, customConfig: P } = e, q = we.value, { storage: J } = q, se = J === !0, ye = se ? {} : Object.assign({}, J || {}), Se = se || ye.resizable, He = se || ye.visible, Be = se || ye.fixed, qe = se || ye.sort;
      if (P && (Se || He || Be || qe)) {
        const Ye = {};
        if (!T) {
          Ht("vxe.error.reqProp", ["id"]);
          return;
        }
        if (Se) {
          const pt = zt(Km)[T];
          pt && I.each(pt, (ct, vt) => {
            Ye[vt] = { resizeWidth: ct };
          });
        }
        if (Be) {
          const pt = zt(jm)[T];
          pt && pt.split(",").forEach((vt) => {
            const [at, wt] = vt.split("|");
            Ye[at] ? Ye[at].fixed = wt : Ye[at] = { fixed: wt };
          });
        }
        let lt = !1;
        if (qe) {
          const pt = zt(qm)[T];
          pt && I.each(pt, (ct, vt) => {
            Ye[vt] ? Ye[vt].renderSortNumber = ct : Ye[vt] = { renderSortNumber: ct }, lt || (lt = !0);
          });
        }
        if (He) {
          const pt = zt(Um)[T];
          if (pt) {
            const ct = pt.split("|"), vt = ct[0] ? ct[0].split(",") : [], at = ct[1] ? ct[1].split(",") : [];
            vt.forEach((wt) => {
              Ye[wt] ? Ye[wt].visible = !1 : Ye[wt] = { visible: !1 };
            }), at.forEach((wt) => {
              Ye[wt] ? Ye[wt].visible = !0 : Ye[wt] = { visible: !0 };
            });
          }
        }
        let { collectColumn: dt } = u;
        const rt = {};
        I.eachTree(dt, (pt) => {
          const ct = pt.getKey();
          ct && (rt[ct] = pt);
        }), I.each(Ye, ({ visible: pt, resizeWidth: ct, fixed: vt, renderSortNumber: at }, wt) => {
          const Rt = rt[wt];
          Rt && (I.isNumber(ct) && (Rt.resizeWidth = ct), I.isBoolean(pt) && (Rt.visible = pt), vt && (Rt.fixed = vt), at && (Rt.renderSortNumber = Number(at)));
        }), lt && (dt = I.orderBy(dt, "renderSortNumber"), u.collectColumn = dt, u.tableFullColumn = Un(dt));
      }
    }, eo = () => {
      const { tableFullColumn: T, collectColumn: P } = u, q = u.fullColumnIdData = {}, J = u.fullColumnFieldData = {}, se = Ne.value, ye = Z.value, Se = te.value, He = P.some(wc);
      let Be = !!e.showOverflow, qe, Ye, lt, dt, rt;
      const pt = (ct, vt, at, wt, Rt) => {
        const { id: Zt, field: Wt, fixed: cn, type: In, treeNode: to } = ct, Bn = { column: ct, colid: Zt, index: vt, items: at, parent: Rt };
        Wt && (process.env.NODE_ENV === "development" && J[Wt] && qt("vxe.error.colRepet", ["field", Wt]), J[Wt] = Bn), !rt && In === "html" && (rt = ct), to ? (process.env.NODE_ENV === "development" && Ye && qt("vxe.error.colRepet", ["tree-node", to]), Ye || (Ye = ct)) : In === "expand" && (process.env.NODE_ENV === "development" && qe && qt("vxe.error.colRepet", ["type", In]), qe || (qe = ct)), process.env.NODE_ENV === "development" && (In === "checkbox" ? (lt && qt("vxe.error.colRepet", ["type", In]), lt || (lt = ct)) : In === "radio" && (dt && qt("vxe.error.colRepet", ["type", In]), dt || (dt = ct))), Be && ct.showOverflow === !1 && (Be = !1), q[Zt] && Ht("vxe.error.colRepet", ["colId", Zt]), q[Zt] = Bn;
      };
      He ? I.eachTree(P, (ct, vt, at, wt, Rt, Zt) => {
        ct.level = Zt.length, pt(ct, vt, at, wt, Rt);
      }) : T.forEach(pt), process.env.NODE_ENV === "development" && qe && se.area && Ht("vxe.error.errConflicts", ["mouse-config.area", "column.type=expand"]), process.env.NODE_ENV === "development" && rt && (ye.useKey || Ht("vxe.error.reqProp", ["column-config.useKey", "column.type=html"]), Se.useKey || Ht("vxe.error.reqProp", ["row-config.useKey", "column.type=html"])), s.isGroup = He, s.treeNodeColumn = Ye, s.expandColumn = qe, s.isAllOverflow = Be;
    }, So = () => {
      u.customHeight = ho("height"), u.customMinHeight = ho("minHeight"), u.customMaxHeight = ho("maxHeight");
    }, st = () => {
      const T = b.value, P = y.value, q = E.value, J = P ? P.$el : null, se = T ? T.$el : null, ye = q ? q.$el : null;
      if (!J)
        return;
      let Se = 0;
      const He = 40, Be = J.clientWidth - 1;
      let qe = Be, Ye = qe / 100;
      const { fit: lt } = e, { columnStore: dt } = s, { resizeList: rt, pxMinList: pt, pxList: ct, scaleList: vt, scaleMinList: at, autoList: wt } = dt;
      if (pt.forEach((On) => {
        const $n = I.toInteger(On.minWidth);
        Se += $n, On.renderWidth = $n;
      }), at.forEach((On) => {
        const $n = Math.floor(I.toInteger(On.minWidth) * Ye);
        Se += $n, On.renderWidth = $n;
      }), vt.forEach((On) => {
        const $n = Math.floor(I.toInteger(On.width) * Ye);
        Se += $n, On.renderWidth = $n;
      }), ct.forEach((On) => {
        const $n = I.toInteger(On.width);
        Se += $n, On.renderWidth = $n;
      }), rt.forEach((On) => {
        const $n = I.toInteger(On.resizeWidth);
        Se += $n, On.renderWidth = $n;
      }), qe -= Se, Ye = qe > 0 ? Math.floor(qe / (at.length + pt.length + wt.length)) : 0, lt ? qe > 0 && at.concat(pt).forEach((On) => {
        Se += Ye, On.renderWidth += Ye;
      }) : Ye = He, wt.forEach((On) => {
        const $n = Math.max(Ye, He);
        On.renderWidth = $n, Se += $n;
      }), lt) {
        const On = vt.concat(at).concat(pt).concat(wt);
        let $n = On.length - 1;
        if ($n > 0) {
          let io = Be - Se;
          if (io > 0) {
            for (; io > 0 && $n >= 0; )
              io--, On[$n--].renderWidth++;
            Se = Be;
          }
        }
      }
      const Rt = J.offsetHeight, Zt = J.scrollHeight > J.clientHeight;
      let Wt = 0;
      Zt && (Wt = Math.max(J.offsetWidth - J.clientWidth, 0)), s.scrollbarWidth = Wt, s.overflowY = Zt, u.tableWidth = Se, u.tableHeight = Rt;
      let cn = 0;
      se && (cn = se.clientHeight, xe(() => {
        se && J && se.scrollLeft !== J.scrollLeft && (se.scrollLeft = J.scrollLeft);
      })), u.headerHeight = cn;
      let In = !1, to = 0, Bn = 0;
      ye ? (to = ye.offsetHeight, In = Se > ye.clientWidth, In && (Bn = Math.max(to - ye.clientHeight, 0))) : (In = Se > Be, In && (Bn = Math.max(Rt - J.clientHeight, 0))), u.footerHeight = to, s.overflowX = In, s.scrollbarHeight = Bn, So(), s.parentHeight = Math.max(u.headerHeight + to + 20, f.getParentHeight()), In && f.checkScrolling();
    }, St = (T) => {
      const { sortBy: P, sortType: q } = T;
      return (J) => {
        let se;
        return P ? se = I.isFunction(P) ? P({ row: J, column: T }) : I.get(J, P) : se = f.getCellLabel(J, T), !q || q === "auto" ? isNaN(se) ? se : I.toNumber(se) : q === "number" ? I.toNumber(se) : q === "string" ? I.toValueString(se) : se;
      };
    }, rn = () => {
      const { treeConfig: T } = e, { afterFullData: P, fullDataRowIdData: q, fullAllDataRowIdData: J } = u, { afterTreeFullData: se } = u, ye = Ee.value, Se = ye.children || ye.childrenField, He = {};
      T ? I.eachTree(se, (Be, qe, Ye, lt) => {
        const dt = yt(be, Be), rt = J[dt], pt = lt.map((ct, vt) => vt % 2 === 0 ? Number(ct) + 1 : ".").join("");
        if (rt)
          rt.seq = pt, rt._index = qe;
        else {
          const ct = { row: Be, rowid: dt, seq: pt, index: -1, $index: -1, _index: qe, items: [], parent: null, level: 0 };
          J[dt] = ct, q[dt] = ct;
        }
        He[dt] = Be;
      }, { children: ye.transform ? ye.mapChildrenField : Se }) : P.forEach((Be, qe) => {
        const Ye = yt(be, Be), lt = J[Ye], dt = qe + 1;
        if (lt)
          lt.seq = dt, lt._index = qe;
        else {
          const rt = { row: Be, rowid: Ye, seq: dt, index: -1, $index: -1, _index: qe, items: [], parent: null, level: 0 };
          J[Ye] = rt, q[Ye] = rt;
        }
        He[Ye] = Be;
      }), u.afterFullRowMaps = He;
    }, Tn = () => {
      const { treeConfig: T } = e, { treeExpandedMaps: P } = s, q = Ee.value;
      if (T && q.transform) {
        const J = [], se = {};
        return I.eachTree(u.afterTreeFullData, (ye, Se, He, Be, qe) => {
          const Ye = yt(be, ye), lt = yt(be, qe);
          (!qe || se[lt] && P[lt]) && (se[Ye] = 1, J.push(ye));
        }, { children: q.mapChildrenField }), u.afterFullData = J, gu(J), J;
      }
      return u.afterFullData;
    }, mo = () => {
      const { treeConfig: T } = e, { tableFullColumn: P, tableFullData: q, tableFullTreeData: J } = u, se = ue.value, ye = $e.value, Se = Ee.value, { transform: He } = Se, { remote: Be, filterMethod: qe } = se, { remote: Ye, sortMethod: lt, multiple: dt, chronological: rt } = ye;
      let pt = [], ct = [];
      if (!Be || !Ye) {
        const vt = [];
        let at = [];
        if (P.forEach((wt) => {
          const { field: Rt, sortable: Zt, order: Wt, filters: cn } = wt;
          if (!Be && cn && cn.length) {
            const In = [], to = [];
            cn.forEach((Bn) => {
              Bn.checked && (to.push(Bn), In.push(Bn.value));
            }), to.length && vt.push({ column: wt, valueList: In, itemList: to });
          }
          !Ye && Zt && Wt && at.push({ column: wt, field: Rt, property: Rt, order: Wt, sortTime: wt.sortTime });
        }), dt && rt && at.length > 1 && (at = I.orderBy(at, "sortTime")), !Be && vt.length) {
          const wt = (Rt) => vt.every(({ column: Zt, valueList: Wt, itemList: cn }) => {
            const { filterMethod: In, filterRender: to } = Zt, Bn = to ? $t.renderer.get(to.name) : null, On = Bn ? Bn.filterMethod : null, $n = Bn ? Bn.defaultFilterMethod : null, io = xa(Rt, Zt);
            return In ? cn.some((Qo) => In({ value: Qo.value, option: Qo, cellValue: io, row: Rt, column: Zt, $table: be })) : On ? cn.some((Qo) => On({ value: Qo.value, option: Qo, cellValue: io, row: Rt, column: Zt, $table: be })) : qe ? qe({ options: cn, values: Wt, cellValue: io, row: Rt, column: Zt }) : $n ? cn.some((Qo) => $n({ value: Qo.value, option: Qo, cellValue: io, row: Rt, column: Zt, $table: be })) : Wt.indexOf(I.get(Rt, Zt.field)) > -1;
          });
          T && He ? (ct = I.searchTree(J, wt, { ...Se, original: !0 }), pt = ct) : (pt = T ? J.filter(wt) : q.filter(wt), ct = pt);
        } else
          T && He ? (ct = I.searchTree(J, () => !0, { ...Se, original: !0 }), pt = ct) : (pt = T ? J.slice(0) : q.slice(0), ct = pt);
        if (!Ye && at.length)
          if (T && He) {
            if (lt) {
              const wt = lt({ data: ct, sortList: at, $table: be });
              ct = I.isArray(wt) ? wt : ct;
            } else
              ct = I.orderBy(ct, at.map(({ column: wt, order: Rt }) => [St(wt), Rt]));
            pt = ct;
          } else {
            if (lt) {
              const wt = lt({ data: pt, sortList: at, $table: be });
              pt = I.isArray(wt) ? wt : pt;
            } else
              pt = I.orderBy(pt, at.map(({ column: wt, order: Rt }) => [St(wt), Rt]));
            ct = pt;
          }
      } else
        T && He ? (ct = I.searchTree(J, () => !0, { ...Se, original: !0 }), pt = ct) : (pt = T ? J.slice(0) : q.slice(0), ct = pt);
      u.afterFullData = pt, u.afterTreeFullData = ct, rn();
    }, ro = () => {
      const { border: T, showFooter: P, showOverflow: q, showHeaderOverflow: J, showFooterOverflow: se, mouseConfig: ye, spanMethod: Se, footerSpanMethod: He, keyboardConfig: Be } = e, { isGroup: qe, currentRow: Ye, tableColumn: lt, scrollXLoad: dt, scrollYLoad: rt, scrollbarWidth: pt, scrollbarHeight: ct, columnStore: vt, editStore: at, mergeList: wt, mergeFooterList: Rt, isAllOverflow: Zt } = s;
      let { visibleColumn: Wt, fullColumnIdData: cn, tableHeight: In, tableWidth: to, headerHeight: Bn, footerHeight: On, elemStore: $n, customHeight: io, customMinHeight: Qo, customMaxHeight: Ma } = u;
      const qi = ["main", "left", "right"], Ws = W.value, wu = Re.value, Ks = Ne.value, wr = Fe.value, Us = $n["main-body-wrapper"], js = Us ? Us.value : null;
      return Ws && (Ws.style.top = `${Bn}px`, Ws.style.height = js ? `${js.offsetHeight - ct}px` : ""), io > 0 && P && (io += ct), qi.forEach((Kl, qs) => {
        const gl = qs > 0 ? Kl : "", qo = ["header", "body", "footer"], Il = gl === "left";
        let bl = [], Ys;
        gl && (bl = Il ? vt.leftList : vt.rightList, Ys = Il ? H.value : K.value), qo.forEach((ca) => {
          const G1 = $n[`${Kl}-${ca}-wrapper`], Xa = G1 ? G1.value : null, X1 = $n[`${Kl}-${ca}-table`], Gs = X1 ? X1.value : null;
          if (ca === "header") {
            let Rl = to, yl = lt;
            qe ? yl = Wt : gl && (dt || J) && (yl = bl), Rl = yl.reduce((el, Eu) => el + Eu.renderWidth, 0), Gs && (Gs.style.width = Rl ? `${Rl + pt}px` : "");
            const ul = $n[`${Kl}-${ca}-repair`], Ul = ul ? ul.value : null;
            Ul && (Ul.style.width = `${to}px`);
            const Yo = $n[`${Kl}-${ca}-list`], Dl = Yo ? Yo.value : null;
            qe && Dl && I.arrayEach(Dl.querySelectorAll(".col--group"), (el) => {
              const Eu = d.getColumnNode(el);
              if (Eu) {
                const Lf = Eu.item, { showHeaderOverflow: Lh } = Lf, Zr = I.isBoolean(Lh) ? Lh : J, Yi = Zr === "title" || (Zr === !0 || Zr === "tooltip") || Zr === "ellipsis";
                let Su = 0, _u = 0;
                Yi && I.eachTree(Lf.children, (Pf) => {
                  (!Pf.children || !Lf.children.length) && _u++, Su += Pf.renderWidth;
                }, { children: "children" }), el.style.width = Yi ? `${Su - _u - (T ? 2 : 0)}px` : "";
              }
            });
          } else if (ca === "body") {
            const Rl = $n[`${Kl}-${ca}-emptyBlock`], yl = Rl ? Rl.value : null;
            if (Mm(Xa)) {
              let Yo = 0;
              const Dl = Qo - Bn - On;
              if (Ma && (Yo = Ma - Bn - On, gl && (Yo -= P ? 0 : ct), Yo = Math.max(Dl, Yo), Xa.style.maxHeight = `${Yo}px`), io) {
                let el = io - Bn - On;
                gl && (el -= P ? 0 : ct), Yo && (el = Math.min(Yo, el)), Xa.style.height = `${Math.max(Dl, el)}px`;
              } else
                Xa.style.height = "";
              Xa.style.minHeight = `${Dl}px`;
            }
            Ys && (Mm(Xa) && (Xa.style.top = `${Bn}px`), Ys.style.height = `${(io > 0 ? io - Bn - On : In) + Bn + On - ct * (P ? 2 : 1)}px`, Ys.style.width = `${bl.reduce((Yo, Dl) => Yo + Dl.renderWidth, Il ? 0 : pt)}px`);
            let ul = to, Ul = lt;
            gl && (!s.expandColumn && (rt || q && Zt) && !wt.length && !Se && !(Be && wr.isMerge) ? Ul = bl : Ul = Wt), ul = Ul.reduce((Yo, Dl) => Yo + Dl.renderWidth, 0), Gs && (Gs.style.width = ul ? `${ul}px` : "", Gs.style.paddingRight = pt && gl && (Jl["-moz"] || Jl.safari) ? `${pt}px` : ""), yl && (yl.style.width = ul ? `${ul}px` : "");
          } else if (ca === "footer") {
            let Rl = to, yl = lt;
            gl && (!s.expandColumn && (dt || se) && (!Rt.length || !He) ? yl = bl : yl = Wt), Rl = yl.reduce((ul, Ul) => ul + Ul.renderWidth, 0), Mm(Xa) && (Ys && (Xa.style.top = `${io > 0 ? io - On : In + Bn}px`), Xa.style.marginTop = `${-Math.max(1, ct)}px`), Gs && (Gs.style.width = Rl ? `${Rl + pt}px` : "");
          }
          const Z1 = $n[`${Kl}-${ca}-colgroup`], J1 = Z1 ? Z1.value : null;
          J1 && I.arrayEach(J1.children, (Rl) => {
            const yl = Rl.getAttribute("name");
            if (yl === "col_gutter" && (Rl.style.width = `${pt}px`), cn[yl]) {
              const ul = cn[yl].column, { showHeaderOverflow: Ul, showFooterOverflow: Yo, showOverflow: Dl } = ul;
              let el;
              Rl.style.width = `${ul.renderWidth}px`, ca === "header" ? el = I.isUndefined(Ul) || I.isNull(Ul) ? J : Ul : ca === "footer" ? el = I.isUndefined(Yo) || I.isNull(Yo) ? se : Yo : el = I.isUndefined(Dl) || I.isNull(Dl) ? q : Dl;
              let Zr = el === "title" || (el === !0 || el === "tooltip") || el === "ellipsis";
              const Ph = $n[`${Kl}-${ca}-list`], Ah = Ph ? Ph.value : null;
              rt && !Zr && (Zr = !0), Ah && I.arrayEach(Ah.querySelectorAll(`.${ul.id}`), (Fh) => {
                const Yi = parseInt(Fh.getAttribute("colspan") || 1), Su = Fh.querySelector(".vxe-cell");
                let _u = ul.renderWidth;
                if (Su) {
                  if (Yi > 1) {
                    const Pf = d.getColumnIndex(ul);
                    for (let Vh = 1; Vh < Yi; Vh++) {
                      const Q1 = d.getColumns(Pf + Vh);
                      Q1 && (_u += Q1.renderWidth);
                    }
                  }
                  Su.style.width = Zr ? `${_u - wu * Yi}px` : "";
                }
              });
            }
          });
        });
      }), Ye && d.setCurrentRow(Ye), ye && Ks.selected && at.selected.row && at.selected.column && be.addCellSelectedClass(), xe();
    }, Io = (T) => be.triggerValidate ? be.triggerValidate(T) : xe(), Oo = (T, P) => {
      Io("blur").catch((q) => q).then(() => {
        be.handleActived(P, T).then(() => Io("change")).catch((q) => q);
      });
    }, so = () => {
      const { sortConfig: T } = e;
      if (T) {
        const P = $e.value;
        let { defaultSort: q } = P;
        q && (I.isArray(q) || (q = [q]), q.length && ((T.multiple ? q : q.slice(0, 1)).forEach((J, se) => {
          const { field: ye, order: Se } = J;
          if (ye && Se) {
            const He = d.getColumnByField(ye);
            He && He.sortable && (He.order = Se, He.sortTime = Date.now() + se);
          }
        }), P.remote || f.handleTableData(!0).then(ro)));
      }
    }, la = () => {
      const { checkboxConfig: T } = e;
      if (T) {
        const { fullDataRowIdData: P } = u, q = Y.value, { checkAll: J, checkRowKeys: se } = q;
        if (J)
          No(!0, !0);
        else if (se) {
          const ye = [];
          se.forEach((Se) => {
            P[Se] && ye.push(P[Se].row);
          }), _o(ye, !0, !0);
        }
      }
    }, aa = () => {
      const { radioConfig: T } = e;
      if (T) {
        const { fullDataRowIdData: P } = u, q = ne.value, { checkRowKey: J, reserve: se } = q;
        if (J && (P[J] && sn(P[J].row, !0), se)) {
          const ye = ti(be);
          u.radioReserveRow = { [ye]: J };
        }
      }
    }, ft = () => {
      const { expandConfig: T } = e;
      if (T) {
        const { fullDataRowIdData: P } = u, q = ge.value, { expandAll: J, expandRowKeys: se } = q;
        if (J)
          d.setAllRowExpand(!0);
        else if (se) {
          const ye = [];
          se.forEach((Se) => {
            P[Se] && ye.push(P[Se].row);
          }), d.setRowExpand(ye, !0);
        }
      }
    }, At = (T) => {
      ne.value.reserve && (u.radioReserveRow = T);
    }, Xt = (T, P) => {
      const { checkboxReserveRowMap: q } = u;
      if (Y.value.reserve) {
        const se = yt(be, T);
        P ? q[se] = T : q[se] && delete q[se];
      }
    }, sn = (T, P) => {
      const q = ne.value, { checkMethod: J } = q;
      return T && (P || !J || J({ row: T })) && (s.selectRadioRow = T, At(T)), xe();
    }, _o = (T, P, q) => (T && !I.isArray(T) && (T = [T]), T.forEach((J) => f.handleSelectRow({ row: J }, !!P, q)), xe()), No = (T, P) => {
      const { treeConfig: q } = e, { selectCheckboxMaps: J } = s, { afterFullData: se, afterFullRowMaps: ye, checkboxReserveRowMap: Se } = u, He = Ee.value, Be = He.children || He.childrenField, qe = Y.value, { checkField: Ye, reserve: lt, checkStrictly: dt, checkMethod: rt } = qe, pt = qe.indeterminateField || qe.halfField, ct = {};
      if (q || I.each(J, (vt, at) => {
        ye[at] || (ct[at] = vt);
      }), dt)
        s.isAllSelected = T;
      else {
        if (Ye) {
          const vt = (at) => {
            (P || !rt || rt({ row: at })) && (T && (ct[yt(be, at)] = at), I.set(at, Ye, T)), q && pt && I.set(at, pt, !1);
          };
          q ? I.eachTree(se, vt, { children: Be }) : se.forEach(vt);
        } else
          q ? T ? I.eachTree(se, (vt) => {
            (P || !rt || rt({ row: vt })) && (ct[yt(be, vt)] = vt);
          }, { children: Be }) : !P && rt && I.eachTree(se, (vt) => {
            const at = yt(be, vt);
            !rt({ row: vt }) && J[at] && (ct[at] = vt);
          }, { children: Be }) : T ? !P && rt ? se.forEach((vt) => {
            const at = yt(be, vt);
            (J[at] || rt({ row: vt })) && (ct[at] = vt);
          }) : se.forEach((vt) => {
            ct[yt(be, vt)] = vt;
          }) : !P && rt && se.forEach((vt) => {
            const at = yt(be, vt);
            !rt({ row: vt }) && J[at] && (ct[at] = vt);
          });
        lt && (T ? I.each(ct, (vt, at) => {
          Se[at] = vt;
        }) : se.forEach((vt) => Xt(vt, !1))), s.selectCheckboxMaps = Ye ? {} : ct;
      }
      return s.treeIndeterminateMaps = {}, u.treeIndeterminateRowMaps = {}, f.checkSelectionStatus(), xe();
    }, Oa = () => {
      const { treeConfig: T } = e, { expandColumn: P, currentRow: q, selectCheckboxMaps: J, selectRadioRow: se, rowExpandedMaps: ye, treeExpandedMaps: Se } = s, { fullDataRowIdData: He, fullAllDataRowIdData: Be, radioReserveRow: qe } = u, Ye = ge.value, lt = Ee.value, dt = ne.value, rt = Y.value;
      if (se && !Be[yt(be, se)] && (s.selectRadioRow = null), dt.reserve && qe) {
        const pt = yt(be, qe);
        He[pt] && sn(He[pt].row, !0);
      }
      s.selectCheckboxMaps = jt(J), rt.reserve && _o(Sn(u.checkboxReserveRowMap), !0, !0), q && !Be[yt(be, q)] && (s.currentRow = null), s.rowExpandedMaps = P ? jt(ye) : {}, P && Ye.reserve && d.setRowExpand(Sn(u.rowExpandedReserveRowMap), !0), s.treeExpandedMaps = T ? jt(Se) : {}, T && lt.reserve && d.setTreeExpand(Sn(u.treeExpandedReserveRowMap), !0);
    }, br = () => {
      const { treeConfig: T } = e;
      if (T) {
        const { tableFullData: P } = u, q = Ee.value, { expandAll: J, expandRowKeys: se } = q, ye = q.children || q.childrenField;
        if (J)
          d.setAllTreeExpand(!0);
        else if (se) {
          const Se = [], He = ti(be);
          se.forEach((Be) => {
            const qe = I.findTree(P, (Ye) => Be === I.get(Ye, He), { children: ye });
            qe && Se.push(qe.item);
          }), d.setTreeExpand(Se, !0);
        }
      }
    }, qa = (T) => {
      const P = Ee.value, q = Y.value, { transform: J, loadMethod: se } = P, { checkStrictly: ye } = q;
      return new Promise((Se) => {
        if (se) {
          const { treeExpandLazyLoadedMaps: He } = s, { fullAllDataRowIdData: Be } = u, qe = yt(be, T), Ye = Be[qe];
          He[qe] = T, se({ $table: be, row: T }).then((lt) => {
            if (Ye.treeLoaded = !0, He[qe] && delete He[qe], I.isArray(lt) || (lt = []), lt)
              return d.loadTreeChildren(T, lt).then((dt) => {
                const { treeExpandedMaps: rt } = s;
                return dt.length && !rt[qe] && (rt[qe] = T), !ye && d.isCheckedByCheckboxRow(T) && _o(dt, !0), xe().then(() => {
                  if (J)
                    return f.handleTableData();
                });
              });
          }).catch(() => {
            const { treeExpandLazyLoadedMaps: lt } = s;
            Ye.treeLoaded = !1, lt[qe] && delete lt[qe];
          }).finally(() => {
            xe().then(() => d.recalculate()).then(() => Se());
          });
        } else
          Se();
      });
    }, ra = (T, P) => {
      const { treeExpandedReserveRowMap: q } = u;
      if (Ee.value.reserve) {
        const se = yt(be, T);
        P ? q[se] = T : q[se] && delete q[se];
      }
    }, cl = (T) => new Promise((P) => {
      const q = ge.value, { loadMethod: J } = q;
      if (J) {
        const { fullAllDataRowIdData: se } = u, { rowExpandLazyLoadedMaps: ye } = s, Se = yt(be, T), He = se[Se];
        ye[Se] = T, J({ $table: be, row: T, rowIndex: d.getRowIndex(T), $rowIndex: d.getVMRowIndex(T) }).then(() => {
          const { rowExpandedMaps: Be } = s;
          He.expandLoaded = !0, Be[Se] = T;
        }).catch(() => {
          He.expandLoaded = !1;
        }).finally(() => {
          const { rowExpandLazyLoadedMaps: Be } = s;
          Be[Se] && delete Be[Se], xe().then(() => d.recalculate()).then(() => P());
        });
      } else
        P();
    }), sa = (T, P) => {
      const { rowExpandedReserveRowMap: q } = u;
      if (ge.value.reserve) {
        const se = yt(be, T);
        P ? q[se] = T : q[se] && delete q[se];
      }
    }, Gr = () => {
      const { mergeCells: T } = e;
      T && d.setMergeCells(T);
    }, Ya = () => {
      const { mergeFooterItems: T } = e;
      T && d.setMergeFooterItems(T);
    }, Ga = () => xe().then(() => {
      const { scrollXLoad: T, scrollYLoad: P } = s, { scrollXStore: q, scrollYStore: J } = u, se = F.value, ye = O.value;
      if (T) {
        const { visibleSize: Be } = hn(), qe = ye.oSize ? I.toNumber(ye.oSize) : Jl.edge ? 5 : 0;
        q.offsetSize = qe, q.visibleSize = Be, q.endIndex = Math.max(q.startIndex + q.visibleSize + qe, q.endIndex), f.updateScrollXData();
      } else
        f.updateScrollXSpace();
      const { rowHeight: Se, visibleSize: He } = xn();
      if (J.rowHeight = Se, P) {
        const Be = se.oSize ? I.toNumber(se.oSize) : Jl.edge ? 10 : 0;
        J.offsetSize = Be, J.visibleSize = He, J.endIndex = Math.max(J.startIndex + He + Be, J.endIndex), f.updateScrollYData();
      } else
        f.updateScrollYSpace();
      s.rowHeight = Se, xe(ro);
    }), ia = (T) => {
      const { keepSource: P, treeConfig: q } = e, { editStore: J, scrollYLoad: se } = s, { scrollYStore: ye, scrollXStore: Se, lastScrollLeft: He, lastScrollTop: Be } = u, qe = Ee.value, { transform: Ye } = qe, lt = qe.children || qe.childrenField;
      let dt = [], rt = en(T ? T.slice(0) : []);
      q && (Ye ? (process.env.NODE_ENV === "development" && (qe.rowField || Ht("vxe.error.reqProp", ["tree-config.rowField"]), qe.parentField || Ht("vxe.error.reqProp", ["tree-config.parentField"]), lt || Ht("vxe.error.reqProp", ["tree-config.childrenField"]), qe.mapChildrenField || Ht("vxe.error.reqProp", ["tree-config.mapChildrenField"]), lt === qe.mapChildrenField && Ht("vxe.error.errConflicts", ["tree-config.childrenField", "tree-config.mapChildrenField"])), dt = I.toArrayTree(rt, {
        key: qe.rowField,
        parentKey: qe.parentField,
        children: lt,
        mapChildren: qe.mapChildrenField
      }), rt = dt.slice(0)) : dt = rt.slice(0)), ye.startIndex = 0, ye.endIndex = 1, Se.startIndex = 0, Se.endIndex = 1, s.scrollVMLoading = !1, J.insertMaps = {}, J.removeMaps = {};
      const pt = gu(rt);
      return s.scrollYLoad = pt, u.tableFullData = rt, u.tableFullTreeData = dt, f.cacheRowMap(!0), u.tableSynchData = T, P && f.cacheSourceMap(rt), process.env.NODE_ENV === "development" && pt && (e.height || e.maxHeight || Ht("vxe.error.reqProp", ["table.height | table.max-height | table.scroll-y={enabled: false}"]), e.showOverflow || qt("vxe.error.reqProp", ["table.show-overflow"]), e.spanMethod && qt("vxe.error.scrollErrProp", ["table.span-method"])), be.clearCellAreas && e.mouseConfig && (be.clearCellAreas(), be.clearCopyCellArea()), d.clearMergeCells(), d.clearMergeFooterItems(), f.handleTableData(!0), d.updateFooter(), xe().then(() => {
        So(), ro();
      }).then(() => {
        Ga();
      }).then(() => (pt && (ye.endIndex = ye.visibleSize), Oa(), f.checkSelectionStatus(), new Promise((ct) => {
        xe().then(() => d.recalculate()).then(() => {
          let vt = He, at = Be;
          const wt = O.value, Rt = F.value;
          wt.scrollToLeftOnChange && (vt = 0), Rt.scrollToTopOnChange && (at = 0), se === pt ? Im(be, vt, at).then(ct) : setTimeout(() => Im(be, vt, at).then(ct));
        });
      })));
    }, Xr = () => {
      la(), aa(), ft(), br(), Gr(), Ya(), xe(() => setTimeout(() => d.recalculate()));
    }, Ml = () => {
      so();
    }, Ro = () => {
      const { scrollXLoad: T } = s, { visibleColumn: P, scrollXStore: q, fullColumnIdData: J } = u, se = T ? P.slice(q.startIndex, q.endIndex) : P.slice(0);
      se.forEach((ye, Se) => {
        const He = ye.id, Be = J[He];
        Be && (Be.$index = Se);
      }), s.tableColumn = se;
    }, yr = () => {
      const { mergeList: T, mergeFooterList: P } = s, { scrollXStore: q } = u, { startIndex: J, endIndex: se, offsetSize: ye } = q, { toVisibleIndex: Se, visibleSize: He } = hn(), Be = {
        startIndex: Math.max(0, Se - 1 - ye),
        endIndex: Se + He + ye
      };
      yn(T.concat(P), Be, "col");
      const { startIndex: qe, endIndex: Ye } = Be;
      (Se <= J || Se >= se - He - 1) && (J !== qe || se !== Ye) && (q.startIndex = qe, q.endIndex = Ye, f.updateScrollXData()), d.closeTooltip();
    }, Un = (T) => {
      const P = [];
      return T.forEach((q) => {
        P.push(...q.children && q.children.length ? Un(q.children) : [q]);
      }), P;
    }, Jo = () => {
      const T = [], P = [], q = [], { isGroup: J, columnStore: se } = s, ye = O.value, { collectColumn: Se, tableFullColumn: He, scrollXStore: Be, fullColumnIdData: qe } = u;
      if (J) {
        const dt = [], rt = [], pt = [];
        I.eachTree(Se, (ct, vt, at, wt, Rt) => {
          const Zt = wc(ct);
          Rt && Rt.fixed && (ct.fixed = Rt.fixed), Rt && ct.fixed !== Rt.fixed && Ht("vxe.error.groupFixed"), Zt ? ct.visible = !!I.findTree(ct.children, (Wt) => wc(Wt) ? !1 : Wt.visible) : ct.visible && (ct.fixed === "left" ? T.push(ct) : ct.fixed === "right" ? q.push(ct) : P.push(ct));
        }), Se.forEach((ct) => {
          ct.visible && (ct.fixed === "left" ? dt.push(ct) : ct.fixed === "right" ? pt.push(ct) : rt.push(ct));
        }), s.tableGroupColumn = dt.concat(rt).concat(pt);
      } else
        He.forEach((dt) => {
          dt.visible && (dt.fixed === "left" ? T.push(dt) : dt.fixed === "right" ? q.push(dt) : P.push(dt));
        });
      const Ye = T.concat(P).concat(q), lt = !!ye.enabled && ye.gt > -1 && (ye.gt === 0 || ye.gt < He.length);
      if (s.hasFixedColumn = T.length > 0 || q.length > 0, Object.assign(se, { leftList: T, centerList: P, rightList: q }), lt) {
        process.env.NODE_ENV === "development" && (e.spanMethod && qt("vxe.error.scrollErrProp", ["span-method"]), e.footerSpanMethod && qt("vxe.error.scrollErrProp", ["footer-span-method"]));
        const { visibleSize: dt } = hn();
        Be.startIndex = 0, Be.endIndex = dt, Be.visibleSize = dt;
      }
      return (Ye.length !== u.visibleColumn.length || !u.visibleColumn.every((dt, rt) => dt === Ye[rt])) && (d.clearMergeCells(), d.clearMergeFooterItems()), s.scrollXLoad = lt, Ye.forEach((dt, rt) => {
        const pt = dt.id, ct = qe[pt];
        ct && (ct._index = rt);
      }), u.visibleColumn = Ye, Ro(), d.updateFooter().then(() => d.recalculate()).then(() => (d.updateCellAreas(), d.recalculate()));
    }, Na = () => {
      const { collectColumn: T } = u;
      T.forEach((P, q) => {
        const J = q + 1;
        P.sortNumber = J, P.renderSortNumber = J;
      });
    }, zs = (T) => {
      u.collectColumn = T;
      const P = Un(T);
      return u.tableFullColumn = P, Na(), Qn(), eo(), Jo().then(() => {
        s.scrollXLoad && yr();
      }), d.clearMergeCells(), d.clearMergeFooterItems(), f.handleTableData(!0), process.env.NODE_ENV === "development" && (s.scrollXLoad || s.scrollYLoad) && s.expandColumn && qt("vxe.error.scrollErrProp", ["column.type=expand"]), xe().then(() => ($ && $.syncUpdate({ collectColumn: T, $table: be }), d.recalculate()));
    }, gu = (T) => {
      const { treeConfig: P } = e, q = F.value, J = Ee.value, { transform: se } = J, ye = T || u.tableFullData, Se = (se || !P) && !!q.enabled && q.gt > -1 && (q.gt === 0 || q.gt < ye.length);
      return s.scrollYLoad = Se, Se;
    }, Of = (T, P) => {
      const { treeExpandedMaps: q, treeExpandLazyLoadedMaps: J, treeNodeColumn: se } = s, ye = { ...q }, { fullAllDataRowIdData: Se, tableFullData: He } = u, Be = Ee.value, { reserve: qe, lazy: Ye, accordion: lt, toggleMethod: dt } = Be, rt = Be.children || Be.childrenField, pt = Be.hasChild || Be.hasChildField, ct = [], vt = d.getColumnIndex(se), at = d.getVMColumnIndex(se);
      let wt = dt ? T.filter((Rt) => dt({ $table: be, expanded: P, column: se, columnIndex: vt, $columnIndex: at, row: Rt })) : T;
      if (lt) {
        wt = wt.length ? [wt[wt.length - 1]] : [];
        const Rt = I.findTree(He, (Zt) => Zt === wt[0], { children: rt });
        Rt && Rt.items.forEach((Zt) => {
          const Wt = yt(be, Zt);
          ye[Wt] && delete ye[Wt];
        });
      }
      return P ? wt.forEach((Rt) => {
        const Zt = yt(be, Rt);
        if (!ye[Zt]) {
          const Wt = Se[Zt];
          Ye && Rt[pt] && !Wt.treeLoaded && !J[Zt] ? ct.push(qa(Rt)) : Rt[rt] && Rt[rt].length && (ye[Zt] = Rt);
        }
      }) : wt.forEach((Rt) => {
        const Zt = yt(be, Rt);
        ye[Zt] && delete ye[Zt];
      }), qe && wt.forEach((Rt) => ra(Rt, P)), s.treeExpandedMaps = ye, Promise.all(ct).then(() => d.recalculate());
    }, xh = (T, P) => Of(T, P).then(() => (Tn(), f.handleTableData())).then(() => d.recalculate()), Nf = (T) => {
      const { mergeList: P } = s, { scrollYStore: q } = u, { startIndex: J, endIndex: se, visibleSize: ye, offsetSize: Se, rowHeight: He } = q, qe = (T.currentTarget || T.target).scrollTop, Ye = Math.floor(qe / He), lt = {
        startIndex: Math.max(0, Ye - 1 - Se),
        endIndex: Ye + ye + Se
      };
      yn(P, lt, "row");
      const { startIndex: dt, endIndex: rt } = lt;
      (Ye <= J || Ye >= se - ye - 1) && (J !== dt || se !== rt) && (q.startIndex = dt, q.endIndex = rt, f.updateScrollYData());
    }, Ui = (T) => function(P) {
      const { fullAllDataRowIdData: q } = u;
      if (P) {
        const J = yt(be, P), se = q[J];
        if (se)
          return se[T];
      }
      return -1;
    }, Cr = (T) => function(P) {
      const { fullColumnIdData: q } = u;
      if (P) {
        const J = q[P.id];
        if (J)
          return J[T];
      }
      return -1;
    }, kh = I.debounce(function(T) {
      Nf(T);
    }, 20, { leading: !1, trailing: !0 });
    let Mf;
    d = {
      dispatchEvent(T, P, q) {
        o(T, Object.assign({ $table: be, $grid: A, $event: q }, P));
      },
      /**
       * 重置表格的一切数据状态
       */
      clearAll() {
        return JCe(be);
      },
      /**
       * 同步 data 数据（即将废弃）
       * 如果用了该方法，那么组件将不再记录增删改的状态，只能自行实现对应逻辑
       * 对于某些特殊的场景，比如深层树节点元素发生变动时可能会用到
       */
      syncData() {
        return qt("vxe.error.delFunc", ["syncData", "getData"]), xe().then(() => (s.tableData = [], o("update:data", u.tableFullData), xe()));
      },
      /**
       * 手动处理数据，用于手动排序与筛选
       * 对于手动更改了排序、筛选...等条件后需要重新处理数据时可能会用到
       */
      updateData() {
        const { scrollXLoad: T, scrollYLoad: P } = s;
        return f.handleTableData(!0).then(() => {
          if (d.updateFooter(), T || P)
            return T && f.updateScrollXSpace(), P && f.updateScrollYSpace(), d.refreshScroll();
        }).then(() => (d.updateCellAreas(), d.recalculate(!0))).then(() => {
          setTimeout(() => be.recalculate(), 50);
        });
      },
      /**
       * 重新加载数据，不会清空表格状态
       * @param {Array} datas 数据
       */
      loadData(T) {
        const { inited: P, initStatus: q } = u;
        return ia(T).then(() => (u.inited = !0, u.initStatus = !0, q || Xr(), P || Ml(), d.recalculate()));
      },
      /**
       * 重新加载数据，会清空表格状态
       * @param {Array} datas 数据
       */
      reloadData(T) {
        const { inited: P } = u;
        return d.clearAll().then(() => (u.inited = !0, u.initStatus = !0, ia(T))).then(() => (Xr(), P || Ml(), d.recalculate()));
      },
      /**
       * 局部加载行数据并恢复到初始状态
       * 对于行数据需要局部更改的场景中可能会用到
       * @param {Row} row 行对象
       * @param {Object} record 新数据
       * @param {String} field 字段名
       */
      reloadRow(T, P, q) {
        const { keepSource: J } = e, { tableData: se } = s, { tableSourceData: ye } = u;
        if (J) {
          const Se = d.getRowIndex(T), He = ye[Se];
          if (He && T)
            if (q) {
              const Be = I.get(P || T, q);
              I.set(T, q, Be), I.set(He, q, Be);
            } else {
              const Be = I.clone({ ...P }, !0);
              I.destructuring(He, Object.assign(T, Be));
            }
          s.tableData = se.slice(0);
        } else
          process.env.NODE_ENV === "development" && qt("vxe.error.reqProp", ["keep-source"]);
        return xe();
      },
      /**
       * 用于树结构，给行数据加载子节点
       */
      loadTreeChildren(T, P) {
        const { keepSource: q } = e, { tableSourceData: J, fullDataRowIdData: se, fullAllDataRowIdData: ye, sourceDataRowIdData: Se } = u, He = Ee.value, { transform: Be, mapChildrenField: qe } = He, Ye = He.children || He.childrenField, lt = ye[yt(be, T)], dt = lt ? lt.level : 0;
        return d.createData(P).then((rt) => {
          if (q) {
            const pt = yt(be, T), ct = I.findTree(J, (vt) => pt === yt(be, vt), { children: Ye });
            ct && (ct.item[Ye] = I.clone(rt, !0)), rt.forEach((vt) => {
              const at = yt(be, vt);
              Se[at] = I.clone(vt, !0);
            });
          }
          return I.eachTree(rt, (pt, ct, vt, at, wt, Rt) => {
            const Zt = yt(be, pt), Wt = wt || lt.row, cn = { row: pt, rowid: Zt, seq: -1, index: ct, _index: -1, $index: -1, items: vt, parent: Wt, level: dt + Rt.length };
            se[Zt] = cn, ye[Zt] = cn;
          }, { children: Ye }), T[Ye] = rt, Be && (T[qe] = rt), rn(), rt;
        });
      },
      /**
       * 加载列配置
       * 对于表格列需要重载、局部递增场景下可能会用到
       * @param {ColumnInfo} columns 列配置
       */
      loadColumn(T) {
        const P = I.mapTree(T, (q) => en(nn.createColumn(be, q)));
        return zs(P);
      },
      /**
       * 加载列配置并恢复到初始状态
       * 对于表格列需要重载、局部递增场景下可能会用到
       * @param {ColumnInfo} columns 列配置
       */
      reloadColumn(T) {
        return d.clearAll().then(() => d.loadColumn(T));
      },
      /**
       * 根据 tr 元素获取对应的 row 信息
       * @param {Element} tr 元素
       */
      getRowNode(T) {
        if (T) {
          const { fullAllDataRowIdData: P } = u, q = T.getAttribute("rowid");
          if (q) {
            const J = P[q];
            if (J)
              return { rowid: J.rowid, item: J.row, index: J.index, items: J.items, parent: J.parent };
          }
        }
        return null;
      },
      /**
       * 根据 th/td 元素获取对应的 column 信息
       * @param {Element} cell 元素
       */
      getColumnNode(T) {
        if (T) {
          const { fullColumnIdData: P } = u, q = T.getAttribute("colid");
          if (q) {
            const J = P[q];
            if (J)
              return { colid: J.colid, item: J.column, index: J.index, items: J.items, parent: J.parent };
          }
        }
        return null;
      },
      /**
       * 根据 row 获取序号
       * @param {Row} row 行对象
       */
      getRowSeq: Ui("seq"),
      /**
       * 根据 row 获取相对于 data 中的索引
       * @param {Row} row 行对象
       */
      getRowIndex: Ui("index"),
      /**
       * 根据 row 获取相对于当前数据中的索引
       * @param {Row} row 行对象
       */
      getVTRowIndex: Ui("_index"),
      /**
       * 根据 row 获取渲染中的虚拟索引
       * @param {Row} row 行对象
       */
      getVMRowIndex: Ui("$index"),
      /**
       * 根据 column 获取相对于 columns 中的索引
       * @param {ColumnInfo} column 列配置
       */
      getColumnIndex: Cr("index"),
      /**
       * 根据 column 获取相对于当前表格列中的索引
       * @param {ColumnInfo} column 列配置
       */
      getVTColumnIndex: Cr("_index"),
      /**
       * 根据 column 获取渲染中的虚拟索引
       * @param {ColumnInfo} column 列配置
       */
      getVMColumnIndex: Cr("$index"),
      /**
       * 创建 data 对象
       * 对于某些特殊场景可能会用到，会自动对数据的字段名进行检测，如果不存在就自动定义
       * @param {Array} records 新数据
       */
      createData(T) {
        return xe().then(() => en(f.defineField(T)));
      },
      /**
       * 创建 Row|Rows 对象
       * 对于某些特殊场景需要对数据进行手动插入时可能会用到
       * @param {Array/Object} records 新数据
       */
      createRow(T) {
        const P = I.isArray(T);
        return P || (T = [T || {}]), d.createData(T).then((q) => P ? q : q[0]);
      },
      /**
       * 还原数据
       * 如果不传任何参数，则还原整个表格
       * 如果传 row 则还原一行
       * 如果传 rows 则还原多行
       * 如果还额外传了 field 则还原指定的单元格数据
       */
      revertData(T, P) {
        const { keepSource: q } = e, { tableSourceData: J, sourceDataRowIdData: se } = u;
        if (!q)
          return process.env.NODE_ENV === "development" && qt("vxe.error.reqProp", ["keep-source"]), xe();
        let ye = T;
        return T ? I.isArray(T) || (ye = [T]) : ye = I.toArray(be.getUpdateRecords()), ye.length && ye.forEach((Se) => {
          if (!d.isInsertByRow(Se)) {
            const He = yt(be, Se), Be = se[He];
            Be && Se && (P ? I.set(Se, P, I.clone(I.get(Be, P), !0)) : I.destructuring(Se, I.clone(Be, !0)));
          }
        }), T ? xe() : d.reloadData(J);
      },
      /**
       * 清空单元格内容
       * 如果不创参数，则清空整个表格内容
       * 如果传 row 则清空一行内容
       * 如果传 rows 则清空多行内容
       * 如果还额外传了 field 则清空指定单元格内容
       * @param {Array/Row} rows 行数据
       * @param {String} field 字段名
       */
      clearData(T, P) {
        const { tableFullData: q, visibleColumn: J } = u;
        return arguments.length ? T && !I.isArray(T) && (T = [T]) : T = q, P ? T.forEach((se) => I.set(se, P, null)) : T.forEach((se) => {
          J.forEach((ye) => {
            ye.field && Or(se, ye, null);
          });
        }), xe();
      },
      /**
       * 检查是否为临时行数据
       * @param {Row} row 行对象
       */
      isInsertByRow(T) {
        const { editStore: P } = s, q = yt(be, T);
        return P.insertMaps[q];
      },
      /**
       * 删除所有新增的临时数据
       * @returns
       */
      removeInsertRow() {
        const { editStore: T } = s;
        return T.insertMaps = {}, be.remove(be.getInsertRecords());
      },
      /**
       * 检查行或列数据是否发生改变
       * @param {Row} row 行对象
       * @param {String} field 字段名
       */
      isUpdateByRow(T, P) {
        const { keepSource: q } = e, { tableFullColumn: J, fullDataRowIdData: se, sourceDataRowIdData: ye } = u;
        if (q) {
          const Se = yt(be, T);
          if (!se[Se])
            return !1;
          const He = ye[Se];
          if (He) {
            if (arguments.length > 1)
              return !an(He, T, P);
            for (let Be = 0, qe = J.length; Be < qe; Be++) {
              const Ye = J[Be].field;
              if (Ye && !an(He, T, Ye))
                return !0;
            }
          }
        }
        return !1;
      },
      /**
       * 获取表格的可视列，也可以指定索引获取列
       * @param {Number} columnIndex 索引
       */
      getColumns(T) {
        const P = u.visibleColumn;
        return I.isUndefined(T) ? P.slice(0) : P[T];
      },
      /**
       * 根据列的唯一主键获取列
       * @param {String} colid 列主键
       */
      getColumnById(T) {
        const P = u.fullColumnIdData;
        return T && P[T] ? P[T].column : null;
      },
      /**
       * 根据列的字段名获取列
       * @param {String} field 字段名
       */
      getColumnByField(T) {
        const P = u.fullColumnFieldData;
        return T && P[T] ? P[T].column : null;
      },
      /**
       * 获取当前表格的列
       * 收集到的全量列、全量表头列、处理条件之后的全量表头列、当前渲染中的表头列
       */
      getTableColumn() {
        return {
          collectColumn: u.collectColumn.slice(0),
          fullColumn: u.tableFullColumn.slice(0),
          visibleColumn: u.visibleColumn.slice(0),
          tableColumn: s.tableColumn.slice(0)
        };
      },
      /**
       * 获取数据，和 data 的行为一致，也可以指定索引获取数据
       */
      getData(T) {
        const P = e.data || u.tableSynchData;
        return I.isUndefined(T) ? P.slice(0) : P[T];
      },
      /**
       * 用于多选行，获取已选中的数据
       */
      getCheckboxRecords(T) {
        const { treeConfig: P } = e, { tableFullData: q, afterFullData: J, afterTreeFullData: se, tableFullTreeData: ye, fullDataRowIdData: Se, afterFullRowMaps: He } = u, Be = Ee.value, qe = Y.value, { transform: Ye, mapChildrenField: lt } = Be, { checkField: dt } = qe, rt = Be.children || Be.childrenField;
        let pt = [];
        const ct = T ? Ye ? ye : q : Ye ? se : J;
        if (dt)
          P ? pt = I.filterTree(ct, (vt) => I.get(vt, dt), { children: Ye ? lt : rt }) : pt = ct.filter((vt) => I.get(vt, dt));
        else {
          const { selectCheckboxMaps: vt } = s;
          I.each(vt, (at, wt) => {
            (T ? Se[wt] : He[wt]) && pt.push(at);
          });
        }
        return pt;
      },
      /**
       * 只对 tree-config 有效，获取行的父级
       */
      getParentRow(T) {
        const { treeConfig: P } = e, { fullDataRowIdData: q } = u;
        if (T && P) {
          let J;
          if (I.isString(T) ? J = T : J = yt(be, T), J) {
            const se = q[J];
            return se ? se.parent : null;
          }
        }
        return null;
      },
      /**
       * 根据行的唯一主键获取行
       * @param {String/Number} rowid 行主键
       */
      getRowById(T) {
        const { fullDataRowIdData: P } = u, q = I.eqNull(T) ? "" : encodeURIComponent(T || "");
        return P[q] ? P[q].row : null;
      },
      /**
       * 根据行获取行的唯一主键
       * @param {Row} row 行对象
       */
      getRowid(T) {
        return yt(be, T);
      },
      /**
       * 获取处理后的表格数据
       * 如果存在筛选条件，继续处理
       * 如果存在排序，继续处理
       */
      getTableData() {
        const { tableData: T, footerTableData: P } = s, { tableFullData: q, afterFullData: J, tableFullTreeData: se } = u;
        return {
          fullData: e.treeConfig ? se.slice(0) : q.slice(0),
          visibleData: J.slice(0),
          tableData: T.slice(0),
          footerData: P.slice(0)
        };
      },
      /**
       * 设置为固定列
       */
      setColumnFixed(T, P) {
        const q = El(be, T), J = S_(be, q), se = Je.value, ye = Z.value, { maxFixedSize: Se } = ye;
        return J && J.fixed !== P ? !J.fixed && se ? ($t.modal && $t.modal.message({
          status: "error",
          content: ee.i18n("vxe.table.maxFixedCol", [Se])
        }), xe()) : (I.eachTree([J], (He) => {
          He.fixed = P;
        }), f.saveCustomFixed(), d.refreshColumn()) : xe();
      },
      /**
       * 取消指定固定列
       */
      clearColumnFixed(T) {
        const P = El(be, T), q = S_(be, P);
        return q && q.fixed ? (I.eachTree([q], (J) => {
          J.fixed = null;
        }), f.saveCustomFixed(), d.refreshColumn()) : xe();
      },
      /**
       * 隐藏指定列
       */
      hideColumn(T) {
        const P = El(be, T);
        return P && P.visible ? (P.visible = !1, f.handleCustom()) : xe();
      },
      /**
       * 显示指定列
       */
      showColumn(T) {
        const P = El(be, T);
        return P && !P.visible ? (P.visible = !0, f.handleCustom()) : xe();
      },
      setColumnWidth(T, P) {
        const q = El(be, T);
        if (q) {
          const J = I.toInteger(P);
          let se = J;
          if (Uu(P)) {
            const ye = y.value, Se = ye ? ye.$el : null, He = Se ? Se.clientWidth - 1 : 0;
            se = Math.floor(J * He);
          }
          q.renderWidth = se;
        }
        return xe();
      },
      getColumnWidth(T) {
        const P = El(be, T);
        return P ? P.renderWidth : 0;
      },
      /**
       * 手动重置列的显示隐藏、列宽拖动的状态、固定列、排序列；
       * 如果为 true 则重置所有状态
       * 如果已关联工具栏，则会同步更新
       */
      resetColumn(T) {
        const { collectColumn: P } = u, q = we.value, { checkMethod: J } = q, se = Object.assign({
          visible: !0,
          resizable: T === !0,
          fixed: T === !0,
          sort: T === !0
        }, T);
        return I.eachTree(P, (ye) => {
          se.resizable && (ye.resizeWidth = 0), se.fixed && (ye.fixed = ye.defaultFixed), se.sort && (ye.renderSortNumber = ye.sortNumber), (!J || J({ column: ye })) && (ye.visible = ye.defaultVisible);
        }), se.resizable && f.saveCustomResizable(!0), se.sort && f.saveCustomSort(!0), se.fixed && f.saveCustomFixed(), f.handleCustom();
      },
      /**
       * 刷新列信息
       * 将固定的列左边、右边分别靠边
       * 如果传 true 则会检查列顺序并排序
       */
      refreshColumn(T) {
        if (T) {
          const P = I.orderBy(u.collectColumn, "renderSortNumber");
          u.collectColumn = P;
          const q = Un(P);
          u.tableFullColumn = q, eo();
        }
        return Jo().then(() => d.refreshScroll()).then(() => d.recalculate());
      },
      /**
       * 刷新滚动操作，手动同步滚动相关位置（对于某些特殊的操作，比如滚动条错位、固定列不同步）
       */
      refreshScroll() {
        const { lastScrollLeft: T, lastScrollTop: P } = u, q = y.value, J = E.value, se = _.value, ye = L.value, Se = q ? q.$el : null, He = se ? se.$el : null, Be = ye ? ye.$el : null, qe = J ? J.$el : null;
        return new Promise((Ye) => {
          if (T || P)
            return Im(be, T, P).then().then(() => {
              setTimeout(Ye, 30);
            });
          sp(Se, P), sp(He, P), sp(Be, P), y_(qe, T), setTimeout(Ye, 30);
        });
      },
      /**
       * 计算单元格列宽，动态分配可用剩余空间
       * 支持 width=? width=?px width=?% min-width=? min-width=?px min-width=?%
       */
      recalculate(T) {
        return st(), T === !0 ? Ga().then(() => (st(), Ga())) : Ga();
      },
      openTooltip(T, P) {
        const q = m.value;
        return q ? q.open(T, P) : xe();
      },
      /**
       * 关闭 tooltip
       */
      closeTooltip() {
        const { tooltipStore: T } = s, P = h.value, q = m.value;
        return T.visible && (Object.assign(T, {
          row: null,
          column: null,
          content: null,
          visible: !1
        }), P && P.close()), q && q.close(), xe();
      },
      /**
       * 判断列头复选框是否被选中
       */
      isAllCheckboxChecked() {
        return s.isAllSelected;
      },
      /**
       * 判断列头复选框是否被半选
       */
      isAllCheckboxIndeterminate() {
        return !s.isAllSelected && s.isIndeterminate;
      },
      /**
       * 获取复选框半选状态的行数据
       */
      getCheckboxIndeterminateRecords(T) {
        const { treeConfig: P } = e, { fullDataRowIdData: q } = u, { treeIndeterminateMaps: J } = s;
        if (P) {
          const se = [], ye = [];
          return I.each(J, (Se, He) => {
            Se && (se.push(Se), q[He] && ye.push(Se));
          }), T ? se : ye;
        }
        return [];
      },
      /**
       * 用于多选行，设置行为选中状态，第二个参数为选中与否
       * @param {Array/Row} rows 行数据
       * @param {Boolean} value 是否选中
       */
      setCheckboxRow(T, P) {
        return _o(T, P, !0);
      },
      isCheckedByCheckboxRow(T) {
        const { selectCheckboxMaps: P } = s, q = Y.value, { checkField: J } = q;
        return J ? I.get(T, J) : !!P[yt(be, T)];
      },
      isIndeterminateByCheckboxRow(T) {
        const { treeIndeterminateMaps: P } = s;
        return !!P[yt(be, T)] && !d.isCheckedByCheckboxRow(T);
      },
      /**
       * 多选，切换某一行的选中状态
       */
      toggleCheckboxRow(T) {
        const { selectCheckboxMaps: P } = s, q = Y.value, { checkField: J } = q, se = J ? !I.get(T, J) : !P[yt(be, T)];
        return f.handleSelectRow({ row: T }, se, !0), xe();
      },
      /**
       * 用于多选行，设置所有行的选中状态
       * @param {Boolean} value 是否选中
       */
      setAllCheckboxRow(T) {
        return No(T, !0);
      },
      /**
       * 获取单选框保留选中的行
       */
      getRadioReserveRecord(T) {
        const { treeConfig: P } = e, { fullDataRowIdData: q, radioReserveRow: J, afterFullData: se } = u, ye = ne.value, Se = Ee.value, He = Se.children || Se.childrenField;
        if (ye.reserve && J) {
          const Be = yt(be, J);
          if (T) {
            if (!q[Be])
              return J;
          } else {
            const qe = ti(be);
            if (P) {
              if (I.findTree(se, (lt) => Be === I.get(lt, qe), { children: He }))
                return J;
            } else if (!se.some((Ye) => Be === I.get(Ye, qe)))
              return J;
          }
        }
        return null;
      },
      clearRadioReserve() {
        return u.radioReserveRow = null, xe();
      },
      /**
       * 获取复选框保留选中的行
       */
      getCheckboxReserveRecords(T) {
        const { treeConfig: P } = e, { afterFullData: q, fullDataRowIdData: J, checkboxReserveRowMap: se } = u, ye = Y.value, Se = Ee.value, He = Se.children || Se.childrenField, Be = [];
        if (ye.reserve) {
          const qe = {};
          P ? I.eachTree(q, (Ye) => {
            qe[yt(be, Ye)] = 1;
          }, { children: He }) : q.forEach((Ye) => {
            qe[yt(be, Ye)] = 1;
          }), I.each(se, (Ye, lt) => {
            Ye && (T ? J[lt] || Be.push(Ye) : qe[lt] || Be.push(Ye));
          });
        }
        return Be;
      },
      clearCheckboxReserve() {
        return u.checkboxReserveRowMap = {}, xe();
      },
      /**
       * 多选，切换所有行的选中状态
       */
      toggleAllCheckboxRow() {
        return f.triggerCheckAllEvent(null, !s.isAllSelected), xe();
      },
      /**
       * 用于多选行，手动清空用户的选择
       * 清空行为不管是否被禁用还是保留记录，都将彻底清空选中状态
       */
      clearCheckboxRow() {
        const { treeConfig: T } = e, { tableFullData: P } = u, q = Ee.value, J = q.children || q.childrenField, se = Y.value, { checkField: ye, reserve: Se } = se, He = se.indeterminateField || se.halfField;
        if (ye) {
          const Be = (qe) => {
            T && He && I.set(qe, He, !1), I.set(qe, ye, !1);
          };
          T ? I.eachTree(P, Be, { children: J }) : P.forEach(Be);
        }
        return Se && P.forEach((Be) => Xt(Be, !1)), s.isAllSelected = !1, s.isIndeterminate = !1, s.selectCheckboxMaps = {}, s.treeIndeterminateMaps = {}, xe();
      },
      /**
       * 用于当前行，设置某一行为高亮状态
       * @param {Row} row 行对象
       */
      setCurrentRow(T) {
        const P = te.value, q = v.value;
        return d.clearCurrentRow(), s.currentRow = T, (P.isCurrent || e.highlightCurrentRow) && q && I.arrayEach(q.querySelectorAll(`[rowid="${yt(be, T)}"]`), (J) => Mr(J, "row--current")), xe();
      },
      isCheckedByRadioRow(T) {
        return be.eqRow(s.selectRadioRow, T);
      },
      /**
       * 用于单选行，设置某一行为选中状态
       * @param {Row} row 行对象
       */
      setRadioRow(T) {
        return sn(T, !0);
      },
      /**
       * 用于当前行，手动清空当前高亮的状态
       */
      clearCurrentRow() {
        const T = v.value;
        return s.currentRow = null, u.hoverRow = null, T && I.arrayEach(T.querySelectorAll(".row--current"), (P) => Xl(P, "row--current")), xe();
      },
      /**
       * 用于单选行，手动清空用户的选择
       */
      clearRadioRow() {
        return s.selectRadioRow = null, xe();
      },
      /**
       * 用于当前行，获取当前行的数据
       */
      getCurrentRecord() {
        return te.value.isCurrent || e.highlightCurrentRow ? s.currentRow : null;
      },
      /**
       * 用于单选行，获取当已选中的数据
       */
      getRadioRecord(T) {
        const { fullDataRowIdData: P, afterFullRowMaps: q } = u, { selectRadioRow: J } = s;
        if (J) {
          const se = yt(be, J);
          if (T) {
            if (P[se])
              return J;
          } else if (q[se])
            return J;
        }
        return null;
      },
      getCurrentColumn() {
        return Z.value.isCurrent || e.highlightCurrentColumn ? s.currentColumn : null;
      },
      /**
       * 用于当前列，设置某列行为高亮状态
       */
      setCurrentColumn(T) {
        const P = El(be, T);
        return P && (d.clearCurrentColumn(), s.currentColumn = P), xe();
      },
      /**
       * 用于当前列，手动清空当前高亮的状态
       */
      clearCurrentColumn() {
        return s.currentColumn = null, xe();
      },
      setPendingRow(T, P) {
        const q = { ...s.pendingRowMaps }, J = [...s.pendingRowList];
        return T && !I.isArray(T) && (T = [T]), P ? T.forEach((se) => {
          const ye = yt(be, se);
          ye && !q[ye] && (J.push(se), q[ye] = se);
        }) : T.forEach((se) => {
          const ye = yt(be, se);
          if (ye && q[ye]) {
            const Se = be.findRowIndexOf(J, se);
            Se > -1 && J.splice(Se, 1), delete q[ye];
          }
        }), s.pendingRowMaps = q, s.pendingRowList = J, xe();
      },
      togglePendingRow(T) {
        const P = { ...s.pendingRowMaps }, q = [...s.pendingRowList];
        return T && !I.isArray(T) && (T = [T]), T.forEach((J) => {
          const se = yt(be, J);
          if (se)
            if (P[se]) {
              const ye = be.findRowIndexOf(q, J);
              ye > -1 && q.splice(ye, 1), delete P[se];
            } else
              q.push(J), P[se] = J;
        }), s.pendingRowMaps = P, s.pendingRowList = q, xe();
      },
      hasPendingByRow(T) {
        const { pendingRowMaps: P } = s, q = yt(be, T);
        return !!P[q];
      },
      getPendingRecords() {
        const { pendingRowList: T } = s;
        return T.slice(0);
      },
      clearPendingRow() {
        return s.pendingRowMaps = {}, s.pendingRowList = [], xe();
      },
      sort(T, P) {
        const q = $e.value, { multiple: J, remote: se, orders: ye } = q;
        return T && I.isString(T) && (T = [
          { field: T, order: P }
        ]), I.isArray(T) || (T = [T]), T.length ? (J || Vn(), (J ? T : [T[0]]).forEach((Se, He) => {
          let { field: Be, order: qe } = Se, Ye = Be;
          I.isString(Be) && (Ye = d.getColumnByField(Be)), Ye && Ye.sortable && (ye.indexOf(qe) === -1 && (qe = _t(Ye)), Ye.order !== qe && (Ye.order = qe), Ye.sortTime = Date.now() + He);
        }), se || f.handleTableData(!0), xe().then(() => (d.updateCellAreas(), ro()))) : xe();
      },
      /**
       * 清空指定列的排序条件
       * 如果为空则清空所有列的排序条件
       * @param {String} fieldOrColumn 列或字段名
       */
      clearSort(T) {
        const P = $e.value;
        if (T) {
          const q = El(be, T);
          q && (q.order = null);
        } else
          Vn();
        return P.remote || f.handleTableData(!0), xe().then(ro);
      },
      isSort(T) {
        if (T) {
          const P = El(be, T);
          return P ? P.sortable && !!P.order : !1;
        }
        return d.getSortColumns().length > 0;
      },
      getSortColumns() {
        const T = $e.value, { multiple: P, chronological: q } = T, J = [], { tableFullColumn: se } = u;
        return se.forEach((ye) => {
          const { field: Se, order: He } = ye;
          ye.sortable && He && J.push({ column: ye, field: Se, property: Se, order: He, sortTime: ye.sortTime });
        }), P && q && J.length > 1 ? I.orderBy(J, "sortTime") : J;
      },
      /**
       * 关闭筛选
       * @param {Event} evnt 事件
       */
      closeFilter() {
        const { filterStore: T } = s, { column: P, visible: q } = T;
        return Object.assign(T, {
          isAllSelected: !1,
          isIndeterminate: !1,
          options: [],
          visible: !1
        }), q && be.dispatchEvent("filter-visible", { column: P, property: P.field, field: P.field, filterList: be.getCheckedFilters(), visible: !1 }, null), xe();
      },
      /**
       * 判断指定列是否为筛选状态，如果为空则判断所有列
       * @param {String} fieldOrColumn 字段名
       */
      isActiveFilterByColumn(T) {
        const P = El(be, T);
        return P ? P.filters && P.filters.some((q) => q.checked) : be.getCheckedFilters().length > 0;
      },
      isFilter(T) {
        return d.isActiveFilterByColumn(T);
      },
      /**
       * 判断展开行是否懒加载完成
       * @param {Row} row 行对象
       */
      isRowExpandLoaded(T) {
        const { fullAllDataRowIdData: P } = u, q = P[yt(be, T)];
        return q && !!q.expandLoaded;
      },
      clearRowExpandLoaded(T) {
        const { rowExpandLazyLoadedMaps: P } = s, { fullAllDataRowIdData: q } = u, J = ge.value, { lazy: se } = J, ye = yt(be, T), Se = q[ye];
        return se && Se && (Se.expandLoaded = !1, delete P[ye]), xe();
      },
      /**
       * 重新懒加载展开行，并展开内容
       * @param {Row} row 行对象
       */
      reloadRowExpand(T) {
        const { rowExpandLazyLoadedMaps: P } = s, q = ge.value, { lazy: J } = q, se = yt(be, T);
        return J && !P[se] && d.clearRowExpandLoaded(T).then(() => cl(T)), xe();
      },
      reloadExpandContent(T) {
        return process.env.NODE_ENV === "development" && qt("vxe.error.delFunc", ["reloadExpandContent", "reloadRowExpand"]), d.reloadRowExpand(T);
      },
      /**
       * 切换展开行
       */
      toggleRowExpand(T) {
        return d.setRowExpand(T, !d.isRowExpandByRow(T));
      },
      /**
       * 设置所有行的展开与否
       * @param {Boolean} expanded 是否展开
       */
      setAllRowExpand(T) {
        const P = Ee.value, { tableFullData: q, tableFullTreeData: J } = u, se = P.children || P.childrenField;
        let ye = [];
        return e.treeConfig ? I.eachTree(J, (Se) => {
          ye.push(Se);
        }, { children: se }) : ye = q, d.setRowExpand(ye, T);
      },
      /**
       * 设置展开行，二个参数设置这一行展开与否
       * 支持单行
       * 支持多行
       * @param {Array/Row} rows 行数据
       * @param {Boolean} expanded 是否展开
       */
      setRowExpand(T, P) {
        const { rowExpandedMaps: q, rowExpandLazyLoadedMaps: J, expandColumn: se } = s, { fullAllDataRowIdData: ye } = u;
        let Se = { ...q };
        const He = ge.value, { reserve: Be, lazy: qe, accordion: Ye, toggleMethod: lt } = He, dt = [], rt = d.getColumnIndex(se), pt = d.getVMColumnIndex(se);
        if (T) {
          I.isArray(T) || (T = [T]), Ye && (Se = {}, T = T.slice(T.length - 1, T.length));
          const ct = lt ? T.filter((vt) => lt({ $table: be, expanded: P, column: se, columnIndex: rt, $columnIndex: pt, row: vt, rowIndex: d.getRowIndex(vt), $rowIndex: d.getVMRowIndex(vt) })) : T;
          P ? ct.forEach((vt) => {
            const at = yt(be, vt);
            if (!Se[at]) {
              const wt = ye[at];
              qe && !wt.expandLoaded && !J[at] ? dt.push(cl(vt)) : Se[at] = vt;
            }
          }) : ct.forEach((vt) => {
            const at = yt(be, vt);
            Se[at] && delete Se[at];
          }), Be && ct.forEach((vt) => sa(vt, P));
        }
        return s.rowExpandedMaps = Se, Promise.all(dt).then(() => d.recalculate());
      },
      /**
       * 判断行是否为展开状态
       * @param {Row} row 行对象
       */
      isRowExpandByRow(T) {
        const { rowExpandedMaps: P } = s, q = yt(be, T);
        return !!P[q];
      },
      isExpandByRow(T) {
        return process.env.NODE_ENV === "development" && qt("vxe.error.delFunc", ["isExpandByRow", "isRowExpandByRow"]), d.isRowExpandByRow(T);
      },
      /**
       * 手动清空展开行状态，数据会恢复成未展开的状态
       */
      clearRowExpand() {
        const { tableFullData: T } = u, P = ge.value, { reserve: q } = P, J = d.getRowExpandRecords();
        return s.rowExpandedMaps = {}, q && T.forEach((se) => sa(se, !1)), xe().then(() => {
          J.length && d.recalculate();
        });
      },
      clearRowExpandReserve() {
        return u.rowExpandedReserveRowMap = {}, xe();
      },
      getRowExpandRecords() {
        const T = [];
        return I.each(s.rowExpandedMaps, (P) => {
          P && T.push(P);
        }), T;
      },
      getTreeExpandRecords() {
        const T = [];
        return I.each(s.treeExpandedMaps, (P) => {
          P && T.push(P);
        }), T;
      },
      /**
       * 判断树节点是否懒加载完成
       * @param {Row} row 行对象
       */
      isTreeExpandLoaded(T) {
        const { fullAllDataRowIdData: P } = u, q = P[yt(be, T)];
        return q && !!q.treeLoaded;
      },
      clearTreeExpandLoaded(T) {
        const { treeExpandedMaps: P } = s, { fullAllDataRowIdData: q } = u, J = Ee.value, { transform: se, lazy: ye } = J, Se = yt(be, T), He = q[Se];
        return ye && He && (He.treeLoaded = !1, P[Se] && delete P[Se]), se ? (Tn(), f.handleTableData()) : xe();
      },
      /**
       * 重新懒加载树节点，并展开该节点
       * @param {Row} row 行对象
       */
      reloadTreeExpand(T) {
        const { treeExpandLazyLoadedMaps: P } = s, q = Ee.value, J = q.hasChild || q.hasChildField, { transform: se, lazy: ye } = q, Se = yt(be, T);
        return ye && T[J] && !P[Se] && d.clearTreeExpandLoaded(T).then(() => qa(T)).then(() => {
          if (se)
            return Tn(), f.handleTableData();
        }).then(() => d.recalculate()), xe();
      },
      reloadTreeChilds(T) {
        return process.env.NODE_ENV === "development" && qt("vxe.error.delFunc", ["reloadTreeChilds", "reloadTreeExpand"]), d.reloadTreeExpand(T);
      },
      /**
       * 切换/展开树节点
       */
      toggleTreeExpand(T) {
        return d.setTreeExpand(T, !d.isTreeExpandByRow(T));
      },
      /**
       * 设置所有树节点的展开与否
       * @param {Boolean} expanded 是否展开
       */
      setAllTreeExpand(T) {
        const { tableFullData: P } = u, q = Ee.value, { transform: J, lazy: se } = q, ye = q.children || q.childrenField, Se = [];
        return I.eachTree(P, (He) => {
          const Be = He[ye];
          (se || Be && Be.length) && Se.push(He);
        }, { children: ye }), d.setTreeExpand(Se, T).then(() => {
          if (J)
            return Tn(), d.recalculate();
        });
      },
      /**
       * 设置展开树形节点，二个参数设置这一行展开与否
       * 支持单行
       * 支持多行
       * @param {Array/Row} rows 行数据
       * @param {Boolean} expanded 是否展开
       */
      setTreeExpand(T, P) {
        const q = Ee.value, { transform: J } = q;
        return T && (I.isArray(T) || (T = [T]), T.length) ? J ? xh(T, P) : Of(T, P) : xe();
      },
      /**
       * 判断行是否为树形节点展开状态
       * @param {Row} row 行对象
       */
      isTreeExpandByRow(T) {
        const { treeExpandedMaps: P } = s;
        return !!P[yt(be, T)];
      },
      /**
       * 手动清空树形节点的展开状态，数据会恢复成未展开的状态
       */
      clearTreeExpand() {
        const { tableFullTreeData: T } = u, P = Ee.value, q = P.children || P.childrenField, { transform: J, reserve: se } = P, ye = d.getTreeExpandRecords();
        return s.treeExpandedMaps = {}, se && I.eachTree(T, (Se) => ra(Se, !1), { children: q }), f.handleTableData().then(() => {
          if (J)
            return Tn(), f.handleTableData();
        }).then(() => {
          if (ye.length)
            return d.recalculate();
        });
      },
      clearTreeExpandReserve() {
        return u.treeExpandedReserveRowMap = {}, xe();
      },
      /**
       * 获取表格的滚动状态
       */
      getScroll() {
        const { scrollXLoad: T, scrollYLoad: P } = s, J = y.value.$el;
        return {
          virtualX: T,
          virtualY: P,
          scrollTop: J.scrollTop,
          scrollLeft: J.scrollLeft
        };
      },
      /**
       * 如果有滚动条，则滚动到对应的位置
       * @param {Number} scrollLeft 左距离
       * @param {Number} scrollTop 上距离
       */
      scrollTo(T, P) {
        const q = y.value, J = E.value, se = L.value, ye = q ? q.$el : null, Se = se ? se.$el : null, He = J ? J.$el : null;
        return I.isNumber(T) && y_(He || ye, T), I.isNumber(P) && sp(Se || ye, P), s.scrollXLoad || s.scrollYLoad ? new Promise((Be) => {
          setTimeout(() => {
            xe(() => {
              Be();
            });
          }, 50);
        }) : xe();
      },
      /**
       * 如果有滚动条，则滚动到对应的行
       * @param {Row} row 行对象
       * @param {ColumnInfo} fieldOrColumn 列配置
       */
      scrollToRow(T, P) {
        const q = [];
        return T && (e.treeConfig ? q.push(f.scrollToTreeRow(T)) : q.push(__(be, T))), P && q.push(d.scrollToColumn(P)), Promise.all(q);
      },
      /**
       * 如果有滚动条，则滚动到对应的列
       */
      scrollToColumn(T) {
        const { fullColumnIdData: P } = u, q = El(be, T);
        return q && P[q.id] ? QCe(be, q) : xe();
      },
      /**
       * 手动清除滚动相关信息，还原到初始状态
       */
      clearScroll() {
        const { scrollXStore: T, scrollYStore: P } = u, q = y.value, J = E.value, se = L.value, ye = q ? q.$el : null, Se = se ? se.$el : null, He = J ? J.$el : null;
        return Se && (pv(Se), Se.scrollTop = 0), He && (He.scrollLeft = 0), ye && (pv(ye), ye.scrollTop = 0, ye.scrollLeft = 0), T.startIndex = 0, P.startIndex = 0, xe();
      },
      /**
       * 更新表尾合计
       */
      updateFooter() {
        const { showFooter: T, footerData: P, footerMethod: q } = e, { visibleColumn: J, afterFullData: se } = u;
        let ye = [];
        return T && P && P.length ? ye = P.slice(0) : T && q && (ye = J.length ? q({ columns: J, data: se, $table: be, $grid: A }) : []), s.footerTableData = ye, xe();
      },
      /**
       * 更新列状态 updateStatus({ row, column }, cellValue)
       * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一列编辑状态
       * 如果单元格配置了校验规则，则会进行校验
       */
      updateStatus(T, P) {
        const q = !I.isUndefined(P);
        return xe().then(() => {
          const { editRules: J } = e, { validStore: se } = s, ye = y.value;
          if (T && ye && J) {
            const { row: Se, column: He } = T, Be = "change";
            if (be.hasCellRules && be.hasCellRules(Be, Se, He)) {
              const qe = f.getCell(Se, He);
              if (qe)
                return be.validCellRules(Be, Se, He, P).then(() => {
                  q && se.visible && Or(Se, He, P), be.clearValidate(Se, He);
                }).catch(({ rule: Ye }) => {
                  q && Or(Se, He, P), be.showValidTooltip({ rule: Ye, row: Se, column: He, cell: qe });
                });
            }
          }
        });
      },
      /**
       * 设置合并单元格
       * @param {TableMergeConfig[]} merges { row: Row|number, column: ColumnInfo|number, rowspan: number, colspan: number }
       */
      setMergeCells(T) {
        return e.spanMethod && Ht("vxe.error.errConflicts", ["merge-cells", "span-method"]), kn(T, s.mergeList, u.afterFullData), xe().then(() => d.updateCellAreas());
      },
      /**
       * 移除单元格合并
       * @param {TableMergeConfig[]} merges 多个或数组 [{row:Row|number, col:ColumnInfo|number}]
       */
      removeMergeCells(T) {
        e.spanMethod && Ht("vxe.error.errConflicts", ["merge-cells", "span-method"]);
        const P = Wn(T, s.mergeList, u.afterFullData);
        return xe().then(() => (d.updateCellAreas(), P));
      },
      /**
       * 获取所有被合并的单元格
       */
      getMergeCells() {
        return s.mergeList.slice(0);
      },
      /**
       * 清除所有单元格合并
       */
      clearMergeCells() {
        return s.mergeList = [], xe();
      },
      setMergeFooterItems(T) {
        return e.footerSpanMethod && Ht("vxe.error.errConflicts", ["merge-footer-items", "footer-span-method"]), kn(T, s.mergeFooterList), xe().then(() => d.updateCellAreas());
      },
      removeMergeFooterItems(T) {
        e.footerSpanMethod && Ht("vxe.error.errConflicts", ["merge-footer-items", "footer-span-method"]);
        const P = Wn(T, s.mergeFooterList);
        return xe().then(() => (d.updateCellAreas(), P));
      },
      /**
       * 获取所有被合并的表尾
       */
      getMergeFooterItems() {
        return s.mergeFooterList.slice(0);
      },
      /**
       * 清除所有表尾合并
       */
      clearMergeFooterItems() {
        return s.mergeFooterList = [], xe();
      },
      updateCellAreas() {
        const { mouseConfig: T } = e, P = Ne.value;
        return T && P.area && be.handleUpdateCellAreas ? be.handleUpdateCellAreas() : xe();
      },
      focus() {
        return u.isActivated = !0, xe();
      },
      blur() {
        return u.isActivated = !1, xe();
      },
      /**
       * 连接工具栏
       * @param $toolbar
       */
      connect(T) {
        return T ? ($ = T, $.syncUpdate({ collectColumn: u.collectColumn, $table: be })) : Ht("vxe.error.barUnableLink"), xe();
      }
    };
    const Th = (T) => {
      const { editStore: P, ctxMenuStore: q, filterStore: J, customStore: se } = s, { mouseConfig: ye, editRules: Se } = e, He = v.value, Be = De.value, qe = D.value, Ye = je.value, { actived: lt } = P, dt = p.value, rt = g.value, pt = w.value, ct = C.value;
      if (rt && (_n(T, He, "vxe-cell--filter").flag || _n(T, rt.$el).flag || _n(T, document.body, "vxe-table--ignore-clear").flag || f.preventEvent(T, "event.clearFilter", J.args, d.closeFilter)), pt && (se.btnEl === T.target || _n(T, document.body, "vxe-toolbar-custom-target").flag || _n(T, pt.$el).flag || _n(T, document.body, "vxe-table--ignore-clear").flag || f.preventEvent(T, "event.clearCustom", {}, () => {
        be.closeCustom && be.closeCustom();
      })), lt.row) {
        if (Be.autoClear !== !1) {
          const at = lt.args.cell;
          (!at || !_n(T, at).flag) && (dt && _n(T, dt.$el).flag || (!u._lastCallTime || u._lastCallTime + 50 < Date.now()) && (_n(T, document.body, "vxe-table--ignore-clear").flag || f.preventEvent(T, "event.clearEdit", lt.args, () => {
            let wt;
            if (Be.mode === "row") {
              const Rt = _n(T, He, "vxe-body--row"), Zt = Rt.flag ? d.getRowNode(Rt.targetElem) : null;
              wt = Zt ? !be.eqRow(Zt.item, lt.args.row) : !1;
            } else
              wt = !_n(T, He, "col--edit").flag;
            if (wt || (wt = _n(T, He, "vxe-header--row").flag), wt || (wt = _n(T, He, "vxe-footer--row").flag), !wt && e.height && !s.overflowY) {
              const Rt = T.target;
              Ar(Rt, "vxe-table--body-wrapper") && (wt = T.offsetY < Rt.clientHeight);
            }
            (wt || // 如果点击了当前表格之外
            !_n(T, He).flag) && setTimeout(() => be.clearEdit(T));
          })));
        }
      } else
        ye && !_n(T, He).flag && !(A && _n(T, A.getRefMaps().refElem.value).flag) && !(ct && _n(T, ct.getRefMaps().refElem.value).flag) && !($ && _n(T, $.getRefMaps().refElem.value).flag) && (be.clearSelected && be.clearSelected(), Ye.autoClear && be.clearCellAreas && (_n(T, document.body, "vxe-table--ignore-areas-clear").flag || f.preventEvent(T, "event.clearAreas", {}, () => {
          be.clearCellAreas(), be.clearCopyCellArea();
        })));
      be.closeMenu && q.visible && ct && !_n(T, ct.getRefMaps().refElem.value).flag && be.closeMenu();
      const vt = _n(T, A ? A.getRefMaps().refElem.value : He).flag;
      !vt && Se && qe.autoClear && (s.validErrorMaps = {}), u.isActivated = vt;
    }, $h = () => {
      d.closeFilter(), be.closeMenu && be.closeMenu();
    }, Oh = () => {
      d.closeTooltip(), be.closeMenu && be.closeMenu();
    }, Nh = (T) => {
      const { mouseConfig: P, keyboardConfig: q } = e, { filterStore: J, ctxMenuStore: se, editStore: ye } = s, Se = Ne.value, He = Fe.value, { actived: Be } = ye;
      Cn(T, un.ESCAPE) && f.preventEvent(T, "event.keydown", null, () => {
        if (d.dispatchEvent("keydown-start", {}, T), q && P && Se.area && be.handleKeyboardEvent)
          be.handleKeyboardEvent(T);
        else if ((Be.row || J.visible || se.visible) && (T.stopPropagation(), be.closeMenu && be.closeMenu(), d.closeFilter(), q && He.isEsc && Be.row)) {
          const Ye = Be.args;
          be.clearEdit(T), Se.selected && xe(() => be.handleSelected(Ye, T));
        }
        d.dispatchEvent("keydown", {}, T), d.dispatchEvent("keydown-end", {}, T);
      });
    }, If = (T) => {
      u.isActivated && f.preventEvent(T, "event.keydown", null, () => {
        const { mouseConfig: P, keyboardConfig: q, treeConfig: J, editConfig: se, highlightCurrentRow: ye } = e, { ctxMenuStore: Se, editStore: He, currentRow: Be } = s, qe = Xe.value, Ye = ke.value, lt = Fe.value, dt = Ne.value, rt = De.value, pt = Ee.value, ct = re.value, vt = te.value, { selected: at, actived: wt } = He, Rt = pt.children || pt.childrenField, Zt = T.keyCode, Wt = Cn(T, un.ESCAPE), cn = Cn(T, un.BACKSPACE), In = Cn(T, un.TAB), to = Cn(T, un.ENTER), Bn = Cn(T, un.SPACEBAR), On = Cn(T, un.ARROW_LEFT), $n = Cn(T, un.ARROW_UP), io = Cn(T, un.ARROW_RIGHT), Qo = Cn(T, un.ARROW_DOWN), Ma = Cn(T, un.DELETE), qi = Cn(T, un.F2), Ws = Cn(T, un.CONTEXT_MENU), wu = T.metaKey, Ks = T.ctrlKey, wr = T.shiftKey, Us = T.altKey, js = On || $n || io || Qo, Kl = qe && Se.visible && (to || Bn || js), qs = mn(se) && wt.column && wt.row;
        let gl;
        if (Kl)
          T.preventDefault(), Se.showChild && wc(Se.selected) ? be.moveCtxMenu(T, Se, "selectChild", On, !1, Se.selected.children) : be.moveCtxMenu(T, Se, "selected", io, !0, ct);
        else if (q && P && dt.area && be.handleKeyboardEvent)
          be.handleKeyboardEvent(T);
        else if (Wt) {
          if (be.closeMenu && be.closeMenu(), d.closeFilter(), q && lt.isEsc && wt.row) {
            const qo = wt.args;
            be.clearEdit(T), dt.selected && xe(() => be.handleSelected(qo, T));
          }
        } else if (Bn && q && lt.isChecked && at.row && at.column && (at.column.type === "checkbox" || at.column.type === "radio"))
          T.preventDefault(), at.column.type === "checkbox" ? f.handleToggleCheckRowEvent(T, at.args) : f.triggerRadioRowEvent(T, at.args);
        else if (qi && mn(se))
          qs || at.row && at.column && (T.preventDefault(), be.handleActived(at.args, T));
        else if (Ws)
          u._keyCtx = at.row && at.column && Ye.length, clearTimeout(Mf), Mf = setTimeout(() => {
            u._keyCtx = !1;
          }, 1e3);
        else if (to && !Us && q && lt.isEnter && (at.row || wt.row || J && (vt.isCurrent || ye) && Be)) {
          if (Ks)
            wt.row && (gl = wt.args, be.clearEdit(T), dt.selected && xe(() => be.handleSelected(gl, T)));
          else if (at.row || wt.row) {
            const qo = at.row ? at.args : wt.args;
            wr ? lt.enterToTab ? be.moveTabSelected(qo, wr, T) : be.moveSelected(qo, On, !0, io, !1, T) : lt.enterToTab ? be.moveTabSelected(qo, wr, T) : be.moveSelected(qo, On, !1, io, !0, T);
          } else if (J && (vt.isCurrent || ye) && Be) {
            const qo = Be[Rt];
            if (qo && qo.length) {
              T.preventDefault();
              const Il = qo[0];
              gl = {
                $table: be,
                row: Il,
                rowIndex: d.getRowIndex(Il),
                $rowIndex: d.getVMRowIndex(Il)
              }, d.setTreeExpand(Be, !0).then(() => d.scrollToRow(Il)).then(() => f.triggerCurrentRowEvent(T, gl));
            }
          }
        } else if (js && q && lt.isArrow)
          qs || (at.row && at.column ? be.moveSelected(at.args, On, $n, io, Qo, T) : ($n || Qo) && (vt.isCurrent || ye) && be.moveCurrentRow($n, Qo, T));
        else if (In && q && lt.isTab)
          at.row || at.column ? be.moveTabSelected(at.args, wr, T) : (wt.row || wt.column) && be.moveTabSelected(wt.args, wr, T);
        else if (q && mn(se) && (Ma || (J && (vt.isCurrent || ye) && Be ? cn && lt.isArrow : cn))) {
          if (!qs) {
            const { delMethod: qo, backMethod: Il } = lt;
            if (lt.isDel && (at.row || at.column))
              qo ? qo({
                row: at.row,
                rowIndex: d.getRowIndex(at.row),
                column: at.column,
                columnIndex: d.getColumnIndex(at.column),
                $table: be
              }) : Or(at.row, at.column, null), cn ? Il ? Il({
                row: at.row,
                rowIndex: d.getRowIndex(at.row),
                column: at.column,
                columnIndex: d.getColumnIndex(at.column),
                $table: be
              }) : be.handleActived(at.args, T) : Ma && d.updateFooter();
            else if (cn && lt.isArrow && J && (vt.isCurrent || ye) && Be) {
              const { parent: bl } = I.findTree(u.afterFullData, (Ys) => Ys === Be, { children: Rt });
              bl && (T.preventDefault(), gl = {
                $table: be,
                row: bl,
                rowIndex: d.getRowIndex(bl),
                $rowIndex: d.getVMRowIndex(bl)
              }, d.setTreeExpand(bl, !1).then(() => d.scrollToRow(bl)).then(() => f.triggerCurrentRowEvent(T, gl)));
            }
          }
        } else if (q && mn(se) && lt.isEdit && !Ks && !wu && (Bn || Zt >= 48 && Zt <= 57 || Zt >= 65 && Zt <= 90 || Zt >= 96 && Zt <= 111 || Zt >= 186 && Zt <= 192 || Zt >= 219 && Zt <= 222)) {
          const { editMethod: qo } = lt;
          if (at.column && at.row && mn(at.column.editRender)) {
            const Il = rt.beforeEditMethod || rt.activeMethod;
            if (!Il || Il({ ...at.args, $table: be, $grid: A })) {
              qo ? qo({
                row: at.row,
                rowIndex: d.getRowIndex(at.row),
                column: at.column,
                columnIndex: d.getColumnIndex(at.column),
                $table: be,
                $grid: A
              }) : (Or(at.row, at.column, null), be.handleActived(at.args, T));
              const bl = rt.afterEditMethod;
              bl && xe(() => {
                bl({
                  row: at.row,
                  rowIndex: d.getRowIndex(at.row),
                  column: at.column,
                  columnIndex: d.getColumnIndex(at.column),
                  $table: be,
                  $grid: A
                });
              });
            }
          }
        }
        d.dispatchEvent("keydown", {}, T);
      });
    }, Rf = (T) => {
      const { keyboardConfig: P, mouseConfig: q } = e, { editStore: J, filterStore: se } = s, { isActivated: ye } = u, Se = Ne.value, He = Fe.value, { actived: Be } = J;
      ye && !se.visible && (Be.row || Be.column || P && He.isClip && q && Se.area && be.handlePasteCellAreaEvent && be.handlePasteCellAreaEvent(T), d.dispatchEvent("paste", {}, T));
    }, Mh = (T) => {
      const { keyboardConfig: P, mouseConfig: q } = e, { editStore: J, filterStore: se } = s, { isActivated: ye } = u, Se = Ne.value, He = Fe.value, { actived: Be } = J;
      ye && !se.visible && (Be.row || Be.column || P && He.isClip && q && Se.area && be.handleCopyCellAreaEvent && be.handleCopyCellAreaEvent(T), d.dispatchEvent("copy", {}, T));
    }, Ih = (T) => {
      const { keyboardConfig: P, mouseConfig: q } = e, { editStore: J, filterStore: se } = s, { isActivated: ye } = u, Se = Ne.value, He = Fe.value, { actived: Be } = J;
      ye && !se.visible && (Be.row || Be.column || P && He.isClip && q && Se.area && be.handleCutCellAreaEvent && be.handleCutCellAreaEvent(T), d.dispatchEvent("cut", {}, T));
    }, Rh = () => {
      be.closeMenu && be.closeMenu(), d.updateCellAreas(), d.recalculate(!0);
    }, ji = (T) => {
      const P = h.value;
      clearTimeout(u.tooltipTimeout), T ? d.closeTooltip() : P && P.setActived(!0);
    }, bu = (T, P, q, J, se) => {
      se.cell = P;
      const { tooltipStore: ye } = s, Se = ve.value, { column: He, row: Be } = se, { showAll: qe, contentMethod: Ye } = Se, lt = Ye ? Ye(se) : null, dt = Ye && !I.eqNull(lt), rt = dt ? lt : I.toString(He.type === "html" ? q.innerText : q.textContent).trim(), pt = q.scrollWidth > q.clientWidth;
      return rt && (qe || dt || pt) && (Object.assign(ye, {
        row: Be,
        column: He,
        visible: !0
      }), xe(() => {
        const ct = h.value;
        ct && ct.open(pt ? q : J || q, ko(rt));
      })), xe();
    };
    f = {
      getSetupOptions() {
        return ee;
      },
      updateAfterDataIndex: rn,
      callSlot(T, P) {
        if (T) {
          if (A)
            return A.callSlot(T, P);
          if (I.isFunction(T))
            return oo(T(P));
        }
        return [];
      },
      /**
       * 获取父容器元素
       */
      getParentElem() {
        const T = v.value;
        if (A) {
          const P = A.getRefMaps().refElem.value;
          return P ? P.parentNode : null;
        }
        return T ? T.parentNode : null;
      },
      /**
       * 获取父容器的高度
       */
      getParentHeight() {
        const { height: T } = e, P = v.value;
        if (P) {
          const q = P.parentNode, J = T === "auto" ? yb(q) : 0;
          return Math.floor(A ? A.getParentHeight() : I.toNumber(getComputedStyle(q).height) - J);
        }
        return 0;
      },
      /**
       * 获取需要排除的高度
       * 但渲染表格高度时，需要排除工具栏或分页等相关组件的高度
       * 如果存在表尾合计滚动条，则需要排除滚动条高度
       */
      getExcludeHeight() {
        return A ? A.getExcludeHeight() : 0;
      },
      /**
       * 定义行数据中的列属性，如果不存在则定义
       * @param {Row} records 行数据
       */
      defineField(T) {
        const { treeConfig: P } = e, q = ge.value, J = Ee.value, se = ne.value, ye = Y.value, Se = J.children || J.childrenField, He = ti(be);
        return I.isArray(T) || (T = [T]), T.map((Be) => (u.tableFullColumn.forEach((Ye) => {
          const { field: lt, editRender: dt } = Ye;
          if (lt && !I.has(Be, lt) && !Be[lt]) {
            let rt = null;
            if (dt) {
              const { defaultValue: pt } = dt;
              I.isFunction(pt) ? rt = pt({ column: Ye }) : I.isUndefined(pt) || (rt = pt);
            }
            I.set(Be, lt, rt);
          }
        }), [se.labelField, ye.checkField, ye.labelField, q.labelField].forEach((Ye) => {
          Ye && La(I.get(Be, Ye)) && I.set(Be, Ye, null);
        }), P && J.lazy && I.isUndefined(Be[Se]) && (Be[Se] = null), La(I.get(Be, He)) && I.set(Be, He, Rm()), Be));
      },
      handleTableData(T) {
        const { scrollYLoad: P } = s, { scrollYStore: q, fullDataRowIdData: J } = u;
        let se = u.afterFullData;
        T && (mo(), se = Tn());
        const ye = P ? se.slice(q.startIndex, q.endIndex) : se.slice(0);
        return ye.forEach((Se, He) => {
          const Be = yt(be, Se), qe = J[Be];
          qe && (qe.$index = He);
        }), s.tableData = ye, xe();
      },
      /**
       * 更新数据行的 Map
       * 牺牲数据组装的耗时，用来换取使用过程中的流畅
       */
      cacheRowMap(T) {
        const { treeConfig: P } = e, q = Ee.value;
        let { fullDataRowIdData: J, fullAllDataRowIdData: se, tableFullData: ye, tableFullTreeData: Se } = u;
        const He = q.children || q.childrenField, Be = q.hasChild || q.hasChildField, qe = ti(be), Ye = P && q.lazy, lt = (dt, rt, pt, ct, vt, at) => {
          let wt = yt(be, dt);
          const Rt = P && ct ? YCe(ct) : rt + 1, Zt = at ? at.length - 1 : 0;
          La(wt) && (wt = Rm(), I.set(dt, qe, wt)), Ye && dt[Be] && I.isUndefined(dt[He]) && (dt[He] = null);
          const Wt = { row: dt, rowid: wt, seq: Rt, index: P && vt ? -1 : rt, _index: -1, $index: -1, items: pt, parent: vt, level: Zt };
          T && (J[wt] = Wt), se[wt] = Wt;
        };
        T && (J = u.fullDataRowIdData = {}), se = u.fullAllDataRowIdData = {}, P ? I.eachTree(Se, lt, { children: He }) : ye.forEach(lt);
      },
      cacheSourceMap(T) {
        const { treeConfig: P } = e, q = Ee.value;
        let { sourceDataRowIdData: J } = u;
        const se = I.clone(T, !0), ye = ti(be);
        J = u.sourceDataRowIdData = {};
        const Se = (He) => {
          let Be = yt(be, He);
          La(Be) && (Be = Rm(), I.set(He, ye, Be)), J[Be] = He;
        };
        if (P) {
          const He = q.children || q.childrenField;
          I.eachTree(se, Se, { children: q.transform ? q.mapChildrenField : He });
        } else
          se.forEach(Se);
        u.tableSourceData = se;
      },
      /**
       * 指定列宽的列进行拆分
       */
      analyColumnWidth() {
        const { tableFullColumn: T } = u, P = Z.value, { width: q, minWidth: J } = P, se = [], ye = [], Se = [], He = [], Be = [], qe = [];
        T.forEach((Ye) => {
          q && !Ye.width && (Ye.width = q), J && !Ye.minWidth && (Ye.minWidth = J), Ye.visible && (Ye.resizeWidth ? se.push(Ye) : bb(Ye.width) ? ye.push(Ye) : Uu(Ye.width) ? He.push(Ye) : bb(Ye.minWidth) ? Se.push(Ye) : Uu(Ye.minWidth) ? Be.push(Ye) : qe.push(Ye));
        }), Object.assign(s.columnStore, { resizeList: se, pxList: ye, pxMinList: Se, scaleList: He, scaleMinList: Be, autoList: qe });
      },
      saveCustomResizable(T) {
        const { id: P, customConfig: q } = e, J = we.value, { collectColumn: se } = u, { storage: ye } = J, Se = ye === !0, He = Se ? {} : Object.assign({}, ye || {}), Be = Se || He.resizable;
        if (q && Be) {
          const qe = zt(Km);
          let Ye;
          if (!P) {
            Ht("vxe.error.reqProp", ["id"]);
            return;
          }
          T || (Ye = I.isPlainObject(qe[P]) ? qe[P] : {}, I.eachTree(se, (lt) => {
            if (lt.resizeWidth) {
              const dt = lt.getKey();
              dt && (Ye[dt] = lt.renderWidth);
            }
          })), qe[P] = I.isEmpty(Ye) ? void 0 : Ye, localStorage.setItem(Km, I.toJSONString(qe));
        }
      },
      saveCustomSort(T) {
        const { id: P, customConfig: q } = e, J = we.value, { collectColumn: se } = u, { storage: ye } = J, Se = ye === !0, He = Se ? {} : Object.assign({}, ye || {}), Be = Se || He.sort;
        if (q && Be) {
          const qe = zt(qm);
          let Ye;
          if (!P) {
            Ht("vxe.error.reqProp", ["id"]);
            return;
          }
          T || (Ye = I.isPlainObject(qe[P]) ? qe[P] : {}, se.forEach((lt) => {
            if (lt.sortNumber !== lt.renderSortNumber) {
              const dt = lt.getKey();
              dt && (Ye[dt] = lt.renderSortNumber);
            }
          })), qe[P] = I.isEmpty(Ye) ? void 0 : Ye, localStorage.setItem(qm, I.toJSONString(qe));
        }
      },
      saveCustomFixed() {
        const { id: T, customConfig: P } = e, { collectColumn: q } = u, J = we.value, { storage: se } = J, ye = se === !0, Se = ye ? {} : Object.assign({}, se || {}), He = ye || Se.fixed;
        if (P && He) {
          const Be = zt(jm), qe = [];
          if (!T) {
            Ht("vxe.error.reqProp", ["id"]);
            return;
          }
          I.eachTree(q, (Ye) => {
            if (Ye.fixed && Ye.fixed !== Ye.defaultFixed) {
              const lt = Ye.getKey();
              lt && qe.push(`${lt}|${Ye.fixed}`);
            }
          }), Be[T] = qe.join(",") || void 0, localStorage.setItem(jm, I.toJSONString(Be));
        }
      },
      saveCustomVisible() {
        const { id: T, customConfig: P } = e, { collectColumn: q } = u, J = we.value, { checkMethod: se, storage: ye } = J, Se = ye === !0, He = Se ? {} : Object.assign({}, ye || {}), Be = Se || He.visible;
        if (P && Be) {
          const qe = zt(Um), Ye = [], lt = [];
          if (!T) {
            Ht("vxe.error.reqProp", ["id"]);
            return;
          }
          I.eachTree(q, (dt) => {
            if (!se || se({ column: dt })) {
              if (!dt.visible && dt.defaultVisible) {
                const rt = dt.getKey();
                rt && Ye.push(rt);
              } else if (dt.visible && !dt.defaultVisible) {
                const rt = dt.getKey();
                rt && lt.push(rt);
              }
            }
          }), qe[T] = [Ye.join(",")].concat(lt.length ? [lt.join(",")] : []).join("|") || void 0, localStorage.setItem(Um, I.toJSONString(qe));
        }
      },
      handleCustom() {
        const { mouseConfig: T } = e;
        return T && (be.clearSelected && be.clearSelected(), be.clearCellAreas && (be.clearCellAreas(), be.clearCopyCellArea())), f.saveCustomVisible(), f.saveCustomSort(), f.analyColumnWidth(), d.refreshColumn(!0);
      },
      handleUpdateDataQueue() {
        s.upDataFlag++;
      },
      handleRefreshColumnQueue() {
        s.reColumnFlag++;
      },
      preventEvent(T, P, q, J, se) {
        let ye = $t.interceptor.get(P);
        !ye.length && P === "event.clearEdit" && (ye = $t.interceptor.get("event.clearActived"), process.env.NODE_ENV === "development" && ye.length && qt("vxe.error.delEvent", ["event.clearActived", "event.clearEdit"]));
        let Se;
        return ye.some((He) => He(Object.assign({ $grid: A, $table: be, $event: T }, q)) === !1) || J && (Se = J()), se && se(), Se;
      },
      checkSelectionStatus() {
        const { treeConfig: T } = e, { selectCheckboxMaps: P, treeIndeterminateMaps: q } = s, { afterFullData: J } = u, se = Y.value, { checkField: ye, checkStrictly: Se, checkMethod: He } = se, Be = se.indeterminateField || se.halfField;
        if (!Se) {
          const qe = [];
          let Ye = !1, lt = !1, dt = !1;
          ye ? (Ye = J.every(He ? (rt) => He({ row: rt }) ? !!I.get(rt, ye) : (qe.push(rt), !0) : (rt) => I.get(rt, ye)), lt = Ye && J.length !== qe.length, T ? Be ? dt = !lt && J.some((rt) => I.get(rt, ye) || I.get(rt, Be) || !!q[yt(be, rt)]) : dt = !lt && J.some((rt) => I.get(rt, ye) || !!q[yt(be, rt)]) : Be ? dt = !lt && J.some((rt) => I.get(rt, ye) || I.get(rt, Be)) : dt = !lt && J.some((rt) => I.get(rt, ye))) : (Ye = J.every(He ? (rt) => He({ row: rt }) ? !!P[yt(be, rt)] : (qe.push(rt), !0) : (rt) => P[yt(be, rt)]), lt = Ye && J.length !== qe.length, T ? dt = !lt && J.some((rt) => {
            const pt = yt(be, rt);
            return q[pt] || P[pt];
          }) : dt = !lt && J.some((rt) => P[yt(be, rt)])), s.isAllSelected = lt, s.isIndeterminate = dt;
        }
      },
      /**
       * 多选，行选中事件
       * value 选中true 不选false 半选-1
       */
      handleSelectRow({ row: T }, P, q) {
        const { treeConfig: J } = e, { selectCheckboxMaps: se, treeIndeterminateMaps: ye } = s, Se = { ...se }, { afterFullData: He } = u, Be = Ee.value, qe = Be.children || Be.childrenField, Ye = Y.value, { checkField: lt, checkStrictly: dt, checkMethod: rt } = Ye, pt = Ye.indeterminateField || Ye.halfField, ct = yt(be, T);
        if (lt)
          if (J && !dt) {
            P === -1 ? (ye[ct] || (pt && I.set(T, pt, !0), ye[ct] = T), I.set(T, lt, !1)) : I.eachTree([T], (at) => {
              (be.eqRow(at, T) || q || !rt || rt({ row: at })) && (I.set(at, lt, P), pt && I.set(T, pt, !1), delete ye[yt(be, at)], Xt(T, P));
            }, { children: qe });
            const vt = I.findTree(He, (at) => be.eqRow(at, T), { children: qe });
            if (vt && vt.parent) {
              let at;
              const wt = [], Rt = {};
              if (!q && rt ? vt.items.forEach((Wt) => {
                if (rt({ row: Wt })) {
                  const cn = yt(be, Wt);
                  Rt[cn] = Wt, wt.push(Wt);
                }
              }) : vt.items.forEach((Wt) => {
                const cn = yt(be, Wt);
                Rt[cn] = Wt, wt.push(Wt);
              }), I.find(vt.items, (Wt) => !!ye[yt(be, Wt)]))
                at = -1;
              else {
                const Wt = [];
                vt.items.forEach((cn) => {
                  I.get(cn, lt) && Wt.push(cn);
                }), at = Wt.filter((cn) => Rt[yt(be, cn)]).length === wt.length ? !0 : Wt.length || P === -1 ? -1 : !1;
              }
              return s.selectCheckboxMaps = Se, f.handleSelectRow({ row: vt.parent }, at, q);
            }
          } else
            (q || !rt || rt({ row: T })) && (I.set(T, lt, P), Xt(T, P));
        else if (J && !dt) {
          P === -1 ? (ye[ct] || (pt && I.set(T, pt, !0), ye[ct] = T), Se[ct] && delete Se[ct]) : I.eachTree([T], (at) => {
            const wt = yt(be, at);
            (be.eqRow(at, T) || q || !rt || rt({ row: at })) && (P ? Se[wt] = at : Se[wt] && delete Se[wt], pt && I.set(T, pt, !1), delete ye[yt(be, at)], Xt(T, P));
          }, { children: qe });
          const vt = I.findTree(He, (at) => be.eqRow(at, T), { children: qe });
          if (vt && vt.parent) {
            let at;
            const wt = [], Rt = {};
            if (!q && rt ? vt.items.forEach((Wt) => {
              if (rt({ row: Wt })) {
                const cn = yt(be, Wt);
                Rt[cn] = Wt, wt.push(Wt);
              }
            }) : vt.items.forEach((Wt) => {
              const cn = yt(be, Wt);
              Rt[cn] = Wt, wt.push(Wt);
            }), I.find(vt.items, (Wt) => !!ye[yt(be, Wt)]))
              at = -1;
            else {
              const Wt = [];
              vt.items.forEach((cn) => {
                const In = yt(be, cn);
                Se[In] && Wt.push(cn);
              }), at = Wt.filter((cn) => Rt[yt(be, cn)]).length === wt.length ? !0 : Wt.length || P === -1 ? -1 : !1;
            }
            return s.selectCheckboxMaps = Se, f.handleSelectRow({ row: vt.parent }, at, q);
          }
        } else
          (q || !rt || rt({ row: T })) && (P ? Se[ct] || (Se[ct] = T) : Se[ct] && delete Se[ct], Xt(T, P));
        s.selectCheckboxMaps = Se, f.checkSelectionStatus();
      },
      triggerHeaderTitleEvent(T, P, q) {
        const J = P.content || P.message;
        if (J) {
          const { tooltipStore: se } = s, { column: ye } = q, Se = vo(J);
          ji(!0), se.row = null, se.column = ye, se.visible = !0, xe(() => {
            const He = h.value;
            He && He.open(T.currentTarget, Se);
          });
        }
      },
      /**
       * 触发表头 tooltip 事件
       */
      triggerHeaderTooltipEvent(T, P) {
        const { tooltipStore: q } = s, { column: J } = P, se = T.currentTarget;
        ji(!0), (q.column !== J || !q.visible) && bu(T, se, se, null, P);
      },
      /**
       * 触发单元格 tooltip 事件
       */
      triggerBodyTooltipEvent(T, P) {
        const { editConfig: q } = e, { editStore: J } = s, { tooltipStore: se } = s, ye = De.value, { actived: Se } = J, { row: He, column: Be } = P, qe = T.currentTarget;
        if (ji(se.column !== Be || se.row !== He), !(Be.editRender && mn(q) && (ye.mode === "row" && Se.row === He || Se.row === He && Se.column === Be)) && (se.column !== Be || se.row !== He || !se.visible)) {
          let Ye, lt;
          Be.treeNode ? (Ye = qe.querySelector(".vxe-tree-cell"), Be.type === "html" && (lt = qe.querySelector(".vxe-cell--html"))) : lt = qe.querySelector(Be.type === "html" ? ".vxe-cell--html" : ".vxe-cell--label"), bu(T, qe, Ye || qe.children[0], lt, P);
        }
      },
      /**
       * 触发表尾 tooltip 事件
       */
      triggerFooterTooltipEvent(T, P) {
        const { column: q } = P, { tooltipStore: J } = s, se = T.currentTarget;
        ji(J.column !== q || !!J.row), (J.column !== q || !J.visible) && bu(T, se, se.querySelector(".vxe-cell--item") || se.children[0], null, P);
      },
      handleTargetLeaveEvent() {
        const T = ve.value;
        let P = h.value;
        P && P.setActived(!1), T.enterable ? u.tooltipTimeout = setTimeout(() => {
          P = h.value, P && !P.isActived() && d.closeTooltip();
        }, T.leaveDelay) : d.closeTooltip();
      },
      triggerHeaderCellClickEvent(T, P) {
        const { _lastResizeTime: q } = u, J = $e.value, se = Z.value, { column: ye } = P, Se = T.currentTarget, He = q && q > Date.now() - 300, Be = _n(T, Se, "vxe-cell--sort").flag, qe = _n(T, Se, "vxe-cell--filter").flag;
        J.trigger === "cell" && !(He || Be || qe) && f.triggerSortEvent(T, ye, _t(ye)), d.dispatchEvent("header-cell-click", Object.assign({ triggerResizable: He, triggerSort: Be, triggerFilter: qe, cell: Se }, P), T), (se.isCurrent || e.highlightCurrentColumn) && d.setCurrentColumn(ye);
      },
      triggerHeaderCellDblclickEvent(T, P) {
        d.dispatchEvent("header-cell-dblclick", Object.assign({ cell: T.currentTarget }, P), T);
      },
      /**
       * 列点击事件
       * 如果是单击模式，则激活为编辑状态
       * 如果是双击模式，则单击后选中状态
       */
      triggerCellClickEvent(T, P) {
        const { highlightCurrentRow: q, editConfig: J } = e, { editStore: se } = s, ye = ge.value, Se = De.value, He = Ee.value, Be = ne.value, qe = Y.value, Ye = Fe.value, lt = te.value, { actived: dt, focused: rt } = se, { row: pt, column: ct } = P, { type: vt, treeNode: at } = ct, wt = vt === "radio", Rt = vt === "checkbox", Zt = vt === "expand", Wt = T.currentTarget, cn = wt && _n(T, Wt, "vxe-cell--radio").flag, In = Rt && _n(T, Wt, "vxe-cell--checkbox").flag, to = at && _n(T, Wt, "vxe-tree--btn-wrapper").flag, Bn = Zt && _n(T, Wt, "vxe-table--expanded").flag;
        P = Object.assign({ cell: Wt, triggerRadio: cn, triggerCheckbox: In, triggerTreeNode: to, triggerExpandNode: Bn }, P), !In && !cn && (!Bn && (ye.trigger === "row" || Zt && ye.trigger === "cell") && f.triggerRowExpandEvent(T, P), (He.trigger === "row" || at && He.trigger === "cell") && f.triggerTreeExpandEvent(T, P)), to || (Bn || ((lt.isCurrent || q) && !In && !cn && f.triggerCurrentRowEvent(T, P), !cn && (Be.trigger === "row" || wt && Be.trigger === "cell") && f.triggerRadioRowEvent(T, P), !In && (qe.trigger === "row" || Rt && qe.trigger === "cell") && f.handleToggleCheckRowEvent(T, P)), mn(J) && (Ye.arrowCursorLock && T && Se.mode === "cell" && T.target && /^input|textarea$/i.test(T.target.tagName) && (rt.column = ct, rt.row = pt), Se.trigger === "manual" ? dt.args && dt.row === pt && ct !== dt.column && Oo(T, P) : (!dt.args || pt !== dt.row || ct !== dt.column) && (Se.trigger === "click" || Se.trigger === "dblclick" && Se.mode === "row" && dt.row === pt) && Oo(T, P))), d.dispatchEvent("cell-click", P, T);
      },
      /**
       * 列双击点击事件
       * 如果是双击模式，则激活为编辑状态
       */
      triggerCellDblclickEvent(T, P) {
        const { editConfig: q } = e, { editStore: J } = s, se = De.value, { actived: ye } = J, Se = T.currentTarget;
        P = Object.assign({ cell: Se }, P), mn(q) && se.trigger === "dblclick" && (!ye.args || T.currentTarget !== ye.args.cell) && (se.mode === "row" ? Io("blur").catch((He) => He).then(() => {
          be.handleActived(P, T).then(() => Io("change")).catch((He) => He);
        }) : se.mode === "cell" && be.handleActived(P, T).then(() => Io("change")).catch((He) => He)), d.dispatchEvent("cell-dblclick", P, T);
      },
      handleToggleCheckRowEvent(T, P) {
        const { selectCheckboxMaps: q } = s, J = Y.value, { checkField: se } = J, { row: ye } = P;
        let Se = !1;
        se ? Se = !I.get(ye, se) : Se = !q[yt(be, ye)], T ? f.triggerCheckRowEvent(T, P, Se) : f.handleSelectRow(P, Se);
      },
      triggerCheckRowEvent(T, P, q) {
        const J = Y.value, { row: se } = P, { afterFullData: ye } = u, { checkMethod: Se } = J;
        if (J.isShiftKey && T.shiftKey && !e.treeConfig) {
          const He = d.getCheckboxRecords();
          if (He.length) {
            const Be = He[0], qe = d.getVTRowIndex(se), Ye = d.getVTRowIndex(Be);
            if (qe !== Ye) {
              d.setAllCheckboxRow(!1);
              const lt = qe < Ye ? ye.slice(qe, Ye + 1) : ye.slice(Ye, qe + 1);
              _o(lt, !0, !1), d.dispatchEvent("checkbox-range-select", Object.assign({ rangeRecords: lt }, P), T);
              return;
            }
          }
        }
        (!Se || Se({ row: se })) && (f.handleSelectRow(P, q), d.dispatchEvent("checkbox-change", Object.assign({
          records: d.getCheckboxRecords(),
          reserves: d.getCheckboxReserveRecords(),
          indeterminates: d.getCheckboxIndeterminateRecords(),
          checked: q
        }, P), T));
      },
      /**
       * 多选，选中所有事件
       */
      triggerCheckAllEvent(T, P) {
        No(P), T && d.dispatchEvent("checkbox-all", {
          records: d.getCheckboxRecords(),
          reserves: d.getCheckboxReserveRecords(),
          indeterminates: d.getCheckboxIndeterminateRecords(),
          checked: P
        }, T);
      },
      /**
       * 单选，行选中事件
       */
      triggerRadioRowEvent(T, P) {
        const { selectRadioRow: q } = s, { row: J } = P, se = ne.value;
        let ye = J, Se = q !== ye;
        Se ? sn(ye) : se.strict || (Se = q === ye, Se && (ye = null, d.clearRadioRow())), Se && d.dispatchEvent("radio-change", { oldValue: q, newValue: ye, ...P }, T);
      },
      triggerCurrentRowEvent(T, P) {
        const { currentRow: q } = s, { row: J } = P, se = q !== J;
        d.setCurrentRow(J), se && d.dispatchEvent("current-change", { oldValue: q, newValue: J, ...P }, T);
      },
      /**
       * 展开行事件
       */
      triggerRowExpandEvent(T, P) {
        const { rowExpandLazyLoadedMaps: q, expandColumn: J } = s, se = ge.value, { row: ye } = P, { lazy: Se } = se, He = yt(be, ye);
        if (!Se || !q[He]) {
          const Be = !d.isRowExpandByRow(ye), qe = d.getColumnIndex(J), Ye = d.getVMColumnIndex(J);
          d.setRowExpand(ye, Be), d.dispatchEvent("toggle-row-expand", {
            expanded: Be,
            column: J,
            columnIndex: qe,
            $columnIndex: Ye,
            row: ye,
            rowIndex: d.getRowIndex(ye),
            $rowIndex: d.getVMRowIndex(ye)
          }, T);
        }
      },
      /**
       * 展开树节点事件
       */
      triggerTreeExpandEvent(T, P) {
        const { treeExpandLazyLoadedMaps: q } = s, J = Ee.value, { row: se, column: ye } = P, { lazy: Se } = J, He = yt(be, se);
        if (!Se || !q[He]) {
          const Be = !d.isTreeExpandByRow(se), qe = d.getColumnIndex(ye), Ye = d.getVMColumnIndex(ye);
          d.setTreeExpand(se, Be), d.dispatchEvent("toggle-tree-expand", { expanded: Be, column: ye, columnIndex: qe, $columnIndex: Ye, row: se }, T);
        }
      },
      /**
       * 点击排序事件
       */
      triggerSortEvent(T, P, q) {
        const { mouseConfig: J } = e, se = $e.value, ye = Ne.value, { field: Se, sortable: He } = P;
        if (He) {
          !q || P.order === q ? d.clearSort(se.multiple ? P : null) : d.sort({ field: Se, order: q });
          const Be = { $table: be, $event: T, column: P, field: Se, property: Se, order: P.order, sortList: d.getSortColumns(), sortTime: P.sortTime };
          J && ye.area && be.handleSortEvent && be.handleSortEvent(T, Be), d.dispatchEvent("sort-change", Be, T);
        }
      },
      /**
       * 横向 X 可视渲染事件处理
       */
      triggerScrollXEvent() {
        yr();
      },
      /**
       * 纵向 Y 可视渲染事件处理
       */
      triggerScrollYEvent(T) {
        const { scrollYStore: P } = u, { adaptive: q, offsetSize: J, visibleSize: se } = P;
        aEe && q && J * 2 + se <= 40 ? Nf(T) : kh(T);
      },
      /**
       * 对于树形结构中，可以直接滚动到指定深层节点中
       * 对于某些特定的场景可能会用到，比如定位到某一节点
       * @param {Row} row 行对象
       */
      scrollToTreeRow(T) {
        const { treeConfig: P } = e, { tableFullData: q } = u, J = [];
        if (P) {
          const se = Ee.value, ye = se.children || se.childrenField, Se = I.findTree(q, (He) => be.eqRow(He, T), { children: ye });
          if (Se) {
            const He = Se.nodes;
            He.forEach((Be, qe) => {
              qe < He.length - 1 && !d.isTreeExpandByRow(Be) && J.push(d.setTreeExpand(Be, !0));
            });
          }
        }
        return Promise.all(J).then(() => __(be, T));
      },
      updateScrollYStatus: gu,
      // 更新横向 X 可视渲染上下剩余空间大小
      updateScrollXSpace() {
        const { isGroup: T, scrollXLoad: P, scrollbarWidth: q } = s, { visibleColumn: J, scrollXStore: se, elemStore: ye, tableWidth: Se } = u, He = b.value, Be = y.value, qe = E.value, Ye = Be ? Be.$el : null;
        if (Ye) {
          const lt = He ? He.$el : null, dt = qe ? qe.$el : null, rt = lt ? lt.querySelector(".vxe-table--header") : null, pt = Ye.querySelector(".vxe-table--body"), ct = dt ? dt.querySelector(".vxe-table--footer") : null, vt = J.slice(0, se.startIndex).reduce((Rt, Zt) => Rt + Zt.renderWidth, 0);
          let at = "";
          P && (at = `${vt}px`), rt && (rt.style.marginLeft = T ? "" : at), pt.style.marginLeft = at, ct && (ct.style.marginLeft = at), ["main"].forEach((Rt) => {
            ["header", "body", "footer"].forEach((Wt) => {
              const cn = ye[`${Rt}-${Wt}-xSpace`], In = cn ? cn.value : null;
              In && (In.style.width = P ? `${Se + (Wt === "header" ? q : 0)}px` : "");
            });
          }), xe(ro);
        }
      },
      // 更新纵向 Y 可视渲染上下剩余空间大小
      updateScrollYSpace() {
        const { scrollYLoad: T } = s, { scrollYStore: P, elemStore: q, afterFullData: J } = u, { startIndex: se, rowHeight: ye } = P, Se = J.length * ye, He = Math.max(0, se * ye), Be = ["main", "left", "right"];
        let qe = "", Ye = "";
        T && (qe = `${He}px`, Ye = `${Se}px`), Be.forEach((lt) => {
          const dt = ["header", "body", "footer"], rt = q[`${lt}-body-table`], pt = rt ? rt.value : null;
          pt && (pt.style.marginTop = qe), dt.forEach((ct) => {
            const vt = q[`${lt}-${ct}-ySpace`], at = vt ? vt.value : null;
            at && (at.style.height = Ye);
          });
        }), xe(ro);
      },
      updateScrollXData() {
        xe(() => {
          Ro(), f.updateScrollXSpace();
        });
      },
      updateScrollYData() {
        xe(() => {
          f.handleTableData(), f.updateScrollYSpace();
        });
      },
      /**
       * 处理固定列的显示状态
       */
      checkScrolling() {
        const T = H.value, P = K.value, q = y.value, J = q ? q.$el : null;
        J && (T && (J.scrollLeft > 0 ? Mr(T, "scrolling--middle") : Xl(T, "scrolling--middle")), P && (J.clientWidth < J.scrollWidth - Math.ceil(J.scrollLeft) ? Mr(P, "scrolling--middle") : Xl(P, "scrolling--middle")));
      },
      updateZindex() {
        e.zIndex ? u.tZindex = e.zIndex : u.tZindex < Yr() && (u.tZindex = dr());
      },
      handleCheckedCheckboxRow: _o,
      /**
       * 行 hover 事件
       */
      triggerHoverEvent(T, { row: P }) {
        f.setHoverRow(P);
      },
      setHoverRow(T) {
        const P = yt(be, T), q = v.value;
        f.clearHoverRow(), q && I.arrayEach(q.querySelectorAll(`[rowid="${P}"]`), (J) => Mr(J, "row--hover")), u.hoverRow = T;
      },
      clearHoverRow() {
        const T = v.value;
        T && I.arrayEach(T.querySelectorAll(".vxe-body--row.row--hover"), (P) => Xl(P, "row--hover")), u.hoverRow = null;
      },
      getCell(T, P) {
        const q = yt(be, T), J = y.value, se = _.value, ye = L.value;
        let Se;
        return P && (P.fixed && (P.fixed === "left" ? se && (Se = se.$el) : ye && (Se = ye.$el)), Se || (Se = J.$el), Se) ? Se.querySelector(`.vxe-body--row[rowid="${q}"] .${P.id}`) : null;
      },
      getCellLabel(T, P) {
        const q = P.formatter, J = xa(T, P);
        let se = J;
        if (q) {
          let ye;
          const { fullAllDataRowIdData: Se } = u, He = yt(be, T), Be = P.id, qe = Se[He];
          if (qe && (ye = qe.formatData, ye || (ye = Se[He].formatData = {}), qe && ye[Be] && ye[Be].value === J))
            return ye[Be].label;
          const Ye = { cellValue: J, row: T, rowIndex: d.getRowIndex(T), column: P, columnIndex: d.getColumnIndex(P) };
          if (I.isString(q)) {
            const lt = $t.formats.get(q);
            se = lt && lt.cellFormatMethod ? lt.cellFormatMethod(Ye) : "";
          } else if (I.isArray(q)) {
            const lt = $t.formats.get(q[0]);
            se = lt && lt.cellFormatMethod ? lt.cellFormatMethod(Ye, ...q.slice(1)) : "";
          } else
            se = q(Ye);
          ye && (ye[Be] = { value: J, label: se });
        }
        return se;
      },
      findRowIndexOf(T, P) {
        return P ? I.findIndexOf(T, (q) => be.eqRow(q, P)) : -1;
      },
      eqRow(T, P) {
        return T && P ? T === P ? !0 : yt(be, T) === yt(be, P) : !1;
      }
    }, process.env.NODE_ENV === "development" && ("openExport,openPrint,exportData,openImport,importData,saveFile,readFile,importByFile,print".split(",").forEach((T) => {
      be[T] = function() {
        Ht("vxe.error.reqModule", ["Export"]);
      };
    }), "clearValidate,fullValidate,validate".split(",").forEach((T) => {
      be[T] = function() {
        Ht("vxe.error.reqModule", ["Validator"]);
      };
    })), Object.assign(be, d, f);
    const Df = (T) => {
      const { showHeader: P, showFooter: q } = e, { tableData: J, tableColumn: se, tableGroupColumn: ye, columnStore: Se, footerTableData: He } = s, Be = T === "left", qe = Be ? Se.leftList : Se.rightList;
      return V("div", {
        ref: Be ? H : K,
        class: `vxe-table--fixed-${T}-wrapper`
      }, [
        P ? V(Y_, {
          ref: Be ? S : N,
          fixedType: T,
          tableData: J,
          tableColumn: se,
          tableGroupColumn: ye,
          fixedColumn: qe
        }) : _e(),
        V(q_, {
          ref: Be ? _ : L,
          fixedType: T,
          tableData: J,
          tableColumn: se,
          fixedColumn: qe
        }),
        q ? V(G_, {
          ref: Be ? k : R,
          footerTableData: He,
          tableColumn: se,
          fixedColumn: qe,
          fixedType: T
        }) : _e()
      ]);
    }, Dh = () => {
      const T = me.value, P = { $table: be };
      if (n.empty)
        return n.empty(P);
      {
        const q = T.name ? $t.renderer.get(T.name) : null, J = q ? q.renderEmpty : null;
        if (J)
          return oo(J(T, P));
      }
      return vo(e.emptyText) || ee.i18n("vxe.table.emptyText");
    };
    function yu() {
      const T = v.value;
      T && T.clientWidth && T.clientHeight && d.recalculate();
    }
    const Cu = B(0);
    Pe(() => e.data ? e.data.length : -1, () => {
      Cu.value++;
    }), Pe(() => e.data, () => {
      Cu.value++;
    }), Pe(Cu, () => {
      const { inited: T, initStatus: P } = u;
      ia(e.data || []).then(() => {
        const { scrollXLoad: q, scrollYLoad: J, expandColumn: se } = s;
        u.inited = !0, u.initStatus = !0, P || Xr(), T || Ml(), process.env.NODE_ENV === "development" && (q || J) && se && qt("vxe.error.scrollErrProp", ["column.type=expand"]), d.recalculate();
      });
    });
    const le = B(0);
    Pe(() => s.staticColumns.length, () => {
      le.value++;
    }), Pe(() => s.staticColumns, () => {
      le.value++;
    }), Pe(le, () => {
      zs(s.staticColumns);
    });
    const Ge = B(0);
    Pe(() => s.tableColumn.length, () => {
      Ge.value++;
    }), Pe(() => s.tableColumn, () => {
      Ge.value++;
    }), Pe(Ge, () => {
      f.analyColumnWidth();
    }), Pe(() => s.upDataFlag, () => {
      xe(() => {
        d.updateData();
      });
    }), Pe(() => s.reColumnFlag, () => {
      xe(() => {
        d.refreshColumn();
      });
    }), Pe(() => e.showHeader, () => {
      xe(() => {
        d.recalculate(!0).then(() => d.refreshScroll());
      });
    }), Pe(() => e.showFooter, () => {
      xe(() => {
        d.recalculate(!0).then(() => d.refreshScroll());
      });
    });
    const tt = B(0);
    Pe(() => e.footerData ? e.footerData.length : -1, () => {
      tt.value++;
    }), Pe(() => e.footerData, () => {
      tt.value++;
    }), Pe(tt, () => {
      d.updateFooter();
    }), Pe(() => e.height, () => {
      xe(() => d.recalculate(!0));
    }), Pe(() => e.maxHeight, () => {
      xe(() => d.recalculate(!0));
    }), Pe(() => e.syncResize, (T) => {
      T && (yu(), xe(() => {
        yu(), setTimeout(() => yu());
      }));
    });
    const ht = B(0);
    Pe(() => e.mergeCells ? e.mergeCells.length : -1, () => {
      ht.value++;
    }), Pe(() => e.mergeCells, () => {
      ht.value++;
    }), Pe(ht, () => {
      d.clearMergeCells(), xe(() => {
        e.mergeCells && d.setMergeCells(e.mergeCells);
      });
    });
    const Tt = B(0);
    Pe(() => e.mergeFooterItems ? e.mergeFooterItems.length : -1, () => {
      Tt.value++;
    }), Pe(() => e.mergeFooterItems, () => {
      Tt.value++;
    }), Pe(Tt, () => {
      d.clearMergeFooterItems(), xe(() => {
        e.mergeFooterItems && d.setMergeFooterItems(e.mergeFooterItems);
      });
    }), $t.hooks.forEach((T) => {
      const { setupTable: P } = T;
      if (P) {
        const q = P(be);
        q && I.isObject(q) && Object.assign(be, q);
      }
    }), f.preventEvent(null, "created", { $table: be });
    let gt;
    j2(() => {
      d.recalculate().then(() => d.refreshScroll()), f.preventEvent(null, "activated", { $table: be });
    }), z2(() => {
      u.isActivated = !1, f.preventEvent(null, "deactivated", { $table: be });
    }), Nt(() => {
      xe(() => {
        const { data: T, treeConfig: P, showOverflow: q } = e, { scrollXStore: J, scrollYStore: se } = u, ye = F.value, Se = De.value, He = Ee.value, Be = ne.value, qe = Y.value, Ye = ge.value, lt = te.value;
        if (process.env.NODE_ENV === "development") {
          e.rowId && qt("vxe.error.delProp", ["row-id", "row-config.keyField"]), e.rowKey && qt("vxe.error.delProp", ["row-key", "row-config.useKey"]), e.columnKey && qt("vxe.error.delProp", ["column-id", "column-config.useKey"]), !(e.rowId || lt.keyField) && (qe.reserve || qe.checkRowKeys || Be.reserve || Be.checkRowKey || Ye.expandRowKeys || He.expandRowKeys) && qt("vxe.error.reqProp", ["row-config.keyField"]), e.editConfig && (Se.showStatus || Se.showUpdateStatus || Se.showInsertStatus) && !e.keepSource && qt("vxe.error.reqProp", ["keep-source"]), P && (He.showLine || He.line) && (!(e.rowKey || lt.useKey) || !q) && qt("vxe.error.reqProp", ["row-config.useKey | show-overflow"]), P && e.stripe && qt("vxe.error.noTree", ["stripe"]), e.showFooter && !(e.footerMethod || e.footerData) && qt("vxe.error.reqProp", ["footer-data | footer-method"]);
          const { exportConfig: dt, importConfig: rt } = e, pt = Te.value, ct = Ce.value;
          rt && ct.types && !ct.importMethod && !I.includeArrays($t.globalConfs.importTypes, ct.types) && qt("vxe.error.errProp", [`export-config.types=${ct.types.join(",")}`, ct.types.filter((vt) => I.includes($t.globalConfs.importTypes, vt)).join(",") || $t.globalConfs.importTypes.join(",")]), dt && pt.types && !pt.exportMethod && !I.includeArrays($t.globalConfs.exportTypes, pt.types) && qt("vxe.error.errProp", [`export-config.types=${pt.types.join(",")}`, pt.types.filter((vt) => I.includes($t.globalConfs.exportTypes, vt)).join(",") || $t.globalConfs.exportTypes.join(",")]);
        }
        if (process.env.NODE_ENV === "development") {
          const dt = we.value, rt = Ne.value, pt = te.value;
          if (!e.id && e.customConfig && (dt.storage === !0 || dt.storage && dt.storage.resizable || dt.storage && dt.storage.visible) && Ht("vxe.error.reqProp", ["id"]), e.treeConfig && qe.range && Ht("vxe.error.noTree", ["checkbox-config.range"]), pt.height && !e.showOverflow && qt("vxe.error.notProp", ["table.show-overflow"]), !be.handleUpdateCellAreas && (e.clipConfig && qt("vxe.error.notProp", ["clip-config"]), e.fnrConfig && qt("vxe.error.notProp", ["fnr-config"]), rt.area)) {
            Ht("vxe.error.notProp", ["mouse-config.area"]);
            return;
          }
          e.treeConfig && He.children && qt("vxe.error.delProp", ["tree-config.children", "tree-config.childrenField"]), e.treeConfig && He.line && qt("vxe.error.delProp", ["tree-config.line", "tree-config.showLine"]), rt.area && rt.selected && qt("vxe.error.errConflicts", ["mouse-config.area", "mouse-config.selected"]), rt.area && qe.range && qt("vxe.error.errConflicts", ["mouse-config.area", "checkbox-config.range"]), e.treeConfig && rt.area && Ht("vxe.error.noTree", ["mouse-config.area"]), e.editConfig && Se.activeMethod && qt("vxe.error.delProp", ["edit-config.activeMethod", "edit-config.beforeEditMethod"]), e.treeConfig && qe.isShiftKey && Ht("vxe.error.errConflicts", ["tree-config", "checkbox-config.isShiftKey"]), qe.halfField && qt("vxe.error.delProp", ["checkbox-config.halfField", "checkbox-config.indeterminateField"]);
        }
        if (process.env.NODE_ENV === "development" && (e.editConfig && !be.insert && Ht("vxe.error.reqModule", ["Edit"]), e.editRules && !be.validate && Ht("vxe.error.reqModule", ["Validator"]), (qe.range || e.keyboardConfig || e.mouseConfig) && !be.triggerCellMousedownEvent && Ht("vxe.error.reqModule", ["Keyboard"]), (e.printConfig || e.importConfig || e.exportConfig) && !be.exportData && Ht("vxe.error.reqModule", ["Export"])), Object.assign(se, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0,
          adaptive: ye.adaptive !== !1
        }), Object.assign(J, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0
        }), ia(T || []).then(() => {
          T && T.length && (u.inited = !0, u.initStatus = !0, Xr(), Ml()), ro();
        }), e.autoResize) {
          const dt = de.value, { refreshDelay: rt } = dt, pt = v.value, ct = f.getParentElem(), vt = rt ? I.throttle(() => d.recalculate(!0), rt, { leading: !0, trailing: !0 }) : null;
          gt = nR(vt ? () => {
            e.autoResize && requestAnimationFrame(vt);
          } : () => {
            e.autoResize && d.recalculate(!0);
          }), pt && gt.observe(pt), ct && gt.observe(ct);
        }
      }), wn.on(be, "paste", Rf), wn.on(be, "copy", Mh), wn.on(be, "cut", Ih), wn.on(be, "mousedown", Th), wn.on(be, "blur", $h), wn.on(be, "mousewheel", Oh), wn.on(be, "keydown", If), wn.on(be, "resize", Rh), be.handleGlobalContextmenuEvent && wn.on(be, "contextmenu", be.handleGlobalContextmenuEvent), f.preventEvent(null, "mounted", { $table: be });
    }), zn(() => {
      gt && gt.disconnect(), d.closeFilter(), be.closeMenu && be.closeMenu(), f.preventEvent(null, "beforeUnmount", { $table: be });
    }), wo(() => {
      wn.off(be, "paste"), wn.off(be, "copy"), wn.off(be, "cut"), wn.off(be, "mousedown"), wn.off(be, "blur"), wn.off(be, "mousewheel"), wn.off(be, "keydown"), wn.off(be, "resize"), wn.off(be, "contextmenu"), f.preventEvent(null, "unmounted", { $table: be });
    });
    const Ft = () => {
      const { loading: T, stripe: P, showHeader: q, height: J, treeConfig: se, mouseConfig: ye, showFooter: Se, highlightCell: He, highlightHoverRow: Be, highlightHoverColumn: qe, editConfig: Ye, editRules: lt } = e, { isGroup: dt, overflowX: rt, overflowY: pt, scrollXLoad: ct, scrollYLoad: vt, scrollbarHeight: at, tableData: wt, tableColumn: Rt, tableGroupColumn: Zt, footerTableData: Wt, initStore: cn, columnStore: In, filterStore: to, customStore: Bn } = s, { leftList: On, rightList: $n } = In, io = n.loading, Qo = ie.value, Ma = D.value, qi = Ee.value, Ws = te.value, wu = Z.value, Ks = r.value, wr = Me.value, Us = Ne.value, js = he.value, Kl = Ke.value, qs = Xe.value;
      return V("div", {
        ref: v,
        class: ["vxe-table", "vxe-table--render-default", `tid_${a}`, `border--${wr}`, {
          [`size--${Ks}`]: Ks,
          [`valid-msg--${Ma.msgMode}`]: !!lt,
          "vxe-editable": !!Ye,
          "old-cell-valid": lt && ee.cellVaildMode === "obsolete",
          "cell--highlight": He,
          "cell--selected": ye && Us.selected,
          "cell--area": ye && Us.area,
          "row--highlight": Ws.isHover || Be,
          "column--highlight": wu.isHover || qe,
          "is--header": q,
          "is--footer": Se,
          "is--group": dt,
          "is--tree-line": se && (qi.showLine || qi.line),
          "is--fixed-left": On.length,
          "is--fixed-right": $n.length,
          "is--animat": !!e.animat,
          "is--round": e.round,
          "is--stripe": !se && P,
          "is--loading": T,
          "is--empty": !T && !wt.length,
          "is--scroll-y": pt,
          "is--scroll-x": rt,
          "is--virtual-x": ct,
          "is--virtual-y": vt
        }],
        onKeydown: Nh
      }, [
        /**
         * 隐藏列
         */
        V("div", {
          class: "vxe-table-slots"
        }, n.default ? n.default({}) : []),
        V("div", {
          class: "vxe-table--render-wrapper"
        }, [
          V("div", {
            class: "vxe-table--main-wrapper"
          }, [
            /**
             * 表头
             */
            q ? V(Y_, {
              ref: b,
              tableData: wt,
              tableColumn: Rt,
              tableGroupColumn: Zt
            }) : _e(),
            /**
             * 表体
             */
            V(q_, {
              ref: y,
              tableData: wt,
              tableColumn: Rt
            }),
            /**
             * 表尾
             */
            Se ? V(G_, {
              ref: E,
              footerTableData: Wt,
              tableColumn: Rt
            }) : _e()
          ]),
          V("div", {
            class: "vxe-table--fixed-wrapper"
          }, [
            /**
             * 左侧固定区域
             */
            On && On.length && rt ? Df("left") : _e(),
            /**
             * 右侧固定区域
             */
            $n && $n.length && rt ? Df("right") : _e()
          ])
        ]),
        /**
         * 空数据
         */
        V("div", {
          ref: W,
          class: "vxe-table--empty-placeholder"
        }, [
          V("div", {
            class: "vxe-table--empty-content"
          }, Dh())
        ]),
        /**
         * 边框线
         */
        V("div", {
          class: "vxe-table--border-line"
        }),
        /**
         * 列宽线
         */
        V("div", {
          ref: U,
          class: "vxe-table--resizable-bar",
          style: rt ? {
            "padding-bottom": `${at}px`
          } : null
        }),
        /**
         * 加载中
         */
        V(uh, {
          class: "vxe-table--loading",
          modelValue: T,
          icon: Kl.icon,
          text: Kl.text
        }, io ? {
          default: () => io({ $table: be, $grid: A })
        } : {}),
        /**
         * 自定义列
         */
        cn.custom ? V(Dt("vxe-table-custom-panel"), {
          ref: w,
          customStore: Bn
        }) : _e(),
        /**
         * 筛选
         */
        cn.filter ? V(Dt("vxe-table-filter-panel"), {
          ref: g,
          filterStore: to
        }) : _e(),
        /**
         * 导入
         */
        cn.import && e.importConfig ? V(Dt("vxe-table-import-panel"), {
          defaultOptions: s.importParams,
          storeData: s.importStore
        }) : _e(),
        /**
         * 导出/导出
         */
        cn.export && (e.exportConfig || e.printConfig) ? V(Dt("vxe-table-export-panel"), {
          defaultOptions: s.exportParams,
          storeData: s.exportStore
        }) : _e(),
        /**
         * 快捷菜单
         */
        qs ? V(Dt("vxe-table-menu-panel"), {
          ref: C
        }) : _e(),
        /**
         * 通用提示
         */
        l ? V(Dt("vxe-tooltip"), {
          ref: m,
          isArrow: !1,
          enterable: !1
        }) : _e(),
        /**
         * 工具提示
         */
        l ? V(Dt("vxe-tooltip"), {
          ref: h,
          ...Qo
        }) : _e(),
        /**
         * 校验提示
         */
        l && e.editRules && Ma.showMessage && (Ma.message === "default" ? !J : Ma.message === "tooltip") ? V(Dt("vxe-tooltip"), {
          ref: p,
          class: [{
            "old-cell-valid": lt && ee.cellVaildMode === "obsolete"
          }, "vxe-table--valid-error"],
          ...Ma.message === "tooltip" || wt.length === 1 ? js : {}
        }) : _e()
      ]);
    };
    return be.renderVN = Ft, Mt("xecolgroup", null), Mt("$xetable", be), be;
  },
  render() {
    return this.renderVN();
  }
}), dh = Object.assign(id, {
  install: function(e) {
    e.component(id.name, id);
  }
}), rEe = dh;
Fn.component(id.name, id);
const fh = Object.assign(Si, {
  install: function(e) {
    e.component(Si.name, Si);
  }
}), sEe = fh;
Fn.component(Si.name, Si);
const cd = Q({
  name: "VxePager",
  props: {
    size: { type: String, default: () => ee.pager.size || ee.size },
    // 自定义布局
    layouts: { type: Array, default: () => ee.pager.layouts || ["PrevJump", "PrevPage", "Jump", "PageCount", "NextPage", "NextJump", "Sizes", "Total"] },
    // 当前页
    currentPage: { type: Number, default: 1 },
    // 加载中
    loading: Boolean,
    // 每页大小
    pageSize: { type: Number, default: () => ee.pager.pageSize || 10 },
    // 总条数
    total: { type: Number, default: 0 },
    // 显示页码按钮的数量
    pagerCount: { type: Number, default: () => ee.pager.pagerCount || 7 },
    // 每页大小选项列表
    pageSizes: { type: Array, default: () => ee.pager.pageSizes || [10, 15, 20, 50, 100] },
    // 列对其方式
    align: { type: String, default: () => ee.pager.align },
    // 带边框
    border: { type: Boolean, default: () => ee.pager.border },
    // 带背景颜色
    background: { type: Boolean, default: () => ee.pager.background },
    // 配套的样式
    perfect: { type: Boolean, default: () => ee.pager.perfect },
    // 当只有一页时隐藏
    autoHidden: { type: Boolean, default: () => ee.pager.autoHidden },
    transfer: { type: Boolean, default: () => ee.pager.transfer },
    className: [String, Function],
    // 自定义图标
    iconPrevPage: String,
    iconJumpPrev: String,
    iconJumpNext: String,
    iconNextPage: String,
    iconJumpMore: String,
    iconHomePage: String,
    iconEndPage: String
  },
  emits: [
    "update:pageSize",
    "update:currentPage",
    "page-change"
  ],
  setup(e, t) {
    const { slots: n, emit: o } = t, l = I.uniqueId(), a = Po(e), r = ot("$xegrid", null), i = en({
      inpCurrPage: e.currentPage
    }), s = B(), u = {
      refElem: s
    }, d = {
      xID: l,
      props: e,
      context: t,
      getRefMaps: () => u
    };
    let f = {}, v = {};
    const h = (Y, ve) => Math.max(Math.ceil(Y / ve), 1), m = x(() => h(e.total, e.pageSize)), p = (Y, ve) => {
      o("update:currentPage", ve), Y && ve !== e.currentPage && f.dispatchEvent("page-change", { type: "current", pageSize: e.pageSize, currentPage: ve }, Y);
    }, C = (Y, ve) => {
      o("update:currentPage", Y), ve && Y !== e.currentPage && f.dispatchEvent("page-change", { type: "current", pageSize: e.pageSize, currentPage: Y }, ve);
    }, g = (Y) => {
      const ve = Y.target, ie = I.toInteger(ve.value), he = m.value, De = ie <= 0 ? 1 : ie >= he ? he : ie, $e = I.toValueString(De);
      ve.value = $e, i.inpCurrPage = $e, C(De, Y);
    }, w = x(() => {
      const { pagerCount: Y } = e, ie = m.value > Y ? Y - 2 : Y, he = [];
      for (let De = 0; De < ie; De++)
        he.push(De);
      return he;
    }), b = x(() => Math.floor((e.pagerCount - 2) / 2)), y = x(() => e.pageSizes.map((Y) => I.isNumber(Y) ? {
      value: Y,
      label: `${ee.i18n("vxe.pager.pagesize", [Y])}`
    } : { value: "", label: "", ...Y })), E = (Y) => {
      const { currentPage: ve } = e;
      ve > 1 && C(1, Y);
    }, S = (Y) => {
      const { currentPage: ve } = e, ie = m.value;
      ve < ie && C(ie, Y);
    }, _ = (Y) => {
      const { currentPage: ve } = e, ie = m.value;
      ve > 1 && C(Math.min(ie, Math.max(ve - 1, 1)), Y);
    }, k = (Y) => {
      const { currentPage: ve } = e, ie = m.value;
      ve < ie && C(Math.min(ie, ve + 1), Y);
    }, N = (Y) => {
      const ve = w.value;
      C(Math.max(e.currentPage - ve.length, 1), Y);
    }, L = (Y) => {
      const ve = m.value, ie = w.value;
      C(Math.min(e.currentPage + ie.length, ve), Y);
    }, R = (Y) => {
      const { value: ve } = Y, ie = I.toNumber(ve), he = h(e.total, ie);
      let De = e.currentPage;
      De > he && (De = he, o("update:currentPage", he)), o("update:pageSize", ie), f.dispatchEvent("page-change", { type: "size", pageSize: ie, currentPage: De });
    }, H = (Y) => {
      const ve = Y.target;
      i.inpCurrPage = ve.value;
    }, K = (Y) => {
      Cn(Y, un.ENTER) ? g(Y) : Cn(Y, un.ARROW_UP) ? (Y.preventDefault(), k(Y)) : Cn(Y, un.ARROW_DOWN) && (Y.preventDefault(), _(Y));
    }, U = () => V("button", {
      class: ["vxe-pager--prev-btn", {
        "is--disabled": e.currentPage <= 1
      }],
      type: "button",
      title: ee.i18n("vxe.pager.homePageTitle"),
      onClick: E
    }, [
      V("i", {
        class: ["vxe-pager--btn-icon", e.iconHomePage || ee.icon.PAGER_HOME]
      })
    ]), W = () => V("button", {
      class: ["vxe-pager--prev-btn", {
        "is--disabled": e.currentPage <= 1
      }],
      type: "button",
      title: ee.i18n("vxe.pager.prevPageTitle"),
      onClick: _
    }, [
      V("i", {
        class: ["vxe-pager--btn-icon", e.iconPrevPage || ee.icon.PAGER_PREV_PAGE]
      })
    ]), A = (Y) => V(Y || "button", {
      class: ["vxe-pager--jump-prev", {
        "is--fixed": !Y,
        "is--disabled": e.currentPage <= 1
      }],
      type: "button",
      title: ee.i18n("vxe.pager.prevJumpTitle"),
      onClick: N
    }, [
      Y ? V("i", {
        class: ["vxe-pager--jump-more-icon", e.iconJumpMore || ee.icon.PAGER_JUMP_MORE]
      }) : null,
      V("i", {
        class: ["vxe-pager--jump-icon", e.iconJumpPrev || ee.icon.PAGER_JUMP_PREV]
      })
    ]), $ = (Y) => {
      const ve = m.value;
      return V(Y || "button", {
        class: ["vxe-pager--jump-next", {
          "is--fixed": !Y,
          "is--disabled": e.currentPage >= ve
        }],
        type: "button",
        title: ee.i18n("vxe.pager.nextJumpTitle"),
        onClick: L
      }, [
        Y ? V("i", {
          class: ["vxe-pager--jump-more-icon", e.iconJumpMore || ee.icon.PAGER_JUMP_MORE]
        }) : null,
        V("i", {
          class: ["vxe-pager--jump-icon", e.iconJumpNext || ee.icon.PAGER_JUMP_NEXT]
        })
      ]);
    }, D = () => {
      const Y = m.value;
      return V("button", {
        class: ["vxe-pager--next-btn", {
          "is--disabled": e.currentPage >= Y
        }],
        type: "button",
        title: ee.i18n("vxe.pager.nextPageTitle"),
        onClick: k
      }, [
        V("i", {
          class: ["vxe-pager--btn-icon", e.iconNextPage || ee.icon.PAGER_NEXT_PAGE]
        })
      ]);
    }, O = () => {
      const Y = m.value;
      return V("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": e.currentPage >= Y
        }],
        type: "button",
        title: ee.i18n("vxe.pager.endPageTitle"),
        onClick: S
      }, [
        V("i", {
          class: ["vxe-pager--btn-icon", e.iconEndPage || ee.icon.PAGER_END]
        })
      ]);
    }, F = (Y) => {
      const { currentPage: ve, pagerCount: ie } = e, he = [], De = m.value, $e = w.value, ue = b.value, Ne = De > ie, je = Ne && ve > ue + 1, Fe = Ne && ve < De - ue;
      let Ve = 1;
      return Ne && (ve >= De - ue ? Ve = Math.max(De - $e.length + 1, 1) : Ve = Math.max(ve - ue, 1)), Y && je && he.push(V("button", {
        class: "vxe-pager--num-btn",
        type: "button",
        onClick: (Ze) => p(Ze, 1)
      }, 1), A("span")), $e.forEach((Ze, ae) => {
        const pe = Ve + ae;
        pe <= De && he.push(V("button", {
          key: pe,
          class: ["vxe-pager--num-btn", {
            "is--active": ve === pe
          }],
          type: "button",
          onClick: (ke) => p(ke, pe)
        }, pe));
      }), Y && Fe && he.push($("button"), V("button", {
        class: "vxe-pager--num-btn",
        type: "button",
        onClick: (Ze) => p(Ze, De)
      }, De)), V("span", {
        class: "vxe-pager--btn-wrapper"
      }, he);
    }, j = () => F(!0), Z = () => {
      const Y = y.value;
      return V(fh, {
        class: "vxe-pager--sizes",
        modelValue: e.pageSize,
        placement: "top",
        transfer: e.transfer,
        options: Y,
        onChange: R
      });
    }, te = (Y) => V("span", {
      class: "vxe-pager--jump"
    }, [
      Y ? V("span", {
        class: "vxe-pager--goto-text"
      }, ee.i18n("vxe.pager.goto")) : null,
      V("input", {
        class: "vxe-pager--goto",
        value: i.inpCurrPage,
        type: "text",
        autocomplete: "off",
        onInput: H,
        onKeydown: K,
        onBlur: g
      }),
      Y ? V("span", {
        class: "vxe-pager--classifier-text"
      }, ee.i18n("vxe.pager.pageClassifier")) : null
    ]), de = () => te(!0), Oe = () => {
      const Y = m.value;
      return V("span", {
        class: "vxe-pager--count"
      }, [
        V("span", {
          class: "vxe-pager--separator"
        }),
        V("span", Y)
      ]);
    }, ce = () => V("span", {
      class: "vxe-pager--total"
    }, ee.i18n("vxe.pager.total", [e.total]));
    f = {
      dispatchEvent(Y, ve, ie) {
        o(Y, Object.assign({ $pager: d, $event: ie }, ve));
      },
      homePage() {
        return E(), xe();
      },
      endPage() {
        return S(), xe();
      },
      prevPage() {
        return _(), xe();
      },
      nextPage() {
        return k(), xe();
      },
      prevJump() {
        return N(), xe();
      },
      nextJump() {
        return L(), xe();
      }
    }, v = {
      handlePrevPage: _,
      handleNextPage: k,
      handlePrevJump: N,
      handleNextJump: L
    }, Object.assign(d, f, v), Pe(() => e.currentPage, (Y) => {
      i.inpCurrPage = Y;
    });
    const ne = () => {
      const { align: Y, layouts: ve, className: ie } = e, he = [], De = a.value, $e = m.value;
      return n.left && he.push(V("span", {
        class: "vxe-pager--left-wrapper"
      }, n.left({ $grid: r }))), ve.forEach((ue) => {
        let Ne;
        switch (ue) {
          case "Home":
            Ne = U;
            break;
          case "PrevJump":
            Ne = A;
            break;
          case "PrevPage":
            Ne = W;
            break;
          case "Number":
            Ne = F;
            break;
          case "JumpNumber":
            Ne = j;
            break;
          case "NextPage":
            Ne = D;
            break;
          case "NextJump":
            Ne = $;
            break;
          case "End":
            Ne = O;
            break;
          case "Sizes":
            Ne = Z;
            break;
          case "FullJump":
            Ne = de;
            break;
          case "Jump":
            Ne = te;
            break;
          case "PageCount":
            Ne = Oe;
            break;
          case "Total":
            Ne = ce;
            break;
        }
        Ne ? he.push(Ne()) : process.env.NODE_ENV === "development" && Ht("vxe.error.notProp", [`layouts -> ${ue}`]);
      }), n.right && he.push(V("span", {
        class: "vxe-pager--right-wrapper"
      }, n.right({ $grid: r }))), V("div", {
        ref: s,
        class: ["vxe-pager", ie ? I.isFunction(ie) ? ie({ $pager: d }) : ie : "", {
          [`size--${De}`]: De,
          [`align--${Y}`]: Y,
          "is--border": e.border,
          "is--background": e.background,
          "is--perfect": e.perfect,
          "is--hidden": e.autoHidden && $e === 1,
          "is--loading": e.loading
        }]
      }, [
        V("div", {
          class: "vxe-pager--wrapper"
        }, he)
      ]);
    };
    return d.renderVN = ne, d;
  },
  render() {
    return this.renderVN();
  }
}), ph = Object.assign(cd, {
  install: function(e) {
    e.component(cd.name, cd);
  }
}), iEe = ph;
Fn.component(cd.name, cd);
const da = Object.assign(Tl, {
  install(e) {
    e.component(Tl.name, Tl);
  }
}), cEe = da;
Fn.component(Tl.name, Tl);
const ud = Q({
  name: "VxeToolbar",
  props: {
    loading: Boolean,
    refresh: [Boolean, Object],
    import: [Boolean, Object],
    export: [Boolean, Object],
    print: [Boolean, Object],
    zoom: [Boolean, Object],
    custom: [Boolean, Object],
    buttons: { type: Array, default: () => ee.toolbar.buttons },
    tools: { type: Array, default: () => ee.toolbar.tools },
    perfect: { type: Boolean, default: () => ee.toolbar.perfect },
    size: { type: String, default: () => ee.toolbar.size || ee.size },
    className: [String, Function]
  },
  emits: [
    "button-click",
    "tool-click"
  ],
  setup(e, t) {
    const { slots: n, emit: o } = t, l = I.uniqueId(), a = Po(e), r = en({
      isRefresh: !1,
      columns: []
    }), i = B(), s = {
      refElem: i
    }, u = {
      xID: l,
      props: e,
      context: t,
      reactData: r,
      getRefMaps: () => s
    };
    let d = {};
    const f = ot("$xegrid", null);
    let v;
    const h = B(0), m = x(() => Object.assign({}, ee.toolbar.refresh, e.refresh)), p = x(() => Object.assign({}, ee.toolbar.import, e.import)), C = x(() => Object.assign({}, ee.toolbar.export, e.export)), g = x(() => Object.assign({}, ee.toolbar.print, e.print)), w = x(() => Object.assign({}, ee.toolbar.zoom, e.zoom)), b = x(() => Object.assign({}, ee.toolbar.custom, e.custom)), y = x(() => {
      if ((h.value || v) && v) {
        const { computeCustomOpts: ne } = v.getComputeMaps();
        return ne.value;
      }
      return {};
    }), E = x(() => y.value.trigger), S = () => {
      if (v)
        return !0;
      Ht("vxe.error.barUnableLink");
    }, _ = ({ $event: ne }) => {
      v && v.triggerCustomEvent(ne);
    }, k = ({ $event: ne }) => {
      v && v.customOpenEvent(ne);
    }, N = ({ $event: ne }) => {
      const { customStore: Y } = v.reactData;
      Y.activeBtn = !1, setTimeout(() => {
        !Y.activeBtn && !Y.activeWrapper && v.customColseEvent(ne);
      }, 350);
    }, L = (ne) => {
      const { isRefresh: Y } = r, ve = m.value;
      if (!Y) {
        const ie = ve.queryMethod || ve.query;
        if (ie) {
          r.isRefresh = !0;
          try {
            Promise.resolve(ie({})).catch((he) => he).then(() => {
              r.isRefresh = !1;
            });
          } catch {
            r.isRefresh = !1;
          }
        } else
          f && (r.isRefresh = !0, f.triggerToolbarCommitEvent({ code: ve.code || "reload" }, ne).catch((he) => he).then(() => {
            r.isRefresh = !1;
          }));
      }
    }, R = (ne) => {
      f && f.triggerZoomEvent(ne);
    }, H = (ne, Y) => {
      const { code: ve } = Y;
      if (ve)
        if (f)
          f.triggerToolbarBtnEvent(Y, ne);
        else {
          const ie = $t.commands.get(ve), he = { code: ve, button: Y, $table: v, $grid: f, $event: ne };
          ie && (ie.commandMethod ? ie.commandMethod(he) : process.env.NODE_ENV === "development" && Ht("vxe.error.notCommands", [ve])), u.dispatchEvent("button-click", he, ne);
        }
    }, K = (ne, Y) => {
      const { code: ve } = Y;
      if (ve)
        if (f)
          f.triggerToolbarTolEvent(Y, ne);
        else {
          const ie = $t.commands.get(ve), he = { code: ve, tool: Y, $table: v, $grid: f, $event: ne };
          ie && (ie.commandMethod ? ie.commandMethod(he) : process.env.NODE_ENV === "development" && Ht("vxe.error.notCommands", [ve])), u.dispatchEvent("tool-click", he, ne);
        }
    }, U = () => {
      S() && v.openImport();
    }, W = () => {
      S() && v.openExport();
    }, A = () => {
      S() && v.openPrint();
    }, $ = (ne, Y) => {
      const { dropdowns: ve } = ne, ie = [];
      return ve ? ve.map((he, De) => he.visible === !1 ? _e() : V(da, {
        key: De,
        disabled: he.disabled,
        loading: he.loading,
        type: he.type,
        icon: he.icon,
        circle: he.circle,
        round: he.round,
        status: he.status,
        content: he.name,
        onClick: ($e) => Y ? H($e, he) : K($e, he)
      })) : ie;
    }, D = () => {
      const { buttons: ne } = e, Y = n.buttons;
      if (Y)
        return oo(Y({ $grid: f, $table: v }));
      const ve = [];
      return ne && ne.forEach((ie) => {
        const { dropdowns: he, buttonRender: De } = ie;
        if (ie.visible !== !1) {
          const $e = De ? $t.renderer.get(De.name) : null;
          if (De && $e && $e.renderToolbarButton) {
            const ue = $e.toolbarButtonClassName, Ne = { $grid: f, $table: v, button: ie };
            ve.push(V("span", {
              class: ["vxe-button--item", ue ? I.isFunction(ue) ? ue(Ne) : ue : ""]
            }, oo($e.renderToolbarButton(De, Ne))));
          } else
            ve.push(V(da, {
              disabled: ie.disabled,
              loading: ie.loading,
              type: ie.type,
              icon: ie.icon,
              circle: ie.circle,
              round: ie.round,
              status: ie.status,
              content: ie.name,
              destroyOnClose: ie.destroyOnClose,
              placement: ie.placement,
              transfer: ie.transfer,
              onClick: (ue) => H(ue, ie)
            }, he && he.length ? {
              dropdowns: () => $(ie, !0)
            } : {}));
        }
      }), ve;
    }, O = () => {
      const { tools: ne } = e, Y = n.tools;
      if (Y)
        return oo(Y({ $grid: f, $table: v }));
      const ve = [];
      return ne && ne.forEach((ie, he) => {
        const { dropdowns: De, toolRender: $e } = ie;
        if (ie.visible !== !1) {
          const ue = $e ? $e.name : null, Ne = $e ? $t.renderer.get(ue) : null;
          if ($e && Ne && Ne.renderToolbarTool) {
            const je = Ne.toolbarToolClassName, Fe = { $grid: f, $table: v, tool: ie };
            ve.push(V("span", {
              key: ue,
              class: ["vxe-tool--item", je ? I.isFunction(je) ? je(Fe) : je : ""]
            }, oo(Ne.renderToolbarTool($e, Fe))));
          } else
            ve.push(V(da, {
              key: he,
              disabled: ie.disabled,
              loading: ie.loading,
              type: ie.type,
              icon: ie.icon,
              circle: ie.circle,
              round: ie.round,
              status: ie.status,
              content: ie.name,
              destroyOnClose: ie.destroyOnClose,
              placement: ie.placement,
              transfer: ie.transfer,
              onClick: (je) => K(je, ie)
            }, De && De.length ? {
              dropdowns: () => $(ie, !1)
            } : {}));
        }
      }), ve;
    }, F = () => {
      const ne = p.value;
      return V(da, {
        key: "import",
        circle: !0,
        icon: ne.icon || ee.icon.TOOLBAR_TOOLS_IMPORT,
        title: ee.i18n("vxe.toolbar.import"),
        onClick: U
      });
    }, j = () => {
      const ne = C.value;
      return V(da, {
        key: "export",
        circle: !0,
        icon: ne.icon || ee.icon.TOOLBAR_TOOLS_EXPORT,
        title: ee.i18n("vxe.toolbar.export"),
        onClick: W
      });
    }, Z = () => {
      const ne = g.value;
      return V(da, {
        key: "print",
        circle: !0,
        icon: ne.icon || ee.icon.TOOLBAR_TOOLS_PRINT,
        title: ee.i18n("vxe.toolbar.print"),
        onClick: A
      });
    }, te = () => {
      const ne = m.value;
      return V(da, {
        key: "refresh",
        circle: !0,
        icon: r.isRefresh ? ne.iconLoading || ee.icon.TOOLBAR_TOOLS_REFRESH_LOADING : ne.icon || ee.icon.TOOLBAR_TOOLS_REFRESH,
        title: ee.i18n("vxe.toolbar.refresh"),
        onClick: L
      });
    }, de = () => {
      const ne = w.value;
      return f ? V(da, {
        key: "zoom",
        circle: !0,
        icon: f.isMaximized() ? ne.iconOut || ee.icon.TOOLBAR_TOOLS_MINIMIZE : ne.iconIn || ee.icon.TOOLBAR_TOOLS_FULLSCREEN,
        title: ee.i18n(`vxe.toolbar.zoom${f.isMaximized() ? "Out" : "In"}`),
        onClick: R
      }) : _e();
    }, Oe = () => {
      const ne = b.value, Y = E.value, ve = {};
      return Y === "manual" || (Y === "hover" ? (ve.onMouseenter = k, ve.onMouseleave = N) : ve.onClick = _), V(da, {
        key: "custom",
        circle: !0,
        icon: ne.icon || ee.icon.TOOLBAR_TOOLS_CUSTOM,
        title: ee.i18n("vxe.toolbar.custom"),
        className: "vxe-toolbar-custom-target",
        ...ve
      });
    };
    d = {
      dispatchEvent(ne, Y, ve) {
        o(ne, Object.assign({ $toolbar: u, $event: ve }, Y));
      },
      syncUpdate(ne) {
        const { collectColumn: Y } = ne;
        v = ne.$table, r.columns = Y, h.value++;
      }
    }, Object.assign(u, d), xe(() => {
      const { refresh: ne } = e, Y = m.value, ve = Y.queryMethod || Y.query;
      ne && !f && !ve && qt("vxe.error.notFunc", ["queryMethod"]);
      const ie = b.value;
      process.env.NODE_ENV === "development" && (ie.isFooter && qt("vxe.error.delProp", ["toolbar.custom.isFooter", "table.custom-config.showFooter"]), ie.showFooter && qt("vxe.error.delProp", ["toolbar.custom.showFooter", "table.custom-config.showFooter"]), ie.immediate && qt("vxe.error.delProp", ["toolbar.custom.immediate", "table.custom-config.immediate"]), ie.trigger && qt("vxe.error.delProp", ["toolbar.custom.trigger", "table.custom-config.trigger"]));
    });
    const ce = () => {
      const { perfect: ne, loading: Y, refresh: ve, zoom: ie, custom: he, className: De } = e, $e = a.value;
      return V("div", {
        ref: i,
        class: ["vxe-toolbar", De ? I.isFunction(De) ? De({ $toolbar: u }) : De : "", {
          [`size--${$e}`]: $e,
          "is--perfect": ne,
          "is--loading": Y
        }]
      }, [
        V("div", {
          class: "vxe-buttons--wrapper"
        }, D()),
        V("div", {
          class: "vxe-tools--wrapper"
        }, O()),
        V("div", {
          class: "vxe-tools--operate"
        }, [
          e.import ? F() : _e(),
          e.export ? j() : _e(),
          e.print ? Z() : _e(),
          ve ? te() : _e(),
          ie && f ? de() : _e(),
          he ? Oe() : _e()
        ])
      ]);
    };
    return u.renderVN = ce, u;
  },
  render() {
    return this.renderVN();
  }
}), vh = Object.assign(ud, {
  install: function(e) {
    e.component(ud.name, ud);
  }
}), uEe = vh;
Fn.component(ud.name, ud);
class oR {
  constructor(t, n) {
    Object.assign(this, {
      id: I.uniqueId("item_"),
      title: n.title,
      field: n.field,
      span: n.span,
      align: n.align,
      titleAlign: n.titleAlign,
      titleWidth: n.titleWidth,
      titleColon: n.titleColon,
      titleAsterisk: n.titleAsterisk,
      titlePrefix: n.titlePrefix,
      titleSuffix: n.titleSuffix,
      titleOverflow: n.titleOverflow,
      showTitle: n.showTitle,
      resetValue: n.resetValue,
      visibleMethod: n.visibleMethod,
      visible: n.visible,
      folding: n.folding,
      collapseNode: n.collapseNode,
      className: n.className,
      contentClassName: n.contentClassName,
      contentStyle: n.contentStyle,
      titleClassName: n.titleClassName,
      titleStyle: n.titleStyle,
      itemRender: n.itemRender,
      // 渲染属性
      showError: !1,
      errRule: null,
      slots: n.slots,
      children: []
    });
  }
  update(t, n) {
    this[t] = n;
  }
}
function dEe(e) {
  return e instanceof oR;
}
function y1(e, t) {
  return dEe(t) ? t : new oR(e, t);
}
function X_(e, t) {
  return t ? I.isString(t) ? e.getItemByField(t) : t : null;
}
function fEe(e, t) {
  const { reactData: n } = e, { collapseAll: o } = n, { folding: l, visible: a } = t;
  return a === !1 || l && o;
}
function C1(e, t) {
  let { visibleMethod: n, itemRender: o, visible: l, field: a } = t;
  if (l === !1)
    return l;
  const r = mn(o) ? $t.renderer.get(o.name) : null;
  if (!n && r && r.itemVisibleMethod && (n = r.itemVisibleMethod), !n)
    return !0;
  const { data: i } = e.props;
  return n({ data: i, field: a, property: a, item: t, $form: e, $grid: e.xegrid });
}
function lR(e, t) {
  Object.keys(e).forEach((n) => {
    Pe(() => e[n], (o) => {
      t.update(n, o);
    });
  });
}
function aR(e, t, n, o) {
  const { reactData: l } = e, { staticItems: a } = l, r = t.parentNode, i = o ? o.formItem : null, s = i ? i.children : a;
  r && (s.splice(I.arrayIndexOf(r.children, t), 0, n), l.staticItems = a.slice(0));
}
function rR(e, t) {
  const { reactData: n } = e, { staticItems: o } = n, l = I.findIndexOf(o, (a) => a.id === t.id);
  l > -1 && o.splice(l, 1), n.staticItems = o.slice(0);
}
const Jc = Object.assign(Ic, {
  install: function(e) {
    $t.tooltip = !0, e.component(Ic.name, Ic);
  }
}), pEe = Jc;
Fn.component(Ic.name, Ic);
function Z_(e) {
  return V("span", {
    class: "vxe-form--item-title-prefix"
  }, [
    V("i", {
      class: e.icon || ee.icon.FORM_PREFIX
    })
  ]);
}
function J_(e) {
  return V("span", {
    class: "vxe-form--item-title-suffix"
  }, [
    V("i", {
      class: e.icon || ee.icon.FORM_SUFFIX
    })
  ]);
}
function sR(e, t) {
  const { data: n } = e.props, { computeTooltipOpts: o } = e.getComputeMaps(), { slots: l, field: a, itemRender: r, titlePrefix: i, titleSuffix: s } = t, u = o.value, d = mn(r) ? $t.renderer.get(r.name) : null, f = { data: n, field: a, property: a, item: t, $form: e, $grid: e.xegrid }, v = l ? l.title : null, h = [], m = [];
  i && m.push(i.content || i.message ? V(Jc, {
    ...u,
    ...i,
    content: vo(i.content || i.message)
  }, {
    default: () => Z_(i)
  }) : Z_(i)), m.push(V("span", {
    class: "vxe-form--item-title-label"
  }, d && d.renderItemTitle ? oo(d.renderItemTitle(r, f)) : v ? e.callSlot(v, f) : vo(t.title))), h.push(V("div", {
    class: "vxe-form--item-title-content"
  }, m));
  const p = [];
  return s && p.push(s.content || s.message ? V(Jc, {
    ...u,
    ...s,
    content: vo(s.content || s.message)
  }, {
    default: () => J_(s)
  }) : J_(s)), h.push(V("div", {
    class: "vxe-form--item-title-postfix"
  }, p)), h;
}
const iR = Q({
  name: "VxeFormConfigItem",
  props: {
    itemConfig: Object
  },
  setup(e) {
    const t = ot("$xeform", {}), n = { itemConfig: e.itemConfig };
    return Mt("$xeformiteminfo", n), Mt("$xeformgather", null), {
      renderVN: () => {
        const { reactData: a } = t, { data: r, rules: i, span: s, align: u, titleAlign: d, titleWidth: f, titleColon: v, titleAsterisk: h, titleOverflow: m, vertical: p } = t.props, { computeValidOpts: C } = t.getComputeMaps(), g = e.itemConfig, { collapseAll: w } = a, b = C.value, { slots: y, title: E, visible: S, folding: _, field: k, collapseNode: N, itemRender: L, showError: R, errRule: H, className: K, titleOverflow: U, vertical: W, children: A, showTitle: $, contentClassName: D, contentStyle: O, titleClassName: F, titleStyle: j } = g, Z = mn(L) ? $t.renderer.get(L.name) : null, te = Z ? Z.itemClassName : "", de = Z ? Z.itemStyle : null, Oe = Z ? Z.itemContentClassName : "", ce = Z ? Z.itemContentStyle : null, ne = Z ? Z.itemTitleClassName : "", Y = Z ? Z.itemTitleStyle : null, ve = y ? y.default : null, ie = y ? y.title : null, he = g.span || s, De = g.align || u, $e = I.eqNull(g.titleAlign) ? d : g.titleAlign, ue = I.eqNull(g.titleWidth) ? f : g.titleWidth, Ne = I.eqNull(g.titleColon) ? v : g.titleColon, je = I.eqNull(g.titleAsterisk) ? h : g.titleAsterisk, Fe = I.isUndefined(U) || I.isNull(U) ? m : U, Ve = I.isUndefined(W) || I.isNull(W) ? p : W, Ze = Fe === "ellipsis", ae = Fe === "title", pe = Fe === !0 || Fe === "tooltip", ke = ae || pe || Ze, Ue = { data: r, field: k, property: k, item: g, $form: t, $grid: t.xegrid };
        if (S === !1)
          return _e();
        let Xe = !1;
        if (i) {
          const Le = i[k];
          Le && (Xe = Le.some((ge) => ge.required));
        }
        if (A && A.length > 0) {
          const Le = A.map((ge, Ee) => V(iR, {
            key: Ee,
            itemConfig: ge
          }));
          return Le.length ? V("div", {
            class: ["vxe-form--gather vxe-row", g.id, he ? `vxe-col--${he} is--span` : "", K ? I.isFunction(K) ? K(Ue) : K : ""]
          }, Le) : _e();
        }
        let Te = [];
        ve ? Te = t.callSlot(ve, Ue) : Z && Z.renderItemContent ? Te = oo(Z.renderItemContent(L, Ue)) : k && (Te = [I.toValueString(I.get(r, k))]), N && Te.push(V("div", {
          class: "vxe-form--item-trigger-node",
          onClick: t.toggleCollapseEvent
        }, [
          V("span", {
            class: "vxe-form--item-trigger-text"
          }, w ? ee.i18n("vxe.form.unfolding") : ee.i18n("vxe.form.folding")),
          V("i", {
            class: ["vxe-form--item-trigger-icon", w ? ee.icon.FORM_FOLDING : ee.icon.FORM_UNFOLDING]
          })
        ])), H && b.showMessage && Te.push(V("div", {
          class: "vxe-form--item-valid",
          style: H.maxWidth ? {
            width: `${H.maxWidth}px`
          } : null
        }, H.content));
        const Ce = pe ? {
          onMouseenter(Le) {
            t.triggerTitleTipEvent(Le, Ue);
          },
          onMouseleave: t.handleTitleTipLeaveEvent
        } : {};
        return V("div", {
          class: [
            "vxe-form--item",
            g.id,
            he ? `vxe-col--${he} is--span` : "",
            K ? I.isFunction(K) ? K(Ue) : K : "",
            te ? I.isFunction(te) ? te(Ue) : te : "",
            {
              "is--title": E,
              "is--colon": Ne,
              "is--vertical": Ve,
              "is--asterisk": je,
              "is--required": Xe,
              "is--hidden": _ && w,
              "is--active": C1(t, g),
              "is--error": R
            }
          ],
          style: I.isFunction(de) ? de(Ue) : de
        }, [
          V("div", {
            class: "vxe-form--item-inner"
          }, [
            $ !== !1 && (E || ie) ? V("div", {
              class: [
                "vxe-form--item-title",
                $e ? `align--${$e}` : "",
                ke ? "is--ellipsis" : "",
                ne ? I.isFunction(ne) ? ne(Ue) : ne : "",
                F ? I.isFunction(F) ? F(Ue) : F : ""
              ],
              style: Object.assign({}, I.isFunction(Y) ? Y(Ue) : Y, I.isFunction(j) ? j(Ue) : j, ue ? {
                width: isNaN(ue) ? ue : `${ue}px`
              } : null),
              title: ae ? vo(E) : null,
              ...Ce
            }, sR(t, g)) : null,
            V("div", {
              class: [
                "vxe-form--item-content",
                De ? `align--${De}` : "",
                Oe ? I.isFunction(Oe) ? Oe(Ue) : Oe : "",
                D ? I.isFunction(D) ? D(Ue) : D : ""
              ],
              style: Object.assign({}, I.isFunction(ce) ? ce(Ue) : ce, I.isFunction(O) ? O(Ue) : O)
            }, Te)
          ])
        ]);
      }
    };
  },
  render() {
    return this.renderVN();
  }
});
class Bu {
  constructor(t) {
    Object.assign(this, {
      $options: t,
      required: t.required,
      min: t.min,
      max: t.min,
      type: t.type,
      pattern: t.pattern,
      validator: t.validator,
      trigger: t.trigger,
      maxWidth: t.maxWidth
    });
  }
  get content() {
    return vo(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
}
const Q_ = (e, t) => {
  const { type: n, min: o, max: l, pattern: a } = e, r = n === "number", i = r ? I.toNumber(t) : I.getSize(t);
  return !!(r && isNaN(t) || !I.eqNull(o) && i < I.toNumber(o) || !I.eqNull(l) && i > I.toNumber(l) || a && !(I.isRegExp(a) ? a : new RegExp(a)).test(t));
};
function vEe(e, t) {
  return I.isArray(e) && (t = []), t;
}
const dd = Q({
  name: "VxeForm",
  props: {
    collapseStatus: { type: Boolean, default: !0 },
    loading: Boolean,
    data: Object,
    size: { type: String, default: () => ee.form.size || ee.size },
    span: { type: [String, Number], default: () => ee.form.span },
    align: { type: String, default: () => ee.form.align },
    titleAlign: { type: String, default: () => ee.form.titleAlign },
    titleWidth: { type: [String, Number], default: () => ee.form.titleWidth },
    titleColon: { type: Boolean, default: () => ee.form.titleColon },
    titleAsterisk: { type: Boolean, default: () => ee.form.titleAsterisk },
    titleOverflow: { type: [Boolean, String], default: null },
    vertical: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    readonly: Boolean,
    items: Array,
    rules: Object,
    preventSubmit: { type: Boolean, default: () => ee.form.preventSubmit },
    validConfig: Object,
    tooltipConfig: Object,
    customLayout: { type: Boolean, default: () => ee.form.customLayout }
  },
  emits: [
    "update:collapseStatus",
    "collapse",
    "toggle-collapse",
    "submit",
    "submit-invalid",
    "reset"
  ],
  setup(e, t) {
    const n = $t.tooltip, { slots: o, emit: l } = t, a = I.uniqueId(), r = Po(e), i = en({
      collapseAll: e.collapseStatus,
      staticItems: [],
      formItems: []
    }), s = en({
      tooltipTimeout: null,
      tooltipStore: {
        item: null,
        visible: !1
      }
    }), u = ot("$xegrid", null), d = B(), f = B();
    let v = {};
    const h = x(() => Object.assign({}, ee.form.validConfig, e.validConfig)), m = x(() => Object.assign({}, ee.tooltip, ee.form.tooltipConfig, e.tooltipConfig)), p = {
      refElem: d
    }, C = {
      computeSize: r,
      computeValidOpts: h,
      computeTooltipOpts: m
    }, g = {
      xID: a,
      props: e,
      context: t,
      reactData: i,
      xegrid: u,
      getRefMaps: () => p,
      getComputeMaps: () => C
    }, w = (Y, ve) => Y && (I.isString(Y) && (Y = o[Y] || null), I.isFunction(Y)) ? oo(Y(ve)) : [], b = (Y) => (Y.length && (process.env.NODE_ENV === "development" && Y.forEach((ve) => {
      ve.slots && I.each(ve.slots, (ie) => {
        I.isFunction(ie) || o[ie] || Ht("vxe.error.notSlot", [ie]);
      });
    }), i.staticItems = I.mapTree(Y, (ve) => y1(g, ve), { children: "children" })), xe()), y = () => {
      const Y = [];
      return I.eachTree(i.formItems, (ve) => {
        Y.push(ve);
      }, { children: "children" }), Y;
    }, E = (Y) => {
      const ve = I.findTree(i.formItems, (ie) => ie.field === Y, { children: "children" });
      return ve ? ve.item : null;
    }, S = () => i.collapseAll, _ = () => {
      const Y = !S();
      return i.collapseAll = Y, l("update:collapseStatus", Y), xe();
    }, k = (Y) => {
      _();
      const ve = S();
      v.dispatchEvent("toggle-collapse", { status: ve, collapse: ve, data: e.data }, Y), v.dispatchEvent("collapse", { status: ve, collapse: ve, data: e.data }, Y);
    }, N = (Y) => {
      if (Y) {
        let ve = Y;
        I.isArray(Y) || (ve = [Y]), ve.forEach((ie) => {
          if (ie) {
            const he = X_(g, ie);
            he && (he.showError = !1);
          }
        });
      } else
        y().forEach((ve) => {
          ve.showError = !1;
        });
      return xe();
    }, L = () => {
      const { data: Y } = e, ve = y();
      return Y && ve.forEach((ie) => {
        const { field: he, resetValue: De, itemRender: $e } = ie;
        if (mn($e)) {
          const ue = $t.renderer.get($e.name);
          ue && ue.itemResetMethod ? ue.itemResetMethod({ data: Y, field: he, property: he, item: ie, $form: g, $grid: g.xegrid }) : he && I.set(Y, he, De === null ? vEe(I.get(Y, he), void 0) : I.clone(De, !0));
        }
      }), N();
    }, R = (Y) => {
      Y.preventDefault(), L(), v.dispatchEvent("reset", { data: e.data }, Y);
    }, H = (Y) => {
      const ve = d.value;
      for (let ie = 0; ie < Y.length; ie++) {
        const he = Y[ie], De = E(he);
        if (De && mn(De.itemRender)) {
          const { itemRender: $e } = De, ue = $t.renderer.get($e.name);
          let Ne = null;
          if (ie || EI(ve.querySelector(`.${De.id}`)), $e.autofocus && (Ne = ve.querySelector(`.${De.id} ${$e.autofocus}`)), !Ne && ue && ue.autofocus && (Ne = ve.querySelector(`.${De.id} ${ue.autofocus}`)), Ne) {
            Ne.focus();
            break;
          }
        }
      }
    }, K = (Y, ve, ie) => {
      const { data: he, rules: De } = e, $e = {};
      return I.isArray(ve) || (ve = [ve]), Promise.all(ve.map((ue) => {
        const Ne = [], je = [];
        if (ue && De) {
          const Fe = I.get(De, ue);
          if (Fe) {
            const Ve = I.isUndefined(ie) ? I.get(he, ue) : ie;
            Fe.forEach((Ze) => {
              const { type: ae, trigger: pe, required: ke, validator: Ue } = Ze;
              if (Y === "all" || !pe || Y === pe)
                if (Ue) {
                  const Xe = {
                    itemValue: Ve,
                    rule: Ze,
                    rules: Fe,
                    data: he,
                    field: ue,
                    property: ue,
                    $form: g
                  };
                  let re;
                  if (I.isString(Ue)) {
                    const Te = $t.validators.get(Ue);
                    Te ? Te.itemValidatorMethod ? re = Te.itemValidatorMethod(Xe) : process.env.NODE_ENV === "development" && qt("vxe.error.notValidators", [Ue]) : process.env.NODE_ENV === "development" && Ht("vxe.error.notValidators", [Ue]);
                  } else
                    re = Ue(Xe);
                  re && (I.isError(re) ? Ne.push(new Bu({ type: "custom", trigger: pe, content: re.message, rule: new Bu(Ze) })) : re.catch && je.push(re.catch((Te) => {
                    Ne.push(new Bu({ type: "custom", trigger: pe, content: Te ? Te.message : Ze.content || Ze.message, rule: new Bu(Ze) }));
                  })));
                } else {
                  const Xe = ae === "array", re = I.isArray(Ve);
                  let Te = !0;
                  Xe || re ? Te = !re || !Ve.length : I.isString(Ve) ? Te = La(Ve.trim()) : Te = La(Ve), (ke ? Te || Q_(Ze, Ve) : !Te && Q_(Ze, Ve)) && Ne.push(new Bu(Ze));
                }
            });
          }
        }
        return Promise.all(je).then(() => {
          Ne.length && ($e[ue] = Ne.map((Fe) => ({
            $form: g,
            rule: Fe,
            data: he,
            field: ue,
            property: ue
          })));
        });
      })).then(() => {
        if (!I.isEmpty($e))
          return Promise.reject($e);
      });
    };
    let U;
    const W = (Y, ve, ie) => {
      const { data: he, rules: De } = e, $e = h.value, ue = {}, Ne = [], je = [];
      return clearTimeout(U), he && De ? (Y.forEach((Fe) => {
        const { field: Ve } = Fe;
        Ve && !fEe(g, Fe) && C1(g, Fe) && je.push(K(ve || "all", Ve).then(() => {
          Fe.errRule = null;
        }).catch((Ze) => {
          const ae = Ze[Ve];
          return ue[Ve] || (ue[Ve] = []), ue[Ve].push(ae), Ne.push(Ve), Fe.errRule = ae[0].rule, Promise.reject(ae);
        }));
      }), Promise.all(je).then(() => {
        ie && ie();
      }).catch(() => new Promise((Fe) => {
        U = window.setTimeout(() => {
          Y.forEach((Ve) => {
            Ve.errRule && (Ve.showError = !0);
          });
        }, 20), $e.autoPos !== !1 && xe(() => {
          H(Ne);
        }), ie ? (ie(ue), Fe()) : Fe(ue);
      }))) : (ie && ie(), Promise.resolve());
    }, A = (Y) => (N(), W(y(), "", Y)), $ = (Y, ve) => {
      let ie = [];
      return I.isArray(Y) ? ie = Y : ie = [Y], W(ie.map((he) => X_(g, he)), "", ve);
    }, D = (Y) => {
      Y.preventDefault(), e.preventSubmit || (N(), W(y()).then((ve) => {
        ve ? v.dispatchEvent("submit-invalid", { data: e.data, errMap: ve }, Y) : v.dispatchEvent("submit", { data: e.data }, Y);
      }));
    }, O = () => {
      const { tooltipStore: Y } = s, ve = f.value;
      return Y.visible && (Object.assign(Y, {
        item: null,
        visible: !1
      }), ve && ve.close()), xe();
    }, F = (Y, ve) => {
      const { item: ie } = ve, { tooltipStore: he } = s, De = f.value, $e = Y.currentTarget.children[0], ue = ($e.textContent || "").trim(), Ne = $e.scrollWidth > $e.clientWidth;
      clearTimeout(s.tooltipTimeout), he.item !== ie && O(), ue && Ne && (Object.assign(he, {
        item: ie,
        visible: !0
      }), De && De.open($e, ue));
    }, j = () => {
      const Y = m.value;
      let ve = f.value;
      ve && ve.setActived(!1), Y.enterable ? s.tooltipTimeout = setTimeout(() => {
        ve = f.value, ve && !ve.isActived() && O();
      }, Y.leaveDelay) : O();
    }, Z = (Y, ve, ie) => ve ? K(Y ? ["blur"].includes(Y.type) ? "blur" : "change" : "all", ve, ie).then(() => {
      N(ve);
    }).catch((he) => {
      const De = he[ve], $e = E(ve);
      De && $e && ($e.showError = !0, $e.errRule = De[0].rule);
    }) : xe();
    v = {
      dispatchEvent(Y, ve, ie) {
        l(Y, Object.assign({ $form: g, $grid: u, $event: ie }, ve));
      },
      reset: L,
      validate: A,
      validateField: $,
      clearValidate: N,
      updateStatus: (Y, ve) => {
        const { field: ie } = Y;
        return Z(new Event("change"), ie, ve);
      },
      toggleCollapse: _,
      getItems: y,
      getItemByField: E,
      closeTooltip: O
    }, Object.assign(g, v, {
      callSlot: w,
      triggerItemEvent: Z,
      toggleCollapseEvent: k,
      triggerTitleTipEvent: F,
      handleTitleTipLeaveEvent: j
    });
    const Oe = B(0);
    Pe(() => i.staticItems.length, () => {
      Oe.value++;
    }), Pe(() => i.staticItems, () => {
      Oe.value++;
    }), Pe(Oe, () => {
      i.formItems = i.staticItems;
    });
    const ce = B(0);
    Pe(() => e.items ? e.items.length : -1, () => {
      ce.value++;
    }), Pe(() => e.items, () => {
      ce.value++;
    }), Pe(ce, () => {
      b(e.items || []);
    }), Pe(() => e.collapseStatus, (Y) => {
      i.collapseAll = !!Y;
    }), Nt(() => {
      xe(() => {
        process.env.NODE_ENV === "development" && e.customLayout && e.items && Ht("vxe.error.errConflicts", ["custom-layout", "items"]), b(e.items || []);
      });
    });
    const ne = () => {
      const { loading: Y, className: ve, data: ie, customLayout: he } = e, { formItems: De } = i, $e = r.value, ue = m.value, Ne = o.default;
      return V("form", {
        ref: d,
        class: ["vxe-form", ve ? I.isFunction(ve) ? ve({ items: De, data: ie, $form: g }) : ve : "", {
          [`size--${$e}`]: $e,
          "is--loading": Y
        }],
        onSubmit: D,
        onReset: R
      }, [
        V("div", {
          class: "vxe-form--wrapper vxe-row"
        }, he ? Ne ? Ne({}) : [] : De.map((je, Fe) => V(iR, {
          key: Fe,
          itemConfig: je
        }))),
        V("div", {
          class: "vxe-form-slots",
          ref: "hideItem"
        }, he ? [] : Ne ? Ne({}) : []),
        /**
         * 加载中
         */
        V(uh, {
          class: "vxe-form--loading",
          modelValue: Y
        }),
        /**
         * 工具提示
         */
        n ? V(Jc, {
          ref: f,
          ...ue
        }) : _e()
      ]);
    };
    return g.renderVN = ne, Mt("$xeform", g), Mt("$xeformgather", null), Mt("$xeformitem", null), Mt("$xeformiteminfo", null), g;
  },
  render() {
    return this.renderVN();
  }
}), hh = Object.assign(dd, {
  install(e) {
    e.component(dd.name, dd);
  }
}), hEe = hh;
Fn.component(dd.name, dd);
const mEe = Object.keys(g1), e2 = ["clearAll", "syncData", "updateData", "loadData", "reloadData", "reloadRow", "loadColumn", "reloadColumn", "getRowNode", "getColumnNode", "getRowIndex", "getVTRowIndex", "getVMRowIndex", "getColumnIndex", "getVTColumnIndex", "getVMColumnIndex", "createData", "createRow", "revertData", "clearData", "isInsertByRow", "isUpdateByRow", "getColumns", "getColumnById", "getColumnByField", "getTableColumn", "getData", "getCheckboxRecords", "getParentRow", "getRowSeq", "getRowById", "getRowid", "getTableData", "setColumnFixed", "clearColumnFixed", "setColumnWidth", "getColumnWidth", "hideColumn", "showColumn", "resetColumn", "refreshColumn", "refreshScroll", "recalculate", "closeTooltip", "isAllCheckboxChecked", "isAllCheckboxIndeterminate", "getCheckboxIndeterminateRecords", "setCheckboxRow", "isCheckedByCheckboxRow", "isIndeterminateByCheckboxRow", "toggleCheckboxRow", "setAllCheckboxRow", "getRadioReserveRecord", "clearRadioReserve", "getCheckboxReserveRecords", "clearCheckboxReserve", "toggleAllCheckboxRow", "clearCheckboxRow", "setCurrentRow", "isCheckedByRadioRow", "setRadioRow", "clearCurrentRow", "clearRadioRow", "getCurrentRecord", "getRadioRecord", "getCurrentColumn", "setCurrentColumn", "clearCurrentColumn", "setPendingRow", "togglePendingRow", "getPendingRecords", "clearPendingRow", "sort", "clearSort", "isSort", "getSortColumns", "closeFilter", "isFilter", "isActiveFilterByColumn", "isRowExpandLoaded", "clearRowExpandLoaded", "reloadRowExpand", "reloadRowExpand", "toggleRowExpand", "setAllRowExpand", "setRowExpand", "isExpandByRow", "isRowExpandByRow", "clearRowExpand", "clearRowExpandReserve", "getRowExpandRecords", "getTreeExpandRecords", "isTreeExpandLoaded", "clearTreeExpandLoaded", "reloadTreeExpand", "reloadTreeChilds", "toggleTreeExpand", "setAllTreeExpand", "setTreeExpand", "isTreeExpandByRow", "clearTreeExpand", "clearTreeExpandReserve", "getScroll", "scrollTo", "scrollToRow", "scrollToColumn", "clearScroll", "updateFooter", "updateStatus", "setMergeCells", "removeInsertRow", "removeMergeCells", "getMergeCells", "clearMergeCells", "setMergeFooterItems", "removeMergeFooterItems", "getMergeFooterItems", "clearMergeFooterItems", "openTooltip", "focus", "blur", "connect"], gEe = [
  ...b1,
  "page-change",
  "form-submit",
  "form-submit-invalid",
  "form-reset",
  "form-collapse",
  "form-toggle-collapse",
  "proxy-query",
  "proxy-delete",
  "proxy-save",
  "toolbar-button-click",
  "toolbar-tool-click",
  "zoom"
], fd = Q({
  name: "VxeGrid",
  props: {
    ...g1,
    layouts: Array,
    columns: Array,
    pagerConfig: Object,
    proxyConfig: Object,
    toolbarConfig: Object,
    formConfig: Object,
    zoomConfig: Object,
    size: { type: String, default: () => ee.grid.size || ee.size }
  },
  emits: gEe,
  setup(e, t) {
    const { slots: n, emit: o } = t, l = I.uniqueId(), a = Pt(), r = Po(e), i = en({
      tableLoading: !1,
      proxyInited: !1,
      isZMax: !1,
      tableData: [],
      filterData: [],
      formData: {},
      sortData: [],
      tZindex: 0,
      tablePage: {
        total: 0,
        pageSize: ee.pager.pageSize || 10,
        currentPage: 1
      }
    }), s = B(), u = B(), d = B(), f = B(), v = B(), h = B(), m = B(), p = B(), C = B(), g = B(), w = (re) => {
      const Te = {};
      return re.forEach((Ce) => {
        Te[Ce] = (...Le) => {
          const ge = u.value;
          if (ge && ge[Ce])
            return ge[Ce](...Le);
        };
      }), Te;
    }, b = w(e2);
    e2.forEach((re) => {
      b[re] = (...Te) => {
        const Ce = u.value;
        if (Ce && Ce[re])
          return Ce && Ce[re](...Te);
      };
    });
    const y = x(() => Object.assign({}, ee.grid.proxyConfig, e.proxyConfig)), E = x(() => y.value.message !== !1), S = x(() => Object.assign({}, ee.grid.pagerConfig, e.pagerConfig)), _ = x(() => Object.assign({}, ee.grid.formConfig, e.formConfig)), k = x(() => Object.assign({}, ee.grid.toolbarConfig, e.toolbarConfig)), N = x(() => Object.assign({}, ee.grid.zoomConfig, e.zoomConfig)), L = x(() => i.isZMax ? { zIndex: i.tZindex } : null), R = x(() => {
      const re = {}, Te = e;
      return mEe.forEach((Ce) => {
        re[Ce] = Te[Ce];
      }), re;
    }), H = {
      refElem: s,
      refTable: u,
      refForm: d,
      refToolbar: f,
      refPager: v
    }, K = {
      computeProxyOpts: y,
      computePagerOpts: S,
      computeFormOpts: _,
      computeToolbarOpts: k,
      computeZoomOpts: N
    }, U = {
      xID: l,
      props: e,
      context: t,
      instance: a,
      reactData: i,
      getRefMaps: () => H,
      getComputeMaps: () => K
    };
    let W = {};
    const A = x(() => {
      const { seqConfig: re, pagerConfig: Te, loading: Ce, editConfig: Le, proxyConfig: ge } = e, { isZMax: Ee, tableLoading: me, tablePage: Ke, tableData: Re } = i, we = R.value, ze = y.value, Je = S.value, Me = Object.assign({}, we);
      return Ee && (we.maxHeight ? Me.maxHeight = "auto" : Me.height = "auto"), ge && mn(ze) && (Me.loading = Ce || me, Me.data = Re, Te && ze.seq && mn(Je) && (Me.seqConfig = Object.assign({}, re, { startIndex: (Ke.currentPage - 1) * Ke.pageSize }))), Le && (Me.editConfig = Object.assign({}, Le)), Me;
    }), $ = () => {
      const re = k.value;
      e.toolbarConfig && mn(re) && xe(() => {
        const Te = u.value, Ce = f.value;
        Te && Ce && Te.connect(Ce);
      });
    }, D = () => {
      const { tablePage: re } = i, { pagerConfig: Te } = e, Ce = S.value, { currentPage: Le, pageSize: ge } = Ce;
      Te && mn(Ce) && (Le && (re.currentPage = Le), ge && (re.pageSize = ge));
    }, O = (re) => {
      const Te = E.value, Ce = u.value, Le = Ce.getCheckboxRecords();
      Le.length ? (Ce.togglePendingRow(Le), b.clearCheckboxRow()) : Te && (process.env.NODE_ENV === "development" && ($t.modal || Ht("vxe.error.reqModule", ["Modal"])), $t.modal.message({ id: re, content: ee.i18n("vxe.grid.selectOneRecord"), status: "warning" }));
    }, F = (re, Te) => {
      const Ce = y.value, { props: Le = {} } = Ce;
      let ge;
      return re && Le.message && (ge = I.get(re, Le.message)), ge || ee.i18n(Te);
    }, j = (re, Te, Ce) => {
      const Le = E.value, ge = b.getCheckboxRecords();
      if (Le) {
        if (ge.length)
          return $t.modal.confirm({ id: `cfm_${re}`, content: ee.i18n(Te), escClosable: !0 }).then((Ee) => {
            if (Ee === "confirm")
              return Ce();
          });
        process.env.NODE_ENV === "development" && ($t.modal || Ht("vxe.error.reqModule", ["Modal"])), $t.modal.message({ id: `msg_${re}`, content: ee.i18n("vxe.grid.selectOneRecord"), status: "warning" });
      } else
        ge.length && Ce();
      return Promise.resolve();
    }, Z = (re) => {
      const { proxyConfig: Te } = e, { tablePage: Ce } = i, { currentPage: Le, pageSize: ge } = re, Ee = y.value;
      Ce.currentPage = Le, Ce.pageSize = ge, W.dispatchEvent("page-change", re), Te && mn(Ee) && W.commitProxy("query").then((me) => {
        W.dispatchEvent("proxy-query", me, re.$event);
      });
    }, te = (re) => {
      const Te = u.value, { proxyConfig: Ce } = e, { computeSortOpts: Le } = Te.getComputeMaps(), ge = y.value;
      Le.value.remote && (i.sortData = re.sortList, Ce && mn(ge) && (i.tablePage.currentPage = 1, W.commitProxy("query").then((me) => {
        W.dispatchEvent("proxy-query", me, re.$event);
      }))), W.dispatchEvent("sort-change", re);
    }, de = (re) => {
      const Te = u.value, { proxyConfig: Ce } = e, { computeFilterOpts: Le } = Te.getComputeMaps(), ge = y.value;
      Le.value.remote && (i.filterData = re.filterList, Ce && mn(ge) && (i.tablePage.currentPage = 1, W.commitProxy("query").then((me) => {
        W.dispatchEvent("proxy-query", me, re.$event);
      }))), W.dispatchEvent("filter-change", re);
    }, Oe = (re) => {
      const { proxyConfig: Te } = e, Ce = y.value;
      Te && mn(Ce) && W.commitProxy("reload").then((Le) => {
        W.dispatchEvent("proxy-query", { ...Le, isReload: !0 }, re.$event);
      }), W.dispatchEvent("form-submit", re);
    }, ce = (re) => {
      const { proxyConfig: Te } = e, Ce = y.value;
      Te && mn(Ce) && W.commitProxy("reload").then((Le) => {
        W.dispatchEvent("proxy-query", { ...Le, isReload: !0 }, re.$event);
      }), W.dispatchEvent("form-reset", re);
    }, ne = (re) => {
      W.dispatchEvent("form-submit-invalid", re);
    }, Y = (re) => {
      xe(() => b.recalculate(!0)), W.dispatchEvent("form-toggle-collapse", re), W.dispatchEvent("form-collapse", re);
    }, ve = (re) => {
      const { isZMax: Te } = i;
      return (re ? !Te : Te) && (i.isZMax = !Te, i.tZindex < Yr() && (i.tZindex = dr())), xe().then(() => b.recalculate(!0)).then(() => i.isZMax);
    }, ie = (re, Te) => {
      const Ce = re[Te];
      if (Ce)
        if (I.isString(Ce)) {
          if (n[Ce])
            return n[Ce];
          process.env.NODE_ENV === "development" && Ht("vxe.error.notSlot", [Ce]);
        } else
          return Ce;
      return null;
    }, he = () => {
      const { formConfig: re, proxyConfig: Te } = e, { formData: Ce } = i, Le = y.value, ge = _.value, Ee = [];
      if (re && mn(ge) || n.form) {
        let me = [];
        if (n.form)
          me = n.form({ $grid: U });
        else if (ge.items) {
          const Ke = {};
          if (!ge.inited) {
            ge.inited = !0;
            const Re = Le.beforeItem;
            Le && Re && ge.items.forEach((we) => {
              Re({ $grid: U, item: we });
            });
          }
          ge.items.forEach((Re) => {
            I.each(Re.slots, (we) => {
              I.isFunction(we) || n[we] && (Ke[we] = n[we]);
            });
          }), me.push(V(hh, {
            ref: d,
            ...Object.assign({}, ge, {
              data: Te && mn(Le) && Le.form ? Ce : ge.data
            }),
            onSubmit: Oe,
            onReset: ce,
            onSubmitInvalid: ne,
            onCollapse: Y
          }, Ke));
        }
        Ee.push(V("div", {
          ref: h,
          key: "form",
          class: "vxe-grid--form-wrapper"
        }, me));
      }
      return Ee;
    }, De = () => {
      const { toolbarConfig: re } = e, Te = k.value, Ce = [];
      if (re && mn(Te) || n.toolbar) {
        let Le = [];
        if (n.toolbar)
          Le = n.toolbar({ $grid: U });
        else {
          const ge = Te.slots;
          let Ee, me;
          const Ke = {};
          ge && (Ee = ie(ge, "buttons"), me = ie(ge, "tools"), Ee && (Ke.buttons = Ee), me && (Ke.tools = me)), Le.push(V(vh, {
            ref: f,
            ...Te
          }, Ke));
        }
        Ce.push(V("div", {
          ref: m,
          key: "toolbar",
          class: "vxe-grid--toolbar-wrapper"
        }, Le));
      }
      return Ce;
    }, $e = () => n.top ? [
      V("div", {
        ref: p,
        key: "top",
        class: "vxe-grid--top-wrapper"
      }, n.top({ $grid: U }))
    ] : [], ue = ["Form", "Toolbar", "Top", "Table", "Bottom", "Pager"], Ne = () => {
      const { layouts: re } = e, Te = [];
      return (re && re.length ? re : ee.grid.layouts || ue).forEach((Le) => {
        switch (Le) {
          case "Form":
            Te.push(he());
            break;
          case "Toolbar":
            Te.push(De());
            break;
          case "Top":
            Te.push($e());
            break;
          case "Table":
            Te.push(Fe());
            break;
          case "Bottom":
            Te.push(Ve());
            break;
          case "Pager":
            Te.push(Ze());
            break;
          default:
            process.env.NODE_ENV === "development" && Ht("vxe.error.notProp", [`layouts -> ${Le}`]);
            break;
        }
      }), Te;
    }, je = {};
    b1.forEach((re) => {
      const Te = I.camelCase(`on-${re}`);
      je[Te] = (...Ce) => o(re, ...Ce);
    });
    const Fe = () => {
      const { proxyConfig: re } = e, Te = A.value, Ce = y.value, Le = Object.assign({}, je), ge = n.empty, Ee = n.loading;
      re && mn(Ce) && (Ce.sort && (Le.onSortChange = te), Ce.filter && (Le.onFilterChange = de));
      const me = {};
      return ge && (me.empty = () => ge({})), Ee && (me.loading = () => Ee({})), [
        V(dh, {
          ref: u,
          key: "table",
          ...Te,
          ...Le
        }, me)
      ];
    }, Ve = () => n.bottom ? [
      V("div", {
        ref: C,
        key: "bottom",
        class: "vxe-grid--bottom-wrapper"
      }, n.bottom({ $grid: U }))
    ] : [], Ze = () => {
      const { proxyConfig: re, pagerConfig: Te } = e, Ce = y.value, Le = S.value, ge = [];
      if (Te && mn(Le) || n.pager) {
        let Ee = [];
        if (n.pager)
          Ee = n.pager({ $grid: U });
        else {
          const me = Le.slots, Ke = {};
          let Re, we;
          me && (Re = ie(me, "left"), we = ie(me, "right"), Re && (Ke.left = Re), we && (Ke.right = we)), Ee.push(V(ph, {
            ref: v,
            ...Le,
            ...re && mn(Ce) ? i.tablePage : {},
            onPageChange: Z
          }, Ke));
        }
        ge.push(V("div", {
          ref: g,
          key: "pager",
          class: "vxe-grid--pager-wrapper"
        }, Ee));
      }
      return ge;
    }, ae = () => {
      const { proxyConfig: re, formConfig: Te } = e, { proxyInited: Ce } = i, Le = y.value, ge = _.value;
      if (re && mn(Le)) {
        if (Te && mn(ge) && Le.form && ge.items) {
          const Ee = {};
          ge.items.forEach((me) => {
            const { field: Ke, itemRender: Re } = me;
            if (Ke) {
              let we = null;
              if (Re) {
                const { defaultValue: ze } = Re;
                I.isFunction(ze) ? we = ze({ item: me }) : I.isUndefined(ze) || (we = ze);
              }
              Ee[Ke] = we;
            }
          }), i.formData = Ee;
        }
        Ce || (i.proxyInited = !0, Le.autoLoad !== !1 && xe().then(() => W.commitProxy("_init")).then((Ee) => {
          W.dispatchEvent("proxy-query", { ...Ee, isInited: !0 }, new Event("init"));
        }));
      }
    };
    W = {
      dispatchEvent(re, Te, Ce) {
        o(re, Object.assign({ $grid: U, $event: Ce }, Te));
      },
      /**
       * 提交指令，支持 code 或 button
       * @param {String/Object} code 字符串或对象
       */
      commitProxy(re, ...Te) {
        const { toolbarConfig: Ce, pagerConfig: Le, editRules: ge, validConfig: Ee } = e, { tablePage: me, formData: Ke } = i, Re = E.value, we = y.value, ze = S.value, Je = k.value, { beforeQuery: Me, afterQuery: et, beforeDelete: mt, afterDelete: Lt, beforeSave: be, afterSave: an, ajax: _t = {}, props: zt = {} } = we, jt = u.value;
        let Sn = null, hn = null;
        if (I.isString(re)) {
          const { buttons: yn } = Je, kn = Ce && mn(Je) && yn ? I.findTree(yn, (Wn) => Wn.code === re, { children: "dropdowns" }) : null;
          Sn = kn ? kn.item : null, hn = re;
        } else
          Sn = re, hn = Sn.code;
        const xn = Sn ? Sn.params : null;
        switch (hn) {
          case "insert":
            return jt.insert({});
          case "insert_edit":
            return jt.insert({}).then(({ row: yn }) => jt.setEditRow(yn));
          case "insert_actived":
            return jt.insert({}).then(({ row: yn }) => jt.setEditRow(yn));
          case "mark_cancel":
            O(hn);
            break;
          case "remove":
            return j(hn, "vxe.grid.removeSelectRecord", () => jt.removeCheckboxRow());
          case "import":
            jt.importData(xn);
            break;
          case "open_import":
            jt.openImport(xn);
            break;
          case "export":
            jt.exportData(xn);
            break;
          case "open_export":
            jt.openExport(xn);
            break;
          case "reset_custom":
            return jt.resetColumn(!0);
          case "_init":
          case "reload":
          case "query": {
            const yn = _t.query;
            if (yn) {
              const kn = hn === "_init", Wn = hn === "reload";
              let Vn = [], ho = [], Qn = {};
              if (Le && ((kn || Wn) && (me.currentPage = 1), mn(ze) && (Qn = { ...me })), kn) {
                const { computeSortOpts: st } = jt.getComputeMaps();
                let rn = st.value.defaultSort;
                rn && (I.isArray(rn) || (rn = [rn]), Vn = rn.map((Tn) => ({
                  field: Tn.field,
                  property: Tn.field,
                  order: Tn.order
                }))), ho = jt.getCheckedFilters();
              } else
                Wn ? jt.clearAll() : (Vn = jt.getSortColumns(), ho = jt.getCheckedFilters());
              const eo = {
                code: hn,
                button: Sn,
                isInited: kn,
                isReload: Wn,
                $grid: U,
                page: Qn,
                sort: Vn.length ? Vn[0] : {},
                sorts: Vn,
                filters: ho,
                form: Ke,
                options: yn
              };
              i.sortData = Vn, i.filterData = ho, i.tableLoading = !0;
              const So = [eo].concat(Te);
              return Promise.resolve((Me || yn)(...So)).then((st) => {
                if (i.tableLoading = !1, st)
                  if (Le && mn(ze)) {
                    const St = I.get(st, zt.total || "page.total") || 0;
                    me.total = I.toNumber(St), i.tableData = I.get(st, zt.result || "result") || [];
                    const rn = Math.max(Math.ceil(St / me.pageSize), 1);
                    me.currentPage > rn && (me.currentPage = rn);
                  } else
                    i.tableData = (zt.list ? I.get(st, zt.list) : st) || [];
                else
                  i.tableData = [];
                return et && et(...So), { status: !0 };
              }).catch(() => (i.tableLoading = !1, { status: !1 }));
            } else
              process.env.NODE_ENV === "development" && Ht("vxe.error.notFunc", ["proxy-config.ajax.query"]);
            break;
          }
          case "delete": {
            const yn = _t.delete;
            if (yn) {
              const kn = b.getCheckboxRecords(), Wn = kn.filter((eo) => !jt.isInsertByRow(eo)), Qn = [{ $grid: U, code: hn, button: Sn, body: { removeRecords: Wn }, form: Ke, options: yn }].concat(Te);
              if (kn.length)
                return j(hn, "vxe.grid.deleteSelectRecord", () => Wn.length ? (i.tableLoading = !0, Promise.resolve((mt || yn)(...Qn)).then((eo) => (i.tableLoading = !1, jt.setPendingRow(Wn, !1), Re && (process.env.NODE_ENV === "development" && ($t.modal || Ht("vxe.error.reqModule", ["Modal"])), $t.modal.message({ content: F(eo, "vxe.grid.delSuccess"), status: "success" })), Lt ? Lt(...Qn) : W.commitProxy("query"), { status: !0 })).catch((eo) => (i.tableLoading = !1, Re && (process.env.NODE_ENV === "development" && ($t.modal.message || Ht("vxe.error.reqModule", ["Modal"])), $t.modal.message({ id: hn, content: F(eo, "vxe.grid.operError"), status: "error" })), { status: !1 }))) : jt.remove(kn));
              Re && (process.env.NODE_ENV === "development" && ($t.modal || Ht("vxe.error.reqModule", ["Modal"])), $t.modal.message({ id: hn, content: ee.i18n("vxe.grid.selectOneRecord"), status: "warning" }));
            } else
              process.env.NODE_ENV === "development" && Ht("vxe.error.notFunc", ["proxy-config.ajax.delete"]);
            break;
          }
          case "save": {
            const yn = _t.save;
            if (yn) {
              const kn = jt.getRecordset(), { insertRecords: Wn, removeRecords: Vn, updateRecords: ho, pendingRecords: Qn } = kn, So = [{ $grid: U, code: hn, button: Sn, body: kn, form: Ke, options: yn }].concat(Te);
              Wn.length && (kn.pendingRecords = Qn.filter((St) => jt.findRowIndexOf(Wn, St) === -1)), Qn.length && (kn.insertRecords = Wn.filter((St) => jt.findRowIndexOf(Qn, St) === -1));
              let st = Promise.resolve();
              return ge && (st = jt[Ee && Ee.msgMode === "full" ? "fullValidate" : "validate"](kn.insertRecords.concat(ho))), st.then((St) => {
                if (!St) {
                  if (kn.insertRecords.length || Vn.length || ho.length || kn.pendingRecords.length)
                    return i.tableLoading = !0, Promise.resolve((be || yn)(...So)).then((rn) => (i.tableLoading = !1, jt.clearPendingRow(), Re && (process.env.NODE_ENV === "development" && ($t.modal || Ht("vxe.error.reqModule", ["Modal"])), $t.modal.message({ content: F(rn, "vxe.grid.saveSuccess"), status: "success" })), an ? an(...So) : W.commitProxy("query"), { status: !0 })).catch((rn) => (i.tableLoading = !1, Re && (process.env.NODE_ENV === "development" && ($t.modal || Ht("vxe.error.reqModule", ["Modal"])), $t.modal.message({ id: hn, content: F(rn, "vxe.grid.operError"), status: "error" })), { status: !1 }));
                  Re && (process.env.NODE_ENV === "development" && ($t.modal || Ht("vxe.error.reqModule", ["Modal"])), $t.modal.message({ id: hn, content: ee.i18n("vxe.grid.dataUnchanged"), status: "info" }));
                }
              });
            } else
              process.env.NODE_ENV === "development" && Ht("vxe.error.notFunc", ["proxy-config.ajax.save"]);
            break;
          }
          default: {
            const yn = $t.commands.get(hn);
            yn && (yn.commandMethod ? yn.commandMethod({ code: hn, button: Sn, $grid: U, $table: jt }, ...Te) : process.env.NODE_ENV === "development" && Ht("vxe.error.notCommands", [hn]));
          }
        }
        return xe();
      },
      zoom() {
        return i.isZMax ? W.revert() : W.maximize();
      },
      isMaximized() {
        return i.isZMax;
      },
      maximize() {
        return ve(!0);
      },
      revert() {
        return ve();
      },
      getFormItems(re) {
        const Te = _.value, { formConfig: Ce } = e, { items: Le } = Te, ge = [];
        return I.eachTree(Ce && mn(Te) && Le ? Le : [], (Ee) => {
          ge.push(Ee);
        }, { children: "children" }), I.isUndefined(re) ? ge : ge[re];
      },
      getProxyInfo() {
        const re = u.value;
        if (e.proxyConfig) {
          const { sortData: Te } = i;
          return {
            data: i.tableData,
            filter: i.filterData,
            form: i.formData,
            sort: Te.length ? Te[0] : {},
            sorts: Te,
            pager: i.tablePage,
            pendingRecords: re ? re.getPendingRecords() : []
          };
        }
        return null;
      }
      // setProxyInfo (options) {
      //   if (props.proxyConfig && options) {
      //     const { pager, form } = options
      //     const proxyOpts = computeProxyOpts.value
      //     if (pager) {
      //       if (pager.currentPage) {
      //         reactData.tablePage.currentPage = Number(pager.currentPage)
      //       }
      //       if (pager.pageSize) {
      //         reactData.tablePage.pageSize = Number(pager.pageSize)
      //       }
      //     }
      //     if (proxyOpts.form && form) {
      //       Object.assign(reactData.formData, form)
      //     }
      //   }
      //   return nextTick()
      // }
    }, process.env.NODE_ENV === "development" && (W.loadColumn = (re) => {
      const Te = u.value;
      return I.eachTree(re, (Ce) => {
        Ce.slots && I.each(Ce.slots, (Le) => {
          I.isFunction(Le) || n[Le] || Ht("vxe.error.notSlot", [Le]);
        });
      }), Te ? Te.loadColumn(re) : xe();
    }, W.reloadColumn = (re) => (b.clearAll(), W.loadColumn(re)));
    const pe = {
      extendTableMethods: w,
      callSlot(re, Te) {
        return re && (I.isString(re) && (re = n[re] || null), I.isFunction(re)) ? oo(re(Te)) : [];
      },
      /**
       * 获取需要排除的高度
       */
      getExcludeHeight() {
        const { height: re } = e, { isZMax: Te } = i, Ce = s.value, Le = h.value, ge = m.value, Ee = p.value, me = C.value, Ke = g.value;
        return (Te || re !== "auto" ? 0 : yb(Ce.parentNode)) + yb(Ce) + Lu(Le) + Lu(ge) + Lu(Ee) + Lu(me) + Lu(Ke);
      },
      getParentHeight() {
        const re = s.value;
        return re ? (i.isZMax ? Cs().visibleHeight : I.toNumber(getComputedStyle(re.parentNode).height)) - pe.getExcludeHeight() : 0;
      },
      triggerToolbarCommitEvent(re, Te) {
        const { code: Ce } = re;
        return W.commitProxy(re, Te).then((Le) => {
          Ce && Le && Le.status && ["query", "reload", "delete", "save"].includes(Ce) && W.dispatchEvent(Ce === "delete" || Ce === "save" ? `proxy-${Ce}` : "proxy-query", { ...Le, isReload: Ce === "reload" }, Te);
        });
      },
      triggerToolbarBtnEvent(re, Te) {
        pe.triggerToolbarCommitEvent(re, Te), W.dispatchEvent("toolbar-button-click", { code: re.code, button: re }, Te);
      },
      triggerToolbarTolEvent(re, Te) {
        pe.triggerToolbarCommitEvent(re, Te), W.dispatchEvent("toolbar-tool-click", { code: re.code, tool: re, $event: Te });
      },
      triggerZoomEvent(re) {
        W.zoom(), W.dispatchEvent("zoom", { type: i.isZMax ? "max" : "revert" }, re);
      }
    };
    Object.assign(U, b, W, pe);
    const ke = B(0);
    Pe(() => e.columns ? e.columns.length : -1, () => {
      ke.value++;
    }), Pe(() => e.columns, () => {
      ke.value++;
    }), Pe(ke, () => {
      xe(() => U.loadColumn(e.columns || []));
    }), Pe(() => e.toolbarConfig, () => {
      $();
    }), Pe(() => e.pagerConfig, () => {
      D();
    }), Pe(() => e.proxyConfig, () => {
      ae();
    });
    const Ue = (re) => {
      const Te = N.value;
      Cn(re, un.ESCAPE) && i.isZMax && Te.escRestore !== !1 && pe.triggerZoomEvent(re);
    };
    $t.hooks.forEach((re) => {
      const { setupGrid: Te } = re;
      if (Te) {
        const Ce = Te(U);
        Ce && I.isObject(Ce) && Object.assign(U, Ce);
      }
    }), D(), Nt(() => {
      xe(() => {
        const { data: re, columns: Te, proxyConfig: Ce } = e, Le = y.value, ge = _.value;
        mn(Ce) && (re || Le.form && ge.data) && Ht("vxe.error.errConflicts", ["grid.data", "grid.proxy-config"]), Te && Te.length && U.loadColumn(Te), $();
      }), wn.on(U, "keydown", Ue);
    }), wo(() => {
      wn.off(U, "keydown");
    }), xe(() => {
      ae();
    });
    const Xe = () => {
      const re = r.value, Te = L.value;
      return V("div", {
        ref: s,
        class: ["vxe-grid", {
          [`size--${re}`]: re,
          "is--animat": !!e.animat,
          "is--round": e.round,
          "is--maximize": i.isZMax,
          "is--loading": e.loading || i.tableLoading
        }],
        style: Te
      }, Ne());
    };
    return U.renderVN = Xe, Mt("$xegrid", U), U;
  },
  render() {
    return this.renderVN();
  }
}), w1 = Object.assign(fd, {
  install(e) {
    e.component(fd.name, fd);
  }
}), bEe = w1;
Fn.component(fd.name, fd);
const E1 = Object.assign(Yl, {
  install(e) {
    e.component(Yl.name, Yl);
  }
}), yEe = E1;
Fn.component(Yl.name, Yl);
const pd = Q({
  name: "VxeCheckboxGroup",
  props: {
    modelValue: Array,
    options: Array,
    optionProps: Object,
    disabled: Boolean,
    max: { type: [String, Number], default: null },
    size: { type: String, default: () => ee.checkboxGroup.size || ee.size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(e, t) {
    const { slots: n, emit: o } = t, l = ot("$xeform", null), a = ot("$xeformiteminfo", null), r = I.uniqueId(), i = x(() => {
      const { modelValue: g, max: w } = e;
      return w ? (g ? g.length : 0) >= I.toNumber(w) : !1;
    }), s = x(() => e.optionProps || {}), u = x(() => s.value.label || "label"), d = x(() => s.value.value || "value"), f = x(() => s.value.disabled || "disabled"), v = {
      computeIsMaximize: i
    }, h = {
      xID: r,
      props: e,
      context: t,
      getComputeMaps: () => v
    };
    Po(e), Object.assign(h, {
      dispatchEvent(g, w, b) {
        o(g, Object.assign({ $checkboxGroup: h, $event: b }, w));
      }
    }, {
      handleChecked(g, w) {
        const { checked: b, label: y } = g, E = e.modelValue || [], S = E.indexOf(y);
        b ? S === -1 && E.push(y) : E.splice(S, 1), o("update:modelValue", E), h.dispatchEvent("change", Object.assign({ checklist: E }, g), w), l && a && l.triggerItemEvent(w, a.itemConfig.field, E);
      }
    });
    const C = () => {
      const { options: g } = e, w = n.default, b = d.value, y = u.value, E = f.value;
      return V("div", {
        class: "vxe-checkbox-group"
      }, w ? w({}) : g ? g.map((S) => V(Yl, {
        label: S[b],
        content: S[y],
        disabled: S[E]
      })) : []);
    };
    return h.renderVN = C, Mt("$xecheckboxgroup", h), C;
  }
}), S1 = Object.assign(pd, {
  install(e) {
    e.component(pd.name, pd);
  }
}), CEe = S1;
Fn.component(pd.name, pd);
const _1 = Object.assign(_i, {
  install: function(e) {
    e.component(_i.name, _i);
  }
}), wEe = _1;
Fn.component(_i.name, _i);
const x1 = Object.assign(xi, {
  install: function(e) {
    e.component(xi.name, xi);
  }
}), EEe = x1;
Fn.component(xi.name, xi);
const k1 = Object.assign(Mc, {
  install: function(e) {
    e.component(Mc.name, Mc);
  }
}), SEe = k1;
Fn.component(Mc.name, Mc);
const T1 = Object.assign(Rr, {
  install(e) {
    e.component(Rr.name, Rr);
  }
}), _Ee = T1;
Fn.component(Rr.name, Rr);
let _r;
const vd = Q({
  name: "VxeTextarea",
  props: {
    modelValue: [String, Number],
    className: String,
    immediate: { type: Boolean, default: !0 },
    name: String,
    readonly: Boolean,
    disabled: Boolean,
    placeholder: {
      type: String,
      default: () => I.eqNull(ee.textarea.placeholder) ? ee.i18n("vxe.base.pleaseInput") : ee.textarea.placeholder
    },
    maxlength: [String, Number],
    rows: { type: [String, Number], default: 2 },
    cols: { type: [String, Number], default: null },
    showWordCount: Boolean,
    countMethod: Function,
    autosize: [Boolean, Object],
    form: String,
    resize: { type: String, default: () => ee.textarea.resize },
    size: { type: String, default: () => ee.textarea.size || ee.size }
  },
  emits: [
    "update:modelValue",
    "input",
    "keydown",
    "keyup",
    "click",
    "change",
    "focus",
    "blur"
  ],
  setup(e, t) {
    const { emit: n } = t, o = ot("$xeform", null), l = ot("$xeformiteminfo", null), a = I.uniqueId(), r = Po(e), i = en({
      inputValue: e.modelValue
    }), s = B(), u = B(), d = {
      refElem: s,
      refTextarea: u
    }, f = {
      xID: a,
      props: e,
      context: t,
      reactData: i,
      getRefMaps: () => d
    };
    let v = {};
    const h = x(() => I.getSize(i.inputValue)), m = x(() => {
      const k = h.value;
      return e.maxlength && k > I.toNumber(e.maxlength);
    }), p = x(() => Object.assign({ minRows: 1, maxRows: 10 }, ee.textarea.autosize, e.autosize)), C = () => {
      const { size: k, autosize: N } = e, { inputValue: L } = i;
      if (N) {
        _r || (_r = document.createElement("div")), _r.parentNode || document.body.appendChild(_r);
        const R = u.value, H = getComputedStyle(R);
        _r.className = ["vxe-textarea--autosize", k ? `size--${k}` : ""].join(" "), _r.style.width = `${R.clientWidth}px`, _r.style.padding = H.padding, _r.innerText = ("" + (L || "　")).replace(/\n$/, `
　`);
      }
    }, g = () => {
      e.autosize && xe(() => {
        const k = p.value, { minRows: N, maxRows: L } = k, R = u.value, H = _r.clientHeight, K = getComputedStyle(R), U = I.toNumber(K.lineHeight), W = I.toNumber(K.paddingTop), A = I.toNumber(K.paddingBottom), $ = I.toNumber(K.borderTopWidth), D = I.toNumber(K.borderBottomWidth), O = W + A + $ + D, F = (H - O) / U, j = F && /[0-9]/.test("" + F) ? F : Math.floor(F) + 1;
        let Z = j;
        j < N ? Z = N : j > L && (Z = L), R.style.height = `${Z * U + O}px`;
      });
    }, w = (k) => {
      const N = i.inputValue;
      f.dispatchEvent(k.type, { value: N }, k);
    }, b = (k, N) => {
      i.inputValue = k, n("update:modelValue", k), I.toValueString(e.modelValue) !== k && (v.dispatchEvent("change", { value: k }, N), o && l && o.triggerItemEvent(N, l.itemConfig.field, k));
    }, y = (k) => {
      const { immediate: N } = e, R = k.target.value;
      i.inputValue = R, N && b(R, k), f.dispatchEvent("input", { value: R }, k), g();
    }, E = (k) => {
      const { immediate: N } = e;
      N ? w(k) : b(i.inputValue, k);
    }, S = (k) => {
      const { immediate: N } = e, { inputValue: L } = i;
      N || b(L, k), f.dispatchEvent("blur", { value: L }, k);
    };
    v = {
      dispatchEvent(k, N, L) {
        n(k, Object.assign({ $textarea: f, $event: L }, N));
      },
      focus() {
        return u.value.focus(), xe();
      },
      blur() {
        return u.value.blur(), xe();
      }
    }, Object.assign(f, v), Pe(() => e.modelValue, (k) => {
      i.inputValue = k, C();
    }), xe(() => {
      const { autosize: k } = e;
      k && (C(), g());
    });
    const _ = () => {
      const { className: k, resize: N, placeholder: L, disabled: R, maxlength: H, autosize: K, showWordCount: U, countMethod: W, rows: A, cols: $ } = e, { inputValue: D } = i, O = r.value, F = m.value, j = h.value;
      return V("div", {
        ref: s,
        class: ["vxe-textarea", k, {
          [`size--${O}`]: O,
          "is--autosize": K,
          "is--count": U,
          "is--disabled": R,
          "def--rows": !I.eqNull(A),
          "def--cols": !I.eqNull($)
        }]
      }, [
        V("textarea", {
          ref: u,
          class: "vxe-textarea--inner",
          value: D,
          name: e.name,
          placeholder: L ? vo(L) : null,
          maxlength: H,
          readonly: e.readonly,
          disabled: R,
          rows: A,
          cols: $,
          style: N ? {
            resize: N
          } : null,
          onInput: y,
          onChange: E,
          onKeydown: w,
          onKeyup: w,
          onClick: w,
          onFocus: w,
          onBlur: S
        }),
        U ? V("span", {
          class: ["vxe-textarea--count", {
            "is--error": F
          }]
        }, W ? `${W({ value: D })}` : `${j}${H ? `/${H}` : ""}`) : null
      ]);
    };
    return f.renderVN = _, f;
  },
  render() {
    return this.renderVN();
  }
}), $1 = Object.assign(vd, {
  install: function(e) {
    e.component(vd.name, vd);
  }
}), xEe = $1;
Fn.component(vd.name, vd);
const hd = Q({
  name: "VxeButtonGroup",
  props: {
    options: Array,
    mode: String,
    status: String,
    round: Boolean,
    circle: Boolean,
    className: [String, Function],
    disabled: Boolean,
    size: { type: String, default: () => ee.buttonGroup.size || ee.size }
  },
  emits: [
    "click"
  ],
  setup(e, t) {
    const { slots: n, emit: o } = t, l = I.uniqueId(), a = {}, r = {
      xID: l,
      props: e,
      context: t,
      getComputeMaps: () => a
    };
    Po(e);
    const i = {
      dispatchEvent(d, f, v) {
        o(d, Object.assign({ $buttonGroup: r, $event: v }, f));
      }
    };
    Object.assign(r, i, {
      handleClick(d, f) {
        const { options: v } = e, { name: h } = d, m = v ? v.find((p) => p.name === h) : null;
        i.dispatchEvent("click", { ...d, option: m }, f);
      }
    });
    const u = () => {
      const { className: d, options: f } = e, v = n.default;
      return V("div", {
        class: ["vxe-button-group", d ? I.isFunction(d) ? d({ $buttonGroup: r }) : d : ""]
      }, v ? v({}) : f ? f.map((h, m) => V(Tl, {
        key: m,
        ...h
      })) : []);
    };
    return r.renderVN = u, Mt("$xebuttongroup", r), u;
  }
}), O1 = Object.assign(hd, {
  install(e) {
    e.component(hd.name, hd);
  }
}), kEe = O1;
Fn.component(hd.name, hd);
function cR(e) {
  return pwe(), new Promise((t) => {
    if (e && e.id && pi.some((n) => n.props.id === e.id))
      t("exist");
    else {
      const n = e.onHide, o = Object.assign(e, {
        key: I.uniqueId(),
        modelValue: !0,
        onHide(l) {
          const a = Hp.modals;
          n && n(l), Hp.modals = a.filter((r) => r.key !== o.key), t(l.type);
        }
      });
      Hp.modals.push(o);
    }
  });
}
function uR(e) {
  return I.find(pi, (t) => t.props.id === e);
}
function TEe(e) {
  const t = e ? [uR(e)] : pi, n = [];
  return t.forEach((o) => {
    o && n.push(o.close());
  }), Promise.all(n);
}
function N1(e, t, n, o) {
  let l;
  return I.isObject(t) ? l = t : l = { content: I.toValueString(t), title: n }, cR({ ...e, ...o, ...l });
}
function $Ee(e, t, n) {
  return N1({
    type: "alert",
    showFooter: !0
  }, e, t, n);
}
function OEe(e, t, n) {
  return N1({
    type: "confirm",
    status: "question",
    showFooter: !0
  }, e, t, n);
}
function NEe(e, t) {
  return N1({
    type: "message",
    mask: !1,
    lockView: !1,
    showHeader: !1
  }, e, "", t);
}
const dR = {
  get: uR,
  close: TEe,
  open: cR,
  alert: $Ee,
  confirm: OEe,
  message: NEe
}, MEe = dR, M1 = Object.assign(ws, {
  install: function(e) {
    e.component(ws.name, ws), $t.modal = dR;
  }
}), IEe = M1;
Fn.component(ws.name, ws);
const fR = {
  title: String,
  field: String,
  span: [String, Number],
  align: String,
  titleAlign: {
    type: String,
    default: null
  },
  titleWidth: {
    type: [String, Number],
    default: null
  },
  titleColon: {
    type: Boolean,
    default: null
  },
  titleAsterisk: {
    type: Boolean,
    default: null
  },
  showTitle: {
    type: Boolean,
    default: !0
  },
  vertical: {
    type: Boolean,
    default: null
  },
  className: [String, Function],
  contentClassName: [String, Function],
  contentStyle: [Object, Function],
  titleClassName: [String, Function],
  titleStyle: [Object, Function],
  titleOverflow: {
    type: [Boolean, String],
    default: null
  },
  titlePrefix: Object,
  titleSuffix: Object,
  resetValue: { default: null },
  visibleMethod: Function,
  visible: { type: Boolean, default: null },
  folding: Boolean,
  collapseNode: Boolean,
  itemRender: Object
}, md = Q({
  name: "VxeFormItem",
  props: fR,
  setup(e, { slots: t }) {
    const n = B(), o = ot("$xeform", {}), l = ot("$xeformgather", null), a = en(y1(o, e)), r = { formItem: a }, i = { itemConfig: a };
    a.slots = t, Mt("$xeformiteminfo", i), Mt("$xeformitem", r), Mt("$xeformgather", null), lR(e, a), Nt(() => {
      aR(o, n.value, a, l);
    }), wo(() => {
      rR(o, a);
    });
    const s = (f, v) => {
      const { props: h, reactData: m } = f, { data: p, rules: C, titleAlign: g, titleWidth: w, titleColon: b, titleAsterisk: y, titleOverflow: E, vertical: S } = h, { collapseAll: _ } = m, { computeValidOpts: k } = f.getComputeMaps(), N = k.value, { slots: L, title: R, visible: H, folding: K, field: U, collapseNode: W, itemRender: A, showError: $, errRule: D, className: O, titleOverflow: F, vertical: j, showTitle: Z, contentClassName: te, contentStyle: de, titleClassName: Oe, titleStyle: ce } = v, ne = mn(A) ? $t.renderer.get(A.name) : null, Y = ne ? ne.itemClassName : "", ve = ne ? ne.itemStyle : null, ie = ne ? ne.itemContentClassName : "", he = ne ? ne.itemContentStyle : null, De = ne ? ne.itemTitleClassName : "", $e = ne ? ne.itemTitleStyle : null, ue = L ? L.default : null, Ne = L ? L.title : null, je = v.span || h.span, Fe = v.align || h.align, Ve = I.eqNull(v.titleAlign) ? g : v.titleAlign, Ze = I.eqNull(v.titleWidth) ? w : v.titleWidth, ae = I.eqNull(v.titleColon) ? b : v.titleColon, pe = I.eqNull(v.titleAsterisk) ? y : v.titleAsterisk, ke = I.isUndefined(F) || I.isNull(F) ? E : F, Ue = I.isUndefined(j) || I.isNull(j) ? S : j, Xe = ke === "ellipsis", re = ke === "title", Te = ke === !0 || ke === "tooltip", Ce = re || Te || Xe, Le = { data: p, field: U, property: U, item: v, $form: f, $grid: f.xegrid };
      let ge = !1;
      if (H === !1)
        return _e();
      if (C) {
        const Ke = C[U];
        Ke && (ge = Ke.some((Re) => Re.required));
      }
      let Ee = [];
      ue ? Ee = f.callSlot(ue, Le) : ne && ne.renderItemContent ? Ee = oo(ne.renderItemContent(A, Le)) : U && (Ee = [`${I.get(p, U)}`]), W && Ee.push(V("div", {
        class: "vxe-form--item-trigger-node",
        onClick: f.toggleCollapseEvent
      }, [
        V("span", {
          class: "vxe-form--item-trigger-text"
        }, _ ? ee.i18n("vxe.form.unfolding") : ee.i18n("vxe.form.folding")),
        V("i", {
          class: ["vxe-form--item-trigger-icon", _ ? ee.icon.FORM_FOLDING : ee.icon.FORM_UNFOLDING]
        })
      ])), D && N.showMessage && Ee.push(V("div", {
        class: "vxe-form--item-valid",
        style: D.maxWidth ? {
          width: `${D.maxWidth}px`
        } : null
      }, D.message));
      const me = Te ? {
        onMouseenter(Ke) {
          f.triggerTitleTipEvent(Ke, Le);
        },
        onMouseleave: f.handleTitleTipLeaveEvent
      } : {};
      return V("div", {
        ref: n,
        class: [
          "vxe-form--item",
          v.id,
          je ? `vxe-col--${je} is--span` : "",
          O ? I.isFunction(O) ? O(Le) : O : "",
          Y ? I.isFunction(Y) ? Y(Le) : Y : "",
          {
            "is--title": R,
            "is--colon": ae,
            "is--vertical": Ue,
            "is--asterisk": pe,
            "is--required": ge,
            "is--hidden": K && _,
            "is--active": C1(f, v),
            "is--error": $
          }
        ],
        style: I.isFunction(ve) ? ve(Le) : ve
      }, [
        V("div", {
          class: "vxe-form--item-inner"
        }, [
          Z !== !1 && (R || Ne) ? V("div", {
            class: [
              "vxe-form--item-title",
              Ve ? `align--${Ve}` : "",
              Ce ? "is--ellipsis" : "",
              De ? I.isFunction(De) ? De(Le) : De : "",
              Oe ? I.isFunction(Oe) ? Oe(Le) : Oe : ""
            ],
            style: Object.assign({}, I.isFunction($e) ? $e(Le) : $e, I.isFunction(ce) ? ce(Le) : ce, Ze ? {
              width: isNaN(Ze) ? Ze : `${Ze}px`
            } : null),
            title: re ? vo(R) : null,
            ...me
          }, sR(f, v)) : null,
          V("div", {
            class: [
              "vxe-form--item-content",
              Fe ? `align--${Fe}` : "",
              ie ? I.isFunction(ie) ? ie(Le) : ie : "",
              te ? I.isFunction(te) ? te(Le) : te : ""
            ],
            style: Object.assign({}, I.isFunction(he) ? he(Le) : he, I.isFunction(de) ? de(Le) : de)
          }, Ee)
        ])
      ]);
    };
    return {
      renderVN: () => {
        const f = o ? o.props : null;
        return f && f.customLayout ? s(o, a) : V("div", {
          ref: n
        });
      }
    };
  },
  render() {
    return this.renderVN();
  }
}), I1 = Object.assign(md, {
  install(e) {
    e.component(md.name, md);
  }
}), REe = I1;
Fn.component(md.name, md);
const gd = Q({
  name: "VxeFormGather",
  props: fR,
  setup(e, { slots: t }) {
    const n = B(), o = ot("$xeform", {}), l = ot("$xeformgather", null), a = t.default, r = en(y1(o, e)), i = { formItem: r }, s = { itemConfig: r };
    return r.children = [], Mt("$xeformiteminfo", s), Mt("$xeformgather", i), Mt("$xeformitem", null), lR(e, r), Nt(() => {
      aR(o, n.value, r, l);
    }), wo(() => {
      rR(o, r);
    }), process.env.NODE_ENV === "development" && xe(() => {
      o && o.props.customLayout && Ht("vxe.error.errConflicts", ["custom-layout", "<form-gather ...>"]);
    }), {
      renderVN: () => V("div", {
        ref: n
      }, a ? a() : [])
    };
  },
  render() {
    return this.renderVN();
  }
}), R1 = Object.assign(gd, {
  install(e) {
    e.component(gd.name, gd);
  }
}), DEe = R1;
Fn.component(gd.name, gd);
class pR {
  constructor(t, n) {
    Object.assign(this, {
      id: I.uniqueId("option_"),
      value: n.value,
      label: n.label,
      visible: n.visible,
      className: n.className,
      disabled: n.disabled
    });
  }
  update(t, n) {
    this[t] = n;
  }
}
function LEe(e) {
  return e instanceof pR;
}
function vR(e, t) {
  return LEe(t) ? t : new pR(e, t);
}
function hR(e, t) {
  Object.keys(e).forEach((n) => {
    Pe(() => e[n], (o) => {
      t.update(n, o);
    });
  });
}
function mR(e, t, n, o) {
  const { reactData: l } = e, { staticOptions: a } = l, r = t.parentNode, i = o ? o.option : null, s = i ? i.options : a;
  r && s && (s.splice(I.arrayIndexOf(r.children, t), 0, n), l.staticOptions = a.slice(0));
}
function gR(e, t) {
  const { reactData: n } = e, { staticOptions: o } = n, l = I.findTree(o, (a) => a.id === t.id, { children: "options" });
  l && l.items.splice(l.index, 1), n.staticOptions = o.slice(0);
}
const bd = Q({
  name: "VxeOptgroup",
  props: {
    label: { type: [String, Number, Boolean], default: "" },
    visible: { type: Boolean, default: null },
    className: [String, Function],
    disabled: Boolean
  },
  setup(e, { slots: t }) {
    const n = B(), o = ot("$xeselect", {}), l = vR(o, e), a = { option: l };
    return l.options = [], Mt("xeoptgroup", a), hR(e, l), Nt(() => {
      mR(o, n.value, l);
    }), wo(() => {
      gR(o, l);
    }), () => V("div", {
      ref: n
    }, t.default ? t.default() : []);
  }
}), D1 = Object.assign(bd, {
  install: function(e) {
    e.component(bd.name, bd);
  }
}), PEe = D1;
Fn.component(bd.name, bd);
const yd = Q({
  name: "VxeOption",
  props: {
    value: null,
    label: { type: [String, Number, Boolean], default: "" },
    visible: { type: Boolean, default: null },
    className: [String, Function],
    disabled: Boolean
  },
  setup(e, { slots: t }) {
    const n = B(), o = ot("$xeselect", {}), l = ot("xeoptgroup", null), a = vR(o, e);
    return a.slots = t, hR(e, a), Nt(() => {
      mR(o, n.value, a, l);
    }), wo(() => {
      gR(o, a);
    }), () => V("div", {
      ref: n
    });
  }
}), L1 = Object.assign(yd, {
  install: function(e) {
    e.component(yd.name, yd);
  }
}), AEe = L1;
Fn.component(yd.name, yd);
const Cd = Q({
  name: "VxeSwitch",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: Boolean,
    size: { type: String, default: () => ee.switch.size || ee.size },
    openLabel: String,
    closeLabel: String,
    openValue: { type: [String, Number, Boolean], default: !0 },
    closeValue: { type: [String, Number, Boolean], default: !1 },
    openIcon: String,
    closeIcon: String
  },
  emits: [
    "update:modelValue",
    "change",
    "focus",
    "blur"
  ],
  setup(e, t) {
    const { emit: n } = t, o = ot("$xeform", null), l = ot("$xeformiteminfo", null), a = I.uniqueId(), r = Po(e), i = en({
      isActivated: !1,
      hasAnimat: !1,
      offsetLeft: 0
    }), s = {
      xID: a,
      props: e,
      context: t,
      reactData: i
    }, u = B();
    let d = {};
    const f = x(() => vo(e.openLabel)), v = x(() => vo(e.closeLabel)), h = x(() => e.modelValue === e.openValue);
    let m;
    const p = (b) => {
      if (!e.disabled) {
        const y = h.value;
        clearTimeout(m);
        const E = y ? e.closeValue : e.openValue;
        i.hasAnimat = !0, n("update:modelValue", E), d.dispatchEvent("change", { value: E }, b), o && l && o.triggerItemEvent(b, l.itemConfig.field, E), m = setTimeout(() => {
          i.hasAnimat = !1;
        }, 400);
      }
    }, C = (b) => {
      i.isActivated = !0, d.dispatchEvent("focus", { value: e.modelValue }, b);
    }, g = (b) => {
      i.isActivated = !1, d.dispatchEvent("blur", { value: e.modelValue }, b);
    };
    d = {
      dispatchEvent(b, y, E) {
        n(b, Object.assign({ $switch: s, $event: E }, y));
      },
      focus() {
        const b = u.value;
        return i.isActivated = !0, b.focus(), xe();
      },
      blur() {
        return u.value.blur(), i.isActivated = !1, xe();
      }
    }, Object.assign(s, d);
    const w = () => {
      const { disabled: b, openIcon: y, closeIcon: E } = e, S = h.value, _ = r.value, k = f.value, N = v.value;
      return V("div", {
        class: ["vxe-switch", S ? "is--on" : "is--off", {
          [`size--${_}`]: _,
          "is--disabled": b,
          "is--animat": i.hasAnimat
        }]
      }, [
        V("button", {
          ref: u,
          class: "vxe-switch--button",
          type: "button",
          disabled: b,
          onClick: p,
          onFocus: C,
          onBlur: g
        }, [
          V("span", {
            class: "vxe-switch--label vxe-switch--label-on"
          }, [
            y ? V("i", {
              class: ["vxe-switch--label-icon", y]
            }) : _e(),
            k
          ]),
          V("span", {
            class: "vxe-switch--label vxe-switch--label-off"
          }, [
            E ? V("i", {
              class: ["vxe-switch--label-icon", E]
            }) : _e(),
            N
          ]),
          V("span", {
            class: "vxe-switch--icon"
          })
        ])
      ]);
    };
    return s.renderVN = w, s;
  },
  render() {
    return this.renderVN();
  }
}), P1 = Object.assign(Cd, {
  install: function(e) {
    e.component(Cd.name, Cd);
  }
}), FEe = P1;
Fn.component(Cd.name, Cd);
const wd = Q({
  name: "VxeList",
  props: {
    data: Array,
    height: [Number, String],
    maxHeight: [Number, String],
    loading: Boolean,
    className: [String, Function],
    size: { type: String, default: () => ee.list.size || ee.size },
    autoResize: { type: Boolean, default: () => ee.list.autoResize },
    syncResize: [Boolean, String, Number],
    scrollY: Object
  },
  emits: [
    "scroll"
  ],
  setup(e, t) {
    const { slots: n, emit: o } = t, l = I.uniqueId(), a = Po(e), r = en({
      scrollYLoad: !1,
      bodyHeight: 0,
      rowHeight: 0,
      topSpaceHeight: 0,
      items: []
    }), i = B(), s = B(), u = B(), d = {
      fullData: [],
      lastScrollLeft: 0,
      lastScrollTop: 0,
      scrollYStore: {
        startIndex: 0,
        endIndex: 0,
        visibleSize: 0,
        offsetSize: 0,
        rowHeight: 0
      }
    }, f = {
      refElem: i
    }, v = {
      xID: l,
      props: e,
      context: t,
      reactData: r,
      internalData: d,
      getRefMaps: () => f
    };
    let h = {};
    const m = x(() => Object.assign({}, ee.list.scrollY, e.scrollY)), p = x(() => {
      const { height: K, maxHeight: U } = e, W = {};
      return K ? W.height = `${isNaN(K) ? K : `${K}px`}` : U && (W.height = "auto", W.maxHeight = `${isNaN(U) ? U : `${U}px`}`), W;
    }), C = () => {
      const { scrollYLoad: K } = r, { scrollYStore: U, fullData: W } = d;
      r.bodyHeight = K ? W.length * U.rowHeight : 0, r.topSpaceHeight = K ? Math.max(U.startIndex * U.rowHeight, 0) : 0;
    }, g = () => {
      const { scrollYLoad: K } = r, { fullData: U, scrollYStore: W } = d;
      return r.items = K ? U.slice(W.startIndex, W.endIndex) : U.slice(0), xe();
    }, w = () => {
      g(), C();
    }, b = () => xe().then(() => {
      const { scrollYLoad: K } = r, { scrollYStore: U } = d, W = u.value, A = m.value;
      let $ = 0, D;
      if (W && (A.sItem && (D = W.querySelector(A.sItem)), D || (D = W.children[0])), D && ($ = D.offsetHeight), $ = Math.max(20, $), U.rowHeight = $, K) {
        const O = s.value, F = Math.max(8, Math.ceil(O.clientHeight / $)), j = A.oSize ? I.toNumber(A.oSize) : Jl.edge ? 10 : 0;
        U.offsetSize = j, U.visibleSize = F, U.endIndex = Math.max(U.startIndex, F + j, U.endIndex), w();
      } else
        C();
      r.rowHeight = $;
    }), y = () => {
      const K = s.value;
      return K && (K.scrollTop = 0), xe();
    }, E = (K, U) => {
      const W = s.value;
      return I.isNumber(K) && (W.scrollLeft = K), I.isNumber(U) && (W.scrollTop = U), r.scrollYLoad ? new Promise((A) => {
        setTimeout(() => {
          xe(() => {
            A();
          });
        }, 50);
      }) : xe();
    }, S = () => {
      const { lastScrollLeft: K, lastScrollTop: U } = d;
      return y().then(() => {
        if (K || U)
          return d.lastScrollLeft = 0, d.lastScrollTop = 0, E(K, U);
      });
    }, _ = () => {
      const K = i.value;
      return K.clientWidth && K.clientHeight ? b() : Promise.resolve();
    }, k = (K) => {
      const { scrollYStore: U } = d, { startIndex: W, endIndex: A, visibleSize: $, offsetSize: D, rowHeight: O } = U, j = K.target.scrollTop, Z = Math.floor(j / O), te = Math.max(0, Z - 1 - D), de = Z + $ + D;
      (Z <= W || Z >= A - $ - 1) && (W !== te || A !== de) && (U.startIndex = te, U.endIndex = de, w());
    }, N = (K) => {
      const U = K.target, W = U.scrollTop, A = U.scrollLeft, $ = A !== d.lastScrollLeft, D = W !== d.lastScrollTop;
      d.lastScrollTop = W, d.lastScrollLeft = A, r.scrollYLoad && k(K), h.dispatchEvent("scroll", { scrollLeft: A, scrollTop: W, isX: $, isY: D }, K);
    };
    h = {
      dispatchEvent(K, U, W) {
        o(K, Object.assign({ $list: v, $event: W }, U));
      },
      /**
       * 加载数据
       * @param {Array} datas 数据
       */
      loadData(K) {
        const { scrollYStore: U } = d, W = m.value, A = K || [];
        return Object.assign(U, {
          startIndex: 0,
          endIndex: 1,
          visibleSize: 0
        }), d.fullData = A, r.scrollYLoad = !!W.enabled && W.gt > -1 && (W.gt === 0 || W.gt <= A.length), g(), b().then(() => {
          S();
        });
      },
      /**
       * 重新加载数据
       * @param {Array} datas 数据
       */
      reloadData(K) {
        return y(), h.loadData(K);
      },
      recalculate: _,
      scrollTo: E,
      refreshScroll: S,
      clearScroll: y
    }, Object.assign(v, h);
    const L = B(0);
    Pe(() => e.data ? e.data.length : -1, () => {
      L.value++;
    }), Pe(() => e.data, () => {
      L.value++;
    }), Pe(L, () => {
      h.loadData(e.data || []);
    }), Pe(() => e.syncResize, (K) => {
      K && (_(), xe(() => setTimeout(() => _())));
    }), j2(() => {
      _().then(() => S());
    });
    let R;
    xe(() => {
      if (wn.on(v, "resize", () => {
        _();
      }), e.autoResize) {
        const K = i.value;
        R = nR(() => _()), R.observe(K);
      }
      h.loadData(e.data || []);
    }), wo(() => {
      R && R.disconnect(), wn.off(v, "resize");
    });
    const H = () => {
      const { className: K, loading: U } = e, { bodyHeight: W, topSpaceHeight: A, items: $ } = r, D = a.value, O = p.value;
      return V("div", {
        ref: i,
        class: ["vxe-list", K ? I.isFunction(K) ? K({ $list: v }) : K : "", {
          [`size--${D}`]: D,
          "is--loading": U
        }]
      }, [
        V("div", {
          ref: s,
          class: "vxe-list--virtual-wrapper",
          style: O,
          onScroll: N
        }, [
          V("div", {
            class: "vxe-list--y-space",
            style: {
              height: W ? `${W}px` : ""
            }
          }),
          V("div", {
            ref: u,
            class: "vxe-list--body",
            style: {
              marginTop: A ? `${A}px` : ""
            }
          }, n.default ? n.default({ items: $, $list: v }) : [])
        ]),
        /**
         * 加载中
         */
        V(uh, {
          class: "vxe-list--loading",
          modelValue: U
        })
      ]);
    };
    return v.renderVN = H, v;
  },
  render() {
    return this.renderVN();
  }
}), A1 = Object.assign(wd, {
  install(e) {
    e.component(wd.name, wd);
  }
}), VEe = A1;
Fn.component(wd.name, wd);
const Ed = Q({
  name: "VxePulldown",
  props: {
    modelValue: Boolean,
    disabled: Boolean,
    placement: String,
    size: { type: String, default: () => ee.size },
    className: [String, Function],
    popupClassName: [String, Function],
    destroyOnClose: Boolean,
    transfer: Boolean
  },
  emits: [
    "update:modelValue",
    "hide-panel"
  ],
  setup(e, t) {
    const { slots: n, emit: o } = t, l = I.uniqueId(), a = Po(e), r = en({
      inited: !1,
      panelIndex: 0,
      panelStyle: null,
      panelPlacement: null,
      visiblePanel: !1,
      animatVisible: !1,
      isActivated: !1
    }), i = B(), s = B(), u = B(), d = {
      refElem: i
    }, f = {
      xID: l,
      props: e,
      context: t,
      reactData: r,
      getRefMaps: () => d
    };
    let v = {};
    const h = () => {
      r.panelIndex < Yr() && (r.panelIndex = dr());
    }, m = () => r.visiblePanel, p = () => xe().then(() => {
      const { transfer: k, placement: N } = e, { panelIndex: L, visiblePanel: R } = r;
      if (R) {
        const H = s.value, K = u.value;
        if (K && H) {
          const U = H.offsetHeight, W = H.offsetWidth, A = K.offsetHeight, $ = K.offsetWidth, D = 5, O = {
            zIndex: L
          }, { boundingTop: F, boundingLeft: j, visibleHeight: Z, visibleWidth: te } = lr(H);
          let de = "bottom";
          if (k) {
            let Oe = j, ce = F + U;
            N === "top" ? (de = "top", ce = F - A) : N || (ce + A + D > Z && (de = "top", ce = F - A), ce < D && (de = "bottom", ce = F + U)), Oe + $ + D > te && (Oe -= Oe + $ + D - te), Oe < D && (Oe = D), Object.assign(O, {
              left: `${Oe}px`,
              top: `${ce}px`,
              minWidth: `${W}px`
            });
          } else
            N === "top" ? (de = "top", O.bottom = `${U}px`) : N || F + U + A > Z && F - U - A > D && (de = "top", O.bottom = `${U}px`);
          r.panelStyle = O, r.panelPlacement = de;
        }
      }
      return xe();
    });
    let C;
    const g = () => (r.inited || (r.inited = !0), new Promise((k) => {
      e.disabled ? xe(() => {
        k();
      }) : (clearTimeout(C), r.isActivated = !0, r.animatVisible = !0, setTimeout(() => {
        r.visiblePanel = !0, o("update:modelValue", !0), p(), setTimeout(() => {
          k(p());
        }, 40);
      }, 10), h());
    })), w = () => (r.visiblePanel = !1, o("update:modelValue", !1), new Promise((k) => {
      r.animatVisible ? C = window.setTimeout(() => {
        r.animatVisible = !1, xe(() => {
          k();
        });
      }, 350) : xe(() => {
        k();
      });
    })), b = () => r.visiblePanel ? w() : g(), y = (k) => {
      const { disabled: N } = e, { visiblePanel: L } = r, R = u.value;
      N || L && (_n(k, R).flag ? p() : (w(), v.dispatchEvent("hide-panel", {}, k)));
    }, E = (k) => {
      const { disabled: N } = e, { visiblePanel: L } = r, R = i.value, H = u.value;
      N || (r.isActivated = _n(k, R).flag || _n(k, H).flag, L && !r.isActivated && (w(), v.dispatchEvent("hide-panel", {}, k)));
    }, S = (k) => {
      r.visiblePanel && (r.isActivated = !1, w(), v.dispatchEvent("hide-panel", {}, k));
    };
    v = {
      dispatchEvent(k, N, L) {
        o(k, Object.assign({ $pulldown: f, $event: L }, N));
      },
      isPanelVisible: m,
      togglePanel: b,
      showPanel: g,
      hidePanel: w
    }, Object.assign(f, v), Pe(() => e.modelValue, (k) => {
      k ? g() : w();
    }), xe(() => {
      wn.on(f, "mousewheel", y), wn.on(f, "mousedown", E), wn.on(f, "blur", S);
    }), wo(() => {
      wn.off(f, "mousewheel"), wn.off(f, "mousedown"), wn.off(f, "blur");
    });
    const _ = () => {
      const { className: k, popupClassName: N, destroyOnClose: L, transfer: R, disabled: H } = e, { inited: K, isActivated: U, animatVisible: W, visiblePanel: A, panelStyle: $, panelPlacement: D } = r, O = a.value, F = n.default, j = n.header, Z = n.footer, te = n.dropdown;
      return V("div", {
        ref: i,
        class: ["vxe-pulldown", k ? I.isFunction(k) ? k({ $pulldown: f }) : k : "", {
          [`size--${O}`]: O,
          "is--visivle": A,
          "is--disabled": H,
          "is--active": U
        }]
      }, [
        V("div", {
          ref: s,
          class: "vxe-pulldown--content"
        }, F ? F({ $pulldown: f }) : []),
        V(ka, {
          to: "body",
          disabled: R ? !K : !0
        }, [
          V("div", {
            ref: u,
            class: ["vxe-table--ignore-clear vxe-pulldown--panel", N ? I.isFunction(N) ? N({ $pulldown: f }) : N : "", {
              [`size--${O}`]: O,
              "is--transfer": R,
              "animat--leave": W,
              "animat--enter": A
            }],
            placement: D,
            style: $
          }, te ? [
            V("div", {
              class: "vxe-pulldown--panel-wrapper"
            }, !K || L && !A && !W ? [] : [
              j ? V("div", {
                class: "vxe-pulldown--panel-header"
              }, j({ $pulldown: f })) : _e(),
              V("div", {
                class: "vxe-pulldown--panel-body"
              }, te({ $pulldown: f })),
              Z ? V("div", {
                class: "vxe-pulldown--panel-footer"
              }, Z({ $pulldown: f })) : _e()
            ])
          ] : [])
        ])
      ]);
    };
    return f.renderVN = _, f;
  },
  render() {
    return this.renderVN();
  }
}), F1 = Object.assign(Ed, {
  install: function(e) {
    e.component(Ed.name, Ed);
  }
}), BEe = F1;
Fn.component(Ed.name, Ed);
const HEe = {
  vxe: {
    base: {
      pleaseInput: "请输入",
      pleaseSelect: "请选择"
    },
    loading: {
      text: "加载中..."
    },
    error: {
      groupFixed: "如果使用分组表头，冻结列必须按组设置",
      groupMouseRange: '分组表头与 "{0}" 不能同时使用，这可能会出现错误',
      groupTag: '分组列头应该使用 "{0}" 而不是 "{1}"，这可能会出现错误',
      scrollErrProp: '启用虚拟滚动后不支持该参数 "{0}"',
      errConflicts: '参数 "{0}" 与 "{1}" 有冲突',
      unableInsert: "无法插入到指定位置，请检查参数是否正确",
      useErr: '安装 "{0}" 模块时发生错误，可能顺序不正确，依赖的模块需要在 Table 之前安装',
      barUnableLink: "工具栏无法关联表格",
      expandContent: '展开行的插槽应该是 "content"，请检查是否正确',
      reqModule: '缺少 "{0}" 模块',
      reqProp: '缺少必要的 "{0}" 参数，这可能会导致出现错误',
      emptyProp: '参数 "{0}" 不允许为空',
      errProp: '不支持的参数 "{0}"，可能为 "{1}"',
      colRepet: 'column.{0}="{1}" 重复了，这可能会导致某些功能无法使用',
      notFunc: '方法 "{0}" 不存在',
      errFunc: '参数 "{0}" 不是一个方法',
      notValidators: '全局校验 "{0}" 不存在',
      notFormats: '全局格式化 "{0}" 不存在',
      notCommands: '全局指令 "{0}" 不存在',
      notSlot: '插槽 "{0}" 不存在',
      noTree: '树结构不支持 "{0}"',
      notProp: '不支持的参数 "{0}"',
      checkProp: '当数据量过大时可能会导致复选框卡顿，建议设置参数 "{0}" 提升渲染速度',
      coverProp: '"{0}" 的参数 "{1}" 重复定义，这可能会出现错误',
      delFunc: '方法 "{0}" 已废弃，请使用 "{1}"',
      delProp: '参数 "{0}" 已废弃，请使用 "{1}"',
      delEvent: '事件 "{0}" 已废弃，请使用 "{1}"',
      removeProp: '参数 "{0}" 已废弃，不建议使用，这可能会导致出现错误',
      errFormat: '全局的格式化内容应该使用 "VXETable.formats" 定义，挂载 "formatter={0}" 的方式已不建议使用',
      notType: '不支持的文件类型 "{0}"',
      notExp: "该浏览器不支持导入/导出功能",
      impFields: "导入失败，请检查字段名和数据格式是否正确",
      treeNotImp: "树表格不支持导入"
    },
    table: {
      emptyText: "暂无数据",
      allTitle: "全选/取消",
      seqTitle: "#",
      confirmFilter: "筛选",
      resetFilter: "重置",
      allFilter: "全部",
      sortAsc: "升序：最低到最高",
      sortDesc: "降序：最高到最低",
      filter: "对所选的列启用筛选",
      impSuccess: "成功导入 {0} 条记录",
      expLoading: "正在导出中",
      expSuccess: "导出成功",
      expFilename: "导出_{0}",
      expOriginFilename: "导出_源_{0}",
      customTitle: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customRestore: "重置",
      maxFixedCol: "最大冻结列的数量不能超过 {0} 个"
    },
    grid: {
      selectOneRecord: "请至少选择一条记录！",
      deleteSelectRecord: "您确定要删除所选记录吗？",
      removeSelectRecord: "您确定要移除所选记录吗？",
      dataUnchanged: "数据未改动！",
      delSuccess: "成功删除所选记录！",
      saveSuccess: "保存成功！",
      operError: "发生错误，操作失败！"
    },
    select: {
      search: "搜索",
      loadingText: "加载中",
      emptyText: "暂无数据"
    },
    pager: {
      goto: "前往",
      pagesize: "{0}条/页",
      total: "共 {0} 条记录",
      pageClassifier: "页",
      homePage: "首页",
      homePageTitle: "首页",
      prevPage: "上一页",
      prevPageTitle: "上一页",
      nextPage: "下一页",
      nextPageTitle: "下一页",
      prevJump: "向上跳页",
      prevJumpTitle: "向上跳页",
      nextJump: "向下跳页",
      nextJumpTitle: "向下跳页",
      endPage: "末页",
      endPageTitle: "末页"
    },
    alert: {
      title: "系统提示"
    },
    button: {
      confirm: "确认",
      cancel: "取消"
    },
    filter: {
      search: "搜索"
    },
    custom: {
      cstmTitle: "列设置",
      cstmRestore: "恢复默认",
      cstmCancel: "取消",
      cstmConfirm: "确定",
      cstmConfirmRestore: "请确认是否恢复成默认列配置？",
      cstmDragTarget: "移动目标：{0}",
      setting: {
        colSort: "排序",
        sortHelpTip: "点击并拖动图标可以调整列的排序",
        colTitle: "标题",
        colVisible: "是否显示",
        colFixed: "冻结列（最多 {0} 列）",
        fixedLeft: "左侧",
        fixedUnset: "不设置",
        fixedRight: "右侧"
      }
    },
    import: {
      modes: {
        covering: "覆盖",
        insert: "新增"
      },
      impTitle: "导入数据",
      impFile: "文件名",
      impSelect: "选择文件",
      impType: "文件类型",
      impOpts: "参数设置",
      impConfirm: "导入",
      impCancel: "取消"
    },
    export: {
      types: {
        csv: "CSV (逗号分隔)(*.csv)",
        html: "网页(*.html)",
        xml: "XML 数据(*.xml)",
        txt: "文本文件(制表符分隔)(*.txt)",
        xls: "Excel 97-2003 工作簿(*.xls)",
        xlsx: "Excel 工作簿(*.xlsx)",
        pdf: "PDF (*.pdf)"
      },
      modes: {
        current: "当前数据（当前页的数据）",
        selected: "选中数据（当前页选中的数据）",
        all: "全量数据（包括所有分页的数据）"
      },
      printTitle: "打印数据",
      expTitle: "导出数据",
      expName: "文件名",
      expNamePlaceholder: "请输入文件名",
      expSheetName: "标题",
      expSheetNamePlaceholder: "请输入标题",
      expType: "保存类型",
      expMode: "选择数据",
      expCurrentColumn: "全部字段",
      expColumn: "选择字段",
      expOpts: "参数设置",
      expOptHeader: "表头",
      expHeaderTitle: "是否需要表头",
      expOptFooter: "表尾",
      expFooterTitle: "是否需要表尾",
      expOptColgroup: "分组表头",
      expColgroupTitle: "如果存在，则支持带有分组结构的表头",
      expOptMerge: "合并",
      expMergeTitle: "如果存在，则支持带有合并结构的单元格",
      expOptAllExpand: "展开层级",
      expAllExpandTitle: "如果存在，则支持将带有层级结构的数据全部展开",
      expOptUseStyle: "样式",
      expUseStyleTitle: "如果存在，则支持带样式的单元格",
      expOptOriginal: "源数据",
      expOriginalTitle: "如果为源数据，则支持导入到表格中",
      expPrint: "打印",
      expConfirm: "导出",
      expCancel: "取消"
    },
    modal: {
      zoomIn: "最大化",
      zoomOut: "还原",
      close: "关闭"
    },
    form: {
      folding: "收起",
      unfolding: "展开"
    },
    toolbar: {
      import: "导入",
      export: "导出",
      print: "打印",
      refresh: "刷新",
      zoomIn: "全屏",
      zoomOut: "还原",
      custom: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customRestore: "重置",
      fixedLeft: "冻结在左侧",
      fixedRight: "冻结在右侧",
      cancelfixed: "取消冻结列"
    },
    input: {
      date: {
        m1: "01 月",
        m2: "02 月",
        m3: "03 月",
        m4: "04 月",
        m5: "05 月",
        m6: "06 月",
        m7: "07 月",
        m8: "08 月",
        m9: "09 月",
        m10: "10 月",
        m11: "11 月",
        m12: "12 月",
        quarterLabel: "{0} 年",
        monthLabel: "{0} 年",
        dayLabel: "{0} 年 {1}",
        labelFormat: {
          date: "yyyy-MM-dd",
          time: "HH:mm:ss",
          datetime: "yyyy-MM-dd HH:mm:ss",
          week: "yyyy 年第 WW 周",
          month: "yyyy-MM",
          quarter: "yyyy 年第 q 季度",
          year: "yyyy"
        },
        weeks: {
          w: "周",
          w0: "周日",
          w1: "周一",
          w2: "周二",
          w3: "周三",
          w4: "周四",
          w5: "周五",
          w6: "周六"
        },
        months: {
          m0: "一月",
          m1: "二月",
          m2: "三月",
          m3: "四月",
          m4: "五月",
          m5: "六月",
          m6: "七月",
          m7: "八月",
          m8: "九月",
          m9: "十月",
          m10: "十一月",
          m11: "十二月"
        },
        quarters: {
          q1: "第一季度",
          q2: "第二季度",
          q3: "第三季度",
          q4: "第四季度"
        }
      }
    },
    /**
     * 扩展插件
     */
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: "无法对合并单元格进行该操作",
          multiErr: "无法对多重选择区域进行该操作",
          extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
          pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作",
          cpInvalidErr: "该操作无法进行，您选择的区域中存在被禁止的列（{0}）"
        },
        fnr: {
          title: "查找和替换",
          findLabel: "查找",
          replaceLabel: "替换",
          findTitle: "查找内容：",
          replaceTitle: "替换为：",
          tabs: {
            find: "查找",
            replace: "替换"
          },
          filter: {
            re: "正则表达式",
            whole: "全词匹配",
            sensitive: "区分大小写"
          },
          btns: {
            findNext: "查找下一个",
            findAll: "查找全部",
            replace: "替换",
            replaceAll: "替换全部",
            cancel: "取消"
          },
          header: {
            seq: "#",
            cell: "单元格",
            value: "值"
          },
          empty: "(空值)",
          reError: "无效的正则表达式",
          recordCount: "已找到 {0} 个单元格",
          notCell: "找不到匹配的单元格",
          replaceSuccess: "成功替换 {0} 个单元格"
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧"
        },
        cases: {
          equal: "等于",
          gt: "大于",
          lt: "小于",
          begin: "开头是",
          endin: "结尾是",
          include: "包含",
          isSensitive: "区分大小写"
        }
      },
      filterCombination: {
        menus: {
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        cases: {
          equal: "等于",
          unequal: "不等于",
          gt: "大于",
          ge: "大于或等于",
          lt: "小于",
          le: "小于或等于",
          begin: "开头是",
          notbegin: "开头不是",
          endin: "结尾是",
          notendin: "结尾不是",
          include: "包含",
          exclude: "不包含",
          between: "介于",
          custom: "自定义筛选",
          insensitive: "不区分大小写",
          isSensitive: "区分大小写"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    },
    /**
     * 以下废弃
     * @deprecated
     */
    pro: {
      area: {
        mergeErr: "无法对合并单元格进行该操作",
        multiErr: "无法对多重选择区域进行该操作",
        extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
        pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作"
      },
      fnr: {
        title: "查找和替换",
        findLabel: "查找",
        replaceLabel: "替换",
        findTitle: "查找内容：",
        replaceTitle: "替换为：",
        tabs: {
          find: "查找",
          replace: "替换"
        },
        filter: {
          re: "正则表达式",
          whole: "全词匹配",
          sensitive: "区分大小写"
        },
        btns: {
          findNext: "查找下一个",
          findAll: "查找全部",
          replace: "替换",
          replaceAll: "替换全部",
          cancel: "取消"
        },
        header: {
          seq: "#",
          cell: "单元格",
          value: "值"
        },
        empty: "(空值)",
        reError: "无效的正则表达式",
        recordCount: "已找到 {0} 个单元格",
        notCell: "找不到匹配的单元格",
        replaceSuccess: "成功替换 {0} 个单元格"
      }
    },
    renderer: {
      search: "搜索",
      cases: {
        equal: "等于",
        unequal: "不等于",
        gt: "大于",
        ge: "大于或等于",
        lt: "小于",
        le: "小于或等于",
        begin: "开头是",
        notbegin: "开头不是",
        endin: "结尾是",
        notendin: "结尾不是",
        include: "包含",
        exclude: "不包含",
        between: "介于",
        custom: "自定义筛选",
        insensitive: "不区分大小写",
        isSensitive: "区分大小写"
      },
      combination: {
        menus: {
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "锁定列",
          fixedGroup: "锁定组",
          cancelFixed: "取消锁定",
          fixedLeft: "锁定左侧",
          fixedRight: "锁定右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    }
  }
}, zEe = [
  // 功能模块
  s1,
  i1,
  c1,
  d1,
  f1,
  p1,
  v1,
  // 可选组件
  Yd,
  h1,
  m1,
  w1,
  vh,
  ph,
  E1,
  S1,
  _1,
  x1,
  k1,
  T1,
  $1,
  da,
  O1,
  M1,
  Jc,
  hh,
  I1,
  R1,
  fh,
  D1,
  L1,
  P1,
  A1,
  F1,
  // 核心
  dh
];
$f({
  i18n: (e, t) => I.toFormatString(I.get(HEe, e), t)
});
function WEe(e, t) {
  I.isPlainObject(t) && ($f(t), t.theme && a1(t)), zEe.forEach((n) => n.install(e));
}
const KEe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Button: cEe,
  ButtonGroup: kEe,
  Checkbox: yEe,
  CheckboxGroup: CEe,
  Colgroup: Qwe,
  Column: Jwe,
  Custom: qwe,
  Edit: Cwe,
  Export: Fwe,
  Filter: vwe,
  Form: hEe,
  FormGather: DEe,
  FormItem: REe,
  Grid: bEe,
  Icon: Ywe,
  Input: _Ee,
  Keyboard: Hwe,
  List: VEe,
  Menu: gwe,
  Modal: IEe,
  Optgroup: PEe,
  Option: AEe,
  Pager: iEe,
  Pulldown: BEe,
  Radio: wEe,
  RadioButton: SEe,
  RadioGroup: EEe,
  Select: sEe,
  Switch: FEe,
  Table: rEe,
  Textarea: xEe,
  Toolbar: uEe,
  Tooltip: pEe,
  VXETable: $t,
  Validator: Kwe,
  VxeButton: da,
  VxeButtonGroup: O1,
  VxeCheckbox: E1,
  VxeCheckboxGroup: S1,
  VxeColgroup: m1,
  VxeColumn: h1,
  VxeForm: hh,
  VxeFormGather: R1,
  VxeFormItem: I1,
  VxeGrid: w1,
  VxeIcon: Yd,
  VxeInput: T1,
  VxeList: A1,
  VxeModal: M1,
  VxeOptgroup: D1,
  VxeOption: L1,
  VxePager: ph,
  VxePulldown: F1,
  VxeRadio: _1,
  VxeRadioButton: k1,
  VxeRadioGroup: x1,
  VxeSelect: fh,
  VxeSwitch: P1,
  VxeTable: dh,
  VxeTableCustomModule: v1,
  VxeTableEditModule: c1,
  VxeTableExportModule: d1,
  VxeTableFilterModule: s1,
  VxeTableKeyboardModule: f1,
  VxeTableMenuModule: i1,
  VxeTableValidatorModule: p1,
  VxeTextarea: $1,
  VxeToolbar: vh,
  VxeTooltip: Jc,
  _t: WI,
  commands: n1,
  config: $f,
  formats: jd,
  globalConfs: KI,
  globalStore: r1,
  hooks: BI,
  install: WEe,
  interceptor: nd,
  menus: o1,
  modal: MEe,
  print: QI,
  readFile: gv,
  renderer: fi,
  saveFile: bv,
  setup: jI,
  t: zI,
  use: HI,
  v: UI,
  validators: l1
}, Symbol.toStringTag, { value: "Module" }));
var UEe = {
  name: "zh-cn",
  el: {
    breadcrumb: {
      label: "面包屑"
    },
    colorpicker: {
      confirm: "确定",
      clear: "清空"
    },
    datepicker: {
      now: "此刻",
      today: "今天",
      cancel: "取消",
      clear: "清空",
      confirm: "确定",
      selectDate: "选择日期",
      selectTime: "选择时间",
      startDate: "开始日期",
      startTime: "开始时间",
      endDate: "结束日期",
      endTime: "结束时间",
      prevYear: "前一年",
      nextYear: "后一年",
      prevMonth: "上个月",
      nextMonth: "下个月",
      year: "年",
      month1: "1 月",
      month2: "2 月",
      month3: "3 月",
      month4: "4 月",
      month5: "5 月",
      month6: "6 月",
      month7: "7 月",
      month8: "8 月",
      month9: "9 月",
      month10: "10 月",
      month11: "11 月",
      month12: "12 月",
      weeks: {
        sun: "日",
        mon: "一",
        tue: "二",
        wed: "三",
        thu: "四",
        fri: "五",
        sat: "六"
      },
      months: {
        jan: "一月",
        feb: "二月",
        mar: "三月",
        apr: "四月",
        may: "五月",
        jun: "六月",
        jul: "七月",
        aug: "八月",
        sep: "九月",
        oct: "十月",
        nov: "十一月",
        dec: "十二月"
      }
    },
    select: {
      loading: "加载中",
      noMatch: "无匹配数据",
      noData: "无数据",
      placeholder: "请选择"
    },
    cascader: {
      noMatch: "无匹配数据",
      loading: "加载中",
      placeholder: "请选择",
      noData: "暂无数据"
    },
    pagination: {
      goto: "前往",
      pagesize: "条/页",
      total: "共 {total} 条",
      pageClassifier: "页",
      page: "页",
      prev: "上一页",
      next: "下一页",
      currentPage: "第 {pager} 页",
      prevPages: "向前 {pager} 页",
      nextPages: "向后 {pager} 页",
      deprecationWarning: "你使用了一些已被废弃的用法，请参考 el-pagination 的官方文档"
    },
    messagebox: {
      title: "提示",
      confirm: "确定",
      cancel: "取消",
      error: "输入的数据不合法!"
    },
    upload: {
      deleteTip: "按 delete 键可删除",
      delete: "删除",
      preview: "查看图片",
      continue: "继续上传"
    },
    table: {
      emptyText: "暂无数据",
      confirmFilter: "筛选",
      resetFilter: "重置",
      clearFilter: "全部",
      sumText: "合计"
    },
    tour: {
      next: "下一步",
      previous: "上一步",
      finish: "结束导览"
    },
    tree: {
      emptyText: "暂无数据"
    },
    transfer: {
      noMatch: "无匹配数据",
      noData: "无数据",
      titles: ["列表 1", "列表 2"],
      filterPlaceholder: "请输入搜索内容",
      noCheckedFormat: "共 {total} 项",
      hasCheckedFormat: "已选 {checked}/{total} 项"
    },
    image: {
      error: "加载失败"
    },
    pageHeader: {
      title: "返回"
    },
    popconfirm: {
      confirmButtonText: "确定",
      cancelButtonText: "取消"
    },
    carousel: {
      leftArrow: "上一张幻灯片",
      rightArrow: "下一张幻灯片",
      indicator: "幻灯片切换至索引 {index}"
    }
  }
};
/*!
  * shared v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const Va = typeof window < "u";
let Ql, Ri;
if (process.env.NODE_ENV !== "production") {
  const e = Va && window.performance;
  e && e.mark && e.measure && e.clearMarks && // @ts-ignore browser compat
  e.clearMeasures && (Ql = (t) => {
    e.mark(t);
  }, Ri = (t, n, o) => {
    e.measure(t, n, o), e.clearMarks(n), e.clearMarks(o);
  });
}
const jEe = /\{([0-9a-zA-Z]+)\}/g;
function V1(e, ...t) {
  return t.length === 1 && Kn(t[0]) && (t = t[0]), (!t || !t.hasOwnProperty) && (t = {}), e.replace(jEe, (n, o) => t.hasOwnProperty(o) ? t[o] : "");
}
const gr = (e, t = !1) => t ? Symbol.for(e) : Symbol(e), qEe = (e, t, n) => YEe({ l: e, k: t, s: n }), YEe = (e) => JSON.stringify(e).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"), Vo = (e) => typeof e == "number" && isFinite(e), GEe = (e) => yR(e) === "[object Date]", Is = (e) => yR(e) === "[object RegExp]", mh = (e) => En(e) && Object.keys(e).length === 0, al = Object.assign;
let t2;
const Nr = () => t2 || (t2 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function n2(e) {
  return e.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const XEe = Object.prototype.hasOwnProperty;
function yv(e, t) {
  return XEe.call(e, t);
}
const fo = Array.isArray, Gn = (e) => typeof e == "function", Vt = (e) => typeof e == "string", Nn = (e) => typeof e == "boolean", Kn = (e) => e !== null && typeof e == "object", ZEe = (e) => Kn(e) && Gn(e.then) && Gn(e.catch), bR = Object.prototype.toString, yR = (e) => bR.call(e), En = (e) => {
  if (!Kn(e))
    return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t.constructor === Object;
}, JEe = (e) => e == null ? "" : fo(e) || En(e) && e.toString === bR ? JSON.stringify(e, null, 2) : String(e);
function QEe(e, t = "") {
  return e.reduce((n, o, l) => l === 0 ? n + o : n + t + o, "");
}
const o2 = 2;
function eSe(e, t = 0, n = e.length) {
  const o = e.split(/\r?\n/);
  let l = 0;
  const a = [];
  for (let r = 0; r < o.length; r++)
    if (l += o[r].length + 1, l >= t) {
      for (let i = r - o2; i <= r + o2 || n > l; i++) {
        if (i < 0 || i >= o.length)
          continue;
        const s = i + 1;
        a.push(`${s}${" ".repeat(3 - String(s).length)}|  ${o[i]}`);
        const u = o[i].length;
        if (i === r) {
          const d = t - (l - u) + 1, f = Math.max(1, n > l ? u - d : n - t);
          a.push("   |  " + " ".repeat(d) + "^".repeat(f));
        } else if (i > r) {
          if (n > l) {
            const d = Math.max(Math.min(n - l, u), 1);
            a.push("   |  " + "^".repeat(d));
          }
          l += u + 1;
        }
      }
      break;
    }
  return a.join(`
`);
}
function gh(e) {
  let t = e;
  return () => ++t;
}
function Bo(e, t) {
  typeof console < "u" && (console.warn("[intlify] " + e), t && console.warn(t.stack));
}
const l2 = {};
function CR(e) {
  l2[e] || (l2[e] = !0, Bo(e));
}
function B1() {
  const e = /* @__PURE__ */ new Map();
  return {
    events: e,
    on(n, o) {
      const l = e.get(n);
      l && l.push(o) || e.set(n, [o]);
    },
    off(n, o) {
      const l = e.get(n);
      l && l.splice(l.indexOf(o) >>> 0, 1);
    },
    emit(n, o) {
      (e.get(n) || []).slice().map((l) => l(o)), (e.get("*") || []).slice().map((l) => l(n, o));
    }
  };
}
const fp = (e) => !Kn(e) || fo(e);
function zp(e, t) {
  if (fp(e) || fp(t))
    throw new Error("Invalid value");
  const n = [{ src: e, des: t }];
  for (; n.length; ) {
    const { src: o, des: l } = n.pop();
    Object.keys(o).forEach((a) => {
      fp(o[a]) || fp(l[a]) ? l[a] = o[a] : n.push({ src: o[a], des: l[a] });
    });
  }
}
/*!
  * message-compiler v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function tSe(e, t, n) {
  return { line: e, column: t, offset: n };
}
function Cv(e, t, n) {
  const o = { start: e, end: t };
  return n != null && (o.source = n), o;
}
const nSe = /\{([0-9a-zA-Z]+)\}/g;
function wR(e, ...t) {
  return t.length === 1 && oSe(t[0]) && (t = t[0]), (!t || !t.hasOwnProperty) && (t = {}), e.replace(nSe, (n, o) => t.hasOwnProperty(o) ? t[o] : "");
}
const ER = Object.assign, a2 = (e) => typeof e == "string", oSe = (e) => e !== null && typeof e == "object";
function SR(e, t = "") {
  return e.reduce((n, o, l) => l === 0 ? n + o : n + t + o, "");
}
const bh = {
  USE_MODULO_SYNTAX: 1,
  __EXTEND_POINT__: 2
}, lSe = {
  [bh.USE_MODULO_SYNTAX]: "Use modulo before '{{0}}'."
};
function aSe(e, t, ...n) {
  const o = wR(lSe[e] || "", ...n || []), l = { message: String(o), code: e };
  return t && (l.location = t), l;
}
const gn = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 17
}, rSe = {
  // tokenizer error messages
  [gn.EXPECTED_TOKEN]: "Expected token: '{0}'",
  [gn.INVALID_TOKEN_IN_PLACEHOLDER]: "Invalid token in placeholder: '{0}'",
  [gn.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: "Unterminated single quote in placeholder",
  [gn.UNKNOWN_ESCAPE_SEQUENCE]: "Unknown escape sequence: \\{0}",
  [gn.INVALID_UNICODE_ESCAPE_SEQUENCE]: "Invalid unicode escape sequence: {0}",
  [gn.UNBALANCED_CLOSING_BRACE]: "Unbalanced closing brace",
  [gn.UNTERMINATED_CLOSING_BRACE]: "Unterminated closing brace",
  [gn.EMPTY_PLACEHOLDER]: "Empty placeholder",
  [gn.NOT_ALLOW_NEST_PLACEHOLDER]: "Not allowed nest placeholder",
  [gn.INVALID_LINKED_FORMAT]: "Invalid linked format",
  // parser error messages
  [gn.MUST_HAVE_MESSAGES_IN_PLURAL]: "Plural must have messages",
  [gn.UNEXPECTED_EMPTY_LINKED_MODIFIER]: "Unexpected empty linked modifier",
  [gn.UNEXPECTED_EMPTY_LINKED_KEY]: "Unexpected empty linked key",
  [gn.UNEXPECTED_LEXICAL_ANALYSIS]: "Unexpected lexical analysis in token: '{0}'",
  // generator error messages
  [gn.UNHANDLED_CODEGEN_NODE_TYPE]: "unhandled codegen node type: '{0}'",
  // minimizer error messages
  [gn.UNHANDLED_MINIFIER_NODE_TYPE]: "unhandled mimifier node type: '{0}'"
};
function mu(e, t, n = {}) {
  const { domain: o, messages: l, args: a } = n, r = wR((l || rSe)[e] || "", ...a || []), i = new SyntaxError(String(r));
  return i.code = e, t && (i.location = t), i.domain = o, i;
}
function sSe(e) {
  throw e;
}
const iSe = /<\/?[\w\s="/.':;#-\/]+>/, cSe = (e) => iSe.test(e), xr = " ", uSe = "\r", wl = `
`, dSe = "\u2028", fSe = "\u2029";
function pSe(e) {
  const t = e;
  let n = 0, o = 1, l = 1, a = 0;
  const r = (_) => t[_] === uSe && t[_ + 1] === wl, i = (_) => t[_] === wl, s = (_) => t[_] === fSe, u = (_) => t[_] === dSe, d = (_) => r(_) || i(_) || s(_) || u(_), f = () => n, v = () => o, h = () => l, m = () => a, p = (_) => r(_) || s(_) || u(_) ? wl : t[_], C = () => p(n), g = () => p(n + a);
  function w() {
    return a = 0, d(n) && (o++, l = 0), r(n) && n++, n++, l++, t[n];
  }
  function b() {
    return r(n + a) && a++, a++, t[n + a];
  }
  function y() {
    n = 0, o = 1, l = 1, a = 0;
  }
  function E(_ = 0) {
    a = _;
  }
  function S() {
    const _ = n + a;
    for (; _ !== n; )
      w();
    a = 0;
  }
  return {
    index: f,
    line: v,
    column: h,
    peekOffset: m,
    charAt: p,
    currentChar: C,
    currentPeek: g,
    next: w,
    peek: b,
    reset: y,
    resetPeek: E,
    skipToPeek: S
  };
}
const is = void 0, vSe = ".", r2 = "'", hSe = "tokenizer";
function mSe(e, t = {}) {
  const n = t.location !== !1, o = pSe(e), l = () => o.index(), a = () => tSe(o.line(), o.column(), o.index()), r = a(), i = l(), s = {
    currentType: 14,
    offset: i,
    startLoc: r,
    endLoc: r,
    lastType: 14,
    lastOffset: i,
    lastStartLoc: r,
    lastEndLoc: r,
    braceNest: 0,
    inLinked: !1,
    text: ""
  }, u = () => s, { onError: d } = t;
  function f(ae, pe, ke, ...Ue) {
    const Xe = u();
    if (pe.column += ke, pe.offset += ke, d) {
      const re = n ? Cv(Xe.startLoc, pe) : null, Te = mu(ae, re, {
        domain: hSe,
        args: Ue
      });
      d(Te);
    }
  }
  function v(ae, pe, ke) {
    ae.endLoc = a(), ae.currentType = pe;
    const Ue = { type: pe };
    return n && (Ue.loc = Cv(ae.startLoc, ae.endLoc)), ke != null && (Ue.value = ke), Ue;
  }
  const h = (ae) => v(
    ae,
    14
    /* TokenTypes.EOF */
  );
  function m(ae, pe) {
    return ae.currentChar() === pe ? (ae.next(), pe) : (f(gn.EXPECTED_TOKEN, a(), 0, pe), "");
  }
  function p(ae) {
    let pe = "";
    for (; ae.currentPeek() === xr || ae.currentPeek() === wl; )
      pe += ae.currentPeek(), ae.peek();
    return pe;
  }
  function C(ae) {
    const pe = p(ae);
    return ae.skipToPeek(), pe;
  }
  function g(ae) {
    if (ae === is)
      return !1;
    const pe = ae.charCodeAt(0);
    return pe >= 97 && pe <= 122 || // a-z
    pe >= 65 && pe <= 90 || // A-Z
    pe === 95;
  }
  function w(ae) {
    if (ae === is)
      return !1;
    const pe = ae.charCodeAt(0);
    return pe >= 48 && pe <= 57;
  }
  function b(ae, pe) {
    const { currentType: ke } = pe;
    if (ke !== 2)
      return !1;
    p(ae);
    const Ue = g(ae.currentPeek());
    return ae.resetPeek(), Ue;
  }
  function y(ae, pe) {
    const { currentType: ke } = pe;
    if (ke !== 2)
      return !1;
    p(ae);
    const Ue = ae.currentPeek() === "-" ? ae.peek() : ae.currentPeek(), Xe = w(Ue);
    return ae.resetPeek(), Xe;
  }
  function E(ae, pe) {
    const { currentType: ke } = pe;
    if (ke !== 2)
      return !1;
    p(ae);
    const Ue = ae.currentPeek() === r2;
    return ae.resetPeek(), Ue;
  }
  function S(ae, pe) {
    const { currentType: ke } = pe;
    if (ke !== 8)
      return !1;
    p(ae);
    const Ue = ae.currentPeek() === ".";
    return ae.resetPeek(), Ue;
  }
  function _(ae, pe) {
    const { currentType: ke } = pe;
    if (ke !== 9)
      return !1;
    p(ae);
    const Ue = g(ae.currentPeek());
    return ae.resetPeek(), Ue;
  }
  function k(ae, pe) {
    const { currentType: ke } = pe;
    if (!(ke === 8 || ke === 12))
      return !1;
    p(ae);
    const Ue = ae.currentPeek() === ":";
    return ae.resetPeek(), Ue;
  }
  function N(ae, pe) {
    const { currentType: ke } = pe;
    if (ke !== 10)
      return !1;
    const Ue = () => {
      const re = ae.currentPeek();
      return re === "{" ? g(ae.peek()) : re === "@" || re === "%" || re === "|" || re === ":" || re === "." || re === xr || !re ? !1 : re === wl ? (ae.peek(), Ue()) : H(ae, !1);
    }, Xe = Ue();
    return ae.resetPeek(), Xe;
  }
  function L(ae) {
    p(ae);
    const pe = ae.currentPeek() === "|";
    return ae.resetPeek(), pe;
  }
  function R(ae) {
    const pe = p(ae), ke = ae.currentPeek() === "%" && ae.peek() === "{";
    return ae.resetPeek(), {
      isModulo: ke,
      hasSpace: pe.length > 0
    };
  }
  function H(ae, pe = !0) {
    const ke = (Xe = !1, re = "", Te = !1) => {
      const Ce = ae.currentPeek();
      return Ce === "{" ? re === "%" ? !1 : Xe : Ce === "@" || !Ce ? re === "%" ? !0 : Xe : Ce === "%" ? (ae.peek(), ke(Xe, "%", !0)) : Ce === "|" ? re === "%" || Te ? !0 : !(re === xr || re === wl) : Ce === xr ? (ae.peek(), ke(!0, xr, Te)) : Ce === wl ? (ae.peek(), ke(!0, wl, Te)) : !0;
    }, Ue = ke();
    return pe && ae.resetPeek(), Ue;
  }
  function K(ae, pe) {
    const ke = ae.currentChar();
    return ke === is ? is : pe(ke) ? (ae.next(), ke) : null;
  }
  function U(ae) {
    const pe = ae.charCodeAt(0);
    return pe >= 97 && pe <= 122 || // a-z
    pe >= 65 && pe <= 90 || // A-Z
    pe >= 48 && pe <= 57 || // 0-9
    pe === 95 || // _
    pe === 36;
  }
  function W(ae) {
    return K(ae, U);
  }
  function A(ae) {
    const pe = ae.charCodeAt(0);
    return pe >= 97 && pe <= 122 || // a-z
    pe >= 65 && pe <= 90 || // A-Z
    pe >= 48 && pe <= 57 || // 0-9
    pe === 95 || // _
    pe === 36 || // $
    pe === 45;
  }
  function $(ae) {
    return K(ae, A);
  }
  function D(ae) {
    const pe = ae.charCodeAt(0);
    return pe >= 48 && pe <= 57;
  }
  function O(ae) {
    return K(ae, D);
  }
  function F(ae) {
    const pe = ae.charCodeAt(0);
    return pe >= 48 && pe <= 57 || // 0-9
    pe >= 65 && pe <= 70 || // A-F
    pe >= 97 && pe <= 102;
  }
  function j(ae) {
    return K(ae, F);
  }
  function Z(ae) {
    let pe = "", ke = "";
    for (; pe = O(ae); )
      ke += pe;
    return ke;
  }
  function te(ae) {
    C(ae);
    const pe = ae.currentChar();
    return pe !== "%" && f(gn.EXPECTED_TOKEN, a(), 0, pe), ae.next(), "%";
  }
  function de(ae) {
    let pe = "";
    for (; ; ) {
      const ke = ae.currentChar();
      if (ke === "{" || ke === "}" || ke === "@" || ke === "|" || !ke)
        break;
      if (ke === "%")
        if (H(ae))
          pe += ke, ae.next();
        else
          break;
      else if (ke === xr || ke === wl)
        if (H(ae))
          pe += ke, ae.next();
        else {
          if (L(ae))
            break;
          pe += ke, ae.next();
        }
      else
        pe += ke, ae.next();
    }
    return pe;
  }
  function Oe(ae) {
    C(ae);
    let pe = "", ke = "";
    for (; pe = $(ae); )
      ke += pe;
    return ae.currentChar() === is && f(gn.UNTERMINATED_CLOSING_BRACE, a(), 0), ke;
  }
  function ce(ae) {
    C(ae);
    let pe = "";
    return ae.currentChar() === "-" ? (ae.next(), pe += `-${Z(ae)}`) : pe += Z(ae), ae.currentChar() === is && f(gn.UNTERMINATED_CLOSING_BRACE, a(), 0), pe;
  }
  function ne(ae) {
    return ae !== r2 && ae !== wl;
  }
  function Y(ae) {
    C(ae), m(ae, "'");
    let pe = "", ke = "";
    for (; pe = K(ae, ne); )
      pe === "\\" ? ke += ve(ae) : ke += pe;
    const Ue = ae.currentChar();
    return Ue === wl || Ue === is ? (f(gn.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, a(), 0), Ue === wl && (ae.next(), m(ae, "'")), ke) : (m(ae, "'"), ke);
  }
  function ve(ae) {
    const pe = ae.currentChar();
    switch (pe) {
      case "\\":
      case "'":
        return ae.next(), `\\${pe}`;
      case "u":
        return ie(ae, pe, 4);
      case "U":
        return ie(ae, pe, 6);
      default:
        return f(gn.UNKNOWN_ESCAPE_SEQUENCE, a(), 0, pe), "";
    }
  }
  function ie(ae, pe, ke) {
    m(ae, pe);
    let Ue = "";
    for (let Xe = 0; Xe < ke; Xe++) {
      const re = j(ae);
      if (!re) {
        f(gn.INVALID_UNICODE_ESCAPE_SEQUENCE, a(), 0, `\\${pe}${Ue}${ae.currentChar()}`);
        break;
      }
      Ue += re;
    }
    return `\\${pe}${Ue}`;
  }
  function he(ae) {
    return ae !== "{" && ae !== "}" && ae !== xr && ae !== wl;
  }
  function De(ae) {
    C(ae);
    let pe = "", ke = "";
    for (; pe = K(ae, he); )
      ke += pe;
    return ke;
  }
  function $e(ae) {
    let pe = "", ke = "";
    for (; pe = W(ae); )
      ke += pe;
    return ke;
  }
  function ue(ae) {
    const pe = (ke) => {
      const Ue = ae.currentChar();
      return Ue === "{" || Ue === "%" || Ue === "@" || Ue === "|" || Ue === "(" || Ue === ")" || !Ue || Ue === xr ? ke : (ke += Ue, ae.next(), pe(ke));
    };
    return pe("");
  }
  function Ne(ae) {
    C(ae);
    const pe = m(
      ae,
      "|"
      /* TokenChars.Pipe */
    );
    return C(ae), pe;
  }
  function je(ae, pe) {
    let ke = null;
    switch (ae.currentChar()) {
      case "{":
        return pe.braceNest >= 1 && f(gn.NOT_ALLOW_NEST_PLACEHOLDER, a(), 0), ae.next(), ke = v(
          pe,
          2,
          "{"
          /* TokenChars.BraceLeft */
        ), C(ae), pe.braceNest++, ke;
      case "}":
        return pe.braceNest > 0 && pe.currentType === 2 && f(gn.EMPTY_PLACEHOLDER, a(), 0), ae.next(), ke = v(
          pe,
          3,
          "}"
          /* TokenChars.BraceRight */
        ), pe.braceNest--, pe.braceNest > 0 && C(ae), pe.inLinked && pe.braceNest === 0 && (pe.inLinked = !1), ke;
      case "@":
        return pe.braceNest > 0 && f(gn.UNTERMINATED_CLOSING_BRACE, a(), 0), ke = Fe(ae, pe) || h(pe), pe.braceNest = 0, ke;
      default: {
        let Xe = !0, re = !0, Te = !0;
        if (L(ae))
          return pe.braceNest > 0 && f(gn.UNTERMINATED_CLOSING_BRACE, a(), 0), ke = v(pe, 1, Ne(ae)), pe.braceNest = 0, pe.inLinked = !1, ke;
        if (pe.braceNest > 0 && (pe.currentType === 5 || pe.currentType === 6 || pe.currentType === 7))
          return f(gn.UNTERMINATED_CLOSING_BRACE, a(), 0), pe.braceNest = 0, Ve(ae, pe);
        if (Xe = b(ae, pe))
          return ke = v(pe, 5, Oe(ae)), C(ae), ke;
        if (re = y(ae, pe))
          return ke = v(pe, 6, ce(ae)), C(ae), ke;
        if (Te = E(ae, pe))
          return ke = v(pe, 7, Y(ae)), C(ae), ke;
        if (!Xe && !re && !Te)
          return ke = v(pe, 13, De(ae)), f(gn.INVALID_TOKEN_IN_PLACEHOLDER, a(), 0, ke.value), C(ae), ke;
        break;
      }
    }
    return ke;
  }
  function Fe(ae, pe) {
    const { currentType: ke } = pe;
    let Ue = null;
    const Xe = ae.currentChar();
    switch ((ke === 8 || ke === 9 || ke === 12 || ke === 10) && (Xe === wl || Xe === xr) && f(gn.INVALID_LINKED_FORMAT, a(), 0), Xe) {
      case "@":
        return ae.next(), Ue = v(
          pe,
          8,
          "@"
          /* TokenChars.LinkedAlias */
        ), pe.inLinked = !0, Ue;
      case ".":
        return C(ae), ae.next(), v(
          pe,
          9,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        return C(ae), ae.next(), v(
          pe,
          10,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        return L(ae) ? (Ue = v(pe, 1, Ne(ae)), pe.braceNest = 0, pe.inLinked = !1, Ue) : S(ae, pe) || k(ae, pe) ? (C(ae), Fe(ae, pe)) : _(ae, pe) ? (C(ae), v(pe, 12, $e(ae))) : N(ae, pe) ? (C(ae), Xe === "{" ? je(ae, pe) || Ue : v(pe, 11, ue(ae))) : (ke === 8 && f(gn.INVALID_LINKED_FORMAT, a(), 0), pe.braceNest = 0, pe.inLinked = !1, Ve(ae, pe));
    }
  }
  function Ve(ae, pe) {
    let ke = {
      type: 14
      /* TokenTypes.EOF */
    };
    if (pe.braceNest > 0)
      return je(ae, pe) || h(pe);
    if (pe.inLinked)
      return Fe(ae, pe) || h(pe);
    switch (ae.currentChar()) {
      case "{":
        return je(ae, pe) || h(pe);
      case "}":
        return f(gn.UNBALANCED_CLOSING_BRACE, a(), 0), ae.next(), v(
          pe,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return Fe(ae, pe) || h(pe);
      default: {
        if (L(ae))
          return ke = v(pe, 1, Ne(ae)), pe.braceNest = 0, pe.inLinked = !1, ke;
        const { isModulo: Xe, hasSpace: re } = R(ae);
        if (Xe)
          return re ? v(pe, 0, de(ae)) : v(pe, 4, te(ae));
        if (H(ae))
          return v(pe, 0, de(ae));
        break;
      }
    }
    return ke;
  }
  function Ze() {
    const { currentType: ae, offset: pe, startLoc: ke, endLoc: Ue } = s;
    return s.lastType = ae, s.lastOffset = pe, s.lastStartLoc = ke, s.lastEndLoc = Ue, s.offset = l(), s.startLoc = a(), o.currentChar() === is ? v(
      s,
      14
      /* TokenTypes.EOF */
    ) : Ve(o, s);
  }
  return {
    nextToken: Ze,
    currentOffset: l,
    currentPosition: a,
    context: u
  };
}
const gSe = "parser", bSe = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function ySe(e, t, n) {
  switch (e) {
    case "\\\\":
      return "\\";
    case "\\'":
      return "'";
    default: {
      const o = parseInt(t || n, 16);
      return o <= 55295 || o >= 57344 ? String.fromCodePoint(o) : "�";
    }
  }
}
function CSe(e = {}) {
  const t = e.location !== !1, { onError: n, onWarn: o } = e;
  function l(b, y, E, S, ..._) {
    const k = b.currentPosition();
    if (k.offset += S, k.column += S, n) {
      const N = t ? Cv(E, k) : null, L = mu(y, N, {
        domain: gSe,
        args: _
      });
      n(L);
    }
  }
  function a(b, y, E, S, ..._) {
    const k = b.currentPosition();
    if (k.offset += S, k.column += S, o) {
      const N = t ? Cv(E, k) : null;
      o(aSe(y, N, _));
    }
  }
  function r(b, y, E) {
    const S = { type: b };
    return t && (S.start = y, S.end = y, S.loc = { start: E, end: E }), S;
  }
  function i(b, y, E, S) {
    S && (b.type = S), t && (b.end = y, b.loc && (b.loc.end = E));
  }
  function s(b, y) {
    const E = b.context(), S = r(3, E.offset, E.startLoc);
    return S.value = y, i(S, b.currentOffset(), b.currentPosition()), S;
  }
  function u(b, y) {
    const E = b.context(), { lastOffset: S, lastStartLoc: _ } = E, k = r(5, S, _);
    return k.index = parseInt(y, 10), b.nextToken(), i(k, b.currentOffset(), b.currentPosition()), k;
  }
  function d(b, y, E) {
    const S = b.context(), { lastOffset: _, lastStartLoc: k } = S, N = r(4, _, k);
    return N.key = y, E === !0 && (N.modulo = !0), b.nextToken(), i(N, b.currentOffset(), b.currentPosition()), N;
  }
  function f(b, y) {
    const E = b.context(), { lastOffset: S, lastStartLoc: _ } = E, k = r(9, S, _);
    return k.value = y.replace(bSe, ySe), b.nextToken(), i(k, b.currentOffset(), b.currentPosition()), k;
  }
  function v(b) {
    const y = b.nextToken(), E = b.context(), { lastOffset: S, lastStartLoc: _ } = E, k = r(8, S, _);
    return y.type !== 12 ? (l(b, gn.UNEXPECTED_EMPTY_LINKED_MODIFIER, E.lastStartLoc, 0), k.value = "", i(k, S, _), {
      nextConsumeToken: y,
      node: k
    }) : (y.value == null && l(b, gn.UNEXPECTED_LEXICAL_ANALYSIS, E.lastStartLoc, 0, Ra(y)), k.value = y.value || "", i(k, b.currentOffset(), b.currentPosition()), {
      node: k
    });
  }
  function h(b, y) {
    const E = b.context(), S = r(7, E.offset, E.startLoc);
    return S.value = y, i(S, b.currentOffset(), b.currentPosition()), S;
  }
  function m(b) {
    const y = b.context(), E = r(6, y.offset, y.startLoc);
    let S = b.nextToken();
    if (S.type === 9) {
      const _ = v(b);
      E.modifier = _.node, S = _.nextConsumeToken || b.nextToken();
    }
    switch (S.type !== 10 && l(b, gn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Ra(S)), S = b.nextToken(), S.type === 2 && (S = b.nextToken()), S.type) {
      case 11:
        S.value == null && l(b, gn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Ra(S)), E.key = h(b, S.value || "");
        break;
      case 5:
        S.value == null && l(b, gn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Ra(S)), E.key = d(b, S.value || "");
        break;
      case 6:
        S.value == null && l(b, gn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Ra(S)), E.key = u(b, S.value || "");
        break;
      case 7:
        S.value == null && l(b, gn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Ra(S)), E.key = f(b, S.value || "");
        break;
      default: {
        l(b, gn.UNEXPECTED_EMPTY_LINKED_KEY, y.lastStartLoc, 0);
        const _ = b.context(), k = r(7, _.offset, _.startLoc);
        return k.value = "", i(k, _.offset, _.startLoc), E.key = k, i(E, _.offset, _.startLoc), {
          nextConsumeToken: S,
          node: E
        };
      }
    }
    return i(E, b.currentOffset(), b.currentPosition()), {
      node: E
    };
  }
  function p(b) {
    const y = b.context(), E = y.currentType === 1 ? b.currentOffset() : y.offset, S = y.currentType === 1 ? y.endLoc : y.startLoc, _ = r(2, E, S);
    _.items = [];
    let k = null, N = null;
    do {
      const H = k || b.nextToken();
      switch (k = null, H.type) {
        case 0:
          H.value == null && l(b, gn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Ra(H)), _.items.push(s(b, H.value || ""));
          break;
        case 6:
          H.value == null && l(b, gn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Ra(H)), _.items.push(u(b, H.value || ""));
          break;
        case 4:
          N = !0;
          break;
        case 5:
          H.value == null && l(b, gn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Ra(H)), _.items.push(d(b, H.value || "", !!N)), N && (a(b, bh.USE_MODULO_SYNTAX, y.lastStartLoc, 0, Ra(H)), N = null);
          break;
        case 7:
          H.value == null && l(b, gn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Ra(H)), _.items.push(f(b, H.value || ""));
          break;
        case 8: {
          const K = m(b);
          _.items.push(K.node), k = K.nextConsumeToken || null;
          break;
        }
      }
    } while (y.currentType !== 14 && y.currentType !== 1);
    const L = y.currentType === 1 ? y.lastOffset : b.currentOffset(), R = y.currentType === 1 ? y.lastEndLoc : b.currentPosition();
    return i(_, L, R), _;
  }
  function C(b, y, E, S) {
    const _ = b.context();
    let k = S.items.length === 0;
    const N = r(1, y, E);
    N.cases = [], N.cases.push(S);
    do {
      const L = p(b);
      k || (k = L.items.length === 0), N.cases.push(L);
    } while (_.currentType !== 14);
    return k && l(b, gn.MUST_HAVE_MESSAGES_IN_PLURAL, E, 0), i(N, b.currentOffset(), b.currentPosition()), N;
  }
  function g(b) {
    const y = b.context(), { offset: E, startLoc: S } = y, _ = p(b);
    return y.currentType === 14 ? _ : C(b, E, S, _);
  }
  function w(b) {
    const y = mSe(b, ER({}, e)), E = y.context(), S = r(0, E.offset, E.startLoc);
    return t && S.loc && (S.loc.source = b), S.body = g(y), e.onCacheKey && (S.cacheKey = e.onCacheKey(b)), E.currentType !== 14 && l(y, gn.UNEXPECTED_LEXICAL_ANALYSIS, E.lastStartLoc, 0, b[E.offset] || ""), i(S, y.currentOffset(), y.currentPosition()), S;
  }
  return { parse: w };
}
function Ra(e) {
  if (e.type === 14)
    return "EOF";
  const t = (e.value || "").replace(/\r?\n/gu, "\\n");
  return t.length > 10 ? t.slice(0, 9) + "…" : t;
}
function wSe(e, t = {}) {
  const n = {
    ast: e,
    helpers: /* @__PURE__ */ new Set()
  };
  return { context: () => n, helper: (a) => (n.helpers.add(a), a) };
}
function s2(e, t) {
  for (let n = 0; n < e.length; n++)
    H1(e[n], t);
}
function H1(e, t) {
  switch (e.type) {
    case 1:
      s2(e.cases, t), t.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      s2(e.items, t);
      break;
    case 6: {
      H1(e.key, t), t.helper(
        "linked"
        /* HelperNameMap.LINKED */
      ), t.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      t.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), t.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      t.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), t.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function ESe(e, t = {}) {
  const n = wSe(e);
  n.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  ), e.body && H1(e.body, n);
  const o = n.context();
  e.helpers = Array.from(o.helpers);
}
function SSe(e) {
  const t = e.body;
  return t.type === 2 ? i2(t) : t.cases.forEach((n) => i2(n)), e;
}
function i2(e) {
  if (e.items.length === 1) {
    const t = e.items[0];
    (t.type === 3 || t.type === 9) && (e.static = t.value, delete t.value);
  } else {
    const t = [];
    for (let n = 0; n < e.items.length; n++) {
      const o = e.items[n];
      if (!(o.type === 3 || o.type === 9) || o.value == null)
        break;
      t.push(o.value);
    }
    if (t.length === e.items.length) {
      e.static = SR(t);
      for (let n = 0; n < e.items.length; n++) {
        const o = e.items[n];
        (o.type === 3 || o.type === 9) && delete o.value;
      }
    }
  }
}
const _Se = "minifier";
function mc(e) {
  switch (e.t = e.type, e.type) {
    case 0: {
      const t = e;
      mc(t.body), t.b = t.body, delete t.body;
      break;
    }
    case 1: {
      const t = e, n = t.cases;
      for (let o = 0; o < n.length; o++)
        mc(n[o]);
      t.c = n, delete t.cases;
      break;
    }
    case 2: {
      const t = e, n = t.items;
      for (let o = 0; o < n.length; o++)
        mc(n[o]);
      t.i = n, delete t.items, t.static && (t.s = t.static, delete t.static);
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const t = e;
      t.value && (t.v = t.value, delete t.value);
      break;
    }
    case 6: {
      const t = e;
      mc(t.key), t.k = t.key, delete t.key, t.modifier && (mc(t.modifier), t.m = t.modifier, delete t.modifier);
      break;
    }
    case 5: {
      const t = e;
      t.i = t.index, delete t.index;
      break;
    }
    case 4: {
      const t = e;
      t.k = t.key, delete t.key;
      break;
    }
    default:
      throw mu(gn.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: _Se,
        args: [e.type]
      });
  }
  delete e.type;
}
const xSe = "parser";
function kSe(e, t) {
  const { sourceMap: n, filename: o, breakLineCode: l, needIndent: a } = t, r = t.location !== !1, i = {
    filename: o,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode: l,
    needIndent: a,
    indentLevel: 0
  };
  r && e.loc && (i.source = e.loc.source);
  const s = () => i;
  function u(C, g) {
    i.code += C;
  }
  function d(C, g = !0) {
    const w = g ? l : "";
    u(a ? w + "  ".repeat(C) : w);
  }
  function f(C = !0) {
    const g = ++i.indentLevel;
    C && d(g);
  }
  function v(C = !0) {
    const g = --i.indentLevel;
    C && d(g);
  }
  function h() {
    d(i.indentLevel);
  }
  return {
    context: s,
    push: u,
    indent: f,
    deindent: v,
    newline: h,
    helper: (C) => `_${C}`,
    needIndent: () => i.needIndent
  };
}
function TSe(e, t) {
  const { helper: n } = e;
  e.push(`${n(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`), Qc(e, t.key), t.modifier ? (e.push(", "), Qc(e, t.modifier), e.push(", _type")) : e.push(", undefined, _type"), e.push(")");
}
function $Se(e, t) {
  const { helper: n, needIndent: o } = e;
  e.push(`${n(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`), e.indent(o());
  const l = t.items.length;
  for (let a = 0; a < l && (Qc(e, t.items[a]), a !== l - 1); a++)
    e.push(", ");
  e.deindent(o()), e.push("])");
}
function OSe(e, t) {
  const { helper: n, needIndent: o } = e;
  if (t.cases.length > 1) {
    e.push(`${n(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`), e.indent(o());
    const l = t.cases.length;
    for (let a = 0; a < l && (Qc(e, t.cases[a]), a !== l - 1); a++)
      e.push(", ");
    e.deindent(o()), e.push("])");
  }
}
function NSe(e, t) {
  t.body ? Qc(e, t.body) : e.push("null");
}
function Qc(e, t) {
  const { helper: n } = e;
  switch (t.type) {
    case 0:
      NSe(e, t);
      break;
    case 1:
      OSe(e, t);
      break;
    case 2:
      $Se(e, t);
      break;
    case 6:
      TSe(e, t);
      break;
    case 8:
      e.push(JSON.stringify(t.value), t);
      break;
    case 7:
      e.push(JSON.stringify(t.value), t);
      break;
    case 5:
      e.push(`${n(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${n(
        "list"
        /* HelperNameMap.LIST */
      )}(${t.index}))`, t);
      break;
    case 4:
      e.push(`${n(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${n(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(t.key)}))`, t);
      break;
    case 9:
      e.push(JSON.stringify(t.value), t);
      break;
    case 3:
      e.push(JSON.stringify(t.value), t);
      break;
    default:
      throw mu(gn.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: xSe,
        args: [t.type]
      });
  }
}
const MSe = (e, t = {}) => {
  const n = a2(t.mode) ? t.mode : "normal", o = a2(t.filename) ? t.filename : "message.intl", l = !!t.sourceMap, a = t.breakLineCode != null ? t.breakLineCode : n === "arrow" ? ";" : `
`, r = t.needIndent ? t.needIndent : n !== "arrow", i = e.helpers || [], s = kSe(e, {
    mode: n,
    filename: o,
    sourceMap: l,
    breakLineCode: a,
    needIndent: r
  });
  s.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), s.indent(r), i.length > 0 && (s.push(`const { ${SR(i.map((f) => `${f}: _${f}`), ", ")} } = ctx`), s.newline()), s.push("return "), Qc(s, e), s.deindent(r), s.push("}"), delete e.helpers;
  const { code: u, map: d } = s.context();
  return {
    ast: e,
    code: u,
    map: d ? d.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function ISe(e, t = {}) {
  const n = ER({}, t), o = !!n.jit, l = !!n.minify, a = n.optimize == null ? !0 : n.optimize, i = CSe(n).parse(e);
  return o ? (a && SSe(i), l && mc(i), { ast: i, code: "" }) : (ESe(i, n), MSe(i, n));
}
/*!
  * core-base v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function RSe() {
  typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Nr().__INTLIFY_PROD_DEVTOOLS__ = !1), typeof __INTLIFY_JIT_COMPILATION__ != "boolean" && (Nr().__INTLIFY_JIT_COMPILATION__ = !1), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Nr().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1);
}
const Hs = [];
Hs[
  0
  /* States.BEFORE_PATH */
] = {
  w: [
    0
    /* States.BEFORE_PATH */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
Hs[
  1
  /* States.IN_PATH */
] = {
  w: [
    1
    /* States.IN_PATH */
  ],
  ".": [
    2
    /* States.BEFORE_IDENT */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
Hs[
  2
  /* States.BEFORE_IDENT */
] = {
  w: [
    2
    /* States.BEFORE_IDENT */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ]
};
Hs[
  3
  /* States.IN_IDENT */
] = {
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ],
  w: [
    1,
    1
    /* Actions.PUSH */
  ],
  ".": [
    2,
    1
    /* Actions.PUSH */
  ],
  "[": [
    4,
    1
    /* Actions.PUSH */
  ],
  o: [
    7,
    1
    /* Actions.PUSH */
  ]
};
Hs[
  4
  /* States.IN_SUB_PATH */
] = {
  "'": [
    5,
    0
    /* Actions.APPEND */
  ],
  '"': [
    6,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  "]": [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  o: 8,
  l: [
    4,
    0
    /* Actions.APPEND */
  ]
};
Hs[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  "'": [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    5,
    0
    /* Actions.APPEND */
  ]
};
Hs[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  '"': [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const DSe = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function LSe(e) {
  return DSe.test(e);
}
function PSe(e) {
  const t = e.charCodeAt(0), n = e.charCodeAt(e.length - 1);
  return t === n && (t === 34 || t === 39) ? e.slice(1, -1) : e;
}
function ASe(e) {
  if (e == null)
    return "o";
  switch (e.charCodeAt(0)) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return e;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function FSe(e) {
  const t = e.trim();
  return e.charAt(0) === "0" && isNaN(parseInt(e)) ? !1 : LSe(t) ? PSe(t) : "*" + t;
}
function VSe(e) {
  const t = [];
  let n = -1, o = 0, l = 0, a, r, i, s, u, d, f;
  const v = [];
  v[
    0
    /* Actions.APPEND */
  ] = () => {
    r === void 0 ? r = i : r += i;
  }, v[
    1
    /* Actions.PUSH */
  ] = () => {
    r !== void 0 && (t.push(r), r = void 0);
  }, v[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    v[
      0
      /* Actions.APPEND */
    ](), l++;
  }, v[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (l > 0)
      l--, o = 4, v[
        0
        /* Actions.APPEND */
      ]();
    else {
      if (l = 0, r === void 0 || (r = FSe(r), r === !1))
        return !1;
      v[
        1
        /* Actions.PUSH */
      ]();
    }
  };
  function h() {
    const m = e[n + 1];
    if (o === 5 && m === "'" || o === 6 && m === '"')
      return n++, i = "\\" + m, v[
        0
        /* Actions.APPEND */
      ](), !0;
  }
  for (; o !== null; )
    if (n++, a = e[n], !(a === "\\" && h())) {
      if (s = ASe(a), f = Hs[o], u = f[s] || f.l || 8, u === 8 || (o = u[0], u[1] !== void 0 && (d = v[u[1]], d && (i = a, d() === !1))))
        return;
      if (o === 7)
        return t;
    }
}
const c2 = /* @__PURE__ */ new Map();
function BSe(e, t) {
  return Kn(e) ? e[t] : null;
}
function HSe(e, t) {
  if (!Kn(e))
    return null;
  let n = c2.get(t);
  if (n || (n = VSe(t), n && c2.set(t, n)), !n)
    return null;
  const o = n.length;
  let l = e, a = 0;
  for (; a < o; ) {
    const r = l[n[a]];
    if (r === void 0 || Gn(l))
      return null;
    l = r, a++;
  }
  return l;
}
const zSe = (e) => e, WSe = (e) => "", KSe = "text", USe = (e) => e.length === 0 ? "" : QEe(e), jSe = JEe;
function u2(e, t) {
  return e = Math.abs(e), t === 2 ? e ? e > 1 ? 1 : 0 : 1 : e ? Math.min(e, 2) : 0;
}
function qSe(e) {
  const t = Vo(e.pluralIndex) ? e.pluralIndex : -1;
  return e.named && (Vo(e.named.count) || Vo(e.named.n)) ? Vo(e.named.count) ? e.named.count : Vo(e.named.n) ? e.named.n : t : t;
}
function YSe(e, t) {
  t.count || (t.count = e), t.n || (t.n = e);
}
function GSe(e = {}) {
  const t = e.locale, n = qSe(e), o = Kn(e.pluralRules) && Vt(t) && Gn(e.pluralRules[t]) ? e.pluralRules[t] : u2, l = Kn(e.pluralRules) && Vt(t) && Gn(e.pluralRules[t]) ? u2 : void 0, a = (g) => g[o(n, g.length, l)], r = e.list || [], i = (g) => r[g], s = e.named || {};
  Vo(e.pluralIndex) && YSe(n, s);
  const u = (g) => s[g];
  function d(g) {
    const w = Gn(e.messages) ? e.messages(g) : Kn(e.messages) ? e.messages[g] : !1;
    return w || (e.parent ? e.parent.message(g) : WSe);
  }
  const f = (g) => e.modifiers ? e.modifiers[g] : zSe, v = En(e.processor) && Gn(e.processor.normalize) ? e.processor.normalize : USe, h = En(e.processor) && Gn(e.processor.interpolate) ? e.processor.interpolate : jSe, m = En(e.processor) && Vt(e.processor.type) ? e.processor.type : KSe, C = {
    list: i,
    named: u,
    plural: a,
    linked: (g, ...w) => {
      const [b, y] = w;
      let E = "text", S = "";
      w.length === 1 ? Kn(b) ? (S = b.modifier || S, E = b.type || E) : Vt(b) && (S = b || S) : w.length === 2 && (Vt(b) && (S = b || S), Vt(y) && (E = y || E));
      const _ = d(g)(C), k = (
        // The message in vnode resolved with linked are returned as an array by processor.nomalize
        E === "vnode" && fo(_) && S ? _[0] : _
      );
      return S ? f(S)(k, E) : k;
    },
    message: d,
    type: m,
    interpolate: h,
    normalize: v,
    values: al({}, r, s)
  };
  return C;
}
let Gd = null;
function XSe(e) {
  Gd = e;
}
function ZSe(e, t, n) {
  Gd && Gd.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: e,
    version: t,
    meta: n
  });
}
const JSe = /* @__PURE__ */ QSe(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function QSe(e) {
  return (t) => Gd && Gd.emit(e, t);
}
const _R = bh.__EXTEND_POINT__, Js = gh(_R), _l = {
  NOT_FOUND_KEY: _R,
  // 2
  FALLBACK_TO_TRANSLATE: Js(),
  // 3
  CANNOT_FORMAT_NUMBER: Js(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: Js(),
  // 5
  CANNOT_FORMAT_DATE: Js(),
  // 6
  FALLBACK_TO_DATE_FORMAT: Js(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: Js(),
  // 8
  __EXTEND_POINT__: Js()
  // 9
}, e_e = {
  [_l.NOT_FOUND_KEY]: "Not found '{key}' key in '{locale}' locale messages.",
  [_l.FALLBACK_TO_TRANSLATE]: "Fall back to translate '{key}' key with '{target}' locale.",
  [_l.CANNOT_FORMAT_NUMBER]: "Cannot format a number value due to not supported Intl.NumberFormat.",
  [_l.FALLBACK_TO_NUMBER_FORMAT]: "Fall back to number format '{key}' key with '{target}' locale.",
  [_l.CANNOT_FORMAT_DATE]: "Cannot format a date value due to not supported Intl.DateTimeFormat.",
  [_l.FALLBACK_TO_DATE_FORMAT]: "Fall back to datetime format '{key}' key with '{target}' locale.",
  [_l.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]: "This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future."
};
function Di(e, ...t) {
  return V1(e_e[e], ...t);
}
const xR = gn.__EXTEND_POINT__, Qs = gh(xR), Go = {
  INVALID_ARGUMENT: xR,
  // 17
  INVALID_DATE_ARGUMENT: Qs(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: Qs(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: Qs(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: Qs(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: Qs(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: Qs(),
  // 23
  __EXTEND_POINT__: Qs()
  // 24
};
function nr(e) {
  return mu(e, null, process.env.NODE_ENV !== "production" ? { messages: t_e } : void 0);
}
const t_e = {
  [Go.INVALID_ARGUMENT]: "Invalid arguments",
  [Go.INVALID_DATE_ARGUMENT]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
  [Go.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string",
  [Go.NOT_SUPPORT_NON_STRING_MESSAGE]: "Not support non-string message",
  [Go.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: "cannot support promise value",
  [Go.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: "cannot support async function",
  [Go.NOT_SUPPORT_LOCALE_TYPE]: "cannot support locale type"
};
function z1(e, t) {
  return t.locale != null ? d2(t.locale) : d2(e.locale);
}
let Ym;
function d2(e) {
  if (Vt(e))
    return e;
  if (Gn(e)) {
    if (e.resolvedOnce && Ym != null)
      return Ym;
    if (e.constructor.name === "Function") {
      const t = e();
      if (ZEe(t))
        throw nr(Go.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
      return Ym = t;
    } else
      throw nr(Go.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
  } else
    throw nr(Go.NOT_SUPPORT_LOCALE_TYPE);
}
function n_e(e, t, n) {
  return [.../* @__PURE__ */ new Set([
    n,
    ...fo(t) ? t : Kn(t) ? Object.keys(t) : Vt(t) ? [t] : [n]
  ])];
}
function kR(e, t, n) {
  const o = Vt(n) ? n : eu, l = e;
  l.__localeChainCache || (l.__localeChainCache = /* @__PURE__ */ new Map());
  let a = l.__localeChainCache.get(o);
  if (!a) {
    a = [];
    let r = [n];
    for (; fo(r); )
      r = f2(a, r, t);
    const i = fo(t) || !En(t) ? t : t.default ? t.default : null;
    r = Vt(i) ? [i] : i, fo(r) && f2(a, r, !1), l.__localeChainCache.set(o, a);
  }
  return a;
}
function f2(e, t, n) {
  let o = !0;
  for (let l = 0; l < t.length && Nn(o); l++) {
    const a = t[l];
    Vt(a) && (o = o_e(e, t[l], n));
  }
  return o;
}
function o_e(e, t, n) {
  let o;
  const l = t.split("-");
  do {
    const a = l.join("-");
    o = l_e(e, a, n), l.splice(-1, 1);
  } while (l.length && o === !0);
  return o;
}
function l_e(e, t, n) {
  let o = !1;
  if (!e.includes(t) && (o = !0, t)) {
    o = t[t.length - 1] !== "!";
    const l = t.replace(/!/g, "");
    e.push(l), (fo(n) || En(n)) && n[l] && (o = n[l]);
  }
  return o;
}
const a_e = "9.13.1", yh = -1, eu = "en-US", wv = "", p2 = (e) => `${e.charAt(0).toLocaleUpperCase()}${e.substr(1)}`;
function r_e() {
  return {
    upper: (e, t) => t === "text" && Vt(e) ? e.toUpperCase() : t === "vnode" && Kn(e) && "__v_isVNode" in e ? e.children.toUpperCase() : e,
    lower: (e, t) => t === "text" && Vt(e) ? e.toLowerCase() : t === "vnode" && Kn(e) && "__v_isVNode" in e ? e.children.toLowerCase() : e,
    capitalize: (e, t) => t === "text" && Vt(e) ? p2(e) : t === "vnode" && Kn(e) && "__v_isVNode" in e ? p2(e.children) : e
  };
}
let TR;
function v2(e) {
  TR = e;
}
let $R;
function s_e(e) {
  $R = e;
}
let OR;
function i_e(e) {
  OR = e;
}
let NR = null;
const c_e = /* @__NO_SIDE_EFFECTS__ */ (e) => {
  NR = e;
}, u_e = /* @__NO_SIDE_EFFECTS__ */ () => NR;
let MR = null;
const h2 = (e) => {
  MR = e;
}, d_e = () => MR;
let m2 = 0;
function f_e(e = {}) {
  const t = Gn(e.onWarn) ? e.onWarn : Bo, n = Vt(e.version) ? e.version : a_e, o = Vt(e.locale) || Gn(e.locale) ? e.locale : eu, l = Gn(o) ? eu : o, a = fo(e.fallbackLocale) || En(e.fallbackLocale) || Vt(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : l, r = En(e.messages) ? e.messages : { [l]: {} }, i = En(e.datetimeFormats) ? e.datetimeFormats : { [l]: {} }, s = En(e.numberFormats) ? e.numberFormats : { [l]: {} }, u = al({}, e.modifiers || {}, r_e()), d = e.pluralRules || {}, f = Gn(e.missing) ? e.missing : null, v = Nn(e.missingWarn) || Is(e.missingWarn) ? e.missingWarn : !0, h = Nn(e.fallbackWarn) || Is(e.fallbackWarn) ? e.fallbackWarn : !0, m = !!e.fallbackFormat, p = !!e.unresolving, C = Gn(e.postTranslation) ? e.postTranslation : null, g = En(e.processor) ? e.processor : null, w = Nn(e.warnHtmlMessage) ? e.warnHtmlMessage : !0, b = !!e.escapeParameter, y = Gn(e.messageCompiler) ? e.messageCompiler : TR;
  process.env.NODE_ENV !== "production" && Gn(e.messageCompiler) && CR(Di(_l.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER));
  const E = Gn(e.messageResolver) ? e.messageResolver : $R || BSe, S = Gn(e.localeFallbacker) ? e.localeFallbacker : OR || n_e, _ = Kn(e.fallbackContext) ? e.fallbackContext : void 0, k = e, N = Kn(k.__datetimeFormatters) ? k.__datetimeFormatters : /* @__PURE__ */ new Map(), L = Kn(k.__numberFormatters) ? k.__numberFormatters : /* @__PURE__ */ new Map(), R = Kn(k.__meta) ? k.__meta : {};
  m2++;
  const H = {
    version: n,
    cid: m2,
    locale: o,
    fallbackLocale: a,
    messages: r,
    modifiers: u,
    pluralRules: d,
    missing: f,
    missingWarn: v,
    fallbackWarn: h,
    fallbackFormat: m,
    unresolving: p,
    postTranslation: C,
    processor: g,
    warnHtmlMessage: w,
    escapeParameter: b,
    messageCompiler: y,
    messageResolver: E,
    localeFallbacker: S,
    fallbackContext: _,
    onWarn: t,
    __meta: R
  };
  return H.datetimeFormats = i, H.numberFormats = s, H.__datetimeFormatters = N, H.__numberFormatters = L, process.env.NODE_ENV !== "production" && (H.__v_emitter = k.__v_emitter != null ? k.__v_emitter : void 0), (process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) && ZSe(H, n, R), H;
}
function Ch(e, t) {
  return e instanceof RegExp ? e.test(t) : e;
}
function IR(e, t) {
  return e instanceof RegExp ? e.test(t) : e;
}
function W1(e, t, n, o, l) {
  const { missing: a, onWarn: r } = e;
  if (process.env.NODE_ENV !== "production") {
    const i = e.__v_emitter;
    i && i.emit("missing", {
      locale: n,
      key: t,
      type: l,
      groupId: `${l}:${t}`
    });
  }
  if (a !== null) {
    const i = a(e, n, t, l);
    return Vt(i) ? i : t;
  } else
    return process.env.NODE_ENV !== "production" && IR(o, t) && r(Di(_l.NOT_FOUND_KEY, { key: t, locale: n })), t;
}
function Hu(e, t, n) {
  const o = e;
  o.__localeChainCache = /* @__PURE__ */ new Map(), e.localeFallbacker(e, n, t);
}
function RR(e, t) {
  return e === t ? !1 : e.split("-")[0] === t.split("-")[0];
}
function p_e(e, t) {
  const n = t.indexOf(e);
  if (n === -1)
    return !1;
  for (let o = n + 1; o < t.length; o++)
    if (RR(e, t[o]))
      return !0;
  return !1;
}
function Gm(e) {
  return (n) => v_e(n, e);
}
function v_e(e, t) {
  const n = t.b || t.body;
  if ((n.t || n.type) === 1) {
    const o = n, l = o.c || o.cases;
    return e.plural(l.reduce((a, r) => [
      ...a,
      g2(e, r)
    ], []));
  } else
    return g2(e, n);
}
function g2(e, t) {
  const n = t.s || t.static;
  if (n)
    return e.type === "text" ? n : e.normalize([n]);
  {
    const o = (t.i || t.items).reduce((l, a) => [...l, Sb(e, a)], []);
    return e.normalize(o);
  }
}
function Sb(e, t) {
  const n = t.t || t.type;
  switch (n) {
    case 3: {
      const o = t;
      return o.v || o.value;
    }
    case 9: {
      const o = t;
      return o.v || o.value;
    }
    case 4: {
      const o = t;
      return e.interpolate(e.named(o.k || o.key));
    }
    case 5: {
      const o = t;
      return e.interpolate(e.list(o.i != null ? o.i : o.index));
    }
    case 6: {
      const o = t, l = o.m || o.modifier;
      return e.linked(Sb(e, o.k || o.key), l ? Sb(e, l) : void 0, e.type);
    }
    case 7: {
      const o = t;
      return o.v || o.value;
    }
    case 8: {
      const o = t;
      return o.v || o.value;
    }
    default:
      throw new Error(`unhandled node type on format message part: ${n}`);
  }
}
const h_e = "Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.";
function DR(e, t) {
  t && cSe(e) && Bo(V1(h_e, { source: e }));
}
const LR = (e) => e;
let Ec = /* @__PURE__ */ Object.create(null);
function PR(e) {
  e.code === bh.USE_MODULO_SYNTAX && Bo(`The use of named interpolation with modulo syntax is deprecated. It will be removed in v10.
reference: https://vue-i18n.intlify.dev/guide/essentials/syntax#rails-i18n-format 
(message compiler warning message: ${e.message})`);
}
const Rs = (e) => Kn(e) && (e.t === 0 || e.type === 0) && ("b" in e || "body" in e);
function AR(e, t = {}) {
  let n = !1;
  const o = t.onError || sSe;
  return t.onError = (l) => {
    n = !0, o(l);
  }, { ...ISe(e, t), detectError: n };
}
const m_e = /* @__NO_SIDE_EFFECTS__ */ (e, t) => {
  if (!Vt(e))
    throw nr(Go.NOT_SUPPORT_NON_STRING_MESSAGE);
  process.env.NODE_ENV !== "production" && (t.onWarn = PR);
  {
    const n = Nn(t.warnHtmlMessage) ? t.warnHtmlMessage : !0;
    process.env.NODE_ENV !== "production" && DR(e, n);
    const l = (t.onCacheKey || LR)(e), a = Ec[l];
    if (a)
      return a;
    const { code: r, detectError: i } = AR(e, t), s = new Function(`return ${r}`)();
    return i ? s : Ec[l] = s;
  }
};
function g_e(e, t) {
  if (process.env.NODE_ENV !== "production" && (t.onWarn = PR), __INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && Vt(e)) {
    const n = Nn(t.warnHtmlMessage) ? t.warnHtmlMessage : !0;
    process.env.NODE_ENV !== "production" && DR(e, n);
    const l = (t.onCacheKey || LR)(e), a = Ec[l];
    if (a)
      return a;
    const { ast: r, detectError: i } = AR(e, {
      ...t,
      location: process.env.NODE_ENV !== "production",
      jit: !0
    }), s = Gm(r);
    return i ? s : Ec[l] = s;
  } else {
    if (process.env.NODE_ENV !== "production" && !Rs(e))
      return Bo(`the message that is resolve with key '${t.key}' is not supported for jit compilation`), () => e;
    const n = e.cacheKey;
    if (n) {
      const o = Ec[n];
      return o || (Ec[n] = Gm(e));
    } else
      return Gm(e);
  }
}
const b2 = () => "", va = (e) => Gn(e);
function y2(e, ...t) {
  const { fallbackFormat: n, postTranslation: o, unresolving: l, messageCompiler: a, fallbackLocale: r, messages: i } = e, [s, u] = _b(...t), d = Nn(u.missingWarn) ? u.missingWarn : e.missingWarn, f = Nn(u.fallbackWarn) ? u.fallbackWarn : e.fallbackWarn, v = Nn(u.escapeParameter) ? u.escapeParameter : e.escapeParameter, h = !!u.resolvedMessage, m = Vt(u.default) || Nn(u.default) ? Nn(u.default) ? a ? s : () => s : u.default : n ? a ? s : () => s : "", p = n || m !== "", C = z1(e, u);
  v && b_e(u);
  let [g, w, b] = h ? [
    s,
    C,
    i[C] || {}
  ] : FR(e, s, C, r, f, d), y = g, E = s;
  if (!h && !(Vt(y) || Rs(y) || va(y)) && p && (y = m, E = y), !h && (!(Vt(y) || Rs(y) || va(y)) || !Vt(w)))
    return l ? yh : s;
  if (process.env.NODE_ENV !== "production" && Vt(y) && e.messageCompiler == null)
    return Bo(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${s}'.`), s;
  let S = !1;
  const _ = () => {
    S = !0;
  }, k = va(y) ? y : VR(e, s, w, y, E, _);
  if (S)
    return y;
  const N = E_e(e, w, b, u), L = GSe(N), R = y_e(e, k, L), H = o ? o(R, s) : R;
  if (process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) {
    const K = {
      timestamp: Date.now(),
      key: Vt(s) ? s : va(y) ? y.key : "",
      locale: w || (va(y) ? y.locale : ""),
      format: Vt(y) ? y : va(y) ? y.source : "",
      message: H
    };
    K.meta = al({}, e.__meta, /* @__PURE__ */ u_e() || {}), JSe(K);
  }
  return H;
}
function b_e(e) {
  fo(e.list) ? e.list = e.list.map((t) => Vt(t) ? n2(t) : t) : Kn(e.named) && Object.keys(e.named).forEach((t) => {
    Vt(e.named[t]) && (e.named[t] = n2(e.named[t]));
  });
}
function FR(e, t, n, o, l, a) {
  const { messages: r, onWarn: i, messageResolver: s, localeFallbacker: u } = e, d = u(e, o, n);
  let f = {}, v, h = null, m = n, p = null;
  const C = "translate";
  for (let g = 0; g < d.length; g++) {
    if (v = p = d[g], process.env.NODE_ENV !== "production" && n !== v && !RR(n, v) && Ch(l, t) && i(Di(_l.FALLBACK_TO_TRANSLATE, {
      key: t,
      target: v
    })), process.env.NODE_ENV !== "production" && n !== v) {
      const E = e.__v_emitter;
      E && E.emit("fallback", {
        type: C,
        key: t,
        from: m,
        to: p,
        groupId: `${C}:${t}`
      });
    }
    f = r[v] || {};
    let w = null, b, y;
    if (process.env.NODE_ENV !== "production" && Va && (w = window.performance.now(), b = "intlify-message-resolve-start", y = "intlify-message-resolve-end", Ql && Ql(b)), (h = s(f, t)) === null && (h = f[t]), process.env.NODE_ENV !== "production" && Va) {
      const E = window.performance.now(), S = e.__v_emitter;
      S && w && h && S.emit("message-resolve", {
        type: "message-resolve",
        key: t,
        message: h,
        time: E - w,
        groupId: `${C}:${t}`
      }), b && y && Ql && Ri && (Ql(y), Ri("intlify message resolve", b, y));
    }
    if (Vt(h) || Rs(h) || va(h))
      break;
    if (!p_e(v, d)) {
      const E = W1(
        e,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        t,
        v,
        a,
        C
      );
      E !== t && (h = E);
    }
    m = p;
  }
  return [h, v, f];
}
function VR(e, t, n, o, l, a) {
  const { messageCompiler: r, warnHtmlMessage: i } = e;
  if (va(o)) {
    const v = o;
    return v.locale = v.locale || n, v.key = v.key || t, v;
  }
  if (r == null) {
    const v = () => o;
    return v.locale = n, v.key = t, v;
  }
  let s = null, u, d;
  process.env.NODE_ENV !== "production" && Va && (s = window.performance.now(), u = "intlify-message-compilation-start", d = "intlify-message-compilation-end", Ql && Ql(u));
  const f = r(o, C_e(e, n, l, o, i, a));
  if (process.env.NODE_ENV !== "production" && Va) {
    const v = window.performance.now(), h = e.__v_emitter;
    h && s && h.emit("message-compilation", {
      type: "message-compilation",
      message: o,
      time: v - s,
      groupId: `translate:${t}`
    }), u && d && Ql && Ri && (Ql(d), Ri("intlify message compilation", u, d));
  }
  return f.locale = n, f.key = t, f.source = o, f;
}
function y_e(e, t, n) {
  let o = null, l, a;
  process.env.NODE_ENV !== "production" && Va && (o = window.performance.now(), l = "intlify-message-evaluation-start", a = "intlify-message-evaluation-end", Ql && Ql(l));
  const r = t(n);
  if (process.env.NODE_ENV !== "production" && Va) {
    const i = window.performance.now(), s = e.__v_emitter;
    s && o && s.emit("message-evaluation", {
      type: "message-evaluation",
      value: r,
      time: i - o,
      groupId: `translate:${t.key}`
    }), l && a && Ql && Ri && (Ql(a), Ri("intlify message evaluation", l, a));
  }
  return r;
}
function _b(...e) {
  const [t, n, o] = e, l = {};
  if (!Vt(t) && !Vo(t) && !va(t) && !Rs(t))
    throw nr(Go.INVALID_ARGUMENT);
  const a = Vo(t) ? String(t) : (va(t), t);
  return Vo(n) ? l.plural = n : Vt(n) ? l.default = n : En(n) && !mh(n) ? l.named = n : fo(n) && (l.list = n), Vo(o) ? l.plural = o : Vt(o) ? l.default = o : En(o) && al(l, o), [a, l];
}
function C_e(e, t, n, o, l, a) {
  return {
    locale: t,
    key: n,
    warnHtmlMessage: l,
    onError: (r) => {
      if (a && a(r), process.env.NODE_ENV !== "production") {
        const i = w_e(o), s = `Message compilation error: ${r.message}`, u = r.location && i && eSe(i, r.location.start.offset, r.location.end.offset), d = e.__v_emitter;
        d && i && d.emit("compile-error", {
          message: i,
          error: r.message,
          start: r.location && r.location.start.offset,
          end: r.location && r.location.end.offset,
          groupId: `translate:${n}`
        }), console.error(u ? `${s}
${u}` : s);
      } else
        throw r;
    },
    onCacheKey: (r) => qEe(t, n, r)
  };
}
function w_e(e) {
  if (Vt(e))
    return e;
  if (e.loc && e.loc.source)
    return e.loc.source;
}
function E_e(e, t, n, o) {
  const { modifiers: l, pluralRules: a, messageResolver: r, fallbackLocale: i, fallbackWarn: s, missingWarn: u, fallbackContext: d } = e, v = {
    locale: t,
    modifiers: l,
    pluralRules: a,
    messages: (h) => {
      let m = r(n, h);
      if (m == null && d) {
        const [, , p] = FR(d, h, t, i, s, u);
        m = r(p, h);
      }
      if (Vt(m) || Rs(m)) {
        let p = !1;
        const g = VR(e, h, t, m, h, () => {
          p = !0;
        });
        return p ? b2 : g;
      } else
        return va(m) ? m : b2;
    }
  };
  return e.processor && (v.processor = e.processor), o.list && (v.list = o.list), o.named && (v.named = o.named), Vo(o.plural) && (v.pluralIndex = o.plural), v;
}
const C2 = typeof Intl < "u", BR = {
  dateTimeFormat: C2 && typeof Intl.DateTimeFormat < "u",
  numberFormat: C2 && typeof Intl.NumberFormat < "u"
};
function w2(e, ...t) {
  const { datetimeFormats: n, unresolving: o, fallbackLocale: l, onWarn: a, localeFallbacker: r } = e, { __datetimeFormatters: i } = e;
  if (process.env.NODE_ENV !== "production" && !BR.dateTimeFormat)
    return a(Di(_l.CANNOT_FORMAT_DATE)), wv;
  const [s, u, d, f] = xb(...t), v = Nn(d.missingWarn) ? d.missingWarn : e.missingWarn, h = Nn(d.fallbackWarn) ? d.fallbackWarn : e.fallbackWarn, m = !!d.part, p = z1(e, d), C = r(
    e,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    l,
    p
  );
  if (!Vt(s) || s === "")
    return new Intl.DateTimeFormat(p, f).format(u);
  let g = {}, w, b = null, y = p, E = null;
  const S = "datetime format";
  for (let N = 0; N < C.length; N++) {
    if (w = E = C[N], process.env.NODE_ENV !== "production" && p !== w && Ch(h, s) && a(Di(_l.FALLBACK_TO_DATE_FORMAT, {
      key: s,
      target: w
    })), process.env.NODE_ENV !== "production" && p !== w) {
      const L = e.__v_emitter;
      L && L.emit("fallback", {
        type: S,
        key: s,
        from: y,
        to: E,
        groupId: `${S}:${s}`
      });
    }
    if (g = n[w] || {}, b = g[s], En(b))
      break;
    W1(e, s, w, v, S), y = E;
  }
  if (!En(b) || !Vt(w))
    return o ? yh : s;
  let _ = `${w}__${s}`;
  mh(f) || (_ = `${_}__${JSON.stringify(f)}`);
  let k = i.get(_);
  return k || (k = new Intl.DateTimeFormat(w, al({}, b, f)), i.set(_, k)), m ? k.formatToParts(u) : k.format(u);
}
const HR = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function xb(...e) {
  const [t, n, o, l] = e, a = {};
  let r = {}, i;
  if (Vt(t)) {
    const s = t.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!s)
      throw nr(Go.INVALID_ISO_DATE_ARGUMENT);
    const u = s[3] ? s[3].trim().startsWith("T") ? `${s[1].trim()}${s[3].trim()}` : `${s[1].trim()}T${s[3].trim()}` : s[1].trim();
    i = new Date(u);
    try {
      i.toISOString();
    } catch {
      throw nr(Go.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (GEe(t)) {
    if (isNaN(t.getTime()))
      throw nr(Go.INVALID_DATE_ARGUMENT);
    i = t;
  } else if (Vo(t))
    i = t;
  else
    throw nr(Go.INVALID_ARGUMENT);
  return Vt(n) ? a.key = n : En(n) && Object.keys(n).forEach((s) => {
    HR.includes(s) ? r[s] = n[s] : a[s] = n[s];
  }), Vt(o) ? a.locale = o : En(o) && (r = o), En(l) && (r = l), [a.key || "", i, a, r];
}
function E2(e, t, n) {
  const o = e;
  for (const l in n) {
    const a = `${t}__${l}`;
    o.__datetimeFormatters.has(a) && o.__datetimeFormatters.delete(a);
  }
}
function S2(e, ...t) {
  const { numberFormats: n, unresolving: o, fallbackLocale: l, onWarn: a, localeFallbacker: r } = e, { __numberFormatters: i } = e;
  if (process.env.NODE_ENV !== "production" && !BR.numberFormat)
    return a(Di(_l.CANNOT_FORMAT_NUMBER)), wv;
  const [s, u, d, f] = kb(...t), v = Nn(d.missingWarn) ? d.missingWarn : e.missingWarn, h = Nn(d.fallbackWarn) ? d.fallbackWarn : e.fallbackWarn, m = !!d.part, p = z1(e, d), C = r(
    e,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    l,
    p
  );
  if (!Vt(s) || s === "")
    return new Intl.NumberFormat(p, f).format(u);
  let g = {}, w, b = null, y = p, E = null;
  const S = "number format";
  for (let N = 0; N < C.length; N++) {
    if (w = E = C[N], process.env.NODE_ENV !== "production" && p !== w && Ch(h, s) && a(Di(_l.FALLBACK_TO_NUMBER_FORMAT, {
      key: s,
      target: w
    })), process.env.NODE_ENV !== "production" && p !== w) {
      const L = e.__v_emitter;
      L && L.emit("fallback", {
        type: S,
        key: s,
        from: y,
        to: E,
        groupId: `${S}:${s}`
      });
    }
    if (g = n[w] || {}, b = g[s], En(b))
      break;
    W1(e, s, w, v, S), y = E;
  }
  if (!En(b) || !Vt(w))
    return o ? yh : s;
  let _ = `${w}__${s}`;
  mh(f) || (_ = `${_}__${JSON.stringify(f)}`);
  let k = i.get(_);
  return k || (k = new Intl.NumberFormat(w, al({}, b, f)), i.set(_, k)), m ? k.formatToParts(u) : k.format(u);
}
const zR = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function kb(...e) {
  const [t, n, o, l] = e, a = {};
  let r = {};
  if (!Vo(t))
    throw nr(Go.INVALID_ARGUMENT);
  const i = t;
  return Vt(n) ? a.key = n : En(n) && Object.keys(n).forEach((s) => {
    zR.includes(s) ? r[s] = n[s] : a[s] = n[s];
  }), Vt(o) ? a.locale = o : En(o) && (r = o), En(l) && (r = l), [a.key || "", i, a, r];
}
function _2(e, t, n) {
  const o = e;
  for (const l in n) {
    const a = `${t}__${l}`;
    o.__numberFormatters.has(a) && o.__numberFormatters.delete(a);
  }
}
RSe();
function S_e() {
  return WR().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function WR() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {};
}
const __e = typeof Proxy == "function", x_e = "devtools-plugin:setup", k_e = "plugin:settings:set";
let uc, Tb;
function T_e() {
  var e;
  return uc !== void 0 || (typeof window < "u" && window.performance ? (uc = !0, Tb = window.performance) : typeof globalThis < "u" && (!((e = globalThis.perf_hooks) === null || e === void 0) && e.performance) ? (uc = !0, Tb = globalThis.perf_hooks.performance) : uc = !1), uc;
}
function $_e() {
  return T_e() ? Tb.now() : Date.now();
}
class O_e {
  constructor(t, n) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = t, this.hook = n;
    const o = {};
    if (t.settings)
      for (const r in t.settings) {
        const i = t.settings[r];
        o[r] = i.defaultValue;
      }
    const l = `__vue-devtools-plugin-settings__${t.id}`;
    let a = Object.assign({}, o);
    try {
      const r = localStorage.getItem(l), i = JSON.parse(r);
      Object.assign(a, i);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return a;
      },
      setSettings(r) {
        try {
          localStorage.setItem(l, JSON.stringify(r));
        } catch {
        }
        a = r;
      },
      now() {
        return $_e();
      }
    }, n && n.on(k_e, (r, i) => {
      r === this.plugin.id && this.fallbacks.setSettings(i);
    }), this.proxiedOn = new Proxy({}, {
      get: (r, i) => this.target ? this.target.on[i] : (...s) => {
        this.onQueue.push({
          method: i,
          args: s
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (r, i) => this.target ? this.target[i] : i === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(i) ? (...s) => (this.targetQueue.push({
        method: i,
        args: s,
        resolve: () => {
        }
      }), this.fallbacks[i](...s)) : (...s) => new Promise((u) => {
        this.targetQueue.push({
          method: i,
          args: s,
          resolve: u
        });
      })
    });
  }
  async setRealTarget(t) {
    this.target = t;
    for (const n of this.onQueue)
      this.target.on[n.method](...n.args);
    for (const n of this.targetQueue)
      n.resolve(await this.target[n.method](...n.args));
  }
}
function N_e(e, t) {
  const n = e, o = WR(), l = S_e(), a = __e && n.enableEarlyProxy;
  if (l && (o.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !a))
    l.emit(x_e, e, t);
  else {
    const r = a ? new O_e(n, l) : null;
    (o.__VUE_DEVTOOLS_PLUGINS__ = o.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: t,
      proxy: r
    }), r && t(r.proxiedTarget);
  }
}
/*!
  * vue-i18n v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const M_e = "9.13.1";
function I_e() {
  typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (Nr().__VUE_I18N_FULL_INSTALL__ = !0), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (Nr().__VUE_I18N_LEGACY_API__ = !0), typeof __INTLIFY_JIT_COMPILATION__ != "boolean" && (Nr().__INTLIFY_JIT_COMPILATION__ = !1), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Nr().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Nr().__INTLIFY_PROD_DEVTOOLS__ = !1);
}
const KR = _l.__EXTEND_POINT__, kr = gh(KR), Co = {
  FALLBACK_TO_ROOT: KR,
  // 9
  NOT_SUPPORTED_PRESERVE: kr(),
  // 10
  NOT_SUPPORTED_FORMATTER: kr(),
  // 11
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: kr(),
  // 12
  NOT_SUPPORTED_GET_CHOICE_INDEX: kr(),
  // 13
  COMPONENT_NAME_LEGACY_COMPATIBLE: kr(),
  // 14
  NOT_FOUND_PARENT_SCOPE: kr(),
  // 15
  IGNORE_OBJ_FLATTEN: kr(),
  // 16
  NOTICE_DROP_ALLOW_COMPOSITION: kr(),
  // 17
  NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: kr()
  // 18
}, R_e = {
  [Co.FALLBACK_TO_ROOT]: "Fall back to {type} '{key}' with root locale.",
  [Co.NOT_SUPPORTED_PRESERVE]: "Not supported 'preserve'.",
  [Co.NOT_SUPPORTED_FORMATTER]: "Not supported 'formatter'.",
  [Co.NOT_SUPPORTED_PRESERVE_DIRECTIVE]: "Not supported 'preserveDirectiveContent'.",
  [Co.NOT_SUPPORTED_GET_CHOICE_INDEX]: "Not supported 'getChoiceIndex'.",
  [Co.COMPONENT_NAME_LEGACY_COMPATIBLE]: "Component name legacy compatible: '{name}' -> 'i18n'",
  [Co.NOT_FOUND_PARENT_SCOPE]: "Not found parent scope. use the global scope.",
  [Co.IGNORE_OBJ_FLATTEN]: "Ignore object flatten: '{key}' key has an string value",
  [Co.NOTICE_DROP_ALLOW_COMPOSITION]: "'allowComposition' option will be dropped in the next major version. For more information, please see 👉 https://tinyurl.com/2p97mcze",
  [Co.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG]: "'translateExistCompatible' option will be dropped in the next major version."
};
function Al(e, ...t) {
  return V1(R_e[e], ...t);
}
const UR = Go.__EXTEND_POINT__, Pl = gh(UR), Hn = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: UR,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: Pl(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: Pl(),
  // 26
  NOT_INSTALLED: Pl(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: Pl(),
  // 28
  // directive module errors
  REQUIRED_VALUE: Pl(),
  // 29
  INVALID_VALUE: Pl(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: Pl(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: Pl(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: Pl(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: Pl(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: Pl(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: Pl(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: Pl(),
  // 37
  // for enhancement
  __EXTEND_POINT__: Pl()
  // 38
};
function Wo(e, ...t) {
  return mu(e, null, process.env.NODE_ENV !== "production" ? { messages: D_e, args: t } : void 0);
}
const D_e = {
  [Hn.UNEXPECTED_RETURN_TYPE]: "Unexpected return type in composer",
  [Hn.INVALID_ARGUMENT]: "Invalid argument",
  [Hn.MUST_BE_CALL_SETUP_TOP]: "Must be called at the top of a `setup` function",
  [Hn.NOT_INSTALLED]: "Need to install with `app.use` function",
  [Hn.UNEXPECTED_ERROR]: "Unexpected error",
  [Hn.NOT_AVAILABLE_IN_LEGACY_MODE]: "Not available in legacy mode",
  [Hn.REQUIRED_VALUE]: "Required in value: {0}",
  [Hn.INVALID_VALUE]: "Invalid value",
  [Hn.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: "Cannot setup vue-devtools plugin",
  [Hn.NOT_INSTALLED_WITH_PROVIDE]: "Need to install with `provide` function",
  [Hn.NOT_COMPATIBLE_LEGACY_VUE_I18N]: "Not compatible legacy VueI18n.",
  [Hn.BRIDGE_SUPPORT_VUE_2_ONLY]: "vue-i18n-bridge support Vue 2.x only",
  [Hn.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION]: "Must define ‘i18n’ option or custom block in Composition API with using local scope in Legacy API mode",
  [Hn.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: "Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly"
}, $b = /* @__PURE__ */ gr("__translateVNode"), Ob = /* @__PURE__ */ gr("__datetimeParts"), Nb = /* @__PURE__ */ gr("__numberParts"), Li = /* @__PURE__ */ gr("__enableEmitter"), Xd = /* @__PURE__ */ gr("__disableEmitter"), jR = gr("__setPluralRules"), qR = /* @__PURE__ */ gr("__injectWithOption"), Mb = /* @__PURE__ */ gr("__dispose");
function Zd(e) {
  if (!Kn(e))
    return e;
  for (const t in e)
    if (yv(e, t))
      if (!t.includes("."))
        Kn(e[t]) && Zd(e[t]);
      else {
        const n = t.split("."), o = n.length - 1;
        let l = e, a = !1;
        for (let r = 0; r < o; r++) {
          if (n[r] in l || (l[n[r]] = {}), !Kn(l[n[r]])) {
            process.env.NODE_ENV !== "production" && Bo(Al(Co.IGNORE_OBJ_FLATTEN, {
              key: n[r]
            })), a = !0;
            break;
          }
          l = l[n[r]];
        }
        a || (l[n[o]] = e[t], delete e[t]), Kn(l[n[o]]) && Zd(l[n[o]]);
      }
  return e;
}
function wh(e, t) {
  const { messages: n, __i18n: o, messageResolver: l, flatJson: a } = t, r = En(n) ? n : fo(o) ? {} : { [e]: {} };
  if (fo(o) && o.forEach((i) => {
    if ("locale" in i && "resource" in i) {
      const { locale: s, resource: u } = i;
      s ? (r[s] = r[s] || {}, zp(u, r[s])) : zp(u, r);
    } else
      Vt(i) && zp(JSON.parse(i), r);
  }), l == null && a)
    for (const i in r)
      yv(r, i) && Zd(r[i]);
  return r;
}
function YR(e) {
  return e.type;
}
function GR(e, t, n) {
  let o = Kn(t.messages) ? t.messages : {};
  "__i18nGlobal" in n && (o = wh(e.locale.value, {
    messages: o,
    __i18n: n.__i18nGlobal
  }));
  const l = Object.keys(o);
  l.length && l.forEach((a) => {
    e.mergeLocaleMessage(a, o[a]);
  });
  {
    if (Kn(t.datetimeFormats)) {
      const a = Object.keys(t.datetimeFormats);
      a.length && a.forEach((r) => {
        e.mergeDateTimeFormat(r, t.datetimeFormats[r]);
      });
    }
    if (Kn(t.numberFormats)) {
      const a = Object.keys(t.numberFormats);
      a.length && a.forEach((r) => {
        e.mergeNumberFormat(r, t.numberFormats[r]);
      });
    }
  }
}
function x2(e) {
  return oe(Fb, null, e, 0);
}
const k2 = "__INTLIFY_META__", T2 = () => [], L_e = () => !1;
let $2 = 0;
function O2(e) {
  return (t, n, o, l) => e(n, o, Pt() || void 0, l);
}
const P_e = /* @__NO_SIDE_EFFECTS__ */ () => {
  const e = Pt();
  let t = null;
  return e && (t = YR(e)[k2]) ? { [k2]: t } : null;
};
function K1(e = {}, t) {
  const { __root: n, __injectWithOption: o } = e, l = n === void 0, a = e.flatJson, r = Va ? B : An, i = !!e.translateExistCompatible;
  process.env.NODE_ENV !== "production" && i && CR(Al(Co.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG));
  let s = Nn(e.inheritLocale) ? e.inheritLocale : !0;
  const u = r(
    // prettier-ignore
    n && s ? n.locale.value : Vt(e.locale) ? e.locale : eu
  ), d = r(
    // prettier-ignore
    n && s ? n.fallbackLocale.value : Vt(e.fallbackLocale) || fo(e.fallbackLocale) || En(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : u.value
  ), f = r(wh(u.value, e)), v = r(En(e.datetimeFormats) ? e.datetimeFormats : { [u.value]: {} }), h = r(En(e.numberFormats) ? e.numberFormats : { [u.value]: {} });
  let m = n ? n.missingWarn : Nn(e.missingWarn) || Is(e.missingWarn) ? e.missingWarn : !0, p = n ? n.fallbackWarn : Nn(e.fallbackWarn) || Is(e.fallbackWarn) ? e.fallbackWarn : !0, C = n ? n.fallbackRoot : Nn(e.fallbackRoot) ? e.fallbackRoot : !0, g = !!e.fallbackFormat, w = Gn(e.missing) ? e.missing : null, b = Gn(e.missing) ? O2(e.missing) : null, y = Gn(e.postTranslation) ? e.postTranslation : null, E = n ? n.warnHtmlMessage : Nn(e.warnHtmlMessage) ? e.warnHtmlMessage : !0, S = !!e.escapeParameter;
  const _ = n ? n.modifiers : En(e.modifiers) ? e.modifiers : {};
  let k = e.pluralRules || n && n.pluralRules, N;
  N = (() => {
    l && h2(null);
    const Ce = {
      version: M_e,
      locale: u.value,
      fallbackLocale: d.value,
      messages: f.value,
      modifiers: _,
      pluralRules: k,
      missing: b === null ? void 0 : b,
      missingWarn: m,
      fallbackWarn: p,
      fallbackFormat: g,
      unresolving: !0,
      postTranslation: y === null ? void 0 : y,
      warnHtmlMessage: E,
      escapeParameter: S,
      messageResolver: e.messageResolver,
      messageCompiler: e.messageCompiler,
      __meta: { framework: "vue" }
    };
    Ce.datetimeFormats = v.value, Ce.numberFormats = h.value, Ce.__datetimeFormatters = En(N) ? N.__datetimeFormatters : void 0, Ce.__numberFormatters = En(N) ? N.__numberFormatters : void 0, process.env.NODE_ENV !== "production" && (Ce.__v_emitter = En(N) ? N.__v_emitter : void 0);
    const Le = f_e(Ce);
    return l && h2(Le), Le;
  })(), Hu(N, u.value, d.value);
  function R() {
    return [
      u.value,
      d.value,
      f.value,
      v.value,
      h.value
    ];
  }
  const H = x({
    get: () => u.value,
    set: (Ce) => {
      u.value = Ce, N.locale = u.value;
    }
  }), K = x({
    get: () => d.value,
    set: (Ce) => {
      d.value = Ce, N.fallbackLocale = d.value, Hu(N, u.value, Ce);
    }
  }), U = x(() => f.value), W = /* @__PURE__ */ x(() => v.value), A = /* @__PURE__ */ x(() => h.value);
  function $() {
    return Gn(y) ? y : null;
  }
  function D(Ce) {
    y = Ce, N.postTranslation = Ce;
  }
  function O() {
    return w;
  }
  function F(Ce) {
    Ce !== null && (b = O2(Ce)), w = Ce, N.missing = b;
  }
  function j(Ce, Le) {
    return Ce !== "translate" || !Le.resolvedMessage;
  }
  const Z = (Ce, Le, ge, Ee, me, Ke) => {
    R();
    let Re;
    try {
      process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__, l || (N.fallbackContext = n ? d_e() : void 0), Re = Ce(N);
    } finally {
      process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__, l || (N.fallbackContext = void 0);
    }
    if (ge !== "translate exists" && // for not `te` (e.g `t`)
    Vo(Re) && Re === yh || ge === "translate exists" && !Re) {
      const [we, ze] = Le();
      if (process.env.NODE_ENV !== "production" && n && Vt(we) && j(ge, ze) && (C && (Ch(p, we) || IR(m, we)) && Bo(Al(Co.FALLBACK_TO_ROOT, {
        key: we,
        type: ge
      })), process.env.NODE_ENV !== "production")) {
        const { __v_emitter: Je } = N;
        Je && C && Je.emit("fallback", {
          type: ge,
          key: we,
          to: "global",
          groupId: `${ge}:${we}`
        });
      }
      return n && C ? Ee(n) : me(we);
    } else {
      if (Ke(Re))
        return Re;
      throw Wo(Hn.UNEXPECTED_RETURN_TYPE);
    }
  };
  function te(...Ce) {
    return Z((Le) => Reflect.apply(y2, null, [Le, ...Ce]), () => _b(...Ce), "translate", (Le) => Reflect.apply(Le.t, Le, [...Ce]), (Le) => Le, (Le) => Vt(Le));
  }
  function de(...Ce) {
    const [Le, ge, Ee] = Ce;
    if (Ee && !Kn(Ee))
      throw Wo(Hn.INVALID_ARGUMENT);
    return te(Le, ge, al({ resolvedMessage: !0 }, Ee || {}));
  }
  function Oe(...Ce) {
    return Z((Le) => Reflect.apply(w2, null, [Le, ...Ce]), () => xb(...Ce), "datetime format", (Le) => Reflect.apply(Le.d, Le, [...Ce]), () => wv, (Le) => Vt(Le));
  }
  function ce(...Ce) {
    return Z((Le) => Reflect.apply(S2, null, [Le, ...Ce]), () => kb(...Ce), "number format", (Le) => Reflect.apply(Le.n, Le, [...Ce]), () => wv, (Le) => Vt(Le));
  }
  function ne(Ce) {
    return Ce.map((Le) => Vt(Le) || Vo(Le) || Nn(Le) ? x2(String(Le)) : Le);
  }
  const ve = {
    normalize: ne,
    interpolate: (Ce) => Ce,
    type: "vnode"
  };
  function ie(...Ce) {
    return Z(
      (Le) => {
        let ge;
        const Ee = Le;
        try {
          Ee.processor = ve, ge = Reflect.apply(y2, null, [Ee, ...Ce]);
        } finally {
          Ee.processor = null;
        }
        return ge;
      },
      () => _b(...Ce),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (Le) => Le[$b](...Ce),
      (Le) => [x2(Le)],
      (Le) => fo(Le)
    );
  }
  function he(...Ce) {
    return Z(
      (Le) => Reflect.apply(S2, null, [Le, ...Ce]),
      () => kb(...Ce),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (Le) => Le[Nb](...Ce),
      T2,
      (Le) => Vt(Le) || fo(Le)
    );
  }
  function De(...Ce) {
    return Z(
      (Le) => Reflect.apply(w2, null, [Le, ...Ce]),
      () => xb(...Ce),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (Le) => Le[Ob](...Ce),
      T2,
      (Le) => Vt(Le) || fo(Le)
    );
  }
  function $e(Ce) {
    k = Ce, N.pluralRules = k;
  }
  function ue(Ce, Le) {
    return Z(() => {
      if (!Ce)
        return !1;
      const ge = Vt(Le) ? Le : u.value, Ee = Fe(ge), me = N.messageResolver(Ee, Ce);
      return i ? me != null : Rs(me) || va(me) || Vt(me);
    }, () => [Ce], "translate exists", (ge) => Reflect.apply(ge.te, ge, [Ce, Le]), L_e, (ge) => Nn(ge));
  }
  function Ne(Ce) {
    let Le = null;
    const ge = kR(N, d.value, u.value);
    for (let Ee = 0; Ee < ge.length; Ee++) {
      const me = f.value[ge[Ee]] || {}, Ke = N.messageResolver(me, Ce);
      if (Ke != null) {
        Le = Ke;
        break;
      }
    }
    return Le;
  }
  function je(Ce) {
    const Le = Ne(Ce);
    return Le ?? (n ? n.tm(Ce) || {} : {});
  }
  function Fe(Ce) {
    return f.value[Ce] || {};
  }
  function Ve(Ce, Le) {
    if (a) {
      const ge = { [Ce]: Le };
      for (const Ee in ge)
        yv(ge, Ee) && Zd(ge[Ee]);
      Le = ge[Ce];
    }
    f.value[Ce] = Le, N.messages = f.value;
  }
  function Ze(Ce, Le) {
    f.value[Ce] = f.value[Ce] || {};
    const ge = { [Ce]: Le };
    if (a)
      for (const Ee in ge)
        yv(ge, Ee) && Zd(ge[Ee]);
    Le = ge[Ce], zp(Le, f.value[Ce]), N.messages = f.value;
  }
  function ae(Ce) {
    return v.value[Ce] || {};
  }
  function pe(Ce, Le) {
    v.value[Ce] = Le, N.datetimeFormats = v.value, E2(N, Ce, Le);
  }
  function ke(Ce, Le) {
    v.value[Ce] = al(v.value[Ce] || {}, Le), N.datetimeFormats = v.value, E2(N, Ce, Le);
  }
  function Ue(Ce) {
    return h.value[Ce] || {};
  }
  function Xe(Ce, Le) {
    h.value[Ce] = Le, N.numberFormats = h.value, _2(N, Ce, Le);
  }
  function re(Ce, Le) {
    h.value[Ce] = al(h.value[Ce] || {}, Le), N.numberFormats = h.value, _2(N, Ce, Le);
  }
  $2++, n && Va && (Pe(n.locale, (Ce) => {
    s && (u.value = Ce, N.locale = Ce, Hu(N, u.value, d.value));
  }), Pe(n.fallbackLocale, (Ce) => {
    s && (d.value = Ce, N.fallbackLocale = Ce, Hu(N, u.value, d.value));
  }));
  const Te = {
    id: $2,
    locale: H,
    fallbackLocale: K,
    get inheritLocale() {
      return s;
    },
    set inheritLocale(Ce) {
      s = Ce, Ce && n && (u.value = n.locale.value, d.value = n.fallbackLocale.value, Hu(N, u.value, d.value));
    },
    get availableLocales() {
      return Object.keys(f.value).sort();
    },
    messages: U,
    get modifiers() {
      return _;
    },
    get pluralRules() {
      return k || {};
    },
    get isGlobal() {
      return l;
    },
    get missingWarn() {
      return m;
    },
    set missingWarn(Ce) {
      m = Ce, N.missingWarn = m;
    },
    get fallbackWarn() {
      return p;
    },
    set fallbackWarn(Ce) {
      p = Ce, N.fallbackWarn = p;
    },
    get fallbackRoot() {
      return C;
    },
    set fallbackRoot(Ce) {
      C = Ce;
    },
    get fallbackFormat() {
      return g;
    },
    set fallbackFormat(Ce) {
      g = Ce, N.fallbackFormat = g;
    },
    get warnHtmlMessage() {
      return E;
    },
    set warnHtmlMessage(Ce) {
      E = Ce, N.warnHtmlMessage = Ce;
    },
    get escapeParameter() {
      return S;
    },
    set escapeParameter(Ce) {
      S = Ce, N.escapeParameter = Ce;
    },
    t: te,
    getLocaleMessage: Fe,
    setLocaleMessage: Ve,
    mergeLocaleMessage: Ze,
    getPostTranslationHandler: $,
    setPostTranslationHandler: D,
    getMissingHandler: O,
    setMissingHandler: F,
    [jR]: $e
  };
  return Te.datetimeFormats = W, Te.numberFormats = A, Te.rt = de, Te.te = ue, Te.tm = je, Te.d = Oe, Te.n = ce, Te.getDateTimeFormat = ae, Te.setDateTimeFormat = pe, Te.mergeDateTimeFormat = ke, Te.getNumberFormat = Ue, Te.setNumberFormat = Xe, Te.mergeNumberFormat = re, Te[qR] = o, Te[$b] = ie, Te[Ob] = De, Te[Nb] = he, process.env.NODE_ENV !== "production" && (Te[Li] = (Ce) => {
    N.__v_emitter = Ce;
  }, Te[Xd] = () => {
    N.__v_emitter = void 0;
  }), Te;
}
function A_e(e) {
  const t = Vt(e.locale) ? e.locale : eu, n = Vt(e.fallbackLocale) || fo(e.fallbackLocale) || En(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : t, o = Gn(e.missing) ? e.missing : void 0, l = Nn(e.silentTranslationWarn) || Is(e.silentTranslationWarn) ? !e.silentTranslationWarn : !0, a = Nn(e.silentFallbackWarn) || Is(e.silentFallbackWarn) ? !e.silentFallbackWarn : !0, r = Nn(e.fallbackRoot) ? e.fallbackRoot : !0, i = !!e.formatFallbackMessages, s = En(e.modifiers) ? e.modifiers : {}, u = e.pluralizationRules, d = Gn(e.postTranslation) ? e.postTranslation : void 0, f = Vt(e.warnHtmlInMessage) ? e.warnHtmlInMessage !== "off" : !0, v = !!e.escapeParameterHtml, h = Nn(e.sync) ? e.sync : !0;
  process.env.NODE_ENV !== "production" && e.formatter && Bo(Al(Co.NOT_SUPPORTED_FORMATTER)), process.env.NODE_ENV !== "production" && e.preserveDirectiveContent && Bo(Al(Co.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
  let m = e.messages;
  if (En(e.sharedMessages)) {
    const S = e.sharedMessages;
    m = Object.keys(S).reduce((k, N) => {
      const L = k[N] || (k[N] = {});
      return al(L, S[N]), k;
    }, m || {});
  }
  const { __i18n: p, __root: C, __injectWithOption: g } = e, w = e.datetimeFormats, b = e.numberFormats, y = e.flatJson, E = e.translateExistCompatible;
  return {
    locale: t,
    fallbackLocale: n,
    messages: m,
    flatJson: y,
    datetimeFormats: w,
    numberFormats: b,
    missing: o,
    missingWarn: l,
    fallbackWarn: a,
    fallbackRoot: r,
    fallbackFormat: i,
    modifiers: s,
    pluralRules: u,
    postTranslation: d,
    warnHtmlMessage: f,
    escapeParameter: v,
    messageResolver: e.messageResolver,
    inheritLocale: h,
    translateExistCompatible: E,
    __i18n: p,
    __root: C,
    __injectWithOption: g
  };
}
function Ib(e = {}, t) {
  {
    const n = K1(A_e(e)), { __extender: o } = e, l = {
      // id
      id: n.id,
      // locale
      get locale() {
        return n.locale.value;
      },
      set locale(a) {
        n.locale.value = a;
      },
      // fallbackLocale
      get fallbackLocale() {
        return n.fallbackLocale.value;
      },
      set fallbackLocale(a) {
        n.fallbackLocale.value = a;
      },
      // messages
      get messages() {
        return n.messages.value;
      },
      // datetimeFormats
      get datetimeFormats() {
        return n.datetimeFormats.value;
      },
      // numberFormats
      get numberFormats() {
        return n.numberFormats.value;
      },
      // availableLocales
      get availableLocales() {
        return n.availableLocales;
      },
      // formatter
      get formatter() {
        return process.env.NODE_ENV !== "production" && Bo(Al(Co.NOT_SUPPORTED_FORMATTER)), {
          interpolate() {
            return [];
          }
        };
      },
      set formatter(a) {
        process.env.NODE_ENV !== "production" && Bo(Al(Co.NOT_SUPPORTED_FORMATTER));
      },
      // missing
      get missing() {
        return n.getMissingHandler();
      },
      set missing(a) {
        n.setMissingHandler(a);
      },
      // silentTranslationWarn
      get silentTranslationWarn() {
        return Nn(n.missingWarn) ? !n.missingWarn : n.missingWarn;
      },
      set silentTranslationWarn(a) {
        n.missingWarn = Nn(a) ? !a : a;
      },
      // silentFallbackWarn
      get silentFallbackWarn() {
        return Nn(n.fallbackWarn) ? !n.fallbackWarn : n.fallbackWarn;
      },
      set silentFallbackWarn(a) {
        n.fallbackWarn = Nn(a) ? !a : a;
      },
      // modifiers
      get modifiers() {
        return n.modifiers;
      },
      // formatFallbackMessages
      get formatFallbackMessages() {
        return n.fallbackFormat;
      },
      set formatFallbackMessages(a) {
        n.fallbackFormat = a;
      },
      // postTranslation
      get postTranslation() {
        return n.getPostTranslationHandler();
      },
      set postTranslation(a) {
        n.setPostTranslationHandler(a);
      },
      // sync
      get sync() {
        return n.inheritLocale;
      },
      set sync(a) {
        n.inheritLocale = a;
      },
      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return n.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(a) {
        n.warnHtmlMessage = a !== "off";
      },
      // escapeParameterHtml
      get escapeParameterHtml() {
        return n.escapeParameter;
      },
      set escapeParameterHtml(a) {
        n.escapeParameter = a;
      },
      // preserveDirectiveContent
      get preserveDirectiveContent() {
        return process.env.NODE_ENV !== "production" && Bo(Al(Co.NOT_SUPPORTED_PRESERVE_DIRECTIVE)), !0;
      },
      set preserveDirectiveContent(a) {
        process.env.NODE_ENV !== "production" && Bo(Al(Co.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
      },
      // pluralizationRules
      get pluralizationRules() {
        return n.pluralRules || {};
      },
      // for internal
      __composer: n,
      // t
      t(...a) {
        const [r, i, s] = a, u = {};
        let d = null, f = null;
        if (!Vt(r))
          throw Wo(Hn.INVALID_ARGUMENT);
        const v = r;
        return Vt(i) ? u.locale = i : fo(i) ? d = i : En(i) && (f = i), fo(s) ? d = s : En(s) && (f = s), Reflect.apply(n.t, n, [
          v,
          d || f || {},
          u
        ]);
      },
      rt(...a) {
        return Reflect.apply(n.rt, n, [...a]);
      },
      // tc
      tc(...a) {
        const [r, i, s] = a, u = { plural: 1 };
        let d = null, f = null;
        if (!Vt(r))
          throw Wo(Hn.INVALID_ARGUMENT);
        const v = r;
        return Vt(i) ? u.locale = i : Vo(i) ? u.plural = i : fo(i) ? d = i : En(i) && (f = i), Vt(s) ? u.locale = s : fo(s) ? d = s : En(s) && (f = s), Reflect.apply(n.t, n, [
          v,
          d || f || {},
          u
        ]);
      },
      // te
      te(a, r) {
        return n.te(a, r);
      },
      // tm
      tm(a) {
        return n.tm(a);
      },
      // getLocaleMessage
      getLocaleMessage(a) {
        return n.getLocaleMessage(a);
      },
      // setLocaleMessage
      setLocaleMessage(a, r) {
        n.setLocaleMessage(a, r);
      },
      // mergeLocaleMessage
      mergeLocaleMessage(a, r) {
        n.mergeLocaleMessage(a, r);
      },
      // d
      d(...a) {
        return Reflect.apply(n.d, n, [...a]);
      },
      // getDateTimeFormat
      getDateTimeFormat(a) {
        return n.getDateTimeFormat(a);
      },
      // setDateTimeFormat
      setDateTimeFormat(a, r) {
        n.setDateTimeFormat(a, r);
      },
      // mergeDateTimeFormat
      mergeDateTimeFormat(a, r) {
        n.mergeDateTimeFormat(a, r);
      },
      // n
      n(...a) {
        return Reflect.apply(n.n, n, [...a]);
      },
      // getNumberFormat
      getNumberFormat(a) {
        return n.getNumberFormat(a);
      },
      // setNumberFormat
      setNumberFormat(a, r) {
        n.setNumberFormat(a, r);
      },
      // mergeNumberFormat
      mergeNumberFormat(a, r) {
        n.mergeNumberFormat(a, r);
      },
      // getChoiceIndex
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getChoiceIndex(a, r) {
        return process.env.NODE_ENV !== "production" && Bo(Al(Co.NOT_SUPPORTED_GET_CHOICE_INDEX)), -1;
      }
    };
    return l.__extender = o, process.env.NODE_ENV !== "production" && (l.__enableEmitter = (a) => {
      const r = n;
      r[Li] && r[Li](a);
    }, l.__disableEmitter = () => {
      const a = n;
      a[Xd] && a[Xd]();
    }), l;
  }
}
const U1 = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (e) => e === "parent" || e === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function F_e({ slots: e }, t) {
  return t.length === 1 && t[0] === "default" ? (e.default ? e.default() : []).reduce((o, l) => [
    ...o,
    // prettier-ignore
    ...l.type === kt ? l.children : [l]
  ], []) : t.reduce((n, o) => {
    const l = e[o];
    return l && (n[o] = l()), n;
  }, {});
}
function XR(e) {
  return kt;
}
const V_e = /* @__PURE__ */ Q({
  /* eslint-disable */
  name: "i18n-t",
  props: al({
    keypath: {
      type: String,
      required: !0
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: (e) => Vo(e) || !isNaN(e)
    }
  }, U1),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(e, t) {
    const { slots: n, attrs: o } = t, l = e.i18n || q1({
      useScope: e.scope,
      __useComponent: !0
    });
    return () => {
      const a = Object.keys(n).filter((f) => f !== "_"), r = {};
      e.locale && (r.locale = e.locale), e.plural !== void 0 && (r.plural = Vt(e.plural) ? +e.plural : e.plural);
      const i = F_e(t, a), s = l[$b](e.keypath, i, r), u = al({}, o), d = Vt(e.tag) || Kn(e.tag) ? e.tag : XR();
      return V(d, u, s);
    };
  }
}), Xm = V_e;
function B_e(e) {
  return fo(e) && !Vt(e[0]);
}
function ZR(e, t, n, o) {
  const { slots: l, attrs: a } = t;
  return () => {
    const r = { part: !0 };
    let i = {};
    e.locale && (r.locale = e.locale), Vt(e.format) ? r.key = e.format : Kn(e.format) && (Vt(e.format.key) && (r.key = e.format.key), i = Object.keys(e.format).reduce((v, h) => n.includes(h) ? al({}, v, { [h]: e.format[h] }) : v, {}));
    const s = o(e.value, r, i);
    let u = [r.key];
    fo(s) ? u = s.map((v, h) => {
      const m = l[v.type], p = m ? m({ [v.type]: v.value, index: h, parts: s }) : [v.value];
      return B_e(p) && (p[0].key = `${v.type}-${h}`), p;
    }) : Vt(s) && (u = [s]);
    const d = al({}, a), f = Vt(e.tag) || Kn(e.tag) ? e.tag : XR();
    return V(f, d, u);
  };
}
const H_e = /* @__PURE__ */ Q({
  /* eslint-disable */
  name: "i18n-n",
  props: al({
    value: {
      type: Number,
      required: !0
    },
    format: {
      type: [String, Object]
    }
  }, U1),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(e, t) {
    const n = e.i18n || q1({
      useScope: e.scope,
      __useComponent: !0
    });
    return ZR(e, t, zR, (...o) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      n[Nb](...o)
    ));
  }
}), N2 = H_e, z_e = /* @__PURE__ */ Q({
  /* eslint-disable */
  name: "i18n-d",
  props: al({
    value: {
      type: [Number, Date],
      required: !0
    },
    format: {
      type: [String, Object]
    }
  }, U1),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(e, t) {
    const n = e.i18n || q1({
      useScope: e.scope,
      __useComponent: !0
    });
    return ZR(e, t, HR, (...o) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      n[Ob](...o)
    ));
  }
}), M2 = z_e;
function W_e(e, t) {
  const n = e;
  if (e.mode === "composition")
    return n.__getInstance(t) || e.global;
  {
    const o = n.__getInstance(t);
    return o != null ? o.__composer : e.global.__composer;
  }
}
function K_e(e) {
  const t = (r) => {
    const { instance: i, modifiers: s, value: u } = r;
    if (!i || !i.$)
      throw Wo(Hn.UNEXPECTED_ERROR);
    const d = W_e(e, i.$);
    process.env.NODE_ENV !== "production" && s.preserve && Bo(Al(Co.NOT_SUPPORTED_PRESERVE));
    const f = I2(u);
    return [
      Reflect.apply(d.t, d, [...R2(f)]),
      d
    ];
  };
  return {
    created: (r, i) => {
      const [s, u] = t(i);
      Va && e.global === u && (r.__i18nWatcher = Pe(u.locale, () => {
        i.instance && i.instance.$forceUpdate();
      })), r.__composer = u, r.textContent = s;
    },
    unmounted: (r) => {
      Va && r.__i18nWatcher && (r.__i18nWatcher(), r.__i18nWatcher = void 0, delete r.__i18nWatcher), r.__composer && (r.__composer = void 0, delete r.__composer);
    },
    beforeUpdate: (r, { value: i }) => {
      if (r.__composer) {
        const s = r.__composer, u = I2(i);
        r.textContent = Reflect.apply(s.t, s, [
          ...R2(u)
        ]);
      }
    },
    getSSRProps: (r) => {
      const [i] = t(r);
      return { textContent: i };
    }
  };
}
function I2(e) {
  if (Vt(e))
    return { path: e };
  if (En(e)) {
    if (!("path" in e))
      throw Wo(Hn.REQUIRED_VALUE, "path");
    return e;
  } else
    throw Wo(Hn.INVALID_VALUE);
}
function R2(e) {
  const { path: t, locale: n, args: o, choice: l, plural: a } = e, r = {}, i = o || {};
  return Vt(n) && (r.locale = n), Vo(l) && (r.plural = l), Vo(a) && (r.plural = a), [t, i, r];
}
function U_e(e, t, ...n) {
  const o = En(n[0]) ? n[0] : {}, l = !!o.useI18nComponentName, a = Nn(o.globalInstall) ? o.globalInstall : !0;
  process.env.NODE_ENV !== "production" && a && l && Bo(Al(Co.COMPONENT_NAME_LEGACY_COMPATIBLE, {
    name: Xm.name
  })), a && ([l ? "i18n" : Xm.name, "I18nT"].forEach((r) => e.component(r, Xm)), [N2.name, "I18nN"].forEach((r) => e.component(r, N2)), [M2.name, "I18nD"].forEach((r) => e.component(r, M2))), e.directive("t", K_e(t));
}
const Zm = {
  "vue-devtools-plugin-vue-i18n": "Vue I18n devtools",
  "vue-i18n-resource-inspector": "I18n Resources",
  "vue-i18n-timeline": "Vue I18n"
}, j_e = {
  "vue-i18n-resource-inspector": "Search for scopes ..."
}, q_e = {
  "vue-i18n-timeline": 16764185
}, JR = "vue-i18n: composer properties";
let Rb;
async function Y_e(e, t) {
  return new Promise((n, o) => {
    try {
      N_e({
        id: "vue-devtools-plugin-vue-i18n",
        label: Zm[
          "vue-devtools-plugin-vue-i18n"
          /* VueDevToolsIDs.PLUGIN */
        ],
        packageName: "vue-i18n",
        homepage: "https://vue-i18n.intlify.dev",
        logo: "https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png",
        componentStateTypes: [JR],
        app: e
        // eslint-disable-line @typescript-eslint/no-explicit-any
      }, (l) => {
        Rb = l, l.on.visitComponentTree(({ componentInstance: r, treeNode: i }) => {
          G_e(r, i, t);
        }), l.on.inspectComponent(({ componentInstance: r, instanceData: i }) => {
          r.vnode.el && r.vnode.el.__VUE_I18N__ && i && (t.mode === "legacy" ? r.vnode.el.__VUE_I18N__ !== t.global.__composer && D2(i, r.vnode.el.__VUE_I18N__) : D2(i, r.vnode.el.__VUE_I18N__));
        }), l.addInspector({
          id: "vue-i18n-resource-inspector",
          label: Zm[
            "vue-i18n-resource-inspector"
            /* VueDevToolsIDs.CUSTOM_INSPECTOR */
          ],
          icon: "language",
          treeFilterPlaceholder: j_e[
            "vue-i18n-resource-inspector"
            /* VueDevToolsIDs.CUSTOM_INSPECTOR */
          ]
        }), l.on.getInspectorTree((r) => {
          r.app === e && r.inspectorId === "vue-i18n-resource-inspector" && e2e(r, t);
        });
        const a = /* @__PURE__ */ new Map();
        l.on.getInspectorState(async (r) => {
          if (r.app === e && r.inspectorId === "vue-i18n-resource-inspector")
            if (l.unhighlightElement(), n2e(r, t), r.nodeId === "global") {
              if (!a.has(r.app)) {
                const [i] = await l.getComponentInstances(r.app);
                a.set(r.app, i);
              }
              l.highlightElement(a.get(r.app));
            } else {
              const i = t2e(r.nodeId, t);
              i && l.highlightElement(i);
            }
        }), l.on.editInspectorState((r) => {
          r.app === e && r.inspectorId === "vue-i18n-resource-inspector" && l2e(r, t);
        }), l.addTimelineLayer({
          id: "vue-i18n-timeline",
          label: Zm[
            "vue-i18n-timeline"
            /* VueDevToolsIDs.TIMELINE */
          ],
          color: q_e[
            "vue-i18n-timeline"
            /* VueDevToolsIDs.TIMELINE */
          ]
        }), n(!0);
      });
    } catch (l) {
      console.error(l), o(!1);
    }
  });
}
function QR(e) {
  return e.type.name || e.type.displayName || e.type.__file || "Anonymous";
}
function G_e(e, t, n) {
  const o = n.mode === "composition" ? n.global : n.global.__composer;
  if (e && e.vnode.el && e.vnode.el.__VUE_I18N__ && e.vnode.el.__VUE_I18N__ !== o) {
    const l = {
      label: `i18n (${QR(e)} Scope)`,
      textColor: 0,
      backgroundColor: 16764185
    };
    t.tags.push(l);
  }
}
function D2(e, t) {
  const n = JR;
  e.state.push({
    type: n,
    key: "locale",
    editable: !0,
    value: t.locale.value
  }), e.state.push({
    type: n,
    key: "availableLocales",
    editable: !1,
    value: t.availableLocales
  }), e.state.push({
    type: n,
    key: "fallbackLocale",
    editable: !0,
    value: t.fallbackLocale.value
  }), e.state.push({
    type: n,
    key: "inheritLocale",
    editable: !0,
    value: t.inheritLocale
  }), e.state.push({
    type: n,
    key: "messages",
    editable: !1,
    value: j1(t.messages.value)
  }), e.state.push({
    type: n,
    key: "datetimeFormats",
    editable: !1,
    value: t.datetimeFormats.value
  }), e.state.push({
    type: n,
    key: "numberFormats",
    editable: !1,
    value: t.numberFormats.value
  });
}
function j1(e) {
  const t = {};
  return Object.keys(e).forEach((n) => {
    const o = e[n];
    Gn(o) && "source" in o ? t[n] = Q_e(o) : Rs(o) && o.loc && o.loc.source ? t[n] = o.loc.source : Kn(o) ? t[n] = j1(o) : t[n] = o;
  }), t;
}
const X_e = {
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "&": "&amp;"
};
function Z_e(e) {
  return e.replace(/[<>"&]/g, J_e);
}
function J_e(e) {
  return X_e[e] || e;
}
function Q_e(e) {
  return {
    _custom: {
      type: "function",
      display: `<span>ƒ</span> ${e.source ? `("${Z_e(e.source)}")` : "(?)"}`
    }
  };
}
function e2e(e, t) {
  e.rootNodes.push({
    id: "global",
    label: "Global Scope"
  });
  const n = t.mode === "composition" ? t.global : t.global.__composer;
  for (const [o, l] of t.__instances) {
    const a = t.mode === "composition" ? l : l.__composer;
    n !== a && e.rootNodes.push({
      id: a.id.toString(),
      label: `${QR(o)} Scope`
    });
  }
}
function t2e(e, t) {
  let n = null;
  if (e !== "global") {
    for (const [o, l] of t.__instances.entries())
      if (l.id.toString() === e) {
        n = o;
        break;
      }
  }
  return n;
}
function e3(e, t) {
  if (e === "global")
    return t.mode === "composition" ? t.global : t.global.__composer;
  {
    const n = Array.from(t.__instances.values()).find((o) => o.id.toString() === e);
    return n ? t.mode === "composition" ? n : n.__composer : null;
  }
}
function n2e(e, t) {
  const n = e3(e.nodeId, t);
  return n && (e.state = o2e(n)), null;
}
function o2e(e) {
  const t = {}, n = "Locale related info", o = [
    {
      type: n,
      key: "locale",
      editable: !0,
      value: e.locale.value
    },
    {
      type: n,
      key: "fallbackLocale",
      editable: !0,
      value: e.fallbackLocale.value
    },
    {
      type: n,
      key: "availableLocales",
      editable: !1,
      value: e.availableLocales
    },
    {
      type: n,
      key: "inheritLocale",
      editable: !0,
      value: e.inheritLocale
    }
  ];
  t[n] = o;
  const l = "Locale messages info", a = [
    {
      type: l,
      key: "messages",
      editable: !1,
      value: j1(e.messages.value)
    }
  ];
  t[l] = a;
  {
    const r = "Datetime formats info", i = [
      {
        type: r,
        key: "datetimeFormats",
        editable: !1,
        value: e.datetimeFormats.value
      }
    ];
    t[r] = i;
    const s = "Datetime formats info", u = [
      {
        type: s,
        key: "numberFormats",
        editable: !1,
        value: e.numberFormats.value
      }
    ];
    t[s] = u;
  }
  return t;
}
function Jd(e, t) {
  if (Rb) {
    let n;
    t && "groupId" in t && (n = t.groupId, delete t.groupId), Rb.addTimelineEvent({
      layerId: "vue-i18n-timeline",
      event: {
        title: e,
        groupId: n,
        time: Date.now(),
        meta: {},
        data: t || {},
        logType: e === "compile-error" ? "error" : e === "fallback" || e === "missing" ? "warning" : "default"
      }
    });
  }
}
function l2e(e, t) {
  const n = e3(e.nodeId, t);
  if (n) {
    const [o] = e.path;
    o === "locale" && Vt(e.state.value) ? n.locale.value = e.state.value : o === "fallbackLocale" && (Vt(e.state.value) || fo(e.state.value) || Kn(e.state.value)) ? n.fallbackLocale.value = e.state.value : o === "inheritLocale" && Nn(e.state.value) && (n.inheritLocale = e.state.value);
  }
}
function a2e(e, t, n) {
  return {
    beforeCreate() {
      const o = Pt();
      if (!o)
        throw Wo(Hn.UNEXPECTED_ERROR);
      const l = this.$options;
      if (l.i18n) {
        const a = l.i18n;
        if (l.__i18n && (a.__i18n = l.__i18n), a.__root = t, this === this.$root)
          this.$i18n = L2(e, a);
        else {
          a.__injectWithOption = !0, a.__extender = n.__vueI18nExtend, this.$i18n = Ib(a);
          const r = this.$i18n;
          r.__extender && (r.__disposer = r.__extender(this.$i18n));
        }
      } else if (l.__i18n)
        if (this === this.$root)
          this.$i18n = L2(e, l);
        else {
          this.$i18n = Ib({
            __i18n: l.__i18n,
            __injectWithOption: !0,
            __extender: n.__vueI18nExtend,
            __root: t
          });
          const a = this.$i18n;
          a.__extender && (a.__disposer = a.__extender(this.$i18n));
        }
      else
        this.$i18n = e;
      l.__i18nGlobal && GR(t, l, l), this.$t = (...a) => this.$i18n.t(...a), this.$rt = (...a) => this.$i18n.rt(...a), this.$tc = (...a) => this.$i18n.tc(...a), this.$te = (a, r) => this.$i18n.te(a, r), this.$d = (...a) => this.$i18n.d(...a), this.$n = (...a) => this.$i18n.n(...a), this.$tm = (a) => this.$i18n.tm(a), n.__setInstance(o, this.$i18n);
    },
    mounted() {
      if (process.env.NODE_ENV !== "production" && this.$el && this.$i18n) {
        const o = this.$i18n;
        this.$el.__VUE_I18N__ = o.__composer;
        const l = this.__v_emitter = B1();
        o.__enableEmitter && o.__enableEmitter(l), l.on("*", Jd);
      }
    },
    unmounted() {
      const o = Pt();
      if (!o)
        throw Wo(Hn.UNEXPECTED_ERROR);
      const l = this.$i18n;
      process.env.NODE_ENV !== "production" && this.$el && this.$el.__VUE_I18N__ && (this.__v_emitter && (this.__v_emitter.off("*", Jd), delete this.__v_emitter), this.$i18n && (l.__disableEmitter && l.__disableEmitter(), delete this.$el.__VUE_I18N__)), delete this.$t, delete this.$rt, delete this.$tc, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, l.__disposer && (l.__disposer(), delete l.__disposer, delete l.__extender), n.__deleteInstance(o), delete this.$i18n;
    }
  };
}
function L2(e, t) {
  e.locale = t.locale || e.locale, e.fallbackLocale = t.fallbackLocale || e.fallbackLocale, e.missing = t.missing || e.missing, e.silentTranslationWarn = t.silentTranslationWarn || e.silentFallbackWarn, e.silentFallbackWarn = t.silentFallbackWarn || e.silentFallbackWarn, e.formatFallbackMessages = t.formatFallbackMessages || e.formatFallbackMessages, e.postTranslation = t.postTranslation || e.postTranslation, e.warnHtmlInMessage = t.warnHtmlInMessage || e.warnHtmlInMessage, e.escapeParameterHtml = t.escapeParameterHtml || e.escapeParameterHtml, e.sync = t.sync || e.sync, e.__composer[jR](t.pluralizationRules || e.pluralizationRules);
  const n = wh(e.locale, {
    messages: t.messages,
    __i18n: t.__i18n
  });
  return Object.keys(n).forEach((o) => e.mergeLocaleMessage(o, n[o])), t.datetimeFormats && Object.keys(t.datetimeFormats).forEach((o) => e.mergeDateTimeFormat(o, t.datetimeFormats[o])), t.numberFormats && Object.keys(t.numberFormats).forEach((o) => e.mergeNumberFormat(o, t.numberFormats[o])), e;
}
const r2e = /* @__PURE__ */ gr("global-vue-i18n");
function s2e(e = {}, t) {
  const n = __VUE_I18N_LEGACY_API__ && Nn(e.legacy) ? e.legacy : __VUE_I18N_LEGACY_API__, o = Nn(e.globalInjection) ? e.globalInjection : !0, l = __VUE_I18N_LEGACY_API__ && n ? !!e.allowComposition : !0, a = /* @__PURE__ */ new Map(), [r, i] = i2e(e, n), s = /* @__PURE__ */ gr(process.env.NODE_ENV !== "production" ? "vue-i18n" : "");
  process.env.NODE_ENV !== "production" && n && l && Bo(Al(Co.NOTICE_DROP_ALLOW_COMPOSITION));
  function u(v) {
    return a.get(v) || null;
  }
  function d(v, h) {
    a.set(v, h);
  }
  function f(v) {
    a.delete(v);
  }
  {
    const v = {
      // mode
      get mode() {
        return __VUE_I18N_LEGACY_API__ && n ? "legacy" : "composition";
      },
      // allowComposition
      get allowComposition() {
        return l;
      },
      // install plugin
      async install(h, ...m) {
        if (process.env.NODE_ENV !== "production" && (h.__VUE_I18N__ = v), h.__VUE_I18N_SYMBOL__ = s, h.provide(h.__VUE_I18N_SYMBOL__, v), En(m[0])) {
          const g = m[0];
          v.__composerExtend = g.__composerExtend, v.__vueI18nExtend = g.__vueI18nExtend;
        }
        let p = null;
        !n && o && (p = g2e(h, v.global)), __VUE_I18N_FULL_INSTALL__ && U_e(h, v, ...m), __VUE_I18N_LEGACY_API__ && n && h.mixin(a2e(i, i.__composer, v));
        const C = h.unmount;
        if (h.unmount = () => {
          p && p(), v.dispose(), C();
        }, process.env.NODE_ENV !== "production") {
          if (!await Y_e(h, v))
            throw Wo(Hn.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN);
          const w = B1();
          if (n) {
            const b = i;
            b.__enableEmitter && b.__enableEmitter(w);
          } else {
            const b = i;
            b[Li] && b[Li](w);
          }
          w.on("*", Jd);
        }
      },
      // global accessor
      get global() {
        return i;
      },
      dispose() {
        r.stop();
      },
      // @internal
      __instances: a,
      // @internal
      __getInstance: u,
      // @internal
      __setInstance: d,
      // @internal
      __deleteInstance: f
    };
    return v;
  }
}
function q1(e = {}) {
  const t = Pt();
  if (t == null)
    throw Wo(Hn.MUST_BE_CALL_SETUP_TOP);
  if (!t.isCE && t.appContext.app != null && !t.appContext.app.__VUE_I18N_SYMBOL__)
    throw Wo(Hn.NOT_INSTALLED);
  const n = c2e(t), o = d2e(n), l = YR(t), a = u2e(e, l);
  if (__VUE_I18N_LEGACY_API__ && n.mode === "legacy" && !e.__useComponent) {
    if (!n.allowComposition)
      throw Wo(Hn.NOT_AVAILABLE_IN_LEGACY_MODE);
    return h2e(t, a, o, e);
  }
  if (a === "global")
    return GR(o, e, l), o;
  if (a === "parent") {
    let s = f2e(n, t, e.__useComponent);
    return s == null && (process.env.NODE_ENV !== "production" && Bo(Al(Co.NOT_FOUND_PARENT_SCOPE)), s = o), s;
  }
  const r = n;
  let i = r.__getInstance(t);
  if (i == null) {
    const s = al({}, e);
    "__i18n" in l && (s.__i18n = l.__i18n), o && (s.__root = o), i = K1(s), r.__composerExtend && (i[Mb] = r.__composerExtend(i)), v2e(r, t, i), r.__setInstance(t, i);
  }
  return i;
}
function i2e(e, t, n) {
  const o = K2();
  {
    const l = __VUE_I18N_LEGACY_API__ && t ? o.run(() => Ib(e)) : o.run(() => K1(e));
    if (l == null)
      throw Wo(Hn.UNEXPECTED_ERROR);
    return [o, l];
  }
}
function c2e(e) {
  {
    const t = ot(e.isCE ? r2e : e.appContext.app.__VUE_I18N_SYMBOL__);
    if (!t)
      throw Wo(e.isCE ? Hn.NOT_INSTALLED_WITH_PROVIDE : Hn.UNEXPECTED_ERROR);
    return t;
  }
}
function u2e(e, t) {
  return mh(e) ? "__i18n" in t ? "local" : "global" : e.useScope ? e.useScope : "local";
}
function d2e(e) {
  return e.mode === "composition" ? e.global : e.global.__composer;
}
function f2e(e, t, n = !1) {
  let o = null;
  const l = t.root;
  let a = p2e(t, n);
  for (; a != null; ) {
    const r = e;
    if (e.mode === "composition")
      o = r.__getInstance(a);
    else if (__VUE_I18N_LEGACY_API__) {
      const i = r.__getInstance(a);
      i != null && (o = i.__composer, n && o && !o[qR] && (o = null));
    }
    if (o != null || l === a)
      break;
    a = a.parent;
  }
  return o;
}
function p2e(e, t = !1) {
  return e == null ? null : t && e.vnode.ctx || e.parent;
}
function v2e(e, t, n) {
  let o = null;
  Nt(() => {
    if (process.env.NODE_ENV !== "production" && t.vnode.el) {
      t.vnode.el.__VUE_I18N__ = n, o = B1();
      const l = n;
      l[Li] && l[Li](o), o.on("*", Jd);
    }
  }, t), wo(() => {
    const l = n;
    process.env.NODE_ENV !== "production" && t.vnode.el && t.vnode.el.__VUE_I18N__ && (o && o.off("*", Jd), l[Xd] && l[Xd](), delete t.vnode.el.__VUE_I18N__), e.__deleteInstance(t);
    const a = l[Mb];
    a && (a(), delete l[Mb]);
  }, t);
}
function h2e(e, t, n, o = {}) {
  const l = t === "local", a = An(null);
  if (l && e.proxy && !(e.proxy.$options.i18n || e.proxy.$options.__i18n))
    throw Wo(Hn.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  const r = Nn(o.inheritLocale) ? o.inheritLocale : !Vt(o.locale), i = B(
    // prettier-ignore
    !l || r ? n.locale.value : Vt(o.locale) ? o.locale : eu
  ), s = B(
    // prettier-ignore
    !l || r ? n.fallbackLocale.value : Vt(o.fallbackLocale) || fo(o.fallbackLocale) || En(o.fallbackLocale) || o.fallbackLocale === !1 ? o.fallbackLocale : i.value
  ), u = B(wh(i.value, o)), d = B(En(o.datetimeFormats) ? o.datetimeFormats : { [i.value]: {} }), f = B(En(o.numberFormats) ? o.numberFormats : { [i.value]: {} }), v = l ? n.missingWarn : Nn(o.missingWarn) || Is(o.missingWarn) ? o.missingWarn : !0, h = l ? n.fallbackWarn : Nn(o.fallbackWarn) || Is(o.fallbackWarn) ? o.fallbackWarn : !0, m = l ? n.fallbackRoot : Nn(o.fallbackRoot) ? o.fallbackRoot : !0, p = !!o.fallbackFormat, C = Gn(o.missing) ? o.missing : null, g = Gn(o.postTranslation) ? o.postTranslation : null, w = l ? n.warnHtmlMessage : Nn(o.warnHtmlMessage) ? o.warnHtmlMessage : !0, b = !!o.escapeParameter, y = l ? n.modifiers : En(o.modifiers) ? o.modifiers : {}, E = o.pluralRules || l && n.pluralRules;
  function S() {
    return [
      i.value,
      s.value,
      u.value,
      d.value,
      f.value
    ];
  }
  const _ = x({
    get: () => a.value ? a.value.locale.value : i.value,
    set: (ue) => {
      a.value && (a.value.locale.value = ue), i.value = ue;
    }
  }), k = x({
    get: () => a.value ? a.value.fallbackLocale.value : s.value,
    set: (ue) => {
      a.value && (a.value.fallbackLocale.value = ue), s.value = ue;
    }
  }), N = x(() => a.value ? a.value.messages.value : u.value), L = x(() => d.value), R = x(() => f.value);
  function H() {
    return a.value ? a.value.getPostTranslationHandler() : g;
  }
  function K(ue) {
    a.value && a.value.setPostTranslationHandler(ue);
  }
  function U() {
    return a.value ? a.value.getMissingHandler() : C;
  }
  function W(ue) {
    a.value && a.value.setMissingHandler(ue);
  }
  function A(ue) {
    return S(), ue();
  }
  function $(...ue) {
    return a.value ? A(() => Reflect.apply(a.value.t, null, [...ue])) : A(() => "");
  }
  function D(...ue) {
    return a.value ? Reflect.apply(a.value.rt, null, [...ue]) : "";
  }
  function O(...ue) {
    return a.value ? A(() => Reflect.apply(a.value.d, null, [...ue])) : A(() => "");
  }
  function F(...ue) {
    return a.value ? A(() => Reflect.apply(a.value.n, null, [...ue])) : A(() => "");
  }
  function j(ue) {
    return a.value ? a.value.tm(ue) : {};
  }
  function Z(ue, Ne) {
    return a.value ? a.value.te(ue, Ne) : !1;
  }
  function te(ue) {
    return a.value ? a.value.getLocaleMessage(ue) : {};
  }
  function de(ue, Ne) {
    a.value && (a.value.setLocaleMessage(ue, Ne), u.value[ue] = Ne);
  }
  function Oe(ue, Ne) {
    a.value && a.value.mergeLocaleMessage(ue, Ne);
  }
  function ce(ue) {
    return a.value ? a.value.getDateTimeFormat(ue) : {};
  }
  function ne(ue, Ne) {
    a.value && (a.value.setDateTimeFormat(ue, Ne), d.value[ue] = Ne);
  }
  function Y(ue, Ne) {
    a.value && a.value.mergeDateTimeFormat(ue, Ne);
  }
  function ve(ue) {
    return a.value ? a.value.getNumberFormat(ue) : {};
  }
  function ie(ue, Ne) {
    a.value && (a.value.setNumberFormat(ue, Ne), f.value[ue] = Ne);
  }
  function he(ue, Ne) {
    a.value && a.value.mergeNumberFormat(ue, Ne);
  }
  const De = {
    get id() {
      return a.value ? a.value.id : -1;
    },
    locale: _,
    fallbackLocale: k,
    messages: N,
    datetimeFormats: L,
    numberFormats: R,
    get inheritLocale() {
      return a.value ? a.value.inheritLocale : r;
    },
    set inheritLocale(ue) {
      a.value && (a.value.inheritLocale = ue);
    },
    get availableLocales() {
      return a.value ? a.value.availableLocales : Object.keys(u.value);
    },
    get modifiers() {
      return a.value ? a.value.modifiers : y;
    },
    get pluralRules() {
      return a.value ? a.value.pluralRules : E;
    },
    get isGlobal() {
      return a.value ? a.value.isGlobal : !1;
    },
    get missingWarn() {
      return a.value ? a.value.missingWarn : v;
    },
    set missingWarn(ue) {
      a.value && (a.value.missingWarn = ue);
    },
    get fallbackWarn() {
      return a.value ? a.value.fallbackWarn : h;
    },
    set fallbackWarn(ue) {
      a.value && (a.value.missingWarn = ue);
    },
    get fallbackRoot() {
      return a.value ? a.value.fallbackRoot : m;
    },
    set fallbackRoot(ue) {
      a.value && (a.value.fallbackRoot = ue);
    },
    get fallbackFormat() {
      return a.value ? a.value.fallbackFormat : p;
    },
    set fallbackFormat(ue) {
      a.value && (a.value.fallbackFormat = ue);
    },
    get warnHtmlMessage() {
      return a.value ? a.value.warnHtmlMessage : w;
    },
    set warnHtmlMessage(ue) {
      a.value && (a.value.warnHtmlMessage = ue);
    },
    get escapeParameter() {
      return a.value ? a.value.escapeParameter : b;
    },
    set escapeParameter(ue) {
      a.value && (a.value.escapeParameter = ue);
    },
    t: $,
    getPostTranslationHandler: H,
    setPostTranslationHandler: K,
    getMissingHandler: U,
    setMissingHandler: W,
    rt: D,
    d: O,
    n: F,
    tm: j,
    te: Z,
    getLocaleMessage: te,
    setLocaleMessage: de,
    mergeLocaleMessage: Oe,
    getDateTimeFormat: ce,
    setDateTimeFormat: ne,
    mergeDateTimeFormat: Y,
    getNumberFormat: ve,
    setNumberFormat: ie,
    mergeNumberFormat: he
  };
  function $e(ue) {
    ue.locale.value = i.value, ue.fallbackLocale.value = s.value, Object.keys(u.value).forEach((Ne) => {
      ue.mergeLocaleMessage(Ne, u.value[Ne]);
    }), Object.keys(d.value).forEach((Ne) => {
      ue.mergeDateTimeFormat(Ne, d.value[Ne]);
    }), Object.keys(f.value).forEach((Ne) => {
      ue.mergeNumberFormat(Ne, f.value[Ne]);
    }), ue.escapeParameter = b, ue.fallbackFormat = p, ue.fallbackRoot = m, ue.fallbackWarn = h, ue.missingWarn = v, ue.warnHtmlMessage = w;
  }
  return Sv(() => {
    if (e.proxy == null || e.proxy.$i18n == null)
      throw Wo(Hn.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    const ue = a.value = e.proxy.$i18n.__composer;
    t === "global" ? (i.value = ue.locale.value, s.value = ue.fallbackLocale.value, u.value = ue.messages.value, d.value = ue.datetimeFormats.value, f.value = ue.numberFormats.value) : l && $e(ue);
  }), De;
}
const m2e = [
  "locale",
  "fallbackLocale",
  "availableLocales"
], P2 = ["t", "rt", "d", "n", "tm", "te"];
function g2e(e, t) {
  const n = /* @__PURE__ */ Object.create(null);
  return m2e.forEach((l) => {
    const a = Object.getOwnPropertyDescriptor(t, l);
    if (!a)
      throw Wo(Hn.UNEXPECTED_ERROR);
    const r = fl(a.value) ? {
      get() {
        return a.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(i) {
        a.value.value = i;
      }
    } : {
      get() {
        return a.get && a.get();
      }
    };
    Object.defineProperty(n, l, r);
  }), e.config.globalProperties.$i18n = n, P2.forEach((l) => {
    const a = Object.getOwnPropertyDescriptor(t, l);
    if (!a || !a.value)
      throw Wo(Hn.UNEXPECTED_ERROR);
    Object.defineProperty(e.config.globalProperties, `$${l}`, a);
  }), () => {
    delete e.config.globalProperties.$i18n, P2.forEach((l) => {
      delete e.config.globalProperties[`$${l}`];
    });
  };
}
I_e();
__INTLIFY_JIT_COMPILATION__ ? v2(g_e) : v2(m_e);
s_e(HSe);
i_e(kR);
if (process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) {
  const e = Nr();
  e.__INTLIFY__ = !0, XSe(e.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
process.env.NODE_ENV;
const b2e = { key: 0 }, y2e = { key: 1 }, C2e = { key: 3 }, Sc = /* @__PURE__ */ Q({
  name: "KButton",
  __name: "button",
  props: {
    type: { default: "normal" },
    size: { default: "base" },
    status: {},
    iconRight: { default: null },
    iconLeft: { default: null },
    value: { default: "" },
    disabled: { type: Boolean, default: !1 },
    loading: { type: Boolean, default: !1 },
    loadingIcon: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const n = e, o = x(() => {
      const { type: u, size: d } = n;
      return {
        ...l(u),
        ...a(d),
        ...r()
      };
    }), l = (u) => {
      const d = {
        type: "",
        plain: !1,
        text: !1
      };
      switch (u) {
        case "main":
          d.type = "primary";
          break;
        case "secondary":
          d.type = "primary", d.plain = !0;
          break;
        case "normal":
          d.type = "";
          break;
        case "text":
          d.type = "primary", d.text = !0;
          break;
      }
      return d;
    }, a = (u) => {
      const d = {
        size: "default"
      };
      switch (u) {
        case "base":
          d.size = "default";
          break;
        case "sm":
          d.size = "small";
          break;
      }
      return d;
    }, r = () => {
      const { disabled: u, loading: d, loadingIcon: f } = n;
      return {
        disabled: u,
        loading: d,
        loadingIcon: f
      };
    }, i = t, s = (u) => {
      i("click", u);
    };
    return (u, d) => {
      const f = Do;
      return M(), G("div", {
        class: z([{ "button-loading": n.loading }, "k-button"])
      }, [
        oe(f, Et({
          ref: "buttonRef",
          class: ["k-button__inner", { loading: n.loading }]
        }, o.value, { onClick: s }), {
          default: fe(() => [
            X("span", null, [
              n.iconLeft ? (M(), G("span", b2e, [
                oe(n.iconLeft, { class: "icon-left" })
              ])) : _e("", !0),
              n.value ? (M(), G("span", y2e, Qe(n.value), 1)) : Ie(u.$slots, "default", {
                key: 2,
                class: "slot-content"
              }),
              n.iconRight ? (M(), G("span", C2e, [
                oe(n.iconRight, { class: "icon-right" })
              ])) : _e("", !0)
            ])
          ]),
          _: 3
        }, 16, ["class"])
      ], 2);
    };
  }
}), w2e = { class: "k-input" }, Eh = /* @__PURE__ */ Q({
  name: "KInput",
  __name: "input",
  props: {
    id: {},
    name: {},
    label: {},
    modelValue: { default: "" },
    type: {},
    width: {},
    prefixIcon: {},
    suffixIcon: {},
    disabled: { type: Boolean, default: !1 },
    placeholder: {},
    size: {},
    clearable: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    showWordLimit: { type: Boolean, default: !1 },
    autosize: { type: [Boolean, Object], default: !1 },
    showPassword: { type: Boolean, default: !1 },
    rows: {},
    maxlength: {},
    minlength: {},
    prependClassName: {},
    appendClassName: {}
  },
  emits: ["update:modelValue", "input", "blur", "change", "clear", "focus"],
  setup(e, { expose: t, emit: n }) {
    var S;
    const o = e, l = Yn(), a = n, r = (S = Pt()) == null ? void 0 : S.appContext.app.config.globalProperties, i = B(""), s = B(null), u = x(() => ({
      ...d(),
      ...f()
    }));
    Pe(() => o.modelValue, (_) => {
      i.value = _;
    }, { immediate: !0 });
    const d = () => ({
      size: o.size === "sm" ? "small" : ""
    }), f = () => ({
      id: o.id,
      name: o.name,
      label: o.label,
      type: o.type,
      disabled: o.disabled,
      placeholder: o.placeholder || (r == null ? void 0 : r.$t("input")),
      readonly: o.readonly,
      clearable: o.clearable,
      prefixIcon: o.prefixIcon,
      suffixIcon: o.suffixIcon,
      showWordLimit: o.showWordLimit,
      autosize: o.autosize,
      rows: o.rows,
      showPassword: o.showPassword,
      maxLength: o.maxlength,
      minLength: o.minlength
    }), v = () => {
      a("update:modelValue", i.value), a("input", i.value);
    }, h = () => {
      a("blur");
    }, m = () => {
      a("focus");
    }, p = (_) => {
      a("change", _);
    }, C = () => {
      a("update:modelValue", ""), a("clear", ""), a("input", ""), a("change", "");
    };
    return t({
      focus: () => {
        var _;
        (_ = s.value) == null || _.focus();
      },
      blur: () => {
        var _;
        (_ = s.value) == null || _.blur();
      },
      select: () => {
        var _;
        (_ = s.value) == null || _.select();
      },
      clear: () => {
        var _;
        (_ = s.value) == null || _.clear();
      },
      resizeTextarea: () => {
        var _;
        (_ = s.value) == null || _.resizeTextarea();
      }
    }), (_, k) => {
      const N = nl;
      return M(), G("div", w2e, [
        oe(N, Et({
          ref_key: "inputRef",
          ref: s,
          modelValue: i.value,
          "onUpdate:modelValue": k[0] || (k[0] = (L) => i.value = L)
        }, u.value, {
          style: {
            width: o.width
          },
          onInput: v,
          onChange: p,
          onFocus: m,
          onBlur: h,
          onClear: C
        }), rl({ _: 2 }, [
          c(l).prepend ? {
            name: "prepend",
            fn: fe(() => [
              Ie(_.$slots, "prepend")
            ]),
            key: "0"
          } : void 0,
          c(l).append ? {
            name: "append",
            fn: fe(() => [
              Ie(_.$slots, "append")
            ]),
            key: "1"
          } : void 0,
          c(l).prefix ? {
            name: "prefix",
            fn: fe(() => [
              Ie(_.$slots, "prefix")
            ]),
            key: "2"
          } : void 0,
          c(l).suffix ? {
            name: "suffix",
            fn: fe(() => [
              Ie(_.$slots, "suffix")
            ]),
            key: "3"
          } : void 0
        ]), 1040, ["modelValue", "style"])
      ]);
    };
  }
}), E2e = { class: "k-input-number" }, S2e = /* @__PURE__ */ Q({
  name: "KInputNumber",
  __name: "input_number",
  props: {
    id: {},
    name: {},
    label: {},
    modelValue: {},
    width: {},
    disabled: { type: Boolean },
    placeholder: {},
    size: {},
    readonly: { type: Boolean },
    min: {},
    max: {},
    step: {},
    stepStrictly: { type: Boolean },
    precision: {},
    controls: { type: Boolean, default: !0 },
    controlsPosition: {}
  },
  emits: ["update:modelValue", "blur", "change", "focus"],
  setup(e, { expose: t, emit: n }) {
    var C;
    const o = e, l = n, a = (C = Pt()) == null ? void 0 : C.appContext.app.config.globalProperties, r = B(null), i = B(0), s = x(() => ({
      ...u(),
      ...d()
    }));
    Pe(() => o.modelValue, (g) => {
      i.value = g;
    }, { immediate: !0 });
    const u = () => ({
      size: o.size === "sm" ? "small" : ""
    }), d = () => ({
      id: o.id,
      name: o.name,
      label: o.label,
      disabled: o.disabled,
      placeholder: o.placeholder || (a == null ? void 0 : a.$t("input")),
      readonly: o.readonly,
      max: o.max,
      min: o.min,
      step: o.step,
      stepStrictly: o.stepStrictly,
      precision: o.precision,
      controls: o.controls,
      controlsPosition: o.controlsPosition
    }), f = () => {
      l("blur");
    }, v = () => {
      l("focus");
    }, h = (g) => {
      l("update:modelValue", g), l("change", g);
    };
    return t({ focus: () => {
      var g;
      (g = r.value) == null || g.focus();
    }, blur: () => {
      var g;
      (g = r.value) == null || g.blur();
    } }), (g, w) => {
      const b = a0;
      return M(), G("div", E2e, [
        oe(b, Et({
          ref_key: "inputNumberRef",
          ref: r,
          modelValue: i.value,
          "onUpdate:modelValue": w[0] || (w[0] = (y) => i.value = y)
        }, s.value, {
          style: {
            width: o.width
          },
          onChange: h,
          onFocus: v,
          onBlur: f
        }), {
          "increase-icon": fe(() => [
            Ie(g.$slots, "increase-icon")
          ]),
          "decrease-icon": fe(() => [
            Ie(g.$slots, "decrease-icon")
          ]),
          _: 3
        }, 16, ["modelValue", "style"])
      ]);
    };
  }
}), _2e = { class: "k-radio" }, x2e = /* @__PURE__ */ Q({
  name: "KRadio",
  __name: "radio",
  props: {
    modelValue: {},
    value: {},
    checked: { type: Boolean },
    disabled: { type: Boolean },
    size: {},
    label: {},
    indeterminate: { type: Boolean },
    color: {}
  },
  emits: ["update:modelValue", "change"],
  setup(e, { emit: t }) {
    const n = e, o = t, l = B(n.modelValue), a = x(() => ({
      ...r(),
      ...i()
    }));
    Pe(() => n.modelValue, (u) => {
      l.value = u;
    });
    const r = () => ({
      size: n.size === "sm" ? "small" : ""
    }), i = () => ({
      value: n.value,
      label: n.label,
      disabled: n.disabled
    }), s = (u) => {
      o("update:modelValue", u), o("change", u);
    };
    return (u, d) => {
      const f = jy;
      return M(), G("div", _2e, [
        oe(f, Et({
          modelValue: l.value,
          "onUpdate:modelValue": d[0] || (d[0] = (v) => l.value = v)
        }, a.value, { onChange: s }), {
          default: fe(() => [
            Ie(u.$slots, "default")
          ]),
          _: 3
        }, 16, ["modelValue"])
      ]);
    };
  }
}), k2e = { class: "k-radio-group" }, T2e = /* @__PURE__ */ Q({
  name: "KRadioGroup",
  __name: "radio_group",
  props: {
    modelValue: {},
    disabled: { type: Boolean },
    size: {},
    color: {}
  },
  emits: ["update:modelValue", "change"],
  setup(e, { emit: t }) {
    const n = e, o = t, l = B(n.modelValue), a = x(() => ({
      ...r(),
      ...i()
    }));
    Pe(() => n.modelValue, (u) => {
      l.value = u;
    });
    const r = () => ({
      size: n.size === "sm" ? "small" : ""
    }), i = () => ({
      disabled: n.disabled
    }), s = (u) => {
      o("update:modelValue", u), o("change", u);
    };
    return (u, d) => {
      const f = YT;
      return M(), G("div", k2e, [
        oe(f, Et({
          modelValue: l.value,
          "onUpdate:modelValue": d[0] || (d[0] = (v) => l.value = v)
        }, a.value, { onChange: s }), {
          default: fe(() => [
            Ie(u.$slots, "default")
          ]),
          _: 3
        }, 16, ["modelValue"])
      ]);
    };
  }
});
function Sh(e) {
  let t = "";
  const n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", o = n.length;
  for (let l = 0; l < e; l++)
    t += n.charAt(Math.floor(Math.random() * o));
  return t;
}
function t3(e) {
  switch (e) {
    case "sm":
      return "small";
    case "lg":
      return "large";
    case "default":
      return "default";
    default:
      return "";
  }
}
class $2e {
  constructor() {
    Jr(this, "events");
    this.events = [];
  }
  on(t, n) {
    this.events.find((l) => l.name === t) || this.events.push({
      name: t,
      callback: n
    });
  }
  emit(t, ...n) {
    const o = this.events.find((l) => l.name === t);
    if (o) {
      const { callback: l } = o;
      l.call(null, ...n);
    }
  }
}
const O2e = ["id"], N2e = { class: "checkbox__label" }, Db = /* @__PURE__ */ Q({
  name: "KCheckbox",
  __name: "checkbox",
  props: {
    modelValue: {},
    value: {},
    checked: { type: Boolean },
    disabled: { type: Boolean },
    size: {},
    label: {},
    indeterminate: { type: Boolean },
    color: {}
  },
  emits: ["update:modelValue", "change"],
  setup(e, { emit: t }) {
    const n = ot("useCheckboxGroup", !1), o = ot("selectedData", []), l = ot("fillColor", null), a = e, r = t, i = B(a.modelValue);
    let s = null, u = null, d = null;
    const f = Sh(8);
    Nt(() => {
      s = document.getElementById(f), s !== null && (d = s.querySelector(".el-checkbox .el-checkbox__inner"), u = s.querySelector(".el-checkbox .el-checkbox__label"));
    });
    const v = x(() => ({
      ...h(),
      ...m()
    }));
    Pe(() => a.modelValue, (g) => {
      i.value = g;
    }, { immediate: !0 }), Pe(() => [i.value, o.value, a.indeterminate], () => {
      xe(() => {
        const g = a.color || l || "#409eff";
        p(g);
      });
    }, { immediate: !0 });
    const h = () => ({
      size: a.size === "sm" ? "small" : ""
    }), m = () => ({
      value: a.value,
      label: a.label,
      disabled: a.disabled,
      indeterminate: a.indeterminate,
      checked: a.checked
    });
    function p(g) {
      let w = !1;
      n ? w = o.value.includes(a.value) : w = i.value === !0, u !== null && w ? u.style.color = g : u !== null && !w && (u.style.color = "#000"), d !== null && (w || a.indeterminate) ? (d.style.backgroundColor = g, d.style.borderColor = g) : d !== null && !w && !a.indeterminate && (d.style.backgroundColor = "#FFF", d.style.borderColor = "#CDCACF");
    }
    const C = (g) => {
      n || (r("update:modelValue", g), r("change", g));
    };
    return (g, w) => {
      const b = ta;
      return M(), G("div", {
        id: c(f),
        class: "k-checkbox"
      }, [
        oe(b, Et({
          modelValue: i.value,
          "onUpdate:modelValue": w[0] || (w[0] = (y) => i.value = y)
        }, v.value, { onChange: C }), {
          default: fe(() => [
            Ie(g.$slots, "default", {}, () => [
              X("span", N2e, Qe(a.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["modelValue"])
      ], 8, O2e);
    };
  }
}), M2e = { class: "k-checkbox-group" }, I2e = /* @__PURE__ */ Q({
  name: "KCheckboxGroup",
  __name: "checkbox_group",
  props: {
    modelValue: {},
    disabled: { type: Boolean },
    size: {},
    color: { default: "#409eff" }
  },
  emits: ["update:modelValue", "change"],
  setup(e, { emit: t }) {
    const n = e, o = t, l = B(n.modelValue), a = x(() => ({
      ...r(),
      ...i()
    }));
    Pe(() => n.modelValue, (u) => {
      l.value = u;
    });
    const r = () => ({
      size: n.size === "sm" ? "small" : ""
    }), i = () => ({
      disabled: n.disabled
    }), s = (u) => {
      o("update:modelValue", u), o("change", u);
    };
    return Mt("useCheckboxGroup", !0), Mt("selectedData", l), Mt("fillColor", n.color), (u, d) => {
      const f = Uy;
      return M(), G("div", M2e, [
        oe(f, Et({
          modelValue: l.value,
          "onUpdate:modelValue": d[0] || (d[0] = (v) => l.value = v),
          class: "k-checkbox-group__inner"
        }, a.value, { onChange: s }), {
          default: fe(() => [
            Ie(u.$slots, "default")
          ]),
          _: 3
        }, 16, ["modelValue"])
      ]);
    };
  }
}), R2e = { class: "k-switch" }, D2e = /* @__PURE__ */ Q({
  name: "KSwitch",
  __name: "switch",
  props: {
    modelValue: { type: Boolean },
    switchOnColor: { default: "" },
    switchOffColor: { default: "" },
    activeText: {},
    inactiveText: {},
    disabled: { type: Boolean },
    width: {},
    loading: { type: Boolean },
    size: {}
  },
  emits: ["update:modelValue", "change"],
  setup(e, { emit: t }) {
    const n = e, o = t, l = B(n.modelValue), a = x(() => ({
      ...r(),
      ...i()
    }));
    Pe(() => n.modelValue, (u) => {
      l.value = u;
    });
    const r = () => ({
      size: n.size === "sm" ? "small" : ""
    }), i = () => ({
      width: n.width,
      loading: n.loading,
      disabled: n.disabled,
      activeText: n.activeText,
      inactiveText: n.inactiveText
    }), s = (u) => {
      o("update:modelValue", u), o("change", u);
    };
    return (u, d) => {
      const f = yO;
      return M(), G("div", R2e, [
        oe(f, Et({
          modelValue: l.value,
          "onUpdate:modelValue": d[0] || (d[0] = (v) => l.value = v)
        }, a.value, {
          style: {
            "--el-switch-on-color": n.switchOnColor,
            "--el-switch-off-color": n.switchOffColor
          },
          "inline-prompt": "",
          onChange: s
        }), null, 16, ["modelValue", "style"])
      ]);
    };
  }
}), L2e = { class: "k-tabs" }, P2e = /* @__PURE__ */ Q({
  name: "KTabs",
  __name: "tabs",
  props: {
    modelValue: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      default: ""
    },
    position: {
      type: String,
      default: "top"
    },
    router: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["tab-click", "tab-remove"],
  setup(e, { emit: t }) {
    const n = e, o = t, l = B("");
    Mt("isUseRouter", n.router), Mt("activeName", l), Pe(() => n.modelValue, () => {
      l.value = n.modelValue;
    }, { immediate: !0 });
    const r = (() => {
      const { type: u } = n;
      return { type: u };
    })(), i = (u) => {
      o("tab-click", u);
    }, s = (u) => {
      o("tab-remove", u);
    };
    return (u, d) => {
      const f = HO;
      return M(), G("div", L2e, [
        oe(f, Et({
          modelValue: l.value,
          "onUpdate:modelValue": d[0] || (d[0] = (v) => l.value = v)
        }, c(r), {
          "tab-position": n.position,
          onTabClick: i,
          onTabRemove: s
        }), {
          default: fe(() => [
            Ie(u.$slots, "default")
          ]),
          _: 3
        }, 16, ["modelValue", "tab-position"])
      ]);
    };
  }
}), A2e = { class: "k-tab-item" }, F2e = { class: "k-tab__label" }, V2e = { key: 0 }, B2e = /* @__PURE__ */ Q({
  name: "KTabItem",
  __name: "tab_item",
  props: {
    label: { default: "" },
    name: { default: "" },
    path: { default: "#" },
    closable: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    icon: { default: null }
  },
  setup(e) {
    var u;
    const t = e, n = Yn(), o = (u = Pt()) == null ? void 0 : u.appContext.app.config, l = o == null ? void 0 : o.globalProperties.$router, a = ot("isUseRouter"), r = ot("activeName"), i = (l == null ? void 0 : l.getRoutes()) || [], s = An(null);
    return Pe(() => r.value, () => {
      var v;
      if (!a || !l || r.value !== t.name)
        return;
      const d = i.find((h) => h.path === t.path);
      if (!d)
        return;
      l.currentRoute.value.path !== t.path && (l.push(t.path), s.value = (v = d.components) == null ? void 0 : v.default);
    }, { immediate: !0 }), (d, f) => {
      const v = zO;
      return M(), G("div", A2e, [
        oe(v, {
          name: t.name,
          closable: d.closable,
          disabled: t.disabled
        }, {
          label: fe(() => [
            X("div", F2e, [
              (M(), We(Qt(t.icon))),
              c(n).label ? Ie(d.$slots, "label", { key: 1 }) : (M(), G("span", V2e, Qe(t.label), 1))
            ])
          ]),
          default: fe(() => [
            Ie(d.$slots, "default", {}, () => [
              c(a) && c(l) ? (M(), We(b3, { key: 0 }, [
                (M(), We(Qt(s.value)))
              ], 1024)) : _e("", !0)
            ])
          ]),
          _: 3
        }, 8, ["name", "closable", "disabled"])
      ]);
    };
  }
}), H2e = { class: "k-pagination" }, z2e = /* @__PURE__ */ Q({
  name: "KPagination",
  __name: "pagination",
  props: {
    total: {},
    pageSize: { default: 10 },
    pageSizes: {},
    disabled: { type: Boolean },
    size: {},
    background: { type: Boolean, default: !0 },
    layout: { default: "total, prev, pager, next, sizes, jumper" }
  },
  emits: [
    "size-change",
    "current-change",
    "change",
    "prev-click",
    "next-click"
  ],
  setup(e, { emit: t }) {
    const n = e, o = t, l = B(n.pageSize), a = x(() => ({
      ...r(),
      ...i()
    })), r = () => ({
      small: n.size === "sm"
    }), i = () => ({
      total: n.total,
      pageSizes: n.pageSizes,
      disabled: n.disabled,
      background: n.background,
      layout: n.layout
    }), s = (h) => {
      o("change", h);
    }, u = (h) => {
      o("size-change", h);
    }, d = (h) => {
      l.value = h, o("current-change", h);
    }, f = (h) => {
      o("prev-click", h);
    }, v = (h) => {
      o("next-click", h);
    };
    return (h, m) => {
      const p = q$;
      return M(), G("div", H2e, [
        oe(p, Et(a.value, {
          "page-size": l.value,
          onSizeChange: d,
          onCurrentChange: u,
          onChange: s,
          onPrevClick: f,
          onNextClick: v
        }), null, 16, ["page-size"])
      ]);
    };
  }
}), W2e = { class: "k-select" }, gc = /* @__PURE__ */ Q({
  name: "KSelect",
  __name: "select",
  props: {
    modelValue: {},
    multiple: { type: Boolean },
    disabled: { type: Boolean },
    valueKey: { default: "value" },
    clearable: { type: Boolean },
    collapseTags: { type: Boolean },
    collapseTagsTooltip: { type: Boolean },
    multipleLimit: { default: 0 },
    autocomplete: { default: "off" },
    placeholder: {},
    filterable: { type: Boolean },
    filterMethod: {},
    remote: { type: Boolean },
    remoteMethod: {},
    remoteShowSuffix: { type: Boolean },
    loading: { type: Boolean },
    loadingText: {},
    noMatchText: {},
    noDataText: {},
    allowCreate: { type: Boolean },
    size: {},
    width: {},
    popperClass: {},
    teleported: { type: Boolean, default: !0 },
    defaultFirstOption: { type: Boolean },
    fitInputWidth: { type: Boolean },
    suffixIcon: {},
    name: {},
    automaticDropdown: { type: Boolean },
    persistent: { type: Boolean, default: !0 }
  },
  emits: [
    "update:modelValue",
    "blur",
    "change",
    "clear",
    "focus",
    "visible-change",
    "remove-tag"
  ],
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, a = Yn(), r = B(""), i = B(null), s = x(() => ({
      ...u(),
      ...d()
    }));
    Pe(() => o.modelValue, (b) => {
      r.value = b;
    }, { immediate: !0 });
    const u = () => ({
      size: o.size === "sm" ? "small" : ""
    }), d = () => ({
      disabled: o.disabled,
      placeholder: o.placeholder,
      clearable: o.clearable,
      multiple: o.multiple,
      filterable: o.filterable,
      allowCreate: o.allowCreate,
      popperClass: o.popperClass,
      teleported: o.teleported,
      valueKey: o.valueKey,
      collapseTags: o.collapseTags,
      collapseTagsTooltip: o.collapseTagsTooltip,
      multipleLimit: o.multipleLimit,
      autocomplete: o.autocomplete,
      filterMethod: o.filterMethod,
      remote: o.remote,
      remoteMethod: o.remoteMethod,
      remoteShowSuffix: o.remoteShowSuffix,
      loading: o.loading,
      loadingText: o.loadingText,
      noMatchText: o.noMatchText,
      noDataText: o.noDataText,
      defaultFirstOption: o.defaultFirstOption,
      fitInputWidth: o.fitInputWidth,
      suffixIcon: o.suffixIcon,
      name: o.name,
      automaticDropdown: o.automaticDropdown,
      persistent: o.persistent
    });
    function f() {
      l("blur");
    }
    function v() {
      l("focus");
    }
    function h(b) {
      l("update:modelValue", b), l("change", b);
    }
    function m() {
      l("update:modelValue", ""), l("clear", ""), l("change", "");
    }
    function p(b) {
      l("visible-change", b);
    }
    function C(b) {
      l("remove-tag", b);
    }
    function g() {
      var b;
      (b = i.value) == null || b.focus();
    }
    function w() {
      var b;
      (b = i.value) == null || b.blur();
    }
    return t({
      focus: g,
      blur: w
    }), (b, y) => {
      const E = Ns;
      return M(), G("div", W2e, [
        oe(E, Et({
          ref_key: "inputRef",
          ref: i,
          modelValue: r.value,
          "onUpdate:modelValue": y[0] || (y[0] = (S) => r.value = S)
        }, s.value, {
          "default-first-option": "",
          style: {
            width: o.width
          },
          onChange: h,
          onFocus: v,
          onBlur: f,
          onClear: m,
          onVisibleChange: p,
          onRemoveTag: C
        }), rl({
          default: fe(() => [
            Ie(b.$slots, "default")
          ]),
          _: 2
        }, [
          c(a).tag ? {
            name: "tag",
            fn: fe(() => [
              c(a).tag ? Ie(b.$slots, "tag", { key: 0 }) : _e("", !0)
            ]),
            key: "0"
          } : void 0,
          c(a).empty ? {
            name: "empty",
            fn: fe(() => [
              Ie(b.$slots, "empty")
            ]),
            key: "1"
          } : void 0,
          c(a).header ? {
            name: "header",
            fn: fe(() => [
              Ie(b.$slots, "header")
            ]),
            key: "2"
          } : void 0,
          c(a).footer ? {
            name: "footer",
            fn: fe(() => [
              Ie(b.$slots, "footer")
            ]),
            key: "3"
          } : void 0
        ]), 1040, ["modelValue", "style"])
      ]);
    };
  }
}), K2e = { class: "k-option" }, fs = /* @__PURE__ */ Q({
  name: "KOption",
  __name: "option",
  props: {
    value: {},
    label: {},
    disabled: { type: Boolean }
  },
  setup(e) {
    const t = e, n = x(() => ({
      value: t.value,
      label: t.label,
      disabled: t.disabled
    }));
    return (o, l) => {
      const a = Ad;
      return M(), G("div", K2e, [
        oe(a, xo(Ao(n.value)), {
          default: fe(() => [
            Ie(o.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]);
    };
  }
}), U2e = { class: "k-option" }, j2e = /* @__PURE__ */ Q({
  name: "KOptionGroup",
  __name: "option_group",
  props: {
    label: {
      type: String,
      default: ""
    }
  },
  setup(e) {
    const t = e;
    return (n, o) => {
      const l = j$;
      return M(), G("div", U2e, [
        oe(l, {
          label: t.label
        }, {
          default: fe(() => [
            Ie(n.$slots, "default")
          ]),
          _: 3
        }, 8, ["label"])
      ]);
    };
  }
}), q2e = { class: "k-cascader" }, Y2e = /* @__PURE__ */ Q({
  name: "KCascader",
  __name: "cascader",
  props: {
    modelValue: {},
    options: {},
    props: {},
    showAllLevels: { type: Boolean, default: !0 },
    separator: { default: "/" },
    disabled: { type: Boolean },
    clearable: { type: Boolean },
    placeholder: {},
    filterable: { type: Boolean },
    size: {},
    width: {},
    popperClass: {},
    collapseTags: { type: Boolean },
    beforeFilter: {}
  },
  emits: [
    "update:modelValue",
    "blur",
    "change",
    "expand-change",
    "focus",
    "visible-change",
    "remove-tag"
  ],
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, a = B(""), r = B(null), i = x(() => ({
      ...u(),
      ...d()
    })), s = x(() => {
      if (!o.props)
        return {};
      const y = o.props;
      return {
        expandTrigger: (y == null ? void 0 : y.expandTrigger) ?? "click",
        multiple: !!(y != null && y.multiple),
        emitPath: !!(y != null && y.emitPath),
        value: (y == null ? void 0 : y.value) ?? "value",
        label: (y == null ? void 0 : y.label) ?? "label",
        children: (y == null ? void 0 : y.children) ?? "children",
        leaf: (y == null ? void 0 : y.leaf) ?? "leaf",
        lazy: !!(y != null && y.lazy),
        lazyLoad: y.lazyLoad ?? null,
        checkStrictly: !!(y != null && y.checkStrictly)
      };
    });
    Pe(() => o.modelValue, (y) => {
      a.value = y;
    }, { immediate: !0 });
    const u = () => ({
      size: o.size === "sm" ? "small" : ""
    }), d = () => ({
      disabled: o.disabled,
      placeholder: o.placeholder,
      clearable: o.clearable,
      filterable: o.filterable,
      popperClass: o.popperClass,
      separator: o.separator,
      options: f(),
      showAllLevels: o.showAllLevels,
      collapseTags: o.collapseTags,
      beforeFilter: o.beforeFilter
    });
    function f() {
      if (!o.props)
        return {};
      const y = o.props, { lazy: E, lazyLoad: S } = y;
      return E && S ? [] : o.options;
    }
    function v() {
      l("blur");
    }
    function h() {
      l("focus");
    }
    function m(y) {
      l("update:modelValue", y), l("change", y);
    }
    function p(y) {
      l("expand-change", y);
    }
    function C(y) {
      l("visible-change", y);
    }
    function g(y) {
      l("remove-tag", y);
    }
    function w(y) {
      var E;
      (E = r.value) == null || E.getCheckedNodes(y);
    }
    function b(y) {
      var E;
      (E = r.value) == null || E.togglePopperVisible(y);
    }
    return t({
      getCheckedNodes: w,
      togglePopperVisible: b
    }), (y, E) => {
      const S = ZT;
      return M(), G("div", q2e, [
        oe(S, Et({
          ref_key: "cascaderRef",
          ref: r,
          modelValue: a.value,
          "onUpdate:modelValue": E[0] || (E[0] = (_) => a.value = _)
        }, i.value, {
          props: s.value,
          "collapse-tags-tooltip": "",
          onChange: m,
          onFocus: h,
          onBlur: v,
          onExpandChange: p,
          onVisibleChange: C,
          onRemoveTag: g
        }), {
          empty: fe(() => [
            Ie(y.$slots, "empty")
          ]),
          _: 3
        }, 16, ["modelValue", "props"])
      ]);
    };
  }
}), G2e = { class: "k-date-picker" }, n3 = /* @__PURE__ */ Q({
  name: "KDatePicker",
  __name: "date_picker",
  props: {
    modelValue: {},
    type: {},
    format: {},
    valueFormat: {},
    rangeSeparator: { default: "-" },
    disabled: { type: Boolean },
    clearable: { type: Boolean, default: !0 },
    placeholder: {},
    startPlaceholder: {},
    endPlaceholder: {},
    size: {},
    width: {},
    popperClass: {},
    readonly: { type: Boolean },
    editable: { type: Boolean, default: !0 },
    disabledDate: {},
    defaultValue: {},
    defaultTime: {},
    prefixIcon: {},
    teleported: { type: Boolean, default: !0 }
  },
  emits: [
    "update:modelValue",
    "change",
    "focus",
    "blur",
    "calendar-change",
    "visible-change"
  ],
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, a = B(o.modelValue), r = B(null), i = x(() => ({
      ...s(),
      ...u()
    }));
    Pe(() => o.modelValue, (C) => {
      if (C) {
        a.value = C;
        return;
      }
      a.value = "";
    });
    const s = () => ({
      size: o.size === "sm" ? "small" : ""
    }), u = () => ({
      type: o.type,
      format: o.format,
      disabled: o.disabled,
      valueFormat: o.valueFormat,
      rangeSeparator: o.rangeSeparator,
      clearable: o.clearable,
      placeholder: o.placeholder,
      startPlaceholder: o.startPlaceholder,
      endPlaceholder: o.endPlaceholder,
      popperClass: o.popperClass,
      readonly: o.readonly,
      editable: o.editable,
      disabledDate: o.disabledDate,
      defaultValue: o.defaultValue,
      defaultTime: o.defaultTime,
      prefixIcon: o.prefixIcon,
      teleported: o.teleported
    });
    function d(C) {
      const g = C || "";
      l("update:modelValue", g), l("change", g);
    }
    function f(C) {
      l("focus", C);
    }
    function v(C) {
      l("blur", C);
    }
    function h(C) {
      l("calendar-change", C);
    }
    function m(C) {
      l("visible-change", C);
    }
    function p() {
      var C;
      (C = r.value) == null || C.foucus();
    }
    return t({ focus: p }), (C, g) => {
      const w = b$;
      return M(), G("div", G2e, [
        oe(w, Et({
          ref_key: "datePickerRef",
          ref: r,
          modelValue: a.value,
          "onUpdate:modelValue": g[0] || (g[0] = (b) => a.value = b)
        }, i.value, {
          "unlink-panels": "",
          onChange: d,
          onFocus: f,
          onBlur: v,
          onCalendarChange: h,
          onVisibleChange: m
        }), null, 16, ["modelValue"])
      ]);
    };
  }
}), Eo = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [o, l] of t)
    n[o] = l;
  return n;
}, X2e = {
  name: "IconEdit",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, Z2e = ["width", "height", "fill"], J2e = /* @__PURE__ */ X("path", { d: "M20.25 19.5H3.75a.75.75 0 1 0 0 1.5h16.5a.75.75 0 1 0 0-1.5" }, null, -1), Q2e = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M5.487 17.961a.7.7 0 0 1-.237.04.75.75 0 0 1-.705-.982l1.5-4.5a.75.75 0 0 1 .18-.3l9-8.999a.75.75 0 0 1 1.062 0l3 3a.75.75 0 0 1 0 1.062l-9 9a.75.75 0 0 1-.3.18zm.959-1.9 2.91-.97 8.34-8.34-1.94-1.94-8.34 8.34zm1.022-3.068.008-.023zm2.025 2.052.02-.007zm-4.48 1.493L5 16.543z"
}, null, -1), exe = [
  J2e,
  Q2e
];
function txe(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), exe, 16, Z2e))
  ], 2);
}
const nxe = /* @__PURE__ */ Eo(X2e, [["render", txe]]), oxe = {
  name: "IconEmptyBox",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, lxe = ["width", "height", "fill"], axe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M8.667 11.375h-5a.625.625 0 1 0 0 1.25h4.375V14.5c0 .345.28.625.625.625h6.666c.345 0 .625-.28.625-.625v-1.875h4.375a.625.625 0 0 0 0-1.25h-5a.625.625 0 0 0-.625.625v1.875H9.292V12a.625.625 0 0 0-.625-.625"
}, null, -1), rxe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M20.919 11.78q.04.106.04.22v5q0 .95-.672 1.62-.671.672-1.62.672H5.333q-.949 0-1.62-.672-.671-.67-.671-1.62v-5q0-.114.04-.22l2.094-5.585q.251-.67.84-1.079.59-.408 1.306-.408h9.356q.717 0 1.306.408.589.409.84 1.08zm-3.265-5.146 2.054 5.48V17q0 .431-.305.737-.305.305-.736.305H5.333q-.431 0-.736-.305-.305-.306-.305-.737v-4.887l2.054-5.479q.254-.676.976-.676h9.356q.722 0 .976.676"
}, null, -1), sxe = [
  axe,
  rxe
];
function ixe(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), sxe, 16, lxe))
  ], 2);
}
const o3 = /* @__PURE__ */ Eo(oxe, [["render", ixe]]), cxe = {
  name: "IconAdd",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, uxe = ["width", "height", "fill"], dxe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M13 19.875V4.125C13 3.504 12.552 3 12 3s-1 .504-1 1.125v15.75c0 .621.448 1.125 1 1.125s1-.504 1-1.125"
}, null, -1), fxe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M19.875 11H4.125C3.504 11 3 11.448 3 12s.504 1 1.125 1h15.75c.621 0 1.125-.448 1.125-1s-.504-1-1.125-1"
}, null, -1), pxe = [
  dxe,
  fxe
];
function vxe(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), pxe, 16, uxe))
  ], 2);
}
const hxe = /* @__PURE__ */ Eo(cxe, [["render", vxe]]), mxe = {
  name: "IconArrowRight",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, gxe = ["width", "height", "fill"], bxe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "m16.523 12-6.363 6.976a.6.6 0 0 0-.16.409c0 .34.283.615.632.615.18 0 .352-.075.472-.207l6.736-7.384a.604.604 0 0 0 0-.818l-6.736-7.384A.64.64 0 0 0 10.632 4a.624.624 0 0 0-.632.615c0 .151.057.297.16.41z"
}, null, -1), yxe = [
  bxe
];
function Cxe(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), yxe, 16, gxe))
  ], 2);
}
const wxe = /* @__PURE__ */ Eo(mxe, [["render", Cxe]]), Exe = {
  name: "IconCheck",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, Sxe = ["width", "height", "fill"], _xe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M7.952 20.471 21.753 4.658l-1.506-1.316L7.866 17.53l-4.152-4.23-1.428 1.402z"
}, null, -1), xxe = [
  _xe
];
function kxe(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), xxe, 16, Sxe))
  ], 2);
}
const Txe = /* @__PURE__ */ Eo(Exe, [["render", kxe]]), $xe = {
  name: "IconClear",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, Oxe = ["width", "height", "fill"], Nxe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M2 12C2 6.5 6.5 2 12 2s10 4.5 10 10-4.5 10-10 10S2 17.5 2 12m14.535-3.536q0 .2-.076.383-.076.184-.216.325L13.414 12l2.829 2.828q.07.07.124.152.055.082.092.173.038.09.057.187t.02.196-.02.195q-.019.096-.057.187-.037.091-.092.173t-.124.152q-.07.07-.152.124-.082.055-.173.092-.09.038-.187.057t-.195.02q-.099 0-.196-.02-.096-.019-.187-.057-.091-.037-.173-.092t-.152-.124L12 13.414l-2.829 2.829q-.14.14-.324.216t-.383.076-.382-.076-.325-.216q-.07-.07-.124-.152-.055-.082-.093-.173-.037-.09-.056-.187t-.02-.195q0-.099.02-.196.019-.096.056-.187t.093-.173.124-.152L10.586 12 7.757 9.172q-.07-.07-.124-.152-.055-.082-.092-.173-.038-.09-.057-.187t-.02-.196.02-.195q.019-.096.057-.187.037-.091.092-.173t.124-.152q.07-.07.152-.124.082-.055.173-.092.09-.038.187-.057t.195-.02q.099 0 .196.02.096.019.187.057.091.037.173.092t.152.124L12 10.586l2.828-2.829q.141-.14.325-.216.183-.077.382-.077.2 0 .383.077.184.076.325.216.14.141.216.325t.076.382"
}, null, -1), Mxe = [
  Nxe
];
function Ixe(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), Mxe, 16, Oxe))
  ], 2);
}
const l3 = /* @__PURE__ */ Eo($xe, [["render", Ixe]]), Rxe = {
  name: "IconClearDate",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, Dxe = ["width", "height", "fill"], Lxe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "m13.163 12.346 6.393-7.922a.75.75 0 1 0-1.167-.941l-6.393 7.921a.75.75 0 1 0 1.167.942"
}, null, -1), Pxe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M2.292 21.375q0-4.604 2.251-7.528 2.48-3.222 6.832-3.222 1.001 0 1.709.708t.708 1.709l-.004.071q-.045.476-.207.925l-.023.056q-.755 1.667-.663 3.494t1.01 3.41a.75.75 0 0 1-.648 1.127H3.042a.75.75 0 0 1-.75-.75m9.76-.75H3.809q.164-3.578 1.923-5.863 2.03-2.637 5.643-2.637.38 0 .648.268.257.257.268.615-.029.254-.113.496-.89 1.985-.781 4.16.078 1.554.655 2.961M21.375 13.833h-4.167a.75.75 0 1 0 0 1.5h4.167a.75.75 0 0 0 0-1.5M21.375 17.167h-5a.75.75 0 1 0 0 1.5h5a.75.75 0 0 0 0-1.5M21.375 20.5h-3.333a.75.75 0 1 0 0 1.5h3.333a.75.75 0 1 0 0-1.5"
}, null, -1), Axe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M12.307 14.782h-.017q-.055.001-.123.01-1.172.023-1.94-.87-.774-.9-.565-2.07a1 1 0 0 0 .012-.131v-.013a.75.75 0 0 0-.75-.737H8.92a.75.75 0 0 0-.734.618q-.335 1.87.904 3.311 1.237 1.44 3.133 1.392.064-.002.14-.012a.75.75 0 0 0 .695-.748v-.019a.75.75 0 0 0-.75-.731zM7.285 18.683q-.252 1.31-.162 2.641l.002.05a.75.75 0 0 1-.75.751.75.75 0 0 1-.748-.7q-.103-1.524.185-3.025a.75.75 0 0 1 1.473.283M10.223 18.661q-.267 1.65.153 2.312a.75.75 0 0 1 .117.374v.028a.75.75 0 0 1-.731.75h-.019a.75.75 0 0 1-.633-.348q-.726-1.143-.368-3.355a.75.75 0 0 1 .724-.63h.016a.75.75 0 0 1 .75.733v.017a1 1 0 0 1-.01.12"
}, null, -1), Fxe = [
  Lxe,
  Pxe,
  Axe
];
function Vxe(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), Fxe, 16, Dxe))
  ], 2);
}
const Bxe = /* @__PURE__ */ Eo(Rxe, [["render", Vxe]]), Hxe = {
  name: "IconClose",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, zxe = ["width", "height", "fill"], Wxe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M20 5.468 5.468 20 4 18.532 18.532 4z"
}, null, -1), Kxe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M5.468 4 20 18.532 18.532 20 4 5.468z"
}, null, -1), Uxe = [
  Wxe,
  Kxe
];
function jxe(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), Uxe, 16, zxe))
  ], 2);
}
const a3 = /* @__PURE__ */ Eo(Hxe, [["render", jxe]]), qxe = {
  name: "IconDelete",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, Yxe = ["width", "height", "fill"], Gxe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M13.5 5.5V4h-3v1.5a1 1 0 0 1-2 0V3a1 1 0 0 1 1-1h5a1 1 0 0 1 1 1v2.5a1 1 0 0 1-2 0M4.25 9.545l.003.073.671 9.174q.1 1.364 1.127 2.291Q7.065 22 8.446 22h7.103q1.38 0 2.395-.916 1.026-.927 1.127-2.29l.676-9.175q.003-.036.003-.074a1 1 0 0 0-1.997-.073l-.677 9.175q-.041.564-.473.953-.443.4-1.054.4H8.446q-.61 0-1.054-.4-.432-.39-.473-.954l-.672-9.174a1 1 0 0 0-1.997.073"
}, null, -1), Xxe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M3 5h18a1 1 0 1 1 0 2H3a1 1 0 0 1 0-2"
}, null, -1), Zxe = [
  Gxe,
  Xxe
];
function Jxe(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), Zxe, 16, Yxe))
  ], 2);
}
const r3 = /* @__PURE__ */ Eo(qxe, [["render", Jxe]]), Qxe = {
  name: "IconFile",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, eke = ["width", "height", "fill"], tke = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M16.375 15.75h-8.75a.625.625 0 1 0 0 1.25h8.75a.625.625 0 1 0 0-1.25M16.375 12h-8.75a.625.625 0 1 0 0 1.25h8.75a.625.625 0 1 0 0-1.25M10.125 8.25h-2.5a.625.625 0 1 0 0 1.25h2.5a.625.625 0 1 0 0-1.25"
}, null, -1), nke = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M20.567 8.433a.63.63 0 0 1 .183.442v12.5c0 .345-.28.625-.625.625H3.875a.625.625 0 0 1-.625-.625V2.625c0-.345.28-.625.625-.625h10c.166 0 .325.066.442.183zm-6.95-5.183L19.5 9.134V20.75h-15V3.25z"
}, null, -1), oke = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M20.125 9.5h-6.25a.625.625 0 0 1-.625-.625v-6.25a.625.625 0 1 1 1.25 0V8.25h5.625a.625.625 0 1 1 0 1.25"
}, null, -1), lke = [
  tke,
  nke,
  oke
];
function ake(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), lke, 16, eke))
  ], 2);
}
const rke = /* @__PURE__ */ Eo(Qxe, [["render", ake]]), ske = {
  name: "IconFilterFill",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, ike = ["width", "height", "fill"], cke = /* @__PURE__ */ X("path", { d: "M4 4h16l-5.818 9.273v4.636L9.818 21v-7.727z" }, null, -1), uke = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M8.818 13.56V21q0 .155.047.303t.137.275q.057.08.129.148.071.068.154.12.084.053.176.088t.189.052q.097.016.195.014.099-.003.195-.025t.186-.062.17-.097l4.364-3.09q.098-.07.176-.16.079-.091.134-.198.055-.106.083-.223.029-.116.029-.236V13.56l5.665-9.029Q21 4.288 21 4q0-.098-.02-.195-.018-.097-.056-.188-.038-.09-.093-.173-.054-.081-.124-.151t-.151-.124q-.082-.055-.173-.093t-.188-.057T20 3H4q-.288 0-.531.153-.084.052-.156.12-.071.068-.128.148t-.098.17-.062.186T3 3.97t.014.196.052.189.087.175zm2-.287q0-.288-.153-.532L5.808 5h12.384l-4.857 7.741q-.153.244-.153.532v4.119l-2.364 1.674z"
}, null, -1), dke = [
  cke,
  uke
];
function fke(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), dke, 16, ike))
  ], 2);
}
const pke = /* @__PURE__ */ Eo(ske, [["render", fke]]), vke = {
  name: "IconFilter",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, hke = ["width", "height", "fill"], mke = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M9.068 21v-7.511l-5.703-9.09A.75.75 0 0 1 4 3.25h16a.75.75 0 0 1 .635 1.149l-5.703 9.09v4.42a.75.75 0 0 1-.317.612l-4.363 3.091A.75.75 0 0 1 9.068 21m1.385-8.126a.75.75 0 0 1 .115.399v6.277l2.864-2.029v-4.248c0-.141.04-.28.114-.399l5.098-8.124H5.356z"
}, null, -1), gke = [
  mke
];
function bke(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), gke, 16, hke))
  ], 2);
}
const yke = /* @__PURE__ */ Eo(vke, [["render", bke]]), Cke = {
  name: "IconFold",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, wke = ["width", "height", "fill"], Eke = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M13.628 13.1h7.714c.355 0 .643-.28.643-.625a.634.634 0 0 0-.643-.625h-7.714a.634.634 0 0 0-.643.625c0 .345.288.625.643.625"
}, null, -1), Ske = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "m17.94 9.167-3.403 3.308 3.402 3.308a.617.617 0 0 1 0 .884.65.65 0 0 1-.423.182l-.03.001a.65.65 0 0 1-.455-.183l-3.858-3.75a.616.616 0 0 1 0-.884l3.858-3.75a.65.65 0 0 1 .909 0 .616.616 0 0 1 0 .884M10.342 11.85H2.628a.634.634 0 0 0-.643.625c0 .345.288.625.643.625h7.714c.355 0 .643-.28.643-.625a.634.634 0 0 0-.643-.625"
}, null, -1), _ke = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "m6.03 15.783 3.403-3.308-3.402-3.308a.617.617 0 0 1 0-.884.65.65 0 0 1 .423-.182l.031-.001c.17 0 .334.066.455.183l3.857 3.75a.616.616 0 0 1 0 .884l-3.857 3.75a.65.65 0 0 1-.91 0 .616.616 0 0 1 0-.884"
}, null, -1), xke = [
  Eke,
  Ske,
  _ke
];
function kke(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), xke, 16, wke))
  ], 2);
}
const Tke = /* @__PURE__ */ Eo(Cke, [["render", kke]]), $ke = {
  name: "IconHide",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, Oke = ["width", "height", "fill"], Nke = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M12.016 19.508q-3.089 0-6.019-2.305-1.892-1.488-3.449-3.693-.448-.64-.448-1.419 0-.778.446-1.415 1.56-2.208 3.451-3.696 2.93-2.305 6.02-2.305 3.088 0 6.018 2.305 1.893 1.488 3.45 3.693.448.64.448 1.418t-.446 1.416q-1.56 2.208-3.452 3.696-2.93 2.305-6.019 2.305m0-1.5q2.57 0 5.092-1.984 1.72-1.353 3.15-3.377.388-.556.002-1.109-1.432-2.026-3.152-3.38-2.522-1.983-5.092-1.983T6.925 8.159q-1.72 1.353-3.15 3.376-.389.556-.002 1.11 1.431 2.026 3.152 3.38 2.522 1.983 5.091 1.983"
}, null, -1), Mke = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M14.904 14.979Q16.1 13.783 16.1 12.09t-1.196-2.887-2.888-1.196T9.13 9.204t-1.196 2.887 1.196 2.888 2.887 1.196 2.888-1.196m-1.061-4.714q.757.756.757 1.826t-.757 1.827-1.827.757-1.826-.757-.757-1.827.757-1.826q.756-.757 1.826-.757t1.827.757"
}, null, -1), Ike = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M19.73 3.14 3.065 19.805a.75.75 0 1 0 1.06 1.06L20.793 4.2a.75.75 0 0 0-1.061-1.06"
}, null, -1), Rke = [
  Nke,
  Mke,
  Ike
];
function Dke(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), Rke, 16, Oke))
  ], 2);
}
const Lke = /* @__PURE__ */ Eo($ke, [["render", Dke]]), Pke = {
  name: "IconMore",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, Ake = ["width", "height", "fill"], Fke = /* @__PURE__ */ X("rect", {
  width: "4",
  height: "4",
  x: "3",
  y: "10",
  rx: "2"
}, null, -1), Vke = /* @__PURE__ */ X("rect", {
  width: "4",
  height: "4",
  x: "10",
  y: "10",
  rx: "2"
}, null, -1), Bke = /* @__PURE__ */ X("rect", {
  width: "4",
  height: "4",
  x: "17",
  y: "10",
  rx: "2"
}, null, -1), Hke = [
  Fke,
  Vke,
  Bke
];
function zke(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), Hke, 16, Ake))
  ], 2);
}
const Y1 = /* @__PURE__ */ Eo(Pke, [["render", zke]]), Wke = {
  name: "IconRefresh",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, Kke = ["width", "height", "fill"], Uke = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M18.592 7.487q-1.715-2.693-4.797-3.49-3.137-.81-5.963.833-1.665.968-2.714 2.57-1.006 1.534-1.276 3.376-.27 1.843.25 3.612.545 1.847 1.86 3.273 1.312 1.421 3.11 2.086 1.72.636 3.57.471 1.85-.164 3.434-1.094 1.655-.972 2.702-2.605v-.001a.75.75 0 0 1 1.264.809q-1.24 1.937-3.207 3.09-1.874 1.102-4.061 1.296t-4.223-.56q-2.135-.789-3.69-2.475-1.554-1.683-2.197-3.866-.615-2.085-.296-4.254.318-2.17 1.505-3.98Q5.107 4.68 7.078 3.532q3.358-1.953 7.093-.988 1.74.45 3.202 1.504 1.493 1.077 2.484 2.632a.75.75 0 1 1-1.265.806"
}, null, -1), jke = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M15 7.25h4.25V2.5h1.5v6.25H15z"
}, null, -1), qke = [
  Uke,
  jke
];
function Yke(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), qke, 16, Kke))
  ], 2);
}
const Gke = /* @__PURE__ */ Eo(Wke, [["render", Yke]]), Xke = {
  name: "IconStatusSuccess",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, Zke = ["width", "height", "fill"], Jke = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M12.1 22.101q.246 0 .491-.012t.49-.036.487-.06.484-.084q.24-.048.478-.108.239-.06.474-.13.234-.072.466-.155.23-.082.458-.176.226-.094.448-.2.222-.104.439-.22.216-.116.427-.242.21-.126.415-.262.204-.137.4-.283.198-.146.388-.302t.371-.32q.182-.166.356-.34.174-.173.338-.355t.321-.371.302-.387.283-.402.262-.414q.126-.21.242-.427t.22-.439q.106-.222.2-.449.094-.226.176-.457.083-.232.154-.467.072-.234.131-.473t.108-.479.084-.483.06-.487q.024-.245.036-.49t.012-.49-.012-.491-.036-.49q-.024-.244-.06-.487t-.084-.484-.108-.478-.13-.474-.155-.466q-.082-.23-.176-.458-.094-.226-.2-.448-.104-.222-.22-.439-.116-.216-.242-.427-.126-.21-.262-.415-.137-.204-.283-.4-.146-.198-.302-.388t-.32-.371-.34-.356q-.173-.174-.355-.338-.181-.165-.371-.321t-.387-.302-.401-.283-.415-.262-.427-.242-.439-.22q-.222-.106-.448-.2-.227-.094-.458-.176-.232-.083-.466-.154-.235-.072-.474-.131-.238-.06-.478-.108-.241-.048-.484-.084t-.487-.06-.49-.036-.49-.012-.491.012-.49.036-.487.06-.483.084-.48.108-.472.13-.467.155-.458.176q-.226.094-.448.2-.222.104-.439.22-.216.116-.427.242-.21.126-.414.262-.205.137-.402.283t-.387.302-.371.32-.356.34q-.174.173-.338.355-.165.181-.321.371t-.302.387-.283.401-.262.415-.242.427-.22.439-.2.448-.176.458q-.083.232-.154.466-.072.235-.131.474-.06.238-.108.478-.048.241-.084.484t-.06.487-.036.49-.012.49.012.491.036.49.06.487.084.483.108.48.13.472.155.467.176.457.2.45q.104.221.22.438.116.216.242.427.126.21.262.414.137.205.283.402t.302.387.32.371.34.356q.173.173.355.338.181.165.371.321t.387.302.402.283q.204.136.414.262t.427.242.439.22.448.2.458.176.467.154.473.131.479.108.483.084.487.06.49.036.49.012m-1.784-5.296 6.889-7.925a.9.9 0 0 0-1.359-1.18l-5.922 6.812a.273.273 0 0 1-.385.027L8.16 13.34A.9.9 0 0 0 6.98 14.7l2.49 2.165a.6.6 0 0 0 .846-.06"
}, null, -1), Qke = [
  Jke
];
function eTe(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), Qke, 16, Zke))
  ], 2);
}
const tTe = /* @__PURE__ */ Eo(Xke, [["render", eTe]]), nTe = {
  name: "IconTableSortDownColor",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, oTe = ["width", "height", "fill"], lTe = /* @__PURE__ */ X("path", {
  fill: "#2882FF",
  d: "M6.375 13.25h11.25L12 19.5z"
}, null, -1), aTe = /* @__PURE__ */ X("path", {
  fill: "#CDCACF",
  d: "m12 4.5 5.625 6.25H6.375z"
}, null, -1), rTe = [
  lTe,
  aTe
];
function sTe(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), rTe, 16, oTe))
  ], 2);
}
const iTe = /* @__PURE__ */ Eo(nTe, [["render", sTe]]), cTe = {
  name: "IconTableSortNormalColor",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, uTe = ["width", "height", "fill"], dTe = /* @__PURE__ */ X("path", {
  fill: "#CDCACF",
  d: "m12 4.5 5.625 6.25H6.375zm-5.625 8.75h11.25L12 19.5z"
}, null, -1), fTe = [
  dTe
];
function pTe(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), fTe, 16, uTe))
  ], 2);
}
const vTe = /* @__PURE__ */ Eo(cTe, [["render", pTe]]), hTe = {
  name: "IconTableSortUpColor",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, mTe = ["width", "height", "fill"], gTe = /* @__PURE__ */ X("path", {
  fill: "#CDCACF",
  d: "M6.375 13.25h11.25L12 19.5z"
}, null, -1), bTe = /* @__PURE__ */ X("path", {
  fill: "#2882FF",
  d: "m12 4.5 5.625 6.25H6.375z"
}, null, -1), yTe = [
  gTe,
  bTe
];
function CTe(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), yTe, 16, mTe))
  ], 2);
}
const wTe = /* @__PURE__ */ Eo(hTe, [["render", CTe]]), ETe = {
  name: "IconTips",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, STe = ["width", "height", "fill"], _Te = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M22 12c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2s10 4.477 10 10m-1.5 0q0-1.621-.597-3.129-.648-1.637-1.893-2.881-1.244-1.245-2.881-1.893Q13.62 3.5 12 3.5t-3.129.597Q7.234 4.745 5.99 5.99 4.745 7.234 4.097 8.87 3.5 10.38 3.5 12t.597 3.129q.648 1.637 1.893 2.881 1.244 1.245 2.881 1.893Q10.38 20.5 12 20.5t3.129-.597q1.637-.648 2.881-1.893 1.245-1.244 1.893-2.881Q20.5 13.62 20.5 12"
}, null, -1), xTe = /* @__PURE__ */ X("path", { d: "M12.01 8.361q-.608 0-.85-.189-.241-.189-.241-.882 0-.714.241-.892.242-.179.85-.179.568 0 .82.179.252.178.252.892 0 .693-.252.882t-.82.19m-.923 2.08h1.806v7.34h-1.806z" }, null, -1), kTe = [
  _Te,
  xTe
];
function TTe(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), kTe, 16, STe))
  ], 2);
}
const s3 = /* @__PURE__ */ Eo(ETe, [["render", TTe]]), $Te = {
  name: "IconUnfold",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, OTe = ["width", "height", "fill"], NTe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M2.643 13h7.714c.355 0 .643-.28.643-.625a.634.634 0 0 0-.643-.625H2.643a.634.634 0 0 0-.643.625c0 .345.288.625.643.625"
}, null, -1), MTe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "m6.955 9.067-3.403 3.308 3.402 3.308a.617.617 0 0 1 0 .884.65.65 0 0 1-.423.182l-.031.001a.65.65 0 0 1-.455-.183l-3.857-3.75a.616.616 0 0 1 0-.884l3.857-3.75a.65.65 0 0 1 .91 0 .616.616 0 0 1 0 .884M21.357 11.8h-7.714a.634.634 0 0 0-.643.625c0 .345.288.625.643.625h7.714c.355 0 .643-.28.643-.625a.634.634 0 0 0-.643-.625"
}, null, -1), ITe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "m17.045 15.733 3.403-3.308-3.402-3.308a.617.617 0 0 1 0-.884.65.65 0 0 1 .423-.182l.031-.001c.17 0 .334.066.455.183l3.857 3.75a.616.616 0 0 1 0 .884l-3.857 3.75a.65.65 0 0 1-.91 0 .616.616 0 0 1 0-.884"
}, null, -1), RTe = [
  NTe,
  MTe,
  ITe
];
function DTe(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), RTe, 16, OTe))
  ], 2);
}
const LTe = /* @__PURE__ */ Eo($Te, [["render", DTe]]), PTe = {
  name: "IconUpload",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, ATe = ["width", "height", "fill"], FTe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M3.667 14.5a.833.833 0 0 0-.834.833v3.334q0 1.035.733 1.767.732.733 1.767.733h13.334q1.035 0 1.767-.733.733-.732.733-1.767v-3.334a.833.833 0 1 0-1.667 0v3.334q0 .345-.244.589t-.59.244H5.334q-.345 0-.589-.244t-.244-.59v-3.333a.833.833 0 0 0-.833-.833"
}, null, -1), VTe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M11.167 16.167v-12.5a.833.833 0 1 1 1.666 0v12.5a.833.833 0 0 1-1.666 0"
}, null, -1), BTe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "m7.244 7.244 4.167-4.167a.833.833 0 0 1 1.178 0l4.167 4.167a.833.833 0 0 1-1.179 1.179L12 4.845 8.423 8.422a.834.834 0 1 1-1.179-1.178"
}, null, -1), HTe = [
  FTe,
  VTe,
  BTe
];
function zTe(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), HTe, 16, ATe))
  ], 2);
}
const A2 = /* @__PURE__ */ Eo(PTe, [["render", zTe]]), WTe = {
  name: "IconWarning",
  props: {
    size: {
      type: [Number, String],
      default: "1em"
    },
    color: {
      type: String,
      default: "currentColor"
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    iconClasses() {
      return [
        "ksw-icon",
        "ksw-icon-" + this.$options.name.toLowerCase(),
        { "ksw-icon-spin": this.spin }
      ];
    }
  }
}, KTe = ["width", "height", "fill"], UTe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M4.58 21.083h-.003q-1.402.005-2.13-1.194-.729-1.201-.075-2.444L9.797 3.408q.324-.612.918-.97.594-.357 1.287-.357t1.286.357.918.97l7.424 14.036q.656 1.245-.075 2.447-.73 1.201-2.136 1.192zm-.003-1.5h14.851q.557.004.846-.472.289-.475.03-.966L12.88 4.11q-.28-.53-.878-.53-.6 0-.88.53L3.7 18.143q-.26.492.03.968.287.475.843.472z"
}, null, -1), jTe = /* @__PURE__ */ X("path", {
  "fill-rule": "evenodd",
  d: "M13.167 8.667v5a1 1 0 0 1-2 0v-5a1 1 0 0 1 2 0"
}, null, -1), qTe = /* @__PURE__ */ X("circle", {
  cx: "12",
  cy: "16.583",
  r: "1.25"
}, null, -1), YTe = [
  UTe,
  jTe,
  qTe
];
function GTe(e, t, n, o, l, a) {
  return M(), G("span", {
    class: z(a.iconClasses)
  }, [
    (M(), G("svg", Et({
      xmlns: "http://www.w3.org/2000/svg",
      width: n.size,
      height: n.size,
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, e.$attrs, { fill: n.color }), YTe, 16, KTe))
  ], 2);
}
const _h = /* @__PURE__ */ Eo(WTe, [["render", GTe]]), XTe = {
  key: 0,
  class: "default-sign"
}, ZTe = {
  key: 0,
  class: "file-list"
}, JTe = { class: "header-icon" }, QTe = ["title"], e$e = { class: "status-icon-box" }, t$e = { class: "status-icon" }, n$e = { class: "remove-file" }, o$e = { class: "el-upload__tip" }, l$e = /* @__PURE__ */ Q({
  name: "KUpload",
  __name: "upload",
  props: {
    action: {},
    headers: {},
    method: { default: "post" },
    multiple: { type: Boolean },
    data: {},
    showFileList: { type: Boolean, default: !0 },
    drag: { type: Boolean },
    withCredentials: { type: Boolean },
    accept: {},
    name: { default: "file" },
    crossorigin: {},
    onPreview: {},
    onRemove: {},
    onSuccess: {},
    onError: {},
    onProgress: {},
    onChange: {},
    onExceed: {},
    beforeUpload: {},
    beforeRemove: {},
    modelValue: {},
    autoUpload: { type: Boolean, default: !0 },
    listType: { default: "text" },
    disabled: { type: Boolean, default: !1 },
    limit: {},
    httpRequest: {},
    removeIcon: {},
    successIcon: {},
    failIcon: {}
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, a = Yn(), r = B(null), i = B(o.modelValue || []), s = x(() => ({
      action: o.action,
      headers: o.headers,
      method: o.method,
      multiple: o.multiple,
      data: o.data,
      showFileList: o.showFileList,
      withCredentials: o.withCredentials,
      accept: o.accept,
      name: o.name,
      crossorigin: o.crossorigin,
      onPreview: o.onPreview,
      onRemove: o.onRemove,
      onSuccess: o.onSuccess,
      onError: o.onError,
      onProgress: o.onProgress,
      onChange: o.onChange,
      onExceed: o.onExceed,
      beforeUpload: o.beforeUpload,
      beforeRemove: o.beforeRemove,
      autoUpload: o.autoUpload,
      listType: o.listType,
      disabled: o.disabled,
      limit: o.limit,
      httpRequest: o.httpRequest,
      removeIcon: o.removeIcon,
      successIcon: o.successIcon,
      failIcon: o.failIcon,
      drag: o.drag
    }));
    Pe(() => o.modelValue, (g) => {
      i.value = g;
    }), Pe(() => i.value, (g) => {
      o.modelValue && l("update:modelValue", g);
    });
    function u(g) {
      var w;
      (w = r.value) == null || w.abort(g);
    }
    function d(g) {
      var w;
      g && g.stopPropagation(), g && g.preventDefault(), (w = r.value) == null || w.submit();
    }
    function f(g) {
      var w;
      (w = r.value) == null || w.clearFiles(g);
    }
    function v(g) {
      var w;
      (w = r.value) == null || w.handleStart(g);
    }
    function h(g, w) {
      var b;
      (b = r.value) == null || b.handleRemove(g, w);
    }
    function m() {
    }
    function p(g, w) {
      const { onChange: b } = o;
      b == null || b(g, w);
      const { uid: y, status: E } = g, S = i.value.find((_) => _.uid === y);
      S ? S.status = E : i.value.push(g);
    }
    function C() {
      r.value.$el.querySelector("input").click();
    }
    return t({
      abort: u,
      submit: d,
      clearFiles: f,
      selectFile: C,
      handleStart: v,
      handleRemove: h
    }), (g, w) => {
      const b = Dt("k-button"), y = c0, E = uN;
      return M(), G("div", {
        class: z(["k-upload", { "k-dragger": o.drag }])
      }, [
        oe(E, Et({
          ref_key: "KUploadRef",
          ref: r,
          "file-list": i.value,
          "onUpdate:fileList": w[1] || (w[1] = (S) => i.value = S)
        }, s.value, { "on-change": p }), {
          trigger: fe(() => [
            Ie(g.$slots, "default", {}, () => [
              o.drag ? (M(), G("div", XTe, [
                oe(c(o3), { color: "#2882ff" }),
                Ut(" " + Qe(g.$t("uploadDragSign")), 1)
              ])) : (M(), G("div", {
                key: 1,
                class: "default-upload-btn",
                onClick: w[0] || (w[0] = It(() => {
                }, ["stop"]))
              }, [
                oe(b, {
                  type: "secondary",
                  onClick: C
                }, {
                  default: fe(() => [
                    o.autoUpload ? (M(), We(c(A2), { key: 0 })) : _e("", !0),
                    Ut(" " + Qe(o.autoUpload ? g.$t("uploadFile") : g.$t("selectFile")), 1)
                  ]),
                  _: 1
                }),
                o.autoUpload ? _e("", !0) : (M(), We(b, {
                  key: 0,
                  type: "main",
                  class: "main-btn",
                  disabled: o.disabled,
                  onClick: d
                }, {
                  default: fe(() => [
                    oe(c(A2)),
                    Ut(" " + Qe(g.$t("uploadFile")), 1)
                  ]),
                  _: 1
                }, 8, ["disabled"]))
              ]))
            ])
          ]),
          file: fe(({ file: S }) => [
            c(a).file ? Ie(g.$slots, "file", { key: 1 }) : (M(), G("div", ZTe, [
              X("div", null, [
                X("a", { onClick: m }, [
                  X("span", JTe, [
                    oe(c(rke))
                  ]),
                  X("span", {
                    title: S.name
                  }, Qe(S.name), 9, QTe)
                ]),
                S.status === "uploading" ? (M(), We(y, {
                  key: 0,
                  type: "line",
                  "stroke-width": 2,
                  percentage: Number(S.percentage),
                  style: "margin-top: 0.5rem"
                }, null, 8, ["percentage"])) : _e("", !0)
              ]),
              X("div", e$e, [
                X("span", t$e, [
                  !o.successIcon && S.status === "success" ? (M(), We(c(Txe), {
                    key: 0,
                    class: "default-success-icon"
                  })) : !o.failIcon && S.status === "fail" ? (M(), We(c(_h), {
                    key: 1,
                    class: "default-fail-icon"
                  })) : o.successIcon && S.status === "success" ? (M(), We(o.successIcon, { key: 2 })) : o.failIcon && S.status === "fail" ? (M(), We(o.failIcon, { key: 3 })) : _e("", !0)
                ]),
                X("span", n$e, [
                  o.removeIcon ? (M(), We(o.removeIcon, {
                    key: 0,
                    onClick: (_) => h(S)
                  }, null, 8, ["onClick"])) : (M(), We(c(r3), {
                    key: 1,
                    class: "default-remove-icon",
                    onClick: (_) => h(S)
                  }, null, 8, ["onClick"]))
                ])
              ])
            ]))
          ]),
          default: fe(() => [
            X("div", o$e, [
              Ie(g.$slots, "tip")
            ])
          ]),
          _: 3
        }, 16, ["file-list"])
      ], 2);
    };
  }
}), a$e = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20fill='none'%20version='1.1'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cdefs%3e%3cclipPath%20id='master_svg0_450_84265'%3e%3crect%20x='0'%20y='0'%20width='24'%20height='24'%20rx='0'/%3e%3c/clipPath%3e%3cclipPath%20id='master_svg1_3105_3983'%3e%3crect%20x='0'%20y='0'%20width='24'%20height='24'%20rx='0'/%3e%3c/clipPath%3e%3c/defs%3e%3cg%20clip-path='url(%23master_svg0_450_84265)'%3e%3cg%20clip-path='url(%23master_svg1_3105_3983)'%3e%3c/g%3e%3cg%20transform='matrix(0,1,-1,0,24,-16)'%3e%3cg%3e%3cg%3e%3cpath%20d='M28,18.5234L21.02422,12.159531C20.911577,12.0567654,20.766101,12,20.615385,12C20.275517,12,20,12.282768,20,12.631579C20,12.811982,20.0751679,12.983774,20.206545,13.10363L27.591160000000002,19.84047C27.82432,20.053179999999998,28.17568,20.053179999999998,28.408839999999998,19.84047L35.7929,13.10416L35.7929,13.10416C35.9248,12.983774,36,12.811982,36,12.631579C36,12.282768,35.7245,12,35.3846,12C35.2339,12,35.0884,12.0567654,34.9758,12.159531L34.9758,12.159531L28,18.5234Z'%20fill-rule='evenodd'%20fill='%2338363C'%20fill-opacity='1'/%3e%3c/g%3e%3cg%3e%3cpath%20d='M28,10.523399999999999L21.02422,4.159531C20.911577,4.0567654,20.766101,4,20.615385,4C20.275517,4,20,4.282768,20,4.631579C20,4.811982,20.0751679,4.983774,20.206545,5.10363L27.591160000000002,11.84047C27.82432,12.05318,28.17568,12.05318,28.408839999999998,11.84047L35.7929,5.10416L35.7929,5.10416C35.9248,4.983774,36,4.811982,36,4.631579C36,4.282768,35.7245,4,35.3846,4C35.2339,4,35.0884,4.0567654,34.9758,4.159531L34.9758,4.159531L28,10.523399999999999Z'%20fill-rule='evenodd'%20fill='%2338363C'%20fill-opacity='1'/%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e", r$e = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20fill='none'%20version='1.1'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cdefs%3e%3cclipPath%20id='master_svg0_3069_6476'%3e%3crect%20x='0'%20y='0'%20width='24'%20height='24'%20rx='0'/%3e%3c/clipPath%3e%3cclipPath%20id='master_svg1_3105_3984'%3e%3crect%20x='0'%20y='0'%20width='24'%20height='24'%20rx='0'/%3e%3c/clipPath%3e%3c/defs%3e%3cg%20clip-path='url(%23master_svg0_3069_6476)'%3e%3cg%20clip-path='url(%23master_svg1_3105_3984)'%3e%3c/g%3e%3cg%20transform='matrix(0,-1,1,0,-16,24)'%3e%3cg%3e%3cg%3e%3cpath%20d='M12,34.39683575515747L5.02422,27.48749075515747C4.911577,27.37591675515747,4.766101,27.31428575515747,4.615385,27.31428575515747C4.275517,27.31428575515747,4,27.62129075515747,4,27.99999975515747C4,28.19586575515747,4.0751679,28.382385755157472,4.206545,28.51250575515747L11.59116,35.82679575515747C11.82432,36.057735755157466,12.17568,36.057735755157466,12.40884,35.82679575515747L19.7929,28.51308575515747L19.7929,28.51308575515747C19.924799999999998,28.382385755157472,20,28.19586575515747,20,27.99999975515747C20,27.62129075515747,19.7245,27.31428575515747,19.3846,27.31428575515747C19.2339,27.31428575515747,19.0884,27.37591675515747,18.9758,27.48749075515747L18.9758,27.48749075515747L12,34.39683575515747Z'%20fill-rule='evenodd'%20fill='%2338363C'%20fill-opacity='1'/%3e%3c/g%3e%3cg%3e%3cpath%20d='M12,27.08255L5.02422,20.173205C4.911577,20.061631,4.766101,20,4.615385,20C4.275517,20,4,20.307005,4,20.685714C4,20.88158,4.0751679,21.0681,4.206545,21.19822L11.59116,28.51251C11.82432,28.74345,12.17568,28.74345,12.40884,28.51251L19.7929,21.1988L19.7929,21.1988C19.924799999999998,21.0681,20,20.88158,20,20.685714C20,20.307005,19.7245,20,19.3846,20C19.2339,20,19.0884,20.061631,18.9758,20.173205L18.9758,20.173205L12,27.08255Z'%20fill-rule='evenodd'%20fill='%2338363C'%20fill-opacity='1'/%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e", s$e = ["id"], i$e = { class: "k-transfer_seacher" }, c$e = /* @__PURE__ */ Q({
  name: "KTransfer",
  __name: "transfer",
  props: {
    modelValue: {},
    data: {},
    filterable: { type: Boolean },
    filterablePlaceholder: {},
    targetOrder: {},
    titles: {},
    buttonTexts: {},
    renderContent: {},
    format: {},
    props: {},
    leftDefaultChecked: {},
    rightDefaultChecked: {},
    filterMethod: {},
    matchKey: { default: "label" },
    defaultKeys: {}
  },
  emits: [
    "update:modelValue",
    "change",
    "left-check-change",
    "right-check-change",
    "input"
  ],
  setup(e, { emit: t }) {
    var y;
    const n = e, o = t, l = (y = Pt()) == null ? void 0 : y.appContext.app.config.globalProperties, a = B([]), r = B(""), i = B(n.data || []);
    let s = null, u = [];
    const d = Sh(8);
    Nt(() => {
      g();
    });
    const f = x(() => ({
      data: n.data,
      format: n.format,
      targetOrder: n.targetOrder,
      titles: n.titles ?? [l == null ? void 0 : l.$t("unselectedFields"), l == null ? void 0 : l.$t("selectedFields")],
      buttonTexts: n.buttonTexts,
      renderContent: n.renderContent,
      filterablePlaceholder: n.filterablePlaceholder,
      props: n.props,
      leftDefaultChecked: n.leftDefaultChecked,
      rightDefaultChecked: n.rightDefaultChecked,
      filterMethod: n.filterMethod
    })), v = x(() => ({
      label: "label",
      key: "key",
      disabled: "disabled",
      ...n.props
    })), h = x(() => n.filterablePlaceholder ?? (l == null ? void 0 : l.$t("searchHeaderName")));
    Pe(() => [n.modelValue, n.matchKey], () => {
      if (!Array.isArray(n.modelValue))
        return [];
      a.value = [], n.modelValue.forEach((E) => {
        const S = i.value.find((_) => _[n.matchKey] === E[n.matchKey]);
        if (S) {
          const { key: _ } = v.value;
          a.value.push(S[_]);
        }
      });
    }, { immediate: !0 }), Pe(() => n.data, (E) => {
      if (E) {
        i.value = E;
        return;
      }
      i.value = [];
    }), Pe(() => r.value, (E) => {
      for (let S = 0; S < u.length; S++) {
        u[S].value = E;
        const _ = new Event("input", { bubbles: !0 });
        u[S].dispatchEvent(_);
      }
    }, { immediate: !0 });
    function m(E, S, _) {
      const k = b(E);
      o("update:modelValue", k), o("change", E, S, _);
    }
    function p(E, S) {
      o("left-check-change", E, S);
    }
    function C(E, S) {
      o("right-check-change", E, S);
    }
    function g() {
      if (s = document.getElementById(d), s === null)
        return;
      u = s.querySelectorAll(".el-transfer-panel__filter input");
      const E = s.querySelectorAll(".el-transfer-panel__header")[1], S = document.createElement("label");
      S.innerHTML = l == null ? void 0 : l.$t("restoreDefault"), S.classList.add("transfer-restore__text"), S.addEventListener("click", () => {
        w();
      }), E.appendChild(S);
      const _ = s.querySelectorAll(".el-transfer__button");
      _[0].innerHTML = `<img class="k-transfer__left-arrow" src="${a$e}" />`, _[1].innerHTML = `<img class="k-transfer__right-arrow" src="${r$e}" />`;
    }
    function w() {
      const { key: E } = v.value, S = n.data.filter((_) => {
        var k;
        return (k = n.defaultKeys) == null ? void 0 : k.includes(_[E]);
      });
      o("update:modelValue", S);
    }
    function b(E) {
      const S = [], { key: _ } = v.value;
      for (const k of E) {
        const N = i.value.find((L) => L[_] === k);
        N && S.push(N);
      }
      return S;
    }
    return (E, S) => {
      const _ = GO;
      return M(), G("div", {
        id: c(d),
        class: "k-transfer"
      }, [
        X("div", i$e, [
          oe(c(Eh), {
            modelValue: r.value,
            "onUpdate:modelValue": S[0] || (S[0] = (k) => r.value = k),
            placeholder: h.value,
            "prefix-icon": c(Xx)
          }, null, 8, ["modelValue", "placeholder", "prefix-icon"])
        ]),
        oe(_, Et({
          ref: "kTransferRef",
          modelValue: a.value,
          "onUpdate:modelValue": S[1] || (S[1] = (k) => a.value = k)
        }, f.value, {
          data: i.value,
          format: {
            noChecked: " ",
            hasChecked: " "
          },
          filterable: "",
          onChange: m,
          onLeftCheckChange: p,
          onRightCheckChange: C
        }), {
          "left-footer": fe(() => [
            Ie(E.$slots, "left-footer")
          ]),
          "right-footer": fe(() => [
            Ie(E.$slots, "right-footer")
          ]),
          _: 3
        }, 16, ["modelValue", "data"])
      ], 8, s$e);
    };
  }
}), u$e = { class: "k-operate" }, d$e = { class: "k-operate__header" }, f$e = { class: "k-operate__content" }, p$e = { class: "k-operate__list" }, v$e = { class: "list-header" }, h$e = ["onClick"], m$e = { class: "k-operate-rest" }, g$e = { class: "el-dropdown-link" }, b$e = { class: "k-operate__close" }, y$e = /* @__PURE__ */ Q({
  name: "KOperate",
  __name: "operate",
  props: {
    dataSize: {
      type: Number || String,
      default: () => "--"
    },
    modelValue: {
      type: Array,
      default: () => [],
      reuired: !0
    },
    max: {
      type: Number,
      default: () => 5
    },
    visible: {
      type: Boolean,
      default: () => !1,
      reuired: !0
    }
  },
  emits: ["run", "close"],
  setup(e, { emit: t }) {
    const n = e, o = B(n.modelValue), l = B(n.visible), a = B([]);
    Pe(() => [n.modelValue, n.max], () => {
      const { max: u } = n;
      n.modelValue.length > u && (o.value = n.modelValue.slice(0, u), a.value = n.modelValue.slice(u));
    }, { immediate: !0 }), Pe(() => n.visible, (u) => {
      l.value = u;
    }, { immediate: !0 });
    const r = t;
    function i(u) {
      r("run", u);
    }
    function s() {
      l.value = !1, r("close");
    }
    return (u, d) => {
      const f = o0, v = l0, h = n0;
      return Bt((M(), G("div", u$e, [
        X("div", d$e, Qe(n.dataSize ? n.dataSize : "--"), 1),
        X("div", f$e, [
          X("ul", p$e, [
            X("li", v$e, Qe(u.$t("batchOperation")) + ":", 1),
            (M(!0), G(kt, null, ln(o.value, (m, p) => (M(), G("li", {
              key: p,
              class: "k-operate-list__item",
              onClick: (C) => i(m)
            }, Qe(m.label), 9, h$e))), 128)),
            Bt(X("li", m$e, [
              oe(h, { trigger: "click" }, {
                dropdown: fe(() => [
                  oe(v, null, {
                    default: fe(() => [
                      (M(!0), G(kt, null, ln(a.value, (m, p) => (M(), We(f, {
                        key: p,
                        style: { color: "#2882FF" },
                        onClick: (C) => i(m)
                      }, {
                        default: fe(() => [
                          Ut(Qe(m.label), 1)
                        ]),
                        _: 2
                      }, 1032, ["onClick"]))), 128))
                    ]),
                    _: 1
                  })
                ]),
                default: fe(() => [
                  X("span", g$e, [
                    oe(c(Y1), { color: "#2882FF" })
                  ])
                ]),
                _: 1
              })
            ], 512), [
              [pn, n.modelValue.length > n.max]
            ])
          ]),
          X("div", b$e, [
            oe(c(a3), { onClick: s })
          ])
        ])
      ], 512)), [
        [pn, l.value]
      ]);
    };
  }
}), C$e = { class: "k-tag" }, w$e = {
  key: 1,
  class: "k-tag__point"
}, E$e = /* @__PURE__ */ Q({
  name: "KTag",
  __name: "tag",
  props: {
    type: { default: "block" },
    color: { default: "#4091FF" },
    closable: { type: Boolean },
    size: {},
    round: { type: Boolean },
    textColor: {}
  },
  setup(e) {
    const t = e, n = x(() => ({
      color: t.color,
      round: t.round,
      size: t.size === "sm" ? "small" : "default"
    })), o = x(() => {
      let l = {
        width: "12px",
        height: "12px",
        fontSize: "16px"
      };
      return t.size === "sm" && (l = {
        width: "8px",
        height: "8px",
        fontSize: "13px"
      }), l;
    });
    return (l, a) => {
      var i, s, u;
      const r = Uc;
      return M(), G("div", C$e, [
        t.type === "block" ? (M(), We(r, Et({
          key: 0,
          class: "k-tag__block"
        }, n.value, { "disable-transitions": "" }), {
          default: fe(() => [
            X("span", {
              style: bt({
                width: "100%",
                color: t.textColor || "#FFF"
              })
            }, [
              Ie(l.$slots, "default")
            ], 4)
          ]),
          _: 3
        }, 16)) : t.type === "point" ? (M(), G("div", w$e, [
          X("div", {
            class: "k-tag__sign",
            style: bt({
              backgroundColor: t.color,
              width: (i = o.value) == null ? void 0 : i.width,
              height: (s = o.value) == null ? void 0 : s.height
            })
          }, null, 4),
          X("div", {
            class: "k-tag__content",
            style: bt({
              color: t.textColor || t.color,
              fontSize: (u = o.value) == null ? void 0 : u.fontSize
            })
          }, [
            Ie(l.$slots, "default")
          ], 4)
        ])) : _e("", !0)
      ]);
    };
  }
}), S$e = { class: "k-popover" }, gs = /* @__PURE__ */ Q({
  name: "KPopover",
  __name: "popover",
  props: {
    trigger: { default: "hover" },
    title: {},
    content: {},
    width: { default: 150 },
    placement: { default: "bottom" },
    disabled: { type: Boolean },
    visible: { type: Boolean, default: void 0 },
    offset: {},
    transition: {},
    popperOptions: {},
    showArrow: { type: Boolean, default: !0 },
    popperClass: {},
    popperStyle: {},
    showAfter: {},
    hideAfter: { default: 200 },
    autoClose: {},
    teleported: { type: Boolean, default: !0 },
    persistent: { type: Boolean, default: !0 }
  },
  emits: ["show", "hide"],
  setup(e, { emit: t }) {
    const n = e, o = t, l = x(() => {
      const s = {};
      return n.visible !== void 0 && (s.visible = n.visible), Object.assign(a(), s);
    }), a = () => ({
      trigger: n.trigger,
      title: n.title,
      content: n.content,
      width: n.width,
      placement: n.placement,
      disabled: n.disabled,
      offset: n.offset,
      transition: n.transition,
      popperOptions: n.popperOptions,
      showArrow: n.showArrow,
      popperClass: n.popperClass,
      popperStyle: n.popperStyle,
      showAfter: n.showAfter,
      hideAfter: n.hideAfter,
      autoClose: n.autoClose,
      teleported: n.teleported,
      persistent: n.persistent
    });
    function r() {
      o("show");
    }
    function i() {
      o("hide");
    }
    return (s, u) => {
      const d = X$;
      return M(), G("div", S$e, [
        oe(d, Et(l.value, {
          onShow: r,
          onHide: i
        }), {
          reference: fe(() => [
            Ie(s.$slots, "reference")
          ]),
          default: fe(() => [
            Ie(s.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]);
    };
  }
}), _$e = { class: "k-popconfirm" }, x$e = /* @__PURE__ */ Q({
  name: "KPopconfirm",
  __name: "popconfirm",
  props: {
    icon: { default: l3 },
    hideIcon: { type: Boolean },
    iconColor: { default: "red" },
    confirmButtonText: {},
    cancelButtonText: {},
    confirmButtonType: {},
    cancelButtonType: {},
    trigger: { default: "click" },
    title: {},
    content: {},
    width: { default: 150 },
    placement: { default: "bottom" },
    disabled: { type: Boolean },
    visible: { type: Boolean, default: void 0 },
    offset: {},
    transition: {},
    popperOptions: {},
    showArrow: { type: Boolean, default: !0 },
    popperClass: {},
    popperStyle: {},
    showAfter: {},
    hideAfter: { default: 200 },
    autoClose: {},
    teleported: { type: Boolean, default: !0 },
    persistent: { type: Boolean, default: !0 }
  },
  emits: ["confirm", "cancel", "show", "hide"],
  setup(e, { emit: t }) {
    const n = e, o = t, l = x(() => {
      const d = {};
      return n.visible !== void 0 && (d.visible = n.visible), Object.assign(a(), d);
    }), a = () => ({
      trigger: n.trigger,
      title: n.title,
      icon: n.icon,
      iconColor: n.iconColor,
      hideIcon: n.hideIcon,
      confirmButtonText: n.confirmButtonText,
      cancelButtonText: n.cancelButtonText,
      confirmButtonType: n.confirmButtonType,
      cancelButtonType: n.cancelButtonType,
      width: n.width,
      placement: n.placement,
      disabled: n.disabled,
      offset: n.offset,
      transition: n.transition,
      popperOptions: n.popperOptions,
      showArrow: n.showArrow,
      popperClass: n.popperClass,
      popperStyle: n.popperStyle,
      showAfter: n.showAfter,
      hideAfter: n.hideAfter,
      autoClose: n.autoClose,
      teleported: n.teleported,
      persistent: n.persistent
    });
    function r() {
      o("confirm");
    }
    function i() {
      o("cancel");
    }
    function s() {
      o("show");
    }
    function u() {
      o("hide");
    }
    return (d, f) => {
      const v = Y$;
      return M(), G("div", _$e, [
        oe(v, Et(l.value, {
          "cancel-button-type": "default",
          onConfirm: r,
          onCancel: i,
          onShow: s,
          onHide: u
        }), {
          reference: fe(() => [
            Ie(d.$slots, "reference")
          ]),
          default: fe(() => [
            Ie(d.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]);
    };
  }
}), k$e = { class: "k-status" }, T$e = { class: "k-status__icon" }, $$e = { class: "k-status__default__icon" }, O$e = { class: "k-status__content" }, N$e = { class: "k-status__default__content" }, M$e = /* @__PURE__ */ Q({
  name: "KStatus",
  __name: "status",
  props: {
    type: { default: "empty" },
    content: {},
    icon: {},
    iconColor: {},
    width: { default: "200px" },
    height: { default: "200px" },
    iconSize: {}
  },
  setup(e) {
    var s;
    const t = (s = Pt()) == null ? void 0 : s.appContext.app.config.globalProperties, n = {
      success: t == null ? void 0 : t.$t("success"),
      danger: t == null ? void 0 : t.$t("error"),
      warning: t == null ? void 0 : t.$t("warning"),
      empty: t == null ? void 0 : t.$t("noData")
    }, o = {
      success: tTe,
      danger: l3,
      warning: _h,
      empty: o3
    }, l = e, a = An(o.empty), r = B(n.empty), i = B("");
    return Pe(() => l.type, (u) => {
      if ((!o[u] || !u) && !l.icon) {
        a.value = o.empty, r.value = n.empty, i.value = "empty-status";
        return;
      }
      a.value = o[u], r.value = n[u], i.value = `${u}-status`;
    }, { immediate: !0 }), Pe(() => l.icon, (u) => {
      u && (a.value = null, r.value = "", i.value = "");
    }, { immediate: !0 }), (u, d) => (M(), G("div", k$e, [
      X("div", T$e, [
        Ie(u.$slots, "icon", {}, () => [
          X("div", $$e, [
            l.icon ? (M(), We(l.icon, {
              key: 0,
              style: bt({
                width: u.iconSize,
                height: u.iconSize,
                color: u.iconColor
              })
            }, null, 8, ["style"])) : (M(), We(c(a), {
              key: 1,
              class: z(i.value),
              style: bt({
                width: u.iconSize,
                height: u.iconSize,
                color: u.iconColor
              })
            }, null, 8, ["class", "style"]))
          ])
        ])
      ]),
      X("div", O$e, [
        Ie(u.$slots, "default", {}, () => [
          X("div", N$e, Qe(u.content || r.value), 1)
        ])
      ])
    ]));
  }
}), Lb = (e) => {
  if (typeof e == "string")
    e = {
      message: e
    };
  else {
    const { type: t } = e;
    t === "warning" && (e.icon = _h);
  }
  return yN(e);
};
["success", "error", "info", "warning"].forEach((e) => {
  const t = e;
  Lb[e] = (n) => (typeof n == "string" ? n = {
    message: n,
    type: t
  } : (e === "warning" && (n.icon = _h), n.type = t), Lb(n));
});
const I$e = (e) => mN.service(e), R$e = { class: "k-dialog" }, i3 = /* @__PURE__ */ Q({
  name: "KDialog",
  __name: "dialog",
  props: {
    modelValue: { type: Boolean },
    title: { default: "" },
    width: { default: "" },
    fullscreen: { type: Boolean },
    top: {},
    modal: { type: Boolean, default: !0 },
    modalClass: {},
    appendToBody: { type: Boolean },
    appendTo: {},
    lockScroll: { type: Boolean, default: !0 },
    openDelay: { default: 0 },
    closeDelay: { default: 0 },
    closeOnClickModal: { type: Boolean },
    closeOnPressEscape: { type: Boolean },
    showClose: { type: Boolean, default: !0 },
    beforeClose: {},
    draggable: { type: Boolean, default: !0 },
    overflow: { type: Boolean },
    center: { type: Boolean },
    alignCenter: { type: Boolean },
    destroyOnClose: { type: Boolean },
    closeIcon: {},
    zIndex: {}
  },
  emits: [
    "update:modelValue",
    "open",
    "opened",
    "close",
    "closed",
    "open-auto-focus",
    "close-auto-focus"
  ],
  setup(e, { emit: t }) {
    const n = e, o = t, l = B(n.modelValue), a = x(() => ({
      ...r()
    }));
    Pe(() => n.modelValue, (h) => {
      h !== l.value && (l.value = h);
    });
    const r = () => ({
      width: n.width,
      title: n.title,
      fullscreen: n.fullscreen,
      top: n.top,
      modal: n.modal,
      modalClass: n.modalClass,
      appendToBody: n.appendToBody,
      appendTo: n.appendTo,
      lockScroll: n.lockScroll,
      openDelay: n.openDelay,
      closeDelay: n.closeDelay,
      closeOnClickModal: n.closeOnClickModal,
      closeOnPressEscape: n.closeOnPressEscape,
      showClose: n.showClose,
      beforeClose: n.beforeClose,
      draggable: n.draggable,
      overflow: n.overflow,
      center: n.center,
      alignCenter: n.alignCenter,
      destroyOnClose: n.destroyOnClose,
      closeIcon: n.closeIcon,
      zIndex: n.zIndex
    });
    function i() {
      o("open");
    }
    function s() {
      o("opened");
    }
    function u() {
      o("update:modelValue", !1), o("close");
    }
    function d() {
      o("closed");
    }
    function f() {
      o("open-auto-focus");
    }
    function v() {
      o("close-auto-focus");
    }
    return (h, m) => {
      const p = x$;
      return M(), G("div", R$e, [
        oe(p, Et({
          modelValue: l.value,
          "onUpdate:modelValue": m[0] || (m[0] = (C) => l.value = C)
        }, a.value, {
          onOpen: i,
          onOpened: s,
          onClose: u,
          onClosed: d,
          onOpenAutoFocus: f,
          onCloseAutoFocus: v
        }), {
          header: fe(() => [
            Ie(h.$slots, "header")
          ]),
          footer: fe(() => [
            Ie(h.$slots, "footer")
          ]),
          default: fe(() => [
            Ie(h.$slots, "default")
          ]),
          _: 3
        }, 16, ["modelValue"])
      ]);
    };
  }
}), D$e = { class: "k-tooltip" }, L$e = {
  key: 0,
  class: "k-tooltip-icon"
}, P$e = {
  key: 1,
  class: "k-tooltip-icon"
}, A$e = /* @__PURE__ */ Q({
  name: "KTooltip",
  __name: "tooltip",
  props: {
    type: { default: void 0 },
    color: { default: "" },
    textColor: { default: "#FFF" },
    icon: {},
    iconSize: { default: "15px" },
    trigger: { default: "click" },
    title: {},
    content: {},
    width: { default: 150 },
    placement: { default: "bottom" },
    disabled: { type: Boolean },
    visible: { type: Boolean, default: void 0 },
    offset: { default: 5 },
    transition: {},
    popperOptions: {},
    showArrow: { type: Boolean, default: !0 },
    popperClass: {},
    popperStyle: {},
    showAfter: {},
    hideAfter: { default: 200 },
    autoClose: {},
    teleported: { type: Boolean, default: !0 },
    persistent: { type: Boolean, default: !0 }
  },
  setup(e) {
    const t = {
      normal: "#000",
      danger: "#ef4444",
      warning: "#f97316",
      primary: "#2882ff"
    }, n = e, o = B("#000"), l = x(() => ({
      trigger: n.trigger,
      title: n.title,
      content: n.content,
      width: n.width,
      placement: n.placement,
      disabled: n.disabled,
      offset: n.offset,
      transition: n.transition,
      popperOptions: n.popperOptions,
      showArrow: n.showArrow,
      popperClass: n.popperClass,
      popperStyle: n.popperStyle,
      showAfter: n.showAfter,
      hideAfter: n.hideAfter,
      autoClose: n.autoClose,
      teleported: n.teleported,
      persistent: n.persistent
    }));
    Pe(() => [n.type, n.color], () => {
      n.color && a(n.color) ? o.value = n.color : !n.color && n.type && t[n.type] ? o.value = t[n.type] : o.value = "#000";
    }, { immediate: !0 });
    function a(r) {
      const i = new Option().style;
      return i.color = r, console.log(i.color), i.color === r.toLowerCase();
    }
    return (r, i) => (M(), G("div", D$e, [
      oe(c(gs), Et(l.value, {
        "popper-style": {
          color: n.textColor,
          backgroundColor: o.value
        }
      }), {
        reference: fe(() => [
          n.icon ? (M(), G("i", L$e, [
            oe(n.icon, {
              style: bt({
                color: o.value,
                width: r.iconSize,
                height: r.iconSize
              })
            }, null, 8, ["style"])
          ])) : (M(), G("i", P$e, [
            oe(c(s3), {
              style: bt({
                color: o.value,
                width: r.iconSize,
                height: r.iconSize
              })
            }, null, 8, ["style"])
          ]))
        ]),
        default: fe(() => [
          Ie(r.$slots, "default")
        ]),
        _: 3
      }, 16, ["popper-style"])
    ]));
  }
}), F2 = [
  {
    label: "exactDate",
    value: "date"
  },
  {
    label: "dateRange",
    value: "range"
  },
  {
    label: "today",
    value: "today"
  },
  {
    label: "tomorrow",
    value: "tomorrow"
  },
  {
    label: "yesterday",
    value: "yesterday"
  },
  {
    label: "thisWeek",
    value: "current-week"
  },
  {
    label: "lastWeek",
    value: "last-week"
  },
  {
    label: "thisMonth",
    value: "current-month"
  },
  {
    label: "lastMonth",
    value: "last-month"
  },
  {
    label: "withinThePastSevenDays",
    value: "past-seven-days"
  },
  {
    label: "withinThePastThirtyDays",
    value: "past-thirty-days"
  }
], F$e = ["equal", "before", "after", "empty", "nonEmpty"], V$e = { class: "k-filter" }, B$e = { class: "k-filter__content" }, H$e = { class: "k-filter__header" }, z$e = { class: "text-lg font-bold" }, W$e = { class: "k-filter__condition" }, K$e = { class: "k-filter__logic" }, U$e = { class: "k-filter__value" }, j$e = {
  key: 1,
  class: "k-filter__date-box"
}, q$e = ["onClick"], Y$e = { class: "k-filter__operate" }, G$e = { class: "k-filer__operate-left text-base" }, X$e = { class: "k-filer__operate-right" }, Z$e = { class: "select-label" }, J$e = /* @__PURE__ */ Q({
  name: "KFilter",
  __name: "filter",
  props: {
    modelValue: {},
    data: {}
  },
  emits: ["update:modelValue", "confirm"],
  setup(e, { emit: t }) {
    var L;
    const n = e, o = t, l = (L = Pt()) == null ? void 0 : L.appContext.app.config.globalProperties, a = l == null ? void 0 : l.$t, r = B([]), i = B(!1), s = B(0), u = x(() => function(R) {
      return n.data.find((H) => H.title === R);
    }), d = x(() => {
      const R = n.data.map((K) => K.title), H = r.value.map((K) => K.title);
      return R.filter((K) => !H.includes(K));
    }), f = x(() => function(R) {
      if (R.dateLogic === (a == null ? void 0 : a("equal")))
        return F2;
      const H = ["past-seven-days", "past-thirty-days"];
      return F2.filter((K) => !H.includes(K.value));
    }), v = x(() => function(R) {
      const H = [a == null ? void 0 : a("empty"), a == null ? void 0 : a("nonEmpty")];
      return !R.dateLogic || H.includes(R.dateLogic);
    }), h = x(() => function(R) {
      const H = ["date", "range"];
      return v.value(R) || !H.includes(R.dateRange);
    });
    Pe(() => n.modelValue, (R) => {
      if (!R || R.length === 0) {
        m();
        return;
      }
      r.value = R;
    }, { immediate: !0, deep: !0 }), Pe(() => r.value, (R) => {
      o("update:modelValue", R);
    }, { immediate: !0, deep: !0 });
    function m() {
      const R = {
        title: "",
        logic: "",
        value: "",
        dateRange: "date",
        dateType: "datetime",
        dateLogic: ""
      };
      r.value.push(R);
    }
    function p(R) {
      r.value.splice(R, 1);
    }
    function C() {
      r.value.length = 0, m();
    }
    function g() {
      o("confirm", r.value);
    }
    function w(R) {
      const H = r.value[R];
      H.logic = "", H.value = "";
    }
    function b(R, H) {
      if (R.uiType === "date") {
        if (H.dateLogic = H.logic, v.value(H)) {
          H.value = "";
          return;
        }
        y(H);
      }
    }
    function y(R) {
      switch (N(R), R.dateRange) {
        case "date":
          R.value = "";
          break;
        case "range":
          R.value = ["", ""];
          break;
        case "today":
          R.value = E(0);
          break;
        case "tomorrow":
          R.value = E(1);
          break;
        case "yesterday":
          R.value = E(-1);
          break;
        case "current-week":
          R.value = [E(-S() + 1), E(7 - S())];
          break;
        case "last-week":
          R.value = [E(-S() - 6), E(-S())];
          break;
        case "current-month":
          R.value = [E(-_() + 1), E(k() - _())];
          break;
        case "last-month":
          R.value = [E(-_() - k() + 1), E(-_())];
          break;
        case "past-seven-days":
          R.value = [E(-7), E(0)];
          break;
        case "past-thirty-days":
          R.value = [E(-30), E(0)];
          break;
      }
      const H = ["current-week", "last-week", "current-month", "last-month"];
      (R.dateLogic === (a == null ? void 0 : a("after")) || R.dateLogic === (a == null ? void 0 : a("before"))) && H.includes(R.dateRange) && (R.value = R.value[0]);
    }
    function E(R) {
      const H = /* @__PURE__ */ new Date(), K = new Date(H);
      return K.setDate(K.getDate() + R), K.setHours(0, 0, 0, 0), K;
    }
    function S() {
      return (/* @__PURE__ */ new Date()).getDay();
    }
    function _() {
      return (/* @__PURE__ */ new Date()).getDate();
    }
    function k() {
      const R = (/* @__PURE__ */ new Date()).getMonth() + 1, H = [1, 3, 5, 7, 8, 10, 12], K = [4, 6, 9, 11];
      if (H.includes(R))
        return 31;
      if (K.includes(R))
        return 30;
      const U = (/* @__PURE__ */ new Date()).getFullYear();
      return U % 4 === 0 && U % 100 !== 0 || U % 400 === 0 ? 29 : 28;
    }
    function N(R) {
      if (R.dateLogic === (a == null ? void 0 : a("equal"))) {
        const H = ["date", "today", "tomorrow", "yesterday"];
        R.dateType = H.includes(R.dateRange) ? "datetime" : "datetimerange";
      } else if (R.dateLogic === (a == null ? void 0 : a("after")) || R.dateLogic === (a == null ? void 0 : a("before"))) {
        const H = ["range"];
        R.dateType = H.includes(R.dateRange) ? "datetimerange" : "datetime";
      }
    }
    return (R, H) => (M(), G("div", V$e, [
      oe(c(gs), {
        trigger: "click",
        "popper-class": "k-filter-custom",
        onShow: H[1] || (H[1] = (K) => i.value = !0),
        onHide: H[2] || (H[2] = (K) => i.value = !1)
      }, {
        reference: fe(() => [
          oe(c(pke), {
            class: "k-filter__trigger-icon",
            style: bt({
              color: i.value ? "#2882FF" : "#000"
            })
          }, null, 8, ["style"])
        ]),
        default: fe(() => [
          X("div", B$e, [
            X("div", H$e, [
              X("span", z$e, Qe(R.$t("seniorFilter")), 1),
              X("span", {
                class: "text-base",
                onClick: C
              }, [
                oe(c(r3)),
                Ut(Qe(R.$t("clearAll")), 1)
              ])
            ]),
            (M(!0), G(kt, null, ln(r.value, (K, U) => {
              var W, A;
              return M(), G("div", {
                key: U,
                class: "k-filter__item"
              }, [
                X("div", W$e, [
                  oe(c(gc), {
                    modelValue: K.title,
                    "onUpdate:modelValue": ($) => K.title = $,
                    teleported: !1,
                    clearable: "",
                    onChange: ($) => w(U)
                  }, {
                    default: fe(() => [
                      (M(!0), G(kt, null, ln(d.value, ($) => (M(), We(c(fs), {
                        key: $,
                        label: $,
                        value: $
                      }, null, 8, ["label", "value"]))), 128))
                    ]),
                    _: 2
                  }, 1032, ["modelValue", "onUpdate:modelValue", "onChange"])
                ]),
                X("div", K$e, [
                  oe(c(gc), {
                    modelValue: K.logic,
                    "onUpdate:modelValue": ($) => K.logic = $,
                    teleported: !1,
                    clearable: "",
                    onChange: ($) => b(u.value(K.title), K)
                  }, {
                    default: fe(() => {
                      var $, D;
                      return [
                        (($ = u.value(K.title)) == null ? void 0 : $.uiType) === "date" ? (M(!0), G(kt, { key: 0 }, ln(c(F$e) || [], (O) => (M(), We(c(fs), {
                          key: R.$t(O),
                          label: R.$t(O),
                          value: R.$t(O)
                        }, null, 8, ["label", "value"]))), 128)) : (M(!0), G(kt, { key: 1 }, ln(((D = u.value(K.title)) == null ? void 0 : D.logicList) || [], (O) => (M(), We(c(fs), {
                          key: O,
                          label: O,
                          value: O
                        }, null, 8, ["label", "value"]))), 128))
                      ];
                    }),
                    _: 2
                  }, 1032, ["modelValue", "onUpdate:modelValue", "onChange"])
                ]),
                X("div", U$e, [
                  ((W = u.value(K.title)) == null ? void 0 : W.uiType) === "select" ? (M(), We(c(gc), {
                    key: 0,
                    modelValue: K.value,
                    "onUpdate:modelValue": ($) => K.value = $,
                    teleported: !1,
                    clearable: ""
                  }, {
                    default: fe(() => {
                      var $;
                      return [
                        (M(!0), G(kt, null, ln((($ = u.value(K.title)) == null ? void 0 : $.valueList) || [], (D) => (M(), We(c(fs), {
                          key: D,
                          label: D,
                          value: D
                        }, null, 8, ["label", "value"]))), 128))
                      ];
                    }),
                    _: 2
                  }, 1032, ["modelValue", "onUpdate:modelValue"])) : ((A = u.value(K.title)) == null ? void 0 : A.uiType) === "date" ? (M(), G("div", j$e, [
                    oe(c(gc), {
                      modelValue: K.dateRange,
                      "onUpdate:modelValue": ($) => K.dateRange = $,
                      teleported: !1,
                      clearable: "",
                      disabled: v.value(K),
                      onChange: ($) => y(K)
                    }, {
                      default: fe(() => [
                        (M(!0), G(kt, null, ln(f.value(K), ($) => (M(), We(c(fs), {
                          key: $.value,
                          label: R.$t($.label),
                          value: $.value
                        }, null, 8, ["label", "value"]))), 128))
                      ]),
                      _: 2
                    }, 1032, ["modelValue", "onUpdate:modelValue", "disabled", "onChange"]),
                    oe(c(n3), {
                      modelValue: K.value,
                      "onUpdate:modelValue": ($) => K.value = $,
                      type: K.dateType,
                      teleported: !1,
                      clearable: "",
                      disabled: h.value(K)
                    }, null, 8, ["modelValue", "onUpdate:modelValue", "type", "disabled"])
                  ])) : (M(), We(c(Eh), {
                    key: 2,
                    modelValue: K.value,
                    "onUpdate:modelValue": ($) => K.value = $,
                    clearable: ""
                  }, null, 8, ["modelValue", "onUpdate:modelValue"]))
                ]),
                X("i", {
                  class: "close-icon",
                  onClick: ($) => p(U)
                }, [
                  oe(c(a3))
                ], 8, q$e)
              ]);
            }), 128)),
            X("div", Y$e, [
              X("div", G$e, [
                X("span", { onClick: m }, [
                  oe(c(hxe)),
                  Ut(Qe(R.$t("addCondition")), 1)
                ])
              ]),
              X("div", X$e, [
                X("span", Z$e, Qe(R.$t("aboveCondition")) + "：", 1),
                oe(c(gc), {
                  modelValue: s.value,
                  "onUpdate:modelValue": H[0] || (H[0] = (K) => s.value = K),
                  teleported: !1
                }, {
                  default: fe(() => [
                    oe(c(fs), {
                      label: R.$t("anyOne"),
                      value: 0
                    }, null, 8, ["label"]),
                    oe(c(fs), {
                      label: R.$t("all"),
                      value: 1
                    }, null, 8, ["label"])
                  ]),
                  _: 1
                }, 8, ["modelValue"]),
                oe(c(Sc), {
                  type: "main",
                  onClick: g
                }, {
                  default: fe(() => [
                    Ut(Qe(R.$t("query")), 1)
                  ]),
                  _: 1
                })
              ])
            ])
          ])
        ]),
        _: 1
      })
    ]));
  }
}), Q$e = { class: "k-table" }, eOe = { class: "k-table__content" }, V2 = "desc-change", tOe = /* @__PURE__ */ Q({
  name: "KTable",
  __name: "table",
  props: {
    size: {},
    id: {},
    data: {},
    height: {},
    minHeight: {},
    maxHeight: {},
    stripe: { type: Boolean },
    round: { type: Boolean },
    border: { type: [Boolean, String], default: !0 },
    loading: { type: Boolean },
    align: {},
    headerAlign: {},
    footerAlign: {},
    showHeader: { type: Boolean, default: !0 },
    showFooter: { type: Boolean },
    footerData: {},
    footerMethod: {},
    rowClassName: {},
    cellClassName: {},
    headerRowClassName: {},
    headerCellClassName: {},
    footerRowClassName: {},
    footerCellClassName: {},
    cellStyle: {},
    rowStyle: {},
    headerCellStyle: {},
    headerRowStyle: {},
    footerRowStyle: {},
    footerCellStyle: {},
    mergeCells: {},
    mergeFooterItems: {},
    spanMethod: {},
    footerSpanMethod: {},
    showOverflow: { type: [Boolean, String, null] },
    showHeaderOverflow: { type: [Boolean, String, null] },
    showFooterOverflow: { type: [Boolean, String, null] },
    keepSource: { type: Boolean },
    autoResize: { type: Boolean },
    syncResize: { type: [Boolean, String, Number] },
    columnConfig: {},
    rowConfig: {},
    customConfig: {},
    resizeConfig: {},
    resizableConfig: {},
    seqConfig: {},
    sortConfig: {},
    filterConfig: {},
    radioConfig: {},
    checkboxConfig: {},
    tooltipConfig: {},
    exportConfig: {},
    importConfig: {},
    printConfig: {},
    expandConfig: {},
    treeConfig: {},
    menuConfig: {},
    mouseConfig: {},
    areaConfig: {},
    fnrConfig: {},
    keyboardConfig: {},
    clipConfig: {},
    editConfig: {},
    validConfig: {},
    editRules: {},
    emptyText: {},
    emptyRender: {},
    loadingConfig: {},
    scrollX: {},
    scrollY: {},
    params: {},
    resizable: { type: Boolean },
    highlightCurrentRow: { type: Boolean },
    highlightHoverRow: { type: Boolean },
    highlightCurrentColumn: { type: Boolean },
    highlightHoverColumn: { type: Boolean },
    highlightCell: { type: Boolean },
    columnKey: { type: Boolean },
    rowKey: { type: Boolean },
    rowId: {},
    fit: { type: Boolean, default: !0 },
    animat: { type: Boolean },
    delayHover: {}
  },
  emits: ["desc-change"],
  setup(e, { expose: t, emit: n }) {
    const o = e;
    Nt(() => {
      var s;
      ((s = Pt()) == null ? void 0 : s.appContext.app.config.globalProperties.__emitter__).on(V2, r.bind(this));
    });
    const l = n, a = B(null);
    function r(i, s) {
      l(V2, i, s);
    }
    return Mt("tableInstance", a), Mt("tableConfig", { ...o }), t({
      tableInstance: a
    }), (i, s) => {
      const u = Dt("vxe-table");
      return M(), G("div", Q$e, [
        X("div", eOe, [
          oe(u, Et({
            ref_key: "vxeTableRef",
            ref: a
          }, o), {
            loading: fe(() => [
              Ie(i.$slots, "loading")
            ]),
            empty: fe(() => [
              Ie(i.$slots, "empty")
            ]),
            default: fe(() => [
              Ie(i.$slots, "default")
            ]),
            _: 3
          }, 16)
        ])
      ]);
    };
  }
}), nOe = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20fill='none'%20version='1.1'%20width='24'%20height='12'%20viewBox='0%200%2024%2012'%3e%3cdefs%3e%3cclipPath%20id='master_svg0_4226_9381'%3e%3crect%20x='0'%20y='0'%20width='24'%20height='12'%20rx='2'/%3e%3c/clipPath%3e%3cclipPath%20id='master_svg1_4226_9382'%3e%3crect%20x='2'%20y='2'%20width='20'%20height='10'%20rx='0'/%3e%3c/clipPath%3e%3c/defs%3e%3cg%20clip-path='url(%23master_svg0_4226_9381)'%3e%3cg%20clip-path='url(%23master_svg1_4226_9382)'%3e%3cg%3e%3cpath%20d='M12,4.5C12,4.5,17.625,10.75,17.625,10.75C17.625,10.75,6.375,10.75,6.375,10.75C6.375,10.75,12,4.5,12,4.5C12,4.5,12,4.5,12,4.5Z'%20fill='%23CDCACF'%20fill-opacity='1'/%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e", oOe = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20fill='none'%20version='1.1'%20width='24'%20height='12'%20viewBox='0%200%2024%2012'%3e%3cdefs%3e%3cclipPath%20id='master_svg0_4226_9392'%3e%3crect%20x='24'%20y='12'%20width='24'%20height='12'%20rx='2'/%3e%3c/clipPath%3e%3cclipPath%20id='master_svg1_4226_9393'%3e%3crect%20x='26'%20y='14'%20width='20'%20height='10'%20rx='0'/%3e%3c/clipPath%3e%3c/defs%3e%3cg%20transform='matrix(-1,1.0987933052319931e-7,-1.0987933052319931e-7,-1,48.000001318551966,23.999997362896067)'%3e%3cg%20clip-path='url(%23master_svg0_4226_9392)'%3e%3cg%20clip-path='url(%23master_svg1_4226_9393)'%3e%3cg%3e%3cpath%20d='M36,16.5C36,16.5,41.625,22.75,41.625,22.75C41.625,22.75,30.375,22.75,30.375,22.75C30.375,22.75,36,16.5,36,16.5C36,16.5,36,16.5,36,16.5Z'%20fill='%23CDCACF'%20fill-opacity='1'/%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e", lOe = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20fill='none'%20version='1.1'%20width='24'%20height='12'%20viewBox='0%200%2024%2012'%3e%3cdefs%3e%3cclipPath%20id='master_svg0_4226_9381'%3e%3crect%20x='0'%20y='0'%20width='24'%20height='12'%20rx='2'/%3e%3c/clipPath%3e%3cclipPath%20id='master_svg1_4226_9382'%3e%3crect%20x='2'%20y='2'%20width='20'%20height='10'%20rx='0'/%3e%3c/clipPath%3e%3c/defs%3e%3cg%20clip-path='url(%23master_svg0_4226_9381)'%3e%3cg%20clip-path='url(%23master_svg1_4226_9382)'%3e%3cg%3e%3cpath%20d='M12,4.5C12,4.5,17.625,10.75,17.625,10.75C17.625,10.75,6.375,10.75,6.375,10.75C6.375,10.75,12,4.5,12,4.5C12,4.5,12,4.5,12,4.5Z'%20fill='%232882FF'%20fill-opacity='1'/%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e", aOe = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20fill='none'%20version='1.1'%20width='24'%20height='12'%20viewBox='0%200%2024%2012'%3e%3cdefs%3e%3cclipPath%20id='master_svg0_4226_9392'%3e%3crect%20x='24'%20y='12'%20width='24'%20height='12'%20rx='2'/%3e%3c/clipPath%3e%3cclipPath%20id='master_svg1_4226_9393'%3e%3crect%20x='26'%20y='14'%20width='20'%20height='10'%20rx='0'/%3e%3c/clipPath%3e%3c/defs%3e%3cg%20transform='matrix(-1,1.0987933052319931e-7,-1.0987933052319931e-7,-1,48.000001318551966,23.999997362896067)'%3e%3cg%20clip-path='url(%23master_svg0_4226_9392)'%3e%3cg%20clip-path='url(%23master_svg1_4226_9393)'%3e%3cg%3e%3cpath%20d='M36,16.5C36,16.5,41.625,22.75,41.625,22.75C41.625,22.75,30.375,22.75,30.375,22.75C30.375,22.75,36,16.5,36,16.5C36,16.5,36,16.5,36,16.5Z'%20fill='%232882FF'%20fill-opacity='1'/%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e", rOe = {
  key: 0,
  class: "k-table-column__header"
}, sOe = { class: "k-table-column__title" }, iOe = { class: "k-column__header-dialog" }, cOe = { class: "header-dialog__buttons" }, uOe = { class: "k-table-column__operate" }, dOe = {
  key: 0,
  class: "k-table-column__tooltip"
}, fOe = ["onClick"], pOe = ["src"], vOe = ["src"], hOe = ["src"], mOe = ["src"], gOe = { class: "k-table-column__more" }, bOe = { class: "more-menu" }, yOe = { class: "more-menu-item" }, COe = { class: "filter-menu" }, wOe = { class: "filter-menu-item" }, EOe = { class: "filter-buttons" }, SOe = { class: "more-menu-item" }, _Oe = { class: "sort-menu" }, xOe = ["onClick"], kOe = ["onClick"], TOe = ["onClick"], $Oe = { key: 1 }, OOe = /* @__PURE__ */ X("span", null, "-", -1), NOe = /* @__PURE__ */ Q({
  name: "KTableColumn",
  __name: "table_column",
  props: {
    desc: { default: "" },
    colId: {},
    type: {},
    field: {},
    title: {},
    width: { default: void 0 },
    minWidth: { default: void 0 },
    maxWidth: {},
    resizable: { type: Boolean, default: void 0 },
    fixed: {},
    align: { default: void 0 },
    headerAlign: { default: void 0 },
    footerAlign: { default: void 0 },
    showOverflow: { type: [Boolean, String, null], default: void 0 },
    showHeaderOverflow: { type: [Boolean, String, null], default: void 0 },
    showFooterOverflow: { type: [Boolean, String, null], default: void 0 },
    className: {},
    headerClassName: {},
    footerClassName: {},
    formatter: {},
    sortable: { type: Boolean },
    sortBy: {},
    sortType: {},
    filters: {},
    filterMultiple: { type: Boolean, default: !0 },
    filterMethod: {},
    filterRender: {},
    treeNode: { type: Boolean },
    visible: { type: Boolean, default: !0 },
    headerExportMethod: {},
    exportMethod: {},
    footerExportMethod: {},
    titleHelp: {},
    titlePrefix: {},
    titleSuffix: {},
    cellType: {},
    cellRender: {},
    editRender: {},
    contentRender: {},
    params: {}
  },
  setup(e) {
    const t = ot("tableInstance"), n = e, o = Yn(), l = B(!1), a = B(n.width), r = B(""), i = B(!1), s = B(""), u = B(!1), d = B(!1), f = B(!0);
    let v;
    Nt(() => {
      var _;
      v = (_ = Pt()) == null ? void 0 : _.appContext.app.config.globalProperties.__emitter__;
    }), Pe(() => n.desc, (_) => {
      _ && (r.value = _);
    }, { immediate: !0 });
    function h(_, k) {
      var L;
      switch ((L = _.target) == null ? void 0 : L.name) {
        case "transangleUp":
          m(k, "asc");
          break;
        case "transangleDown":
          m(k, "desc");
          break;
        case "transangleUpLight":
          p(k);
          break;
        case "transangleDownLight":
          p(k);
          break;
      }
    }
    function m(_, k) {
      var N;
      (N = t.value) == null || N.sort({
        field: _.field,
        order: k
      });
    }
    function p(_) {
      var k;
      (k = t.value) == null || k.clearSort(_);
    }
    function C(_) {
      l.value = _, _ ? a.value = "40" : a.value = n.width;
    }
    function g() {
      s.value = r.value || "";
    }
    function w(_) {
      r.value = s.value, i.value = !1, v == null || v.emit("desc-change", _, r.value);
    }
    function b() {
      var _;
      u.value && d.value && (d.value = !1), (_ = n.filters) == null || _.forEach((k) => {
        k.checked = u.value;
      });
    }
    function y() {
      var k, N;
      if (!Array.isArray(n.filters)) {
        u.value = !1;
        return;
      }
      u.value = (k = n.filters) == null ? void 0 : k.every((L) => L.checked);
      const _ = (N = n.filters) == null ? void 0 : N.some((L) => L.checked);
      !u.value && _ ? d.value = !0 : d.value = !1;
    }
    async function E(_, k) {
      await t.value.setFilter(_, k), t.value.updateData();
    }
    async function S(_) {
      var k;
      await t.value.clearFilter(_), (k = n.filters) == null || k.forEach((N) => {
        N.checked = !1;
      }), d.value = !1, u.value = !1;
    }
    return (_, k) => {
      const N = Dt("vxe-column");
      return f.value ? (M(), We(N, Et({ key: 0 }, n, { width: a.value }), rl({
        header: fe((L) => [
          l.value ? (M(), G("div", $Oe, [
            oe(c(LTe), {
              style: {
                width: "20px",
                cursor: "pointer"
              },
              class: "expand-icon",
              onClick: k[7] || (k[7] = (R) => C(!1))
            })
          ])) : (M(), G("div", rOe, [
            Ie(_.$slots, "header", xo(Ao(L)), () => [
              X("span", sOe, Qe(L.column.title || "-"), 1)
            ]),
            oe(c(i3), {
              modelValue: i.value,
              "onUpdate:modelValue": k[2] || (k[2] = (R) => i.value = R),
              title: _.$t("customDescription"),
              onOpen: g
            }, {
              default: fe(() => [
                X("div", iOe, [
                  oe(c(Eh), {
                    modelValue: s.value,
                    "onUpdate:modelValue": k[0] || (k[0] = (R) => s.value = R),
                    type: "textarea"
                  }, null, 8, ["modelValue"]),
                  X("div", cOe, [
                    oe(c(Sc), {
                      onClick: k[1] || (k[1] = () => i.value = !1)
                    }, {
                      default: fe(() => [
                        Ut(Qe(_.$t("cancel")), 1)
                      ]),
                      _: 1
                    }),
                    oe(c(Sc), {
                      type: "main",
                      onClick: (R) => w(L.column)
                    }, {
                      default: fe(() => [
                        Ut(Qe(_.$t("confirm")), 1)
                      ]),
                      _: 2
                    }, 1032, ["onClick"])
                  ])
                ])
              ]),
              _: 2
            }, 1032, ["modelValue", "title"]),
            X("div", uOe, [
              r.value ? (M(), G("span", dOe, [
                oe(c(gs), {
                  trigger: "click",
                  content: r.value,
                  placement: "top"
                }, {
                  reference: fe(() => [
                    X("i", null, [
                      oe(c(s3))
                    ])
                  ]),
                  _: 1
                }, 8, ["content"])
              ])) : _e("", !0),
              n.sortable ? (M(), G("span", {
                key: 1,
                class: "k-table-column__sort",
                onClick: (R) => h(R, L.column)
              }, [
                Bt(X("img", {
                  src: c(nOe),
                  name: "transangleUp"
                }, null, 8, pOe), [
                  [pn, L.column.order !== "asc"]
                ]),
                Bt(X("img", {
                  src: c(lOe),
                  name: "transangleUpLight"
                }, null, 8, vOe), [
                  [pn, L.column.order === "asc"]
                ]),
                Bt(X("img", {
                  src: c(oOe),
                  name: "transangleDown"
                }, null, 8, hOe), [
                  [pn, L.column.order !== "desc"]
                ]),
                Bt(X("img", {
                  src: c(aOe),
                  name: "transangleDownLight"
                }, null, 8, mOe), [
                  [pn, L.column.order === "desc"]
                ])
              ], 8, fOe)) : _e("", !0),
              X("span", gOe, [
                oe(c(gs), {
                  trigger: "click",
                  "show-arrow": !1,
                  placement: "bottom-start",
                  "popper-class": "more-box",
                  offset: 2,
                  width: "160px"
                }, {
                  reference: fe(() => [
                    X("i", null, [
                      oe(c(Y1))
                    ])
                  ]),
                  default: fe(() => [
                    X("ul", bOe, [
                      X("li", yOe, [
                        oe(c(gs), {
                          trigger: "hover",
                          "show-arrow": !1,
                          placement: "right-start",
                          "popper-class": "filter-box",
                          offset: 2,
                          disabled: !n.filters,
                          teleported: !1,
                          onShow: y
                        }, {
                          reference: fe(() => [
                            X("div", {
                              class: z(["filter-select-item", { disabled: !n.filters }])
                            }, [
                              oe(c(yke), { class: "menu-item-icon" }),
                              Ut(" " + Qe(_.$t("filter")), 1)
                            ], 2)
                          ]),
                          default: fe(() => [
                            Ie(_.$slots, "filter", {}, () => [
                              X("ul", COe, [
                                X("li", wOe, [
                                  oe(c(Db), {
                                    modelValue: u.value,
                                    "onUpdate:modelValue": k[3] || (k[3] = (R) => u.value = R),
                                    label: _.$t("all"),
                                    value: "all",
                                    indeterminate: d.value,
                                    onChange: b
                                  }, null, 8, ["modelValue", "label", "indeterminate"])
                                ]),
                                (M(!0), G(kt, null, ln(n.filters, (R, H) => (M(), G("li", {
                                  key: H,
                                  class: "filter-menu-item"
                                }, [
                                  oe(c(Db), {
                                    modelValue: R.checked,
                                    "onUpdate:modelValue": (K) => R.checked = K,
                                    label: R.label,
                                    value: R.value,
                                    onChange: y
                                  }, null, 8, ["modelValue", "onUpdate:modelValue", "label", "value"])
                                ]))), 128))
                              ])
                            ]),
                            X("div", EOe, [
                              oe(c(Sc), {
                                size: "sm",
                                onClick: (R) => S(L.column)
                              }, {
                                default: fe(() => [
                                  Ut(Qe(_.$t("reset")), 1)
                                ]),
                                _: 2
                              }, 1032, ["onClick"]),
                              oe(c(Sc), {
                                class: "filter-btn-item",
                                size: "sm",
                                type: "secondary",
                                onClick: (R) => E(L.column.field, n.filters)
                              }, {
                                default: fe(() => [
                                  Ut(Qe(_.$t("filter")), 1)
                                ]),
                                _: 2
                              }, 1032, ["onClick"])
                            ])
                          ]),
                          _: 2
                        }, 1032, ["disabled"])
                      ]),
                      X("li", SOe, [
                        oe(c(gs), {
                          trigger: "hover",
                          "show-arrow": !1,
                          placement: "right-start",
                          "popper-class": "more-box",
                          offset: 2,
                          disabled: !n.sortable,
                          teleported: !1
                        }, {
                          reference: fe(() => [
                            X("div", {
                              class: z(["sort-select-item", { disabled: !n.sortable }])
                            }, [
                              oe(c(vTe), { class: "menu-item-icon" }),
                              Ut(" " + Qe(_.$t("sort")) + " ", 1),
                              oe(c(wxe), { class: "sort-arrow-right" })
                            ], 2)
                          ]),
                          default: fe(() => [
                            X("ul", _Oe, [
                              X("li", {
                                class: "sort-menu-item",
                                onClick: (R) => m(L.column, "asc")
                              }, [
                                oe(c(wTe)),
                                Ut(" " + Qe(_.$t("ascendingOrder")), 1)
                              ], 8, xOe),
                              X("li", {
                                class: "sort-menu-item",
                                onClick: (R) => m(L.column, "desc")
                              }, [
                                oe(c(iTe)),
                                Ut(" " + Qe(_.$t("descendingOrder")), 1)
                              ], 8, kOe),
                              X("li", {
                                class: "sort-menu-item",
                                onClick: (R) => p(L.column)
                              }, [
                                oe(c(Bxe)),
                                Ut(" " + Qe(_.$t("clearSorting")), 1)
                              ], 8, TOe)
                            ])
                          ]),
                          _: 2
                        }, 1032, ["disabled"])
                      ]),
                      X("li", {
                        class: "more-menu-item",
                        onClick: k[4] || (k[4] = (R) => C(!0))
                      }, [
                        oe(c(Tke), { class: "menu-item-icon" }),
                        Ut(" " + Qe(_.$t("retract")), 1)
                      ]),
                      X("li", {
                        class: "more-menu-item",
                        onClick: k[5] || (k[5] = () => f.value = !1)
                      }, [
                        oe(c(Lke), { class: "menu-item-icon" }),
                        Ut(" " + Qe(_.$t("hide")), 1)
                      ]),
                      X("li", {
                        class: "more-menu-item",
                        onClick: k[6] || (k[6] = () => i.value = !0)
                      }, [
                        oe(c(nxe), { class: "menu-item-icon" }),
                        Ut(" " + Qe(_.$t("customDescription")), 1)
                      ])
                    ])
                  ]),
                  _: 2
                }, 1024)
              ])
            ])
          ]))
        ]),
        _: 2
      }, [
        l.value ? {
          name: "default",
          fn: fe(() => [
            OOe
          ]),
          key: "0"
        } : c(o).default && !l.value ? {
          name: "default",
          fn: fe((L) => [
            Ie(_.$slots, "default", xo(Ao(L)))
          ]),
          key: "1"
        } : void 0,
        c(o).footer ? {
          name: "footer",
          fn: fe((L) => [
            Ie(_.$slots, "footer", xo(Ao(L)))
          ]),
          key: "2"
        } : void 0,
        c(o).radio ? {
          name: "radio",
          fn: fe((L) => [
            Ie(_.$slots, "radio", xo(Ao(L)))
          ]),
          key: "3"
        } : void 0,
        c(o).checkbox ? {
          name: "checkbox",
          fn: fe((L) => [
            Ie(_.$slots, "checkbox", xo(Ao(L)))
          ]),
          key: "4"
        } : void 0,
        c(o).title ? {
          name: "title",
          fn: fe((L) => [
            Ie(_.$slots, "title", xo(Ao(L)))
          ]),
          key: "5"
        } : void 0,
        c(o).edit ? {
          name: "edit",
          fn: fe((L) => [
            Ie(_.$slots, "edit", xo(Ao(L)))
          ]),
          key: "6"
        } : void 0,
        c(o).valid ? {
          name: "valid",
          fn: fe((L) => [
            Ie(_.$slots, "valid", xo(Ao(L)))
          ]),
          key: "7"
        } : void 0,
        c(o).content ? {
          name: "content",
          fn: fe((L) => [
            Ie(_.$slots, "content", xo(Ao(L)))
          ]),
          key: "8"
        } : void 0
      ]), 1040, ["width"])) : _e("", !0);
    };
  }
}), MOe = /* @__PURE__ */ Q({
  name: "KColumnGroup",
  __name: "column_group",
  props: {
    type: {},
    field: {},
    title: {},
    width: { default: void 0 },
    minWidth: { default: void 0 },
    resizable: { type: Boolean, default: void 0 },
    fixed: {},
    align: { default: void 0 },
    headerAlign: { default: void 0 },
    showOverflow: { type: [Boolean, String, null], default: void 0 },
    showHeaderOverflow: { type: [Boolean, String, null], default: void 0 },
    className: {},
    headerClassName: {},
    visible: { type: Boolean, default: !0 },
    params: {}
  },
  setup(e) {
    const t = e, n = Yn();
    return (o, l) => {
      const a = Dt("vxe-colgroup");
      return M(), We(a, xo(Ao(t)), rl({
        default: fe(() => [
          Ie(o.$slots, "default")
        ]),
        _: 2
      }, [
        c(n).header ? {
          name: "header",
          fn: fe((r) => [
            Ie(o.$slots, "header", xo(Ao(r)))
          ]),
          key: "0"
        } : void 0
      ]), 1040);
    };
  }
}), IOe = { class: "k-drawer" }, ROe = /* @__PURE__ */ Q({
  name: "KDrawer",
  __name: "drawer",
  props: {
    modelValue: { type: Boolean },
    appendToBody: { type: Boolean },
    lockScroll: { type: Boolean, default: !0 },
    openDelay: {},
    closeDelay: {},
    closeOnClickModal: { type: Boolean },
    closeOnPressEscape: { type: Boolean },
    showClose: { type: Boolean, default: !0 },
    destroyOnClose: { type: Boolean },
    modal: { type: Boolean, default: !0 },
    direction: {},
    size: {},
    title: {},
    withHeader: { type: Boolean, default: !0 },
    modalClass: {},
    zIndex: {},
    beforeClose: {}
  },
  emits: [
    "update:modelValue",
    "open",
    "opened",
    "close",
    "closed",
    "open-auto-focus",
    "close-auto-focus"
  ],
  setup(e, { expose: t, emit: n }) {
    const o = e, l = Yn(), a = n, r = B(o.modelValue), i = B(null), s = x(() => ({
      appendToBody: o.appendToBody,
      lockScroll: o.lockScroll,
      openDelay: o.openDelay,
      closeDelay: o.closeDelay,
      closeOnClickModal: o.closeOnClickModal,
      closeOnPressEscape: o.closeOnPressEscape,
      showClose: o.showClose,
      destroyOnClose: o.destroyOnClose,
      modal: o.modal,
      direction: o.direction,
      size: o.size,
      title: o.title,
      withHeader: o.withHeader,
      modalClass: o.modalClass,
      zIndex: o.zIndex,
      beforeClose: o.beforeClose
    }));
    Pe(() => o.modelValue, (C) => {
      C !== r.value && (r.value = C);
    });
    function u() {
      a("open");
    }
    function d() {
      a("opened");
    }
    function f() {
      a("update:modelValue", !1), a("close");
    }
    function v() {
      a("closed");
    }
    function h() {
      a("open-auto-focus");
    }
    function m() {
      a("close-auto-focus");
    }
    function p() {
      var C;
      (C = i.value) == null || C.handleClose();
    }
    return t({ handleClose: p }), (C, g) => {
      const w = T$;
      return M(), G("div", IOe, [
        oe(w, Et({
          ref_key: "KDrawerRef",
          ref: i,
          modelValue: r.value,
          "onUpdate:modelValue": g[0] || (g[0] = (b) => r.value = b)
        }, s.value, {
          onOpen: u,
          onOpened: d,
          onClose: f,
          onClosed: v,
          onOpenAutoFocus: h,
          onCloseAutoFocus: m
        }), rl({
          default: fe(() => [
            Ie(C.$slots, "default")
          ]),
          _: 2
        }, [
          c(l).header ? {
            name: "header",
            fn: fe((b) => [
              Ie(C.$slots, "header", xo(Ao(b)))
            ]),
            key: "0"
          } : void 0,
          c(l).footer ? {
            name: "footer",
            fn: fe(() => [
              Ie(C.$slots, "footer")
            ]),
            key: "1"
          } : void 0
        ]), 1040, ["modelValue"])
      ]);
    };
  }
}), DOe = { class: "k-form" }, LOe = /* @__PURE__ */ Q({
  name: "KForm",
  __name: "form",
  props: {
    model: {},
    rules: {},
    inline: { type: Boolean },
    labelPosition: { default: "right" },
    labelWidth: {},
    labelSuffix: {},
    hideRequiredAsterisk: { type: Boolean },
    requireAsteriskPosition: { default: "left" },
    showMessage: { type: Boolean, default: !0 },
    inlineMessage: { type: Boolean },
    statusIcon: { type: Boolean },
    validateOnRuleChange: { type: Boolean, default: !0 },
    size: {},
    disabled: { type: Boolean },
    scrollToError: { type: Boolean },
    scrollIntoViewOptions: { type: [Boolean, Object] }
  },
  emits: ["update:modelValue", "validate"],
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, a = B(null), r = x(() => ({
      model: o.model,
      rules: o.rules,
      inline: o.inline,
      labelPosition: o.labelPosition,
      labelWidth: o.labelWidth,
      labelSuffix: o.labelSuffix,
      hideRequiredAsterisk: o.hideRequiredAsterisk,
      requireAsteriskPosition: o.requireAsteriskPosition,
      showMessage: o.showMessage,
      inlineMessage: o.inlineMessage,
      statusIcon: o.statusIcon,
      validateOnRuleChange: o.validateOnRuleChange,
      size: t3(o.size),
      disabled: o.disabled,
      scrollToError: o.scrollToError,
      scrollIntoViewOptions: o.scrollIntoViewOptions
    })), i = (m, p, C) => {
      l("validate", m, p, C);
    }, s = (m) => {
      var p;
      (p = a.value) == null || p.validate(m);
    }, u = (m, p) => {
      var C;
      (C = a.value) == null || C.validateField(m, p);
    }, d = (m) => {
      var p;
      (p = a.value) == null || p.resetFields(m);
    }, f = (m) => {
      var p;
      (p = a.value) == null || p.scrollToField(m);
    }, v = (m) => {
      var p;
      (p = a.value) == null || p.clearValidate(m);
    }, h = x(() => {
      var m;
      return (m = a.value) == null ? void 0 : m.fields;
    });
    return t({
      fields: h,
      validate: s,
      validateField: u,
      resetFields: d,
      scrollToField: f,
      clearValidate: v
    }), (m, p) => {
      const C = jk;
      return M(), G("div", DOe, [
        oe(C, Et({
          ref_key: "KFormRef",
          ref: a
        }, r.value, { onValidate: i }), {
          default: fe(() => [
            Ie(m.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]);
    };
  }
}), POe = /* @__PURE__ */ Q({
  name: "KFormItem",
  __name: "form_item",
  props: {
    props: {},
    label: {},
    labelWidth: { default: "" },
    required: { type: Boolean, default: void 0 },
    rules: {},
    error: {},
    showMessage: { type: Boolean, default: !0 },
    inlineMessage: { type: [String, Boolean], default: "" },
    size: {},
    for: {},
    validateStatus: {}
  },
  setup(e, { expose: t }) {
    const n = e, o = Yn(), l = B(null), a = x(() => ({
      props: n.props,
      label: n.label,
      labelWidth: n.labelWidth,
      required: n.required,
      rules: n.rules,
      error: n.error,
      showMessage: n.showMessage,
      inlineMessage: n.inlineMessage,
      size: t3(n.size),
      for: n.for,
      validateStatus: n.validateStatus
    })), r = (v, h) => {
      var m;
      (m = l.value) == null || m.validate(v, h);
    }, i = () => {
      var v;
      (v = l.value) == null || v.resetField();
    }, s = () => {
      var v;
      (v = l.value) == null || v.clearValidate();
    }, u = x(() => {
      var v;
      return (v = l.value) == null ? void 0 : v.size;
    }), d = x(() => {
      var v;
      return (v = l.value) == null ? void 0 : v.validateMessage;
    }), f = x(() => {
      var v;
      return (v = l.value) == null ? void 0 : v.validateState;
    });
    return t({
      size: u,
      validateMessage: d,
      validateState: f,
      validate: r,
      resetField: i,
      clearValidate: s
    }), (v, h) => {
      const m = qk;
      return M(), We(m, Et({
        ref_key: "KFormItemRef",
        ref: l,
        class: "k-form-item"
      }, a.value), rl({
        default: fe(() => [
          Ie(v.$slots, "default")
        ]),
        _: 2
      }, [
        c(o).label ? {
          name: "label",
          fn: fe(() => [
            Ie(v.$slots, "label")
          ]),
          key: "0"
        } : void 0,
        c(o).error ? {
          name: "error",
          fn: fe(() => [
            Ie(v.$slots, "error")
          ]),
          key: "1"
        } : void 0
      ]), 1040);
    };
  }
}), AOe = { class: "k-steps" }, FOe = ["id"], VOe = /* @__PURE__ */ Q({
  name: "KSteps",
  __name: "steps",
  props: {
    space: { default: "" },
    direction: { default: "horizontal" },
    active: { default: 0 },
    processStatus: { default: "wait" },
    finishStatus: { default: "finish" },
    alignCenter: { type: Boolean },
    capsule: { type: Boolean },
    height: {}
  },
  setup(e) {
    const t = e, n = B(t.active), o = Sh(8), l = x(() => ({
      space: t.space,
      direction: t.direction,
      processStatus: a(t.processStatus),
      finishStatus: a(t.finishStatus),
      alignCenter: t.alignCenter
    }));
    Pe(() => t.active, (r) => {
      n.value = r;
    }), Pe(() => t.height, (r) => {
      r && xe(() => {
        const i = typeof r == "number" ? `${r}px` : r, s = document.getElementById(o);
        s == null || s.style.setProperty("--height", i);
      });
    }, { immediate: !0 });
    function a(r) {
      switch (r) {
        case "primary":
          return "finish";
        case "wait":
          return "wait";
        case "success":
          return "success";
        case "error":
          return "error";
        default:
          return "finish";
      }
    }
    return Mt("isCapsule", t.capsule), (r, i) => {
      const s = gO;
      return M(), G("div", AOe, [
        t.capsule ? (M(), G("div", {
          key: 1,
          id: c(o),
          class: "k-step__capsule"
        }, [
          Ie(r.$slots, "default")
        ], 8, FOe)) : (M(), We(s, Et({
          key: 0,
          active: n.value
        }, l.value), {
          default: fe(() => [
            Ie(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["active"]))
      ]);
    };
  }
}), BOe = ["id"], HOe = { class: "k-step__title" }, zOe = /* @__PURE__ */ Q({
  name: "KStep",
  __name: "step",
  props: {
    title: { default: "" },
    description: { default: "" },
    icon: {},
    status: { default: "" },
    width: {},
    color: {}
  },
  setup(e) {
    const t = e, n = ot("isCapsule"), o = Yn(), l = Sh(8), a = {
      primary: "#2882FF",
      success: "#22C55E",
      error: "#EF4444",
      wait: "#EAE8EB"
    }, r = x(() => ({
      title: t.title,
      description: t.description,
      icon: t.icon,
      status: i(t.status)
    }));
    Pe(() => [t.color, t.status], (s) => {
      if (!s[0] && !s[1])
        return;
      let u;
      t.status && a[t.status] ? u = a[t.status] : t.color ? u = t.color : u = a.primary, xe(() => {
        var f;
        const d = document.getElementById(l);
        (f = d == null ? void 0 : d.style) == null || f.setProperty("--default-bgColor", u);
      });
    }, { immediate: !0, deep: !0 });
    function i(s) {
      switch (s) {
        case "primary":
          return "finish";
        case "wait":
          return "wait";
        case "success":
          return "success";
        case "error":
          return "error";
        default:
          return "";
      }
    }
    return (s, u) => {
      const d = bO;
      return c(n) ? (M(), G("div", {
        key: 1,
        id: c(l),
        class: "k-step__capsule-box"
      }, [
        oe(c(gs), {
          "show-after": 500,
          disabled: !t.description
        }, {
          reference: fe(() => [
            X("span", HOe, [
              t.icon ? (M(), We(t.icon, {
                key: 0,
                class: "k-step__icon"
              })) : _e("", !0),
              Ut(" " + Qe(t.title), 1)
            ])
          ]),
          default: fe(() => [
            Ut(" " + Qe(t.description), 1)
          ]),
          _: 1
        }, 8, ["disabled"])
      ], 8, BOe)) : (M(), We(d, Et({ key: 0 }, r.value, { class: "k-step" }), rl({ _: 2 }, [
        c(o).title ? {
          name: "title",
          fn: fe(() => [
            Ie(s.$slots, "title")
          ]),
          key: "0"
        } : void 0,
        c(o).description ? {
          name: "description",
          fn: fe(() => [
            Ie(s.$slots, "description")
          ]),
          key: "1"
        } : void 0,
        c(o).icon ? {
          name: "icon",
          fn: fe(() => [
            Ie(s.$slots, "icon")
          ]),
          key: "2"
        } : void 0
      ]), 1040));
    };
  }
}), WOe = { class: "k-collapse" }, KOe = /* @__PURE__ */ Q({
  name: "KCollapse",
  __name: "collapse",
  props: {
    modelValue: {},
    accordion: { type: Boolean }
  },
  emits: ["update:modelValue", "change"],
  setup(e, { emit: t }) {
    const n = e, o = t, l = B(n.modelValue), a = x(() => ({
      accordion: n.accordion
    })), r = (i) => {
      o("update:modelValue", i), o("change", i);
    };
    return (i, s) => {
      const u = t$;
      return M(), G("div", WOe, [
        oe(u, Et({
          modelValue: l.value,
          "onUpdate:modelValue": s[0] || (s[0] = (d) => l.value = d)
        }, a.value, { onChange: r }), {
          default: fe(() => [
            Ie(i.$slots, "default")
          ]),
          _: 3
        }, 16, ["modelValue"])
      ]);
    };
  }
}), UOe = { class: "k-collapse-item" }, jOe = /* @__PURE__ */ Q({
  name: "KCollapseItem",
  __name: "collapse_item",
  props: {
    name: {
      type: String || Number,
      default: ""
    },
    title: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = e, n = Yn();
    return (o, l) => {
      const a = n$;
      return M(), G("div", UOe, [
        oe(a, {
          name: t.name,
          title: t.title,
          disabled: t.disabled
        }, rl({
          default: fe(() => [
            Ie(o.$slots, "default")
          ]),
          _: 2
        }, [
          c(n).title ? {
            name: "title",
            fn: fe(() => [
              Ie(o.$slots, "title")
            ]),
            key: "0"
          } : void 0
        ]), 1032, ["name", "title", "disabled"])
      ]);
    };
  }
}), qOe = { class: "k-view__header" }, YOe = { class: "view-title text-base font-bold" }, GOe = { class: "k-view__spcial-data" }, XOe = { class: "k-view__custom-data text-base" }, ZOe = { class: "custom-table-box" }, JOe = /* @__PURE__ */ Q({
  name: "KView",
  __name: "view",
  props: {
    modelValue: {},
    width: { default: "200px" }
  },
  emits: ["refresh", "change", "remove", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e;
    Nt(() => {
      var u;
      const s = (u = Pt()) == null ? void 0 : u.appContext.app.config.globalProperties.__emitter__;
      s.on("change-active-view", r.bind(this)), s.on("remove", i.bind(this));
    });
    const o = t, l = B(n.modelValue);
    Pe(() => n.modelValue, (s) => {
      l.value = s;
    });
    function a() {
      o("refresh");
    }
    function r(s) {
      o("update:modelValue", s), o("change", s);
    }
    function i(s) {
      o("remove", s);
    }
    return Mt("activeView", l), (s, u) => (M(), G("div", {
      class: "k-view text-base",
      style: bt({
        width: n.width + (typeof n.width == "number" ? "px" : "")
      })
    }, [
      X("div", qOe, [
        X("div", YOe, [
          Ie(s.$slots, "header", {}, () => [
            Ut(Qe(s.$t("view")), 1)
          ])
        ]),
        X("span", {
          class: "view-fresh",
          onClick: a
        }, [
          oe(c(Gke))
        ])
      ]),
      X("div", GOe, [
        Ie(s.$slots, "default")
      ]),
      X("div", XOe, [
        X("span", ZOe, Qe(s.$t("customView")), 1),
        Ie(s.$slots, "custom")
      ])
    ], 4));
  }
}), QOe = { class: "k-view-item__label" }, eNe = { class: "k-view-item__other" }, tNe = /* @__PURE__ */ Q({
  name: "KView",
  __name: "view_item",
  props: {
    value: {},
    label: { default: "" },
    count: { default: 0 },
    disabled: { type: Boolean }
  },
  setup(e) {
    var i;
    const t = e, n = ot("activeView"), o = (i = Pt()) == null ? void 0 : i.appContext.app.config.globalProperties.__emitter__;
    function l(s) {
      switch (s) {
        case "remove":
          r(t.value);
      }
    }
    function a() {
      t.disabled || o.emit("change-active-view", t.value);
    }
    function r(s) {
      o.emit("remove", s);
    }
    return (s, u) => {
      const d = o0, f = l0, v = n0;
      return M(), G("div", {
        class: z(["k-view-item", {
          "k-view-active": c(n) === t.value,
          "k-view-disabled": t.disabled
        }]),
        onClick: a
      }, [
        X("div", QOe, [
          Ie(s.$slots, "label", {}, () => [
            Ut(Qe(t.label), 1)
          ])
        ]),
        X("div", eNe, [
          X("span", null, Qe(t.count), 1),
          oe(v, {
            trigger: "click",
            onCommand: l
          }, {
            dropdown: fe(() => [
              oe(f, null, {
                default: fe(() => [
                  oe(d, { command: "remove" }, {
                    default: fe(() => [
                      Ut(Qe(s.$t("remove")), 1)
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            default: fe(() => [
              X("span", {
                class: "k-view-item-remove",
                onClick: u[0] || (u[0] = It(() => {
                }, ["stop", "prevent"]))
              }, [
                oe(c(Y1))
              ])
            ]),
            _: 1
          })
        ])
      ], 2);
    };
  }
}), nNe = { class: "k-badge" }, oNe = /* @__PURE__ */ Q({
  name: "KBadge",
  __name: "badge",
  props: {
    value: { default: "" },
    max: { default: 99 },
    isDot: { type: Boolean },
    hidden: { type: Boolean },
    color: {},
    showZero: { type: Boolean, default: !0 },
    offset: {},
    badgeStyle: {},
    badgeClass: {}
  },
  setup(e) {
    const t = e, n = x(() => ({
      value: t.value,
      max: t.max,
      isDot: t.isDot,
      hidden: t.hidden,
      color: t.color,
      showZero: t.showZero,
      offset: t.offset,
      badgeStyle: t.badgeStyle,
      badgeClass: t.badgeClass
    }));
    return (o, l) => {
      const a = zy;
      return M(), G("div", nNe, [
        oe(a, xo(Ao(n.value)), {
          default: fe(() => [
            Ie(o.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]);
    };
  }
}), B2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  KBadge: oNe,
  KButton: Sc,
  KCascader: Y2e,
  KCheckbox: Db,
  KCheckboxGroup: I2e,
  KCollapse: KOe,
  KCollapseItem: jOe,
  KColumnGroup: MOe,
  KDatePicker: n3,
  KDialog: i3,
  KDrawer: ROe,
  KFilter: J$e,
  KForm: LOe,
  KFormItem: POe,
  KInput: Eh,
  KInputNumber: S2e,
  KLoading: I$e,
  KMessage: Lb,
  KOperate: y$e,
  KOption: fs,
  KOptionGroup: j2e,
  KPagination: z2e,
  KPopconfirm: x$e,
  KPopover: gs,
  KRadio: x2e,
  KRadioGroup: T2e,
  KSelect: gc,
  KStatus: M$e,
  KStep: zOe,
  KSteps: VOe,
  KSwitch: D2e,
  KTabItem: B2e,
  KTable: tOe,
  KTableColumn: NOe,
  KTabs: P2e,
  KTag: E$e,
  KTooltip: A$e,
  KTransfer: c$e,
  KUpload: l$e,
  KView: JOe,
  KViewItem: tNe
}, Symbol.toStringTag, { value: "Module" })), lNe = {
  seniorFilter: "高级筛选",
  clearAll: "清除所有条件",
  addCondition: "添加条件",
  aboveCondition: "以上条件",
  anyOne: "任意一条",
  all: "全部",
  query: "查询",
  exactDate: "具体日期",
  dateRange: "日期区间",
  today: "今天",
  tomorrow: "明天",
  yesterday: "昨天",
  thisWeek: "本周",
  lastWeek: "上周",
  thisMonth: "本月",
  lastMonth: "上月",
  withinThePastSevenDays: "过去七天内",
  withinThePastThirtyDays: "过去30天内",
  equal: "等于",
  before: "早于",
  after: "晚于",
  empty: "为空",
  nonEmpty: "不为空",
  batchOperation: "批量操作",
  customDescription: "自定义说明",
  cancel: "取消",
  confirm: "确认",
  filter: "筛选",
  reset: "重置",
  sort: "排序",
  ascendingOrder: "升序",
  descendingOrder: "降序",
  clearSorting: "清除排序",
  hide: "隐藏",
  retract: "收起",
  uploadDragSign: "单击或拖拽文件到此处上传",
  uploadFile: "上传文件",
  selectFile: "选择文件",
  remove: "移除",
  view: "视图",
  customView: "自定义视图",
  input: "请输入",
  success: "成功",
  error: "错误",
  warning: "警告",
  noData: "暂无数据",
  selectedFields: "已选字段",
  unselectedFields: "待选字段",
  restoreDefault: "恢复默认",
  searchHeaderName: "搜索表头名称"
}, aNe = {
  seniorFilter: "Senior Filter",
  clearAll: "clear all",
  addCondition: "add condition",
  aboveCondition: "above condition",
  anyOne: "Any One",
  all: "All",
  query: "query",
  exactDate: "exact date",
  dateRange: "date range",
  today: "today",
  tomorrow: "tomorrow",
  yesterday: "yesterday",
  thisWeek: "this week",
  lastWeek: "last week",
  thisMonth: "this month",
  lastMonth: "last month",
  withinThePastSevenDays: "within the past seven days",
  withinThePastThirtyDays: "Within the past thirty days",
  equal: "equal",
  before: "before",
  after: "after",
  empty: "empty",
  nonEmpty: "non empty",
  batchOperation: "batch operation",
  customDescription: "custom description",
  cancel: "cancel",
  confirm: "confirm",
  filter: "filter",
  reset: "reset",
  sort: "sort",
  ascendingOrder: "ascending order",
  descendingOrder: "descending order",
  clearSorting: "clear sorting",
  hide: "hide",
  retract: "retract",
  uploadDragSign: "Click or drag the file here to upload",
  uploadFile: "upload file",
  selectFile: "select file",
  remove: "remove",
  view: "view",
  customView: "custom view",
  input: "Please Input",
  success: "success",
  error: "error",
  warning: "warning",
  noData: "no data",
  selectedFields: "Selected",
  unselectedFields: "Unselected",
  restoreDefault: "Restore",
  searchHeaderName: "Search Header Name"
}, pNe = (e, t) => {
  const n = { zh: lNe, en: aNe }, o = s2e({
    locale: (t == null ? void 0 : t.locale) === "en" ? "en" : "zh",
    messages: n
  });
  e.use(_re, {
    locale: (t == null ? void 0 : t.locale) === "en" ? ok : UEe
  }), e.use(KEe), e.use(o);
  for (const l in B2)
    e.component(l, B2[l]);
  e.config.globalProperties.__emitter__ = new $2e(), e.config.globalProperties.$t = o.global.t;
};
export {
  oNe as KBadge,
  Sc as KButton,
  Y2e as KCascader,
  Db as KCheckbox,
  I2e as KCheckboxGroup,
  KOe as KCollapse,
  jOe as KCollapseItem,
  MOe as KColumnGroup,
  n3 as KDatePicker,
  i3 as KDialog,
  ROe as KDrawer,
  J$e as KFilter,
  LOe as KForm,
  POe as KFormItem,
  Eh as KInput,
  S2e as KInputNumber,
  I$e as KLoading,
  Lb as KMessage,
  y$e as KOperate,
  fs as KOption,
  j2e as KOptionGroup,
  z2e as KPagination,
  x$e as KPopconfirm,
  gs as KPopover,
  x2e as KRadio,
  T2e as KRadioGroup,
  gc as KSelect,
  M$e as KStatus,
  zOe as KStep,
  VOe as KSteps,
  D2e as KSwitch,
  B2e as KTabItem,
  tOe as KTable,
  NOe as KTableColumn,
  P2e as KTabs,
  E$e as KTag,
  A$e as KTooltip,
  c$e as KTransfer,
  l$e as KUpload,
  JOe as KView,
  tNe as KViewItem,
  pNe as default
};
